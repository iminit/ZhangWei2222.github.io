<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解压文件时报错gzip stdin not in gzip format]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E6%97%B6%E6%8A%A5%E9%94%99gzip%20stdin%20not%20in%20gzip%20format%2F</url>
    <content type="text"><![CDATA[在服务器解压 MySQL 压缩包时报错123gzip: stdin: not in gzip formattar: Child returned status 1tar: Error is not recoverable: exiting now 用的命令为 tar -zxvf mysql-server-...e.tar 解决办法：将参数改为 -xvf]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux 下卸载 MySQL 数据库]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2FLinux%20%E4%B8%8B%E5%8D%B8%E8%BD%BD%20MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[因为数据库突然崩了，所以有了这么一次卸载的机会，记录一下，记录一下 卸载1. 查看当前安装情况1rpm -qa|grep -i mysql 2. 检查 MySQL 服务并关闭服务进程查看 MySQL 服务状态，根据开机初始化目录下 MySQL 脚本的文件名而定，我这里是 mysqld 1service mysqld status 如果正在运行则需要关闭服务 1service mysqld stop 3. 删除之前安装的 MySQL1rpm -ev &#123;包名&#125; 如果提示依赖包错误，则使用以下命令尝试： 1rpm -ev MySQL-client-5.5.25a-1.rhel5 --nodeps 如果提示错误：error: %preun(xxxxxx) scriptlet failed, exit status 1 ，则使用以下命令尝试： 1rpm -e --noscripts &#123;包名&#125; 如果提示错误：mysql-community-common(x86-64) &gt;= 5.7.9 is needed by mysql-community-libs-5.7.21-1.el7.x86_64 ，这个时候需要将已经安装的 rpm包 卸载（依赖问题） 4. 查找 mysql 的安装目录并彻底删除查找跟 mysql 相关的目录 1find / -name mysql 删除查找出来的目录 1rm -rf '目录' 5. 删除 mysql 配置文件删除 /etc/my.cnf 文件 1rm -rf /etc/my.cnf 删除 /etc/init.d/ 下跟 mysql 有关的全部文件，一般包括 mysql 文件或 mysqld 文件 1rm -rf /etc/init.d/mysqld 如果存在mysql文件则删除 1rm -rf/etc/init.d/mysql 6. 删除mysql用户及用户组查看 MySQL 用户及用户组 1id mysql 删除MySQL用户及用户组 1userdel mysql 如果使用 userdel 无法删除用户，如下报错 123456root@ per # userdel -r mysqluserdel： user mysql is currently used by process 1748root@ per # groupdel mysqlgroupdel：不能移除用户“mysql”的主组# 删除该用户就提醒用户当前在进程运行，删除他的组也报错。 则可使用 vipw 命令 123456root@ per# vipw# 找到之前创建的用户，用dd删除那行（记得保存：wq or ：x）。root@per# vipw -s# 找到那个用户所属组，也dd干掉即可（记得保存：wq or ：x）# 使用vipw -s的原因只有一个，就是必须保证数据的一致性，不然可能会造成系统崩溃等问题。 7. 再次查找机器是否安装 MySQL1rpm -qa|grep -i mysql 无结果，则代表彻底卸载完毕 参考文章Linux下MySQL卸载和安装图文教程 Linux-&gt;解决用userdel删除不掉用户的问题 Linux下彻底卸载mysql详解]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-查找配置文件 my.cnf 路径]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E6%9F%A5%E6%89%BE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20my.cnf%20%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[如果安装时没有做什么修改，则默认路径为 /etc/my.cnf 查找 mysqld 的路径 12which mysqld# /usr/sbin/mysqld 敲命令，即可找到 1/usr/sbin/mysqld --verbose --help |grep -A 1 'Default options']]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-查看数据库安装路径]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[查询运行文件所在路径 12which mysql# /usr/bin/mysql 可通过以下方式连接Mysql 1/usr/bin/mysql -uroot -p]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 koa2-cors 跨域]]></title>
    <url>%2F2020%2F04%2F28%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FKoa2%2F%E4%BD%BF%E7%94%A8%20koa2-cors%20%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[介绍使用 koa2-cors 进行跨域的配置 安装1npm install koa2-cors 配置1234567891011121314151617181920212223242526272829const Koa = require('koa');const bodyParser = require('koa-bodyparser'); // post数据处理const router = require('koa-router')(); // 路由模块const cors = require('koa2-cors'); // 跨域处理const app = new Koa();app.use( cors(&#123; origin: function(ctx) &#123; // 设置允许来自指定域名请求 if (ctx.url === '/test') &#123; return '*'; // 允许来自所有域名请求 &#125; return 'http://localhost:8080'; // 只允许http://localhost:8080这个域名的请求 &#125;, maxAge: 5, // 指定本次预检请求的有效期，单位为秒。 credentials: true, // 是否允许发送Cookie allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], // 设置所允许的HTTP请求方法 allowHeaders: ['Content-Type', 'Authorization', 'Accept'], // 设置服务器支持的所有头信息字段 exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'] // 设置获取其他自定义字段 &#125;));router.post('/', async function (ctx) &#123; ctx.body = '请求成功了'&#125;);// 监听端口app.listen(config.port, () =&gt; &#123; console.log("——————————服务已启动——————————");&#125;)]]></content>
      <categories>
        <category>Koa2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[服务器部署 node 环境]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%20node%20%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[安装 安装 epel 源 1yum install epel-release 安装 node npm 1yum install npm nodejs 不断 y ，y 按下去，然后检查是否成功 1node -v 除了可以使用 yum 安装软件，还可以使用 wgdt 再tar 安装 xshell 6+centos下安装node环境（较麻烦） 配置环境变量12345678# 1. 查看当前的环境变量配置env # 2. 修改/etc/profile文件，在末尾添加以下内容export NODE_HOME=/usr/local/node # Node 所在路径，可以使用 whereis node 查看export PATH=$NODE_HOME/bin:$PATH# 3. 执行命令source /etc/profile # 4. 重启后，即可生效]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-LEFT JOIN 多表联查]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2FLEFT%20JOIN%20%E5%A4%9A%E8%A1%A8%E8%81%94%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[LEFT JOIN：返回包括左表中的所有的记录和右表连接字段相等的记录 select * from A left join B on A.id = B.id 因为 LEFT JOIN 是以左表为主表，所以只要左表有数据，不管右表有没有数据。(如果右表没有数据则为 null ，查询结果都会存在） 二表联查12SELECT a.name,b.valueFROM users AS a LEFT JOIN orders AS b ON a.id = b.userId 三表联查123SELECT a.count,b.bname,c.agefrom users AS a LEFT JOIN orders AS b ON a.ruleid = b.id LEFT JOIN landlords as c ON a.topruleid = c.id]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Global 类型中不存在 Property]]></title>
    <url>%2F2020%2F04%2F28%2FTypeScript%2FGlobal%20%E7%B1%BB%E5%9E%8B%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%20Property%2F</url>
    <content type="text"><![CDATA[问题描述：为了能够执行日志打印命令，使用 global.log.info(&#39;测试&#39;) ，却始终报错： 1Property 'window' does not exist on type 'Global'. 解决办法： 把以下代码放在脚本的顶部 1const globalAny:any = global; 脚本中使用 globalAny 代替 global 1globalAny.log.info('测试'); 需要在脚本的最后加上以下代码，避免和全局作用域的变量起冲突 1export &#123;&#125;;]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[error TS2451：Cannot redeclare block-scoped variable 'globalAny']]></title>
    <url>%2F2020%2F04%2F28%2FTypeScript%2Ferror%20TS2451%EF%BC%9ACannot%20redeclare%20block-scoped%20variable%20'globalAny'%2F</url>
    <content type="text"><![CDATA[报错原因：在默认状态下，typescript 将 DOM typings 作为全局的运行环境，所以当我们声明 globalAny 时， 与 DOM 中的全局 window 对象下的 globalAny 属性出现了重名。 解决办法： 将脚本封装到模块内，module 有自己的作用域，自然不会与全局作用域的变量产生冲突。 在 Typescript 中，只要文件存在 import 或 export 关键字，都被视为 module 在脚本最后一行，添加 export {};。将文件声明为 module， 变量 globalAny 被限制在了 module 的作用域下，因此不会与全局的 globalAny 产生冲突。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实现对数字强制保留两位小数，不足两位自动补0]]></title>
    <url>%2F2020%2F04%2F28%2FJavaScript%2F%E5%87%BD%E6%95%B0%2F%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E5%AD%97%E5%BC%BA%E5%88%B6%E4%BF%9D%E7%95%99%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0%EF%BC%8C%E4%B8%8D%E8%B6%B3%E4%B8%A4%E4%BD%8D%E8%87%AA%E5%8A%A8%E8%A1%A50%2F</url>
    <content type="text"><![CDATA[12345678910111213function returnFloat(value) &#123; let res = Math.round(parseFloat(value) * 100) / 100; let s = res.toString().split("."); if (s.length == 1) &#123; return res.toString() + ".00"; &#125; if (s.length &gt; 1) &#123; if (s[1].length &lt; 2) &#123; return res.toString() + "0"; &#125; return res.toString() &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Computed property XXX was assigned to but it has no setter]]></title>
    <url>%2F2020%2F04%2F28%2FVue%2FComputed%20property%20XXX%20was%20assigned%20to%20but%20it%20has%20no%20setter%2F</url>
    <content type="text"><![CDATA[报错原因： 组件中 v-model = ‘xxx’，而 xxx 是 vuex state 中的某个变量 vuex 是单项流，v-model 是 vue 的双向绑定，但是在 computed 中只通过 get 获取参数值，没有 set，所以无法改变参数值 解决办法： 在 computed 中添加 get 和 set ![image-20200428175953621](Computed property XXX was assigned to but it has no setter.assets/image-20200428175953621.png) 将 v-model 改成 :value]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[服务器安装 pm2 管理工具]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%20pm2%20%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[使用 pm2 管理工具，可以维持服务器的后端 node 运行文件，并且能够自动重启，以及查看日志。接下来，介绍其部署的步骤。 安装1npm install -g pm2 部署环境变量如果以下命令显示 command not found，是因为没有将 pm2 加到环境变量中 1pm2 -v 查看 node 目录 12whereis nodenode: /usr/local/bin/node 进入本地环境变量的路径 12345cd /usr/local/binlllrwxrwxrwx 1 root root 43 Jul 6 09:49 node -&gt; /usr/nodejs/node-v8.11.3-linux-x64/bin/nodelrwxrwxrwx 1 root root 42 Jul 6 09:49 npm -&gt; /usr/nodejs/node-v8.11.3-linux-x64/bin/npm 进入 node 目录 123cd /usr/nodejs/node-v8.11.3-linux-x64/binnode npm pm2 发现 pm2 ，将其加至本地的环境变量 1ln -s /usr/nodejs/node-v8.11.3-linux-x64/bin/pm2 /usr/local/bin 检查是否成功 1pm2 -v 运行 TypeScript 文件12pm2 install typescriptpm2 start app.ts 使用1234567891011121314# --watch参数是监测 node 文件，如果被更改了会自动重启pm2 start server.js --watch# 查看部署的 node 进程pm2 list# 重启 pm2pm2 restart &#123;list里的id号/文件&#125;# 查看日志pm2 log# 结束 pm2pm2 stop &#123;list里的id号/文件&#125; 参考文章Linux下使用pm2部署node以及安装后command not found解决]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由报错： Navigating to current location (XXX) is not allowed]]></title>
    <url>%2F2020%2F04%2F28%2FVue%2F%E8%B7%AF%E7%94%B1%E6%8A%A5%E9%94%99%EF%BC%9A%20Navigating%20to%20current%20location%20(XXX)%20is%20not%20allowed%2F</url>
    <content type="text"><![CDATA[报错原因：在路由中添加了相同的路由解决办法：重写路由的 push 方法在 src/router/index.js 里面 import Router from &#39;vue-router&#39; 下面写入下面方法即可 1234567/** * 重写路由的push方法 */const routerPush = Router.prototype.pushRouter.prototype.push = function push(location) &#123; return routerPush.call(this, location).catch(error=&gt; error)&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js-path模块中 path.resolve() 和 path.join() 的区别]]></title>
    <url>%2F2020%2F04%2F28%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FNode.js%2Fpath%E6%A8%A1%E5%9D%97%E4%B8%AD%20path.resolve()%20%E5%92%8C%20path.join()%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[path 模块的引入作用：直接引用，node中自带的模块 1const path = require('path'); path.join(path1，path2，path3…….)作用：将路径片段使用特定的分隔符（window：\）连接起来形成路径，并规范化生成的路径。若任意一个路径片段类型错误，会报错。 123456789const path = require('path')let myPath = path.join(__dirname, '/client/src')let myPath2 = path.join(__dirname, './client/src')let myPath3 = path.join('/foo', 'bar', 'baz/s', '..')console.log(__dirname) // I:\Youth-Hostelconsole.log(myPath) // I:\Youth-Hostel\client\srcconsole.log(myPath2) // I:\Youth-Hostel\client\srcconsole.log(myPath3) // \foo\bar\baz path.resolve([from…],to)作用：把一个路径或路径片段的序列解析为一个绝对路径。相当于执行 cd 操作。 / 被解析为根目录。 1234567891011const path = require('path')let myPath = path.resolve(__dirname, '/client/src')let myPath2 = path.resolve(__dirname, './client/src')let myPath3 = path.resolve('/foo', '/bar')let myPath4 = path.resolve('/foo', './bar')console.log(__dirname) // I:\Youth-Hostelconsole.log(myPath) // I:\client\srcconsole.log(myPath2) // I:\Youth-Hostel\client\srcconsole.log(myPath3) // I:\barconsole.log(myPath4) // I:\foo\bar]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue + Typescript项目@引入无法找到模块问题]]></title>
    <url>%2F2020%2F04%2F28%2FTypeScript%2FVue%20%2B%20Typescript%E9%A1%B9%E7%9B%AE%40%E5%BC%95%E5%85%A5%E6%97%A0%E6%B3%95%E6%89%BE%E5%88%B0%E6%A8%A1%E5%9D%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述：在项目中如下引入模块会报错1import &#123; userInfoAPI, userImageAPI &#125; from "@/services/userAPI.ts";解决办法：只 webpack 中配置 alias 是不行的，还要在 tsconfig.json 文件里面配置 12345678&#123; "compilerOptions": &#123; "baseUrl": ".", "paths": &#123; "@/*": ["*","src/*"] &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[eslint报错：invalid-first-character-of-tag-name]]></title>
    <url>%2F2020%2F04%2F28%2F%E5%BC%80%E5%8F%91%2Feslint%E6%8A%A5%E9%94%99%EF%BC%9Ainvalid-first-character-of-tag-name%2F</url>
    <content type="text"><![CDATA[报错原因：html 特殊字符如‘大于’ ‘小于’ 号的写法要用原始码，如 ‘&lt;’ 原始码为 &amp;lt;，‘&gt;’ 原始码为&amp;gt; 12345// 原始错误代码&lt;span class="site"&gt;当前位置 &lt; &lt;/span&gt; // 修改后&lt;span class="site"&gt;当前位置 &amp;lt; &lt;/span&gt;]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-操作外键报错]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E6%93%8D%E4%BD%9C%E5%A4%96%E9%94%AE%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[添加外键时，报错 11022-Can't write;duplicate key in table 'users' 报错原因：外键名称重复，改为不同名字即可 删除有外键关联的数据或者表的时候，报错： 1Cannot delete or update a parent row: a foreign key constraint fails 解决办法：先关闭外键约束，执行删除操作，然后再开启外键约束 123456# 先设置外键约束检查关闭SET foreign_key_checks = 0; # 删除数据，表或者视图drop table mytable; # 开启外键约束检查，以保持表结构完整性SET foreign_key_checks = 1;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Error listen EADDRINUSE报错]]></title>
    <url>%2F2020%2F04%2F28%2F%E5%BC%80%E5%8F%91%2FError%20listen%20EADDRINUSE%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[报错原因：端口被其他应用程序占用，只要找到占用该端口的应用程序，杀死即可 1234567# windowsnetstat -ano | findstr &#123;端口号&#125;taskkill /f /t /im &#123;PID号&#125;# linuxsudo lsof -i:&#123;端口号&#125;sudo kill -9 &#123;PID号&#125;]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xshell 上传下载 zip 文件]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2Fxshell%20%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%20zip%20%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123yum install -y &#123;zip文件&#125;# 解压unzip xxx.zip]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 koa-multer 上传头像]]></title>
    <url>%2F2020%2F04%2F28%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FKoa2%2F%E4%BD%BF%E7%94%A8%20koa-multer%20%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[上传头像的原理是： 使用 koa-multer 上传图片到服务器 上传成功，返回图片名 前端根据返回的图片名从服务器获取图片，达到实时上传的效果 安装中间件1npm install koa-multer --save 后端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const multer = require('koa-multer');const path = require('path')// 文件上传 配置const storage = multer.diskStorage(&#123; // 文件保存路径 destination: function (req, file, cb) &#123; cb(null, path.join(__dirname, '../../public/userUploads')) // 服务器的存放地址 &#125;, // 修改文件名称 // 上传的文件默认没有后缀名，需要手动加上后缀名；为了命名不重复，使用时间戳转为16进制作为文件命名 filename: function (req, file, cb) &#123; let type = file.originalname.split('.')[1] // 以点分割成数组，数组的最后一项就是后缀名 cb(null, `$&#123;file.fieldname&#125;-$&#123;Date.now().toString(16)&#125;.$&#123;type&#125;`) &#125;&#125;)// //文件上传限制，指定限制可以帮助保护站点免受拒绝服务(DoS)攻击// const limits = &#123;// fields: 10, // 非文件字段的数量// fileSize: 500 * 1024, // 文件大小 单位 b// files: 1 // 文件数量//&#125;// 加载配置//const upload = multer(&#123; storage, limits &#125;)const upload = multer(&#123; storage &#125;)// 路由// 由于这里只上传一个文件，所以使用 single 方法，single 方法接受一个字符串，这个字符串为上传文件的字段名，另外上传多文件可以使用 array、filedsrouter.post('/api/userImage', checkToken, upload.single('avatar'), async (ctx, next) =&gt; &#123; // 在路由中，可通过 ctx.file 获取上传完毕的文件信息，多文件上传可通过 ctx.files 获取 let user = &#123; id: ctx.req.body.id, filename: ctx.req.file.filename &#125; await userModel.uploadUserAvator(user).then((res) =&gt; &#123; global.log.trace("[userImage] 头像上传成功!" + ctx.req.file.filename); ctx.body = &#123; code: 0, msg: '上传成功!', filename: ctx.req.file.filename // 返回文件名 &#125; &#125;).catch((err) =&gt; &#123; global.log.error("[userImage] 头像上传失败!" + err); ctx.body = &#123; code: -1, msg: err, data: [] &#125; &#125;)&#125;) 前端123456789101112131415161718192021222324let self = this;let params = new FormData(); // 创建一个form对象,必须是form对象否则后端接受不到数据params.append("avatar", file.file); // append 向form表单添加数据// 添加请求头 通过form添加的图片和文件的格式必须是multipart/form-dataparams.append("id", self.user["id"]);let config = &#123; headers: &#123; "Content-Type": "multipart/form-data" &#125; // 重要！&#125;;const res = await userImageAPI(params, config);try &#123; console.log("上传头像信息" + JSON.stringify(res.data)); if (res.data.code === 0) &#123; Toast.success(res.data.msg); window.location.reload(); &#125; else if (res.data.code === 104) &#123; Toast.fail(res.data.msg); &#125;&#125; catch (error) &#123; Toast.fail("上传失败"); console.log("上传失败" + error);&#125; 参考文章node koa2图片上传的实现 Koa - 使用koa-multer上传文件（上传限制、错误处理）]]></content>
      <categories>
        <category>Koa2</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[img 标签图片居中显示]]></title>
    <url>%2F2020%2F04%2F27%2FCss3%2Fimg%20%E6%A0%87%E7%AD%BE%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[使用 object-fit 属性 123456.img &#123; position: absolute; width: 100%; height: 100%; object-fit: cover; // 保证图片覆盖容器的宽高&#125; 其它值 fill：中文释义“填充”。默认值。替换内容拉伸填满整个contentbox，不保证保持原有的比例。 contain：中文释义“包含”。保持原有尺寸比例。保证替换内容尺寸一定可以在容器里面放得下。因此，此参数可能会在容器内留下空白。 cover：中文释义“覆盖”。保持原有尺寸比例。保证替换内容尺寸一定大于容器尺寸，宽度和高度至少有一个和容器一致。因此，此参数可能会让替换内容部分区域不可见。 none：中文释义“无”。保持原有尺寸比例。同时保持替换内容原始尺寸大小。 scale-down：中文释义“降低”。就好像依次设置了none或contain, 最终呈现的是尺寸比较小的那个。]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-插入数据报错]]></title>
    <url>%2F2020%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[ERROR 1366: 1366: Incorrect string value: &#39;\xE5\xA5\xB3&#39; for column &#39;sex&#39; at原因：当字段字符集和插入数据的字符不同，则出现Error 1366。 解决： alter database db_name character set utf8; 在 HeDiSQL 中，选择某个表的选项，选择默认字符校对为 utf8_general_ci ，选择转换数据，最后点击保存表。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决 this.$router.push 传出参数不同 页面不刷新的问题]]></title>
    <url>%2F2020%2F04%2F27%2FVue%2F%E8%A7%A3%E5%86%B3%20this.%24router.push%20%E4%BC%A0%E5%87%BA%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%20%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在页面的watch中，监听$router的变化12345watch: &#123; $route (to, from) &#123; this.$router.go(0) &#125;&#125; 其中 this.$router.go(0)为刷新页面，但此方法可能在 Safari 中无法实现，建议使用 JS 原生的方法：window.location.reload()]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-delimiter 命令的作用]]></title>
    <url>%2F2020%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2Fdelimiter%20%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在学习游标的过程中，发现有个教程会写 delimiter 命令，尝试过不写，有时会无法建立存储过程或函数。接下来研究一下 delimiter 命令的作用 delimiter 命令的作用：设置命令段的结束符号，即遇到这个所设置的结束符号后，按回车，则命令段就可以执行了。 通常默认情况下，命令的结束符号是分号（;），但是在存储过程中，过程体内可能会包含分号（;），因此需要将命令结束符号替换成其他的字符，如$$、//等，存储过程创建完成后，可以将命令段的结束符号重新设为分号。 语法：delimiter 命令段结束符 123456789101112131415161718192021222324252627282930-- 定义语法结束符号delimiter //-- 创建一个名称为 p 的存储过程create procedure p()BEGIN declare mcId int; declare flag int default 0; -- 声明游标 declare mc cursor for SELECT id FROM `orders` WHERE STATUS = -1 AND NOW() &gt;= (orders.startDate + INTERVAL days day); declare continue handler for not found set flag = 1; -- 打开游标 open mc; -- 循环 lp:loop -- 获取结果 fetch mc into mcId; if flag=1 then -- 当无法fetch会触发handler continue leave lp; end if; -- 这里是为了显示获取结果 CALL set_orderStatus(mcId, &apos;0&apos;); -- 结束循环 end loop; -- 关闭游标 close mc;END //delimiter ;call p();]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-游标 fetch 注入的变量为 null]]></title>
    <url>%2F2020%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E6%B8%B8%E6%A0%87%20fetch%20%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%BA%20null%2F</url>
    <content type="text"><![CDATA[可能是注入的变量名与表的字段名称重复，因为MySQL 不分大小写，即使字段名称是大写，变量名称是小写，也会被认为是同一个字符串。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-游标]]></title>
    <url>%2F2020%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E6%B8%B8%E6%A0%87%2F</url>
    <content type="text"><![CDATA[使用游标，可以遍历返回的多行结果，只适用于存储过程以及函数。游标每一次fetch都是获取一行结果，可以使用变量来获取fetch到的每一列的值。 语法 定义游标：declare 游标名 cursor for select语句; 打开游标：open 游标名; 获取结果：fetch 游标名 into 变量名[,变量名]; 关闭游标：close 游标名; 1234567891011121314151617181920212223242526create procedure p()BEGIN declare mcId int; declare flag int default 0; -- 声明游标 declare mc cursor for SELECT id FROM `orders` WHERE STATUS = -1 AND NOW() &gt;= (orders.startDate + INTERVAL days day); declare continue handler for not found set flag = 1; -- 打开游标 open mc; -- 循环 lp:loop -- 获取结果 fetch mc into mcId; if flag=1 then -- 当无法fetch会触发handler continue leave lp; end if; -- 这里是为了显示获取结果 CALL set_orderStatus(mcId, &apos;0&apos;); -- 结束循环 end loop; -- 关闭游标 close mc;ENDcall p(); 参考文章mysql之游标]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-执行定时事件]]></title>
    <url>%2F2020%2F04%2F27%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E6%89%A7%E8%A1%8C%E5%AE%9A%E6%97%B6%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[可以使用以下命令查看数据库是否开启 event_scheduler 1SHOW VARIABLES LIKE &apos;event_scheduler&apos; 使用命令开启（临时开启，重启mysql又还原回去了） 1set global event_scheduler = on; 修改配置（永久修改） 进入服务器，输入vim /etc/my.cnf，在 [mysqld] 部分加上 event_scheduler=ON 即可]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-无刷新修改 url 参数]]></title>
    <url>%2F2020%2F04%2F27%2FVue%2F%E6%97%A0%E5%88%B7%E6%96%B0%E4%BF%AE%E6%94%B9%20url%20%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516import merge from 'webpack-merge'；// 修改原有参数 this.$router.push(&#123; query:merge( this.$route.query, &#123; 'maxPrice': '630' &#125;)&#125;)// 新增一个参数：this.$router.push(&#123; query:merge( this.$route.query, &#123; 'addParams': '新增参数' &#125;)&#125;)// 替换所有参数：this.$router.push(&#123; query:merge( &#123;&#125;, &#123; 'maxPrice': '630' &#125;)&#125;)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-生产环境和开发环境的判断]]></title>
    <url>%2F2020%2F04%2F27%2FVue%2F%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[1234const urlDev = 'http://dev.test.com' // 开发环境const urlQa = 'http://test.com' // 生产环境var url = ''process.env.NODE_ENV === 'development' ? url = urlDev : url = urlQa]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[this.$router.push、replace、go 区别]]></title>
    <url>%2F2020%2F04%2F27%2FVue%2Fthis.%24router.push%E3%80%81replace%E3%80%81go%20%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[this.$router.push() 跳转到不同的 url，但这个方法会向 history 栈添加一个记录，点击后退会返回到上一个页面。 12this.$router.push(&#123; path: '/user', query: &#123;id : 1&#125;&#125;)this.$router.push(&#123; name: 'user', query: &#123;id : 1&#125;&#125;) this.$router.replace() 同样是跳转到指定的url，但是这个方法不会向 history 里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。 this.$router.go() 相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n 可为正数可为负数。 12345// 在浏览器记录中前进一步，等同于 history.forward()this.$router.go(1)//后退一步记录，等同于 history.bacK()this.$router.go(-1)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 concurrently 并行地运行多个命令]]></title>
    <url>%2F2020%2F04%2F26%2F%E5%BC%80%E5%8F%91%2F%E4%BD%BF%E7%94%A8%20concurrently%20%E5%B9%B6%E8%A1%8C%E5%9C%B0%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[项目目录结构如下，想要实现一个命令同时跑前端和后端，可以使用 concurrently 12345678.├── client // 前端代码├── db // 后端代码├── logs // 日志├── node_modules├── package-lock.json├── package.json└── README.md 在项目根目录安装 1npm i concurrently --save 修改 package.json 123456"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "client": "npm start --prefix client", "server": "nodemon ./db/index.ts", "dev": "concurrently \"npm run server\" \"npm run client\""&#125; 执行 123npm run client # 执行前端代码npm run server # 执行后端代码npm run dev # 同时执行前面两条代码]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vscode-自动生成文件头部注释和函数注释]]></title>
    <url>%2F2020%2F04%2F26%2F%E5%BC%80%E5%8F%91%2FVscode%2F%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E6%B3%A8%E9%87%8A%E5%92%8C%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[本文记录使用 KoroFileHeader 插件完成自动生成文件头部注释和函数注释的功能 安装与设置 在 vscode 中安装好 KoroFileHeader 插件 在vscode左下角点击设置按钮，选择“设置”，然后输入fileheader 文件头部注释：Fileheader:custom Made 函数注释：Fileheader:cursor Mode 随便点击哪个在 setting.json 中编辑，输入以下设置后保存，然后重启 vscode 更新设置 1234567891011121314151617// 文件头部注释"fileheader.customMade": &#123; "Description": "", // "version": "", "Author": "Vivian", "Date": "Do not edit", // "LastEditors": "Vivian", "LastEditTime": "Do not Edit"&#125;,//函数注释"fileheader.cursorMode": &#123; "name": "", "test": "test font", "msg": "", "param": "", "return": ""&#125; 使用函数头部注释 快捷键：crtl+alt+i（window）,ctrl+cmd+t (mac) 生成样式如下： 文件头部注释 快捷键：crtl+alt+i（window）,ctrl+cmd+t (mac) 生成样式如下：]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单SQL语句拼接模板-Node.js版]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E7%AE%80%E5%8D%95SQL%E8%AF%AD%E5%8F%A5%E6%8B%BC%E6%8E%A5%E6%A8%A1%E6%9D%BF-Node.js%E7%89%88%2F</url>
    <content type="text"><![CDATA[毕业项目的接口编写中，需要写很多查询、修改等 SQL 语句，下面记录简单的 SQL 语句拼接模板，扩展性强，能够满足绝大多数的简单语句拼接 模板代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 返回组装好的sql语句const getSql = &#123; // 构造通用的数据库语句结构体 getSQLObject: function () &#123; return &#123; // select/update/delete/insert "query": "select", // table name "tables": "", "data": &#123; // for select, use ("key": anything) // for others, use ("key": value) &#125;, "where": &#123; // and / or / not / "" "type": "and", "condition": [] &#125;, // options "options": &#123; "group by": "", "order by": "" &#125; &#125;; &#125;, // 构造一个保存 SQL 语句的结构体 getSQLObject_sv: function () &#123; return &#123; "sql": "", "value": [] &#125;; &#125;, // SQL 语句组装模块，解析数据库结构体 _structureAnalysis: function (sqlObj) &#123; let dataKey = [], dataValue = []; let optionKey = []; let whereSql = ""; let hasWhere = false; // 读取键值 for (var key in sqlObj["data"]) &#123; if (sqlObj["query"] == 'update') &#123; dataKey.push([key, "?"].join("=")); &#125; else &#123; dataKey.push(key); &#125; dataValue.push(sqlObj["data"][key]); &#125; // 判断是否有where条件 hasWhere = sqlObj["where"]["condition"].length == 0 ? false : true; whereSql = "where " + sqlObj["where"]["condition"].join(` $&#123;sqlObj["where"]["type"]&#125; `); // 读取语句中的可选部分(order by, group by) for (var key in sqlObj["options"]) &#123; if (sqlObj["options"][key] &amp;&amp; sqlObj["options"][key] != "") &#123; optionKey.push([key, sqlObj["options"][key]].join(" ")); &#125; &#125; // 组装语句 let sql = &#123; "update": `update $&#123;sqlObj["tables"]&#125; set $&#123;dataKey.join(",")&#125; $&#123;hasWhere ? whereSql : ""&#125;;`, "select": `select $&#123;dataKey.join(",")&#125; from $&#123;sqlObj["tables"]&#125; $&#123;hasWhere ? whereSql : ""&#125; $&#123;optionKey.join(" ")&#125;;`, "delete": `delete from $&#123;sqlObj["tables"]&#125; $&#123;hasWhere ? whereSql : ""&#125;;`, "insert": `insert into $&#123;sqlObj["tables"]&#125; ($&#123;dataKey.join(",")&#125;) values($&#123;dataKey.fill('?').join(",")&#125;);` &#125; // 生成SQL结构体 let result = getSql.getSQLObject_sv(); result["sql"] = sql[sqlObj["query"]]; result["value"] = sqlObj["query"] == "select" ? [] : dataValue; return result; &#125;&#125;module.exports = getSqlexport &#123; &#125;; 应用select 语句1234567891011121314const findUser = (val) =&gt; &#123; // 查找所有User let stru = getSQLObject(); stru["query"] = "select"; stru["tables"] = "users"; stru["data"] = &#123; "*": '*' &#125;; stru["where"]["condition"] = [ "name = '" + val + "'", ]; stru["options"]["group by"] = "id"; let result = _structureAnalysis(stru); return result;&#125; insert 语句1234567891011const insetUser = (val) =&gt; &#123; // 注册 let stru = getSQLObject(); stru["query"] = "insert"; stru["tables"] = "users"; stru["data"] = &#123; "name": val.name, "password": val.password &#125;; let result = _structureAnalysis(stru); return result;&#125; update语句12345678910111213const refuseOrder = (val) =&gt; &#123; // 取消订单 let stru = getSQLObject(); stru["query"] = "update"; stru["tables"] = "orders"; stru["data"] = &#123; "refuseReason": val.refuseReason &#125;; stru["where"]["condition"] = [ "id = " + val.orderId, ]; let result = _structureAnalysis(stru); return result;&#125; delete 语句12345678910const deleteOrder = (val) =&gt; &#123; // 删除订单 let stru = getSQLObject(); stru["query"] = "delete"; stru["tables"] = "orders"; stru["where"]["condition"] = [ 'id = ' + val.orderId ]; let result = _structureAnalysis(stru); return result;&#125; 参考文章简单SQL语句拼接模块(Nodejs版)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-@import 路径问题]]></title>
    <url>%2F2020%2F04%2F26%2FVue%2F%40import%20%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[想要采用别名将公共样式文件的路径引入，应当如此：@import url(&quot;~@/common/style/Variable.less&quot;); 因为 CSS loader 会把非根路径的 url 解释为相对路径， 加 ~ 前缀 才会解释成模块路径]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HeDiSQL-设置 id 自动增加]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FHeiDiSQL%2F%E8%AE%BE%E7%BD%AE%20id%20%E8%87%AA%E5%8A%A8%E5%A2%9E%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[一般主键 id 会设置成自动增长，在 HeDiSQL 中，可以选中 id 行，将默认值选项，选择“auto_increment” ![image-20200426171514521](设置 id 自动增加.assets/image-20200426171514521.png)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[log4js 配置]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2Flog4js%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[使用 Node.js 编写后端程序，为了调试、debugger代码，当然少不了日志，log4js 是一个很好的日志管理工具，下面记录它的配置 安装1npm install log4js --save 编写配置文件创建 logs 文件夹，添加 log_config.json 文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#123; "appenders": &#123; "console": &#123; "type": "console", "category": "console" &#125;, "info": &#123; "category": "log_info", "type": "dateFile", // 可以设置成 console、file、dateFile三种 "filename": "./logs/info/info_file", // 设置 log 输出的文件路径 "pattern": "yyyy-MM-dd.log", // 设置 log 输出的文件名 "alwaysIncludePattern": true, // 和上面同时使用 设置每天生成log名 "backups": 4, // 仅保留最新的四个日志文件 "maxLogSize ": 10000000, // 设置文件大小 "encoding": "utf-8" // 设置文件编码格式 &#125;, "error": &#123; "category": "log_error", "type": "dateFile", "filename": "./logs/error/error_file", "pattern": "yyyy-MM-dd.log", "alwaysIncludePattern": true, "backups": 4, "maxLogSize ": 10000000, "encoding": "utf-8" &#125;, "minError": &#123; "type": "logLevelFilter", "appender": "error", "level": "error" // 设置log输出的最低级别 &#125;, "debug": &#123; "category": "log_debug", "type": "dateFile", "filename": "./logs/debug/debug_file", "pattern": "yyyy-MM-dd.log", "alwaysIncludePattern": true, "backups": 4, "maxLogSize ": 10000000, "encoding": "utf-8" &#125;, "maxDebug": &#123; "type": "logLevelFilter", "appender": "debug", "level": "debug", "maxLevel": "debug" // 设置log输出的最高级别 // log级别为8级 ALL&lt;TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR&lt;FATAL&lt;MARK&lt;OFF。默认级别是 OFF &#125;, "trace": &#123; "category": "log_trace", "type": "dateFile", "filename": "./logs/trace/trace_file", "pattern": "yyyy-MM-dd.log", "alwaysIncludePattern": true, "backups": 4, "maxLogSize ": 10000000, "encoding": "utf-8" &#125;, "maxTrace": &#123; "type": "logLevelFilter", "appender": "trace", "level": "trace", "maxLevel": "trace" &#125; &#125;, "categories": &#123; "default": &#123; "appenders": [ "console", "info", "minError", "maxDebug", "maxTrace" ], "level": "ALL" &#125; &#125;, "replaceConsole": true&#125; 使用在后端执行文件中，添加启动日志服务代码 1234567const log4js = require("log4js");const log4js_config = require("../logs/log_config.json");log4js.configure(log4js_config);global.log = log4js.getLogger("wei");// 使用global.log.info('---开始listen in localhost:' + config.port); 随后在 logs 文件夹中，可以看到各分类文件夹及相关文件 如果仅在为了调试，可以使用 console.log 进行输出数据查看]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[v-model 三元运算]]></title>
    <url>%2F2020%2F04%2F26%2FVue%2Fv-model%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[发现在 v-model 使用三元运算符绑定数据，不能够，比如 v-model=&quot;name === &#39;&#39; ? text : name&quot;，如果 name 字段是空字符串时， 就让 input 绑定 text 字段，这样会报错。可以采取 computed 方式 1234567891011&lt;input type=&quot;text&quot; v-model=&quot;xxx&quot;&gt;computed:&#123; xxx()&#123; if(this.name)&#123; return this.text; &#125;else&#123; return this.name; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-记录字段值赋值给变量]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E8%AE%B0%E5%BD%95%E5%AD%97%E6%AE%B5%E5%80%BC%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[可以使用 select into 把记录字段值赋值给变量 12SELECT id ,NAME INTO @ss,@yy from users;SELECT @ss,@yy;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-给当前日期加时间]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E7%BB%99%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%8A%A0%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[可以使用 INTERVAL给当前日期或者指定日期加时间 1SELECT NOW() + INTERVAL 1 DAY; year 年份 month 月份 day 天 minute 分钟 second 秒]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-字符串拼接]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[字符串拼接在查询语句中，很常用，接下来整理三种字符串拼接方式 CONCAT() CONCAT_WS() GROUP_CONCAT() s_id s_name s_sex 01 张三 男 02 李四 null CONCAT() CONCAT(string1，string2) 最常用的字符串拼接方法，但遇到拼接中的字符串出现 null 的情况会返回 null。 1234SELECT CONCAT(s_name,s_sex) FROM student# 返回# 张三男# null CONCAT_WS() CONCAT_WS(separator,str1,str2,…) concat()的特殊形式，第一个参数是其它参数的分隔符，如果某个字符串为null，会忽略null，并返回其他字符串的值。 1234SELECT CONCAT_WS(&apos;--&apos;，s_name,s_sex) FROM student# 返回# 张三--男# 李四 GROUP_CONCAT() group_concat( [DISTINCT] 连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’] ) 连接字段，多个值显示为一行，可以是多个字段，也可以对连接字段进行排序。 1234567SELECT GROUP_CONCAT(s_id) FROM student# 返回# 01,02SELECT GROUP_CONCAT(s_id,s_name order by s_id desc separator &apos;-&apos;) FROM student# 返回# 02-李四,01-张三 参考文章MySQL教程之concat以及group_concat的用法]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL-三元运算]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[数据库的三元运算有两种方式 if(expr1, expr2, expr3) case when 条件 then (条件为true) else (条件为false) end 第一种方式需要消耗大量时间，如果较复杂的操作，尽量使用第二种方式 if(expr1, expr2, expr3)如果 expr1 是TRUE，则 IF() 的返回值为 expr2 ，否则返回值则为 expr3 case when]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[switch分支合并]]></title>
    <url>%2F2020%2F04%2F26%2FJavaScript%2Fswitch%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[switch 分支合并，会 case 穿透： 123case 1: case 2: key = 1; break;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为什么123456的MD5有两个]]></title>
    <url>%2F2020%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F%E4%B8%BA%E4%BB%80%E4%B9%88123456%E7%9A%84MD5%E6%9C%89%E4%B8%A4%E4%B8%AA%2F</url>
    <content type="text"><![CDATA[毕业项目中，测试密码时，发现输入密码不对，便去数据库查看，发现输入‘123456’后，数据库存入的值不一样：‘e10adc3949ba59abbe56e057f20f883e’和‘14e1b600b1fd579f47433b88e8d85291’，原因是代码处理不当，密码进行了二次加密： 常规加密md5($pass)：‘e10adc3949ba59abbe56e057f20f883e’ 二次加密md5(md5($pass))：‘14e1b600b1fd579f47433b88e8d85291’]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库备份与还原]]></title>
    <url>%2F2020%2F04%2F24%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[本文介绍 MySQL 数据库简单备份、定时备份与还原 简单备份123mysqldump -u root -p 数据库名称 &gt; 具体备份路径# 例如：mysqldump -u root -p youth_hostel &gt; /mysqlbak/hostel.sql 定时备份 创建备份目录 12# root 用户,创建备份目录mkdir -p /mysqlbak 编写运行脚本 vi /usr/sbin/bakmysql.sh 12345678910111213141516171819202122232425262728me:bakmysql.sh# This is a ShellScript For Auto DB Backup and Delete old Backup## Database infoDB_USER="root" # mysql login nameDB_PASS="123456" # passwordDB_HOST="localhost" # db_addressDB_NAME="youth_hostel" # db_nameDB_ZFBM="--default-character-set=utf8" # character#DB_TABLE="exam_quest_bank" # table name# Others varsBIN_DIR="/usr/bin" # the mysql bin pathBCK_DIR="/mysqlbak" # the backup file directoryDATE=`date +%F`#--skip-lock-tables zg backup#$BIN_DIR/mysqldump -u $DB_USER -p$DB_PASS $DB_ZFBM $DB_NAME $DB_TABLE | gzip &gt; $BCK_DIR/db_$DATE.sql.gz#data beifen$BIN_DIR/mysqldump --opt -u$DB_USER -p$DB_PASS -h$DB_HOST $DB_ZFBM $DB_NAME | gzip &gt; $BCK_DIR/db_$DATE.sql.gz#sql back#$BIN_DIR/mysqldump --opt -u$DB_USER -p$DB_PASS -h$DB_HOST $DB_ZFBM $DB_NAME $DB_TABLE &gt; $BCK_DIR/db_$DATE.sql#find $BCK_DIR -name "db_*.sql" -type f -mtime +3 -exec rm &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1find $BCK_DIR -name "db_*.gz" -type f -mtime +3 -exec rm &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1 脚本说明： $BIN_DIR mysql备份地址 $DB_USER 数据库用户名 $DB_PASS 数据库密码 $DB_HOST 数据库地址（IP或者是localhost之类的） $DB_ZFBM 字符集编码设置（这个很关键，解决导出文件中中文乱码） $DB_NAME 数据库名称 $DB_TABLE 要备份的表名（如果只对单一表进行备份，可以加此字段，全库备份的可以省略掉） $BCK_DIR/db_$DATE.sql 备份的地址和备份文件名称 给脚本文件加权限 1chmod +x /usr/sbin/bakmysql.sh 执行脚本，验证脚本是否正确，正确的话，备份目录会出现对应日期的文件 1./bakmysql.sh 编辑定时任务列表 1234crontab -e# 输入：# 每天早上 5:00am 执行00 05 * * * /bin/sh /usr/sbin/bakmysql.sh 查看设置的定时任务是否成功 1crontab -l 重启crontab（分别有给出了别的操作命令） 1234567891011121314# 重启/bin/systemctl restart crond.service # 开启/bin/systemctl start crond.service # 停止/bin/systemctl stop crond.service # 重载/bin/systemctl reload crond.service # 状态/bin/systemctl status crond.service 解释 导出的脚本 12345678#--skip-lock-tables zg backup$BIN_DIR/mysqldump -u $DB_USER -p$DB_PASS $DB_ZFBM $DB_NAME $DB_TABLE | gzip &gt; $BCK_DIR/db_$DATE.sql.gz#data beifen$BIN_DIR/mysqldump --opt -u$DB_USER -p$DB_PASS -h$DB_HOST $DB_ZFBM $DB_NAME | gzip &gt; $BCK_DIR/db_$DATE.sql.gz#sql back$BIN_DIR/mysqldump --opt -u$DB_USER -p$DB_PASS -h$DB_HOST $DB_ZFBM $DB_NAME $DB_TABLE &gt; $BCK_DIR/db_$DATE.sql 第三条导出的是整个数据库文件，较大，建议使用压缩文件的形式，即第一、二条，导出整个数据库表使用第二条，导出某个数据库表使用第一条（带 $DB_TABLE） 定时删除备份数据库脚本 1find $BCK_DIR -name "db_*.gz" -type f -mtime +3 -exec rm &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1 -type f 表示查找普通类型的文件，f表示普通文件。 -mtime +3 按照文件的更改时间来查找文件，+3表示文件更改时间距现在3天以前；如果是 -mmin +5 表示文件更改时间距现在5分钟以前。 -exec rm {} \; 表示执行一段shell命令，exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号。 /dev/null 2&gt;&amp;1 把标准出错重定向到标准输出，然后扔到/DEV/NULL下面去。通俗的说，就是把所有标准输出和标准出错都扔到垃圾桶里面；其中的&amp; 表示让该命令在后台执行。 定时的一些说明： crontab 配置文件格式如下： 分 时 日 月 周 命令 {minute} {hour} {day-of-month} {month} {day-of-week} {full-path-to-shell-script} minute: 区间为 0 – 59 hour: 区间为 0 – 23 day-of-month: 区间为 0 – 31 month: 区间为 1 – 12. 1 是1月. 12是12月. Day-of-week: 区间为 0 – 7. 周日可以是0或7. crontab 示例 在 12:01 a.m 运行，即每天凌晨过一分钟。这是一个恰当的进行备份的时间，因为此时系统负载不大。 1 0 * * * /root/bin/backup.sh 每个工作日(Mon – Fri) 11:59 p.m 都进行备份作业。 59 11 * * 1,2,3,4,5 /root/bin/backup.sh 59 11 * * 1-5 /root/bin/backup.sh 每5分钟运行一次命令 */5 * * * * /root/bin/check-status.sh 每个月的第一天 1:10 p.m 运行 10 13 1 * * /root/bin/full-backup.sh 每个工作日 11 p.m 运行。 0 23 * * 1-5 /root/bin/incremental-backup.sh 还原数据库1234567891011mysql -u root -p# 根据提示输入密码后进入mysql控制台show databases;# 创建数据库create database mysite;# 进入数据库use mysite;# 从文件导入所有数据source /mysqlbak/hostel.sql# 注意：如果备份的数据库是 gz文件，需要实现解压：gzip -d file.sql.gz 参考文章linux定时备份mysql并同步到其它服务器 Linux下Mysql的数据库备份（基于 CentOS 7.4 64位） crontab 定时任务时间格式设置]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次MySQL数据库崩溃历程]]></title>
    <url>%2F2020%2F04%2F24%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E8%AE%B0%E4%B8%80%E6%AC%A1MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B4%A9%E6%BA%83%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[上星期在等待毕业论文的批改时，想着把开发毕业项目时收录的问题和解决方法整理成文章。就在自己验证数据库的某个操作时，突然数据库报错打不开，赶紧百度，折腾了一天，最后数据库真的凉了，只能选择重装，抱着应该可以自动找回之前的数据的微弱希望，重装了后发现还是报错，在这个时候突然醒悟了如何解决以及当初自己如何一步步走向深渊。尽管最后还是要重录数据，但是摸索出来了原因后，心里美滋滋。接下来还原一下当时的场景和整理解决方法。 踩坑记 打开 HediSQL 输入密码，发现 1Access denied for user &apos;root&apos;@&apos;ip地址&apos; (using password: YES) 服务器连接 mySQL ，能够成功 百度之后，在 .my.cnf文件中的 mysqld 加 skip-grant-tables 除了加字段，还尝试了改密码 重启服务器，重启数据库 systemctl restart mysqld 结果报错 12Job for mysql.service failed because the control process exited with error code.See &quot;systemctl status mysql.service&quot; and &quot;journalctl -xe&quot; for details. 如果是使用 mysql -u root -p 会报 1Can&apos;t connect to local MySQL server through socket &apos;/var/lib/mysql/mysql.sock 接下来一直围绕着上面两个报错打转，网上的方法要么是内存泄露，但是我的内存没有，要么是改.sock，或者改成tmp.sock 软连接。反复尝试，报错依旧，最后破罐子破摔，重装！ 重装后，使用 systemctl restart mysqld 重启数据库，这时服务器连接 mySQL 终于没问题了，数据因为前面为了解决报错乱输命令的缘故已删除或损坏，无法还原。但打开HediSQL发现还是出错，（注意：服务器连接mySQL没问题）便打算去阿里云服务器中点击重启，然后重启数据库报错了！这个时候是为何呢？ 想起第一次报错的时候，自己想到是不是服务器的锅，重启服务器后再重启数据库，在服务器连接mySQL才出现的 .sock 地狱，之前尽管HediSQL报错，但是服务器是可以连接mySQL的，所以问题出在重启服务器上！ 百度‘重启服务器 无法启动 mySQL’，很快解决办法就搜出来了：需要删除 mySQL 文件中的 ib_logfile0 和 ib_logfile1 两个文件 mySQL 的 innodb 中事务日志：ib_logfile 事务日志或称 redo 日志，在 mySQL 中默认以 ib_logfile0,ib_logfile1 名称存在,可以手工修改参数，调节开启几组日志来服务于当前 mySQL 数据库,mySQL 采用顺序，循环写方式，每开启一个事务时，会把一些相关信息记录事务日志中(记录对数据文件数据修改的物理位置或叫做偏移量)； 作用:在系统崩溃重启时，作事务重做；在系统正常时，每次checkpoint时间点，会将之前写入事务应用到数据文件中。 设想，在服务器重启的时候，数据库从原有的事务日志中恢复，但是发生一些异常，比如 bin-log 没写，最后导致主从不一致。解决办法：干净关闭数据库情况下，删除 mySQL 文件中的 ib_logfile，而后重启数据库，会自行创建该文件。 总结这次的崩溃真是意想不到，因为之前也试过重启服务器的操作，但是没有出错，令人感到玄学，所以以后还是不要随意重启服务器为妙。HediSQL的报错最后解决的也比较玄学，在删除两个文件后，又可以连接了。不确定是不是因为之前尝试过在 my.conf [mysqld]中添加skip-name-resolve，配置账号远程权限grant all privileges on *.* to &#39;mysql&#39;@&#39;%&#39; identified by &#39;passwd&#39; with grant option; flush privileges; 解决思路应该是这样子。 也引申出一个很重要的问题：为何当初没做数据库备份！！！！如果备份了，就不会在重不重装上犹豫不决，为了不重装不重录数据，一直死磕…幸亏这次是数据库中没有太多逻辑上的 SQL语句，大部分是表、试图、简单的存储过程和定时事件，不然真的会猛虎落泪 &gt;&lt;。所以在重录数据库后，赶紧做了一次定时数据库备份操作，将在下一篇文章中阐述，如何定时备份数据库，定时删除多余数据库数据以及如何还原数据库。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决input在移动端点击时页面会放大的问题]]></title>
    <url>%2F2020%2F04%2F17%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F%E8%A7%A3%E5%86%B3input%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%82%B9%E5%87%BB%E6%97%B6%E9%A1%B5%E9%9D%A2%E4%BC%9A%E6%94%BE%E5%A4%A7%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在毕设项目（移动项目）中，发现真机测试时，点击输入框，页面会放大，以下为解决办法： 12&lt;!-- Vue项目中的index.html中加 --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1"/&gt;]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-滚动行为]]></title>
    <url>%2F2020%2F04%2F17%2FVue%2F%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[在毕设项目中，想要当切换到新路由时，让页面自动滚到顶部。想到这个效果后，第一个涌入脑海里的解决办法就是给路由的afterEach()方法加window.scrollTo(0, 0)，又觉得不太优雅，能不能统一处理呢？查阅资料后，发现官方有提供应对的解决办法vue官方-滚动行为 12345678// 在router实例中添加scrollBehavior(to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition &#125; return &#123; x: 0, y: 0 &#125;&#125;// 第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的 前进/后退 按钮触发) 时才可用，如果返回一个 falsy (虚值：是在 Boolean 上下文中认定为 false 的值)的值，或者是一个空对象，那么不会发生滚动。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue项目中的时间在ios显示NaN的问题]]></title>
    <url>%2F2020%2F04%2F17%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2FVue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%9C%A8ios%E6%98%BE%E7%A4%BANaN%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在毕设项目中，发现2020-03-22 10:00:00这种类型的时间，在ios显示为NaN-NaN-NaN NaN:NaN:NaN，但是在PC端调试没有任何问题，数据是正常到达页面的，为啥到了真机就NaN呢？查阅资料后发现，ios 不支持时间的-连接符，解决方法可以把-替换成/ 123var date = '2020-03-22 12:00:00';var format = date.replace(/-/g, '/');var time= Date.parse(new Date(format));]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-生成5个不重复的随机数]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F9.%20%E7%94%9F%E6%88%905%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[生成5个不重复的随机数[1-5] 123456789101112131415161718192021222324252627282930313233343536import java.util.Random;public class RandomTest02 &#123; public static void main(String[] args) &#123; Random r = new Random(); int[] a = new int[5]; int index = 0; while (index &lt; 5) &#123; int temp = r.nextInt(6); if (temp != 0 &amp;&amp; !contains(a, temp)) &#123; a[index++] = temp; &#125; &#125; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; &#125; // 判断temp元素在a数组中是否包含 private static boolean contains(int[] a, int temp) &#123; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i] == temp) &#123; return true; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-枚举类型 enum]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.18%20%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%20enum%2F</url>
    <content type="text"><![CDATA[需求：定义一个方法，该方法的作用是计算两个 int 类型数据的商。如果计算成功返回1，执行失败返回0 程序执行成功，但是该程序可能存在风险，比如写错返回的值，导致判断失误 程序中的问题能在编译阶段解决的，绝对不会放在运行期解决，所以引入“枚举类型” 123456789101112131415161718192021222324252627282930public class EnumTest01 &#123; public static void main(String[] args) &#123; int a = 10; int b = 0; Result retValue = divide(a, b); if (retValue == Result.SUCCESS) &#123; System.out.println("成功"); &#125; else if (retValue == Result.FAIL) &#123; System.out.println("失败"); &#125; &#125; private static Result divide(int a, int b) &#123; try &#123; int c = a / b; return Result.SUCCESS; &#125; catch (Exception e) &#123; return Result.FAIL; &#125; &#125;&#125;// 定义一个枚举类型enum Result &#123; // 规范要求：大写 SUCCESS, FAIL&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-随机数 Random]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.17%20%E9%9A%8F%E6%9C%BA%E6%95%B0%20Random%2F</url>
    <content type="text"><![CDATA[用来生成随机数 1234567891011121314import java.util.Random;public class RandomTest01 &#123; public static void main(String[] args) &#123; // 创建一个新的随机数生成器 Random r = new Random(); // 循环生成5个随机数 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(r.nextInt(10)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-BigDecimal]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.16%20BigDecimal%2F</url>
    <content type="text"><![CDATA[java.math.BigDecimal;该类型的数据精确度极高，适合做财务软件；财务软件中 double 类型精确度太低 123456789101112131415161718import java.math.BigDecimal;public class NumberTest02 &#123; public static void main(String[] args) &#123; // 创建大数据 BigDecimal v1 = new BigDecimal(10); BigDecimal v2 = new BigDecimal(20); // 做加法运算 // v1 + v2; 错误：两个引用类型不能做加法运算 // 必须调用方法执行加法运算 BigDecimal v3 = v1.add(v2); System.out.println(v3); // 30 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-DecimalFormat 数字格式化]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.15%20DecimalFormat%20%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[关于数字格式化：java.text.DecimalFormat;数字格式元素： # 任意数字 , 千分位 . 小数点0 不够补0 12345678910111213141516171819202122import java.text.DecimalFormat;public class NumberTest01 &#123; public static void main(String[] args) &#123; // 1. 创建数字格式化对象 // 需求：加入千分位 DecimalFormat df = new DecimalFormat("###,###"); // 开始格式化 // Number --&gt; Sting System.out.println(df.format(1234567)); // 1,234,567 // 需求：加入千分位，保留2位小数 DecimalFormat df1 = new DecimalFormat("###,###.##"); System.out.println(df1.format(1234567.123)); // 1,234,567.12 // 需求：加入千分位，保留4位小数，不够补0 DecimalFormat df2 = new DecimalFormat("###,###.0000"); System.out.println(df2.format(1234567.123)); // 1,234,567.1230 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-日历 Calendar]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.14%20%E6%97%A5%E5%8E%86%20Calendar%2F</url>
    <content type="text"><![CDATA[获取当前日历、当前星期几、指定日期的星期几 12345678910111213141516171819202122232425262728import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;public class DateTest05 &#123; public static void main(String[] args) throws ParseException &#123; // 获取系统当前日历 Calendar c = Calendar.getInstance(); System.out.println(c); // 查看当前日历的“星期几” int i = c.get(Calendar.DAY_OF_WEEK); System.out.println(i); // 7（中国星期日，外国看成第一天） // 获取2008 8 8是星期几 // 1. 获取2008 8 8的日历 String strTime = "2008,08,08"; Date d = new SimpleDateFormat("yyy,MM,dd").parse(strTime); // 该日历就是2008 8 8的日历 c.setTime(d); System.out.println(c.get(Calendar.DAY_OF_WEEK)); // 6 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-获取当前时间的前10分钟的时间]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.13%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E7%9A%84%E5%89%8D10%E5%88%86%E9%92%9F%E7%9A%84%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[获取当前时间的前10分钟的时间 1234567891011121314151617181920import java.text.SimpleDateFormat;import java.util.Date;public class DateTest04 &#123; public static void main(String[] args) &#123; // 1000 是自 1970-1-1 00:00:00 000 的毫秒数 Date t1 = new Date(1000); // Date --&gt; String SimpleDateFormat sdf = new SimpleDateFormat("yyy,MM,dd HH:mm:ss SSS"); // 北京东八区 System.out.println(sdf.format(t1)); // 1970,01,01 08:00:01 000 // 获取当前系统时间的前十分钟时间 Date t2 = new Date(System.currentTimeMillis() - 1000 * 60 * 10); System.out.println(sdf.format(t2)); // 2020,02,29 16:36:40 472 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-SimpleDateFormat 解析字符串]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.12%20SimpleDateFormat%20%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[通过解析日期字符串为例，说明 12345678910111213141516171819import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateTest03 &#123; public static void main(String[] args) throws ParseException &#123; String strTime = "2020年02月29日 16:33:19 957"; // 将 String 日期转换成日期类型 Date String--&gt;Date // 1. 创建日期格式化对象 SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss SSS"); // 格式不能随意，需要和上面的字符串格式一致 // 2. 将字符串转换成日期类型 Date t = sdf.parse(strTime); System.out.println(t); // Sat Feb 29 16:33:19 CST 2020 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-SimpleDateFormat 格式化日期]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.11%20SimpleDateFormat%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[通过格式化系统当前日期为例，说明 1234567891011121314151617181920212223242526import java.text.SimpleDateFormat;import java.util.Date;public class DateTest02 &#123; public static void main(String[] args) &#123; // 获取系统当前时间 java.util.Date --&gt; String Date nowTime = new Date(); System.out.println(nowTime); // Sat Feb 29 16:33:19 CST 2020 // 以上程序说明 java.util.Date 已经重写了 Object 中的 toString 方法 // 但是重写的结果对于中国人来说不容易理解 // 下面“格式化”日期 /* * 日期格式： y 年 M 月 d 日 H 小时 m 分 s 秒 S 毫秒 */ // 1. 创建日期格式化对象 SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss SSS"); // 2. 开始格式化（Date --&gt; String） String strTime = sdf.format(nowTime); System.out.println(strTime); // 2020年02月29日 16:33:19 957 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-获取当前系统时间的毫秒数]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.10%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E6%AF%AB%E7%A7%92%E6%95%B0%2F</url>
    <content type="text"><![CDATA[获取自 1970年1月1日 00时00分00秒 000毫秒 到当前的毫秒数1000毫秒 = 1秒 123456public class DateTest01 &#123; public static void main(String[] args) &#123; long now = System.currentTimeMillis(); System.out.println(now); // 1582964795679 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-自动装箱、自动拆箱]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.9%20%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[JDK 5.0 新特性【以下的特性适合 JDK1.5 版本之后，包括1.5】自动装箱（auto_boxing）和自动拆箱（auto_unboxing） 12345678910111213141516171819202122232425262728public class IntegerTest05 &#123; public static void main(String[] args) &#123; // JDK 5.0 之前 // int --&gt; Integer（装箱） Integer i1 = new Integer(10); // Integer --&gt; int（拆箱） int i2 = i1.intValue(); m1(321); // 自动装箱 321 System.out.println(m2(10, 5)); // 自动拆箱 5 // JDK 5.0 之后，包括 5.0 Integer i3 = 10; // 自动装箱 int i4 = i3; // 自动拆箱 System.out.println(i3); // "10" System.out.println(i4 + 1); // 11 &#125; private static void m1(Object o) &#123; System.out.println(o); &#125; private static int m2(Integer i, Integer j) &#123; return i - j; &#125;&#125; 深入 自动装箱和自动拆箱是程序编译阶段的一个概念，和程序运行无关 主要目的：方便程序员编码 比较两个 Integer 类型的数据是否相等，不能用“=”，Integer 已经重写了 Object 中的 equals 方法 12345678910111213141516171819202122public class IntegerTest06 &#123; public static void main(String[] args) &#123; Integer i1 = new Integer(10); Integer i2 = new Integer(10); // 这里不会有自动拆箱 System.out.println(i1 == i2); // false // 应该使用 equals 方法比较 System.out.println(i1.equals(i2)); // true // 重点： Integer i3 = 128; Integer i4 = 128; // 上面等同于 // Integer i3 = new Integer(128); // Integer i4 = new Integer(128); System.out.println(i3 == i4); // false &#125;&#125; 如果数据是在（-128127）之间，java 中引入了一个“整型常量池”，在方法区中。**该整型常量池只存储-128127之间的数据** 1234567Integer i5 = 127; // 这个程序不会在堆中创建对象，会直接从整型常量池中拿Integer i6 = 127;System.out.println(i5 == i6); // trueInteger i7 = -129; // 这个程序不会在堆中创建对象，会直接从整型常量池中拿Integer i8 = -129;System.out.println(i7 == i8); // false]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-Integer、int 和 String 互相转换]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.8%20Integer%E3%80%81int%20%E5%92%8C%20String%20%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Integer、int 和 String 三种类型互相转换 123456789101112131415161718192021public class IntegerTest04 &#123; public static void main(String[] args) &#123; // 1. int--&gt;Integer Integer i1 = Integer.valueOf(10); // 2. Integer--&gt;int int i2 = i1.intValue(); // 3. String--&gt;Integer Integer i3 = Integer.valueOf("10"); // 4. Integer--&gt;String String s1 = i3.toString(); // 5. String--&gt;int int i4 = Integer.parseInt("123"); // 6. int--&gt;String String s2 = 10 + ""; &#125;&#125; ![image-20200229122915414](12.8 Integer、int 和 String 互相转换.assets/image-20200229122915414.png)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-Integer 类]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.7%20Integer%20%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[以 java.lang.Integer; 类型为例，讲解八种类型 12345678910111213141516171819202122public class IntegerTest02 &#123; public static void main(String[] args) &#123; // 获取 int 类型的最大值和最小值 System.out.println("int 最大值：" + Integer.MAX_VALUE); // 2147483647 System.out.println("int 最小值：" + Integer.MIN_VALUE); // -2147483648 // 以 int 推 byte System.out.println("byte 最大值：" + Byte.MAX_VALUE); // 127 System.out.println("byte 最小值：" + Byte.MIN_VALUE); // -128 // 创建 Integer 类型的对象 Integer i1 = new Integer(10); // int --&gt; Integer Integer i2 = new Integer("123"); // String --&gt; Integer System.out.println(i1); // 10 System.out.println(i2); // 123 // 以下程序虽然编译通过，但是运行时会报异常：数字格式化异常 // 虽然可以将字符串转换成 Integer 类型，但是该字符串必须是“数字字符串” Integer i3 = new Integer("abc"); // NumberFormatException &#125;&#125; Integer 中常用的方法1234567891011121314151617181920212223242526272829303132333435363738394041public class IntegerTest03 &#123; public static void main(String[] args) &#123; // int --&gt; Integer // 基本数据类型 --&gt; 引用类型 Integer i1 = new Integer(10); // Integer --&gt; int // 引用类型 --&gt; 基本类型 int i2 = i1.intValue(); System.out.println(i2 + 1); // 11 // 重要：static int parseInt(String s); // String --&gt; int int age = Integer.parseInt("21"); // 必须是“数字字符串” System.out.println(age + 1); // 22 // 重要：static double parseDouble(String s); double price = Double.parseDouble("3.0"); System.out.println(price + 1); // 4.0 // 将 int 类型的十进制转换成 2 进制 String s1 = Integer.toBinaryString(10); System.out.println(s1); // 1010 // 将 int 类型的十进制转换成 16 进制 String s2 = Integer.toHexString(10); System.out.println(s2); // a // 将 int 类型的十进制转换成 8 进制 String s3 = Integer.toOctalString(10); System.out.println(s3); // 12 // int --&gt; Integer Integer i3 = Integer.valueOf(10); System.out.println(i3); // 10 // String --&gt; Integer Integer i4 = Integer.valueOf("10"); System.out.println(i4); // 10 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-包装类型]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.6%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[java 中八种基本数据类型对应的包装类型： 基本数据类型 包装类型 byte java.lang.Byte; short java.lang.Short; int java.lang.Integer; long java.lang.Long; float java.lang.Float; double java.lang.Doule; boolean java.lang.Boolean; char java.lang.Character; 包装类型的作用：方便！ 1234567891011121314151617public class IntegerTest01 &#123; // 需求：规定 m1 方法可以接收 java 中任何一种数据类型 // m1 方法如果想接收 byte 类型的数据，可以将 byte 类型先包装成 java.lang.Byte; 再传递参数 public static void m1(Object o) &#123; System.out.println(o); // 10 &#125; public static void main(String[] args) &#123; // 基本数据类型 byte b = 10; // 引用类型 Byte b1 = new Byte(b); m1(b1); // Byte 已经将 Object 中的 toString 方法重写 &#125;&#125; 类层次结构![image-20200229120424673](12.6 包装类型.assets/image-20200229120424673.png)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-StringBuffer 和 StringBuilder]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.5%20StringBuffer%20%E5%92%8C%20StringBuilder%2F</url>
    <content type="text"><![CDATA[java.lang.StringBuffer、java.lang.StringBuilder 是一个字符串缓存区 工作原理：预先在内存中申请一块空间，以容纳字符序列，如果预留的空间不够用，则进行自动扩容，以容纳更多字符序列 和 String 最大的区别 String 是不可变的字符序列，存储在字符串常量池中 StringBuffer 和 StringBuilder 底层是一个 char 数组，但是该数组是可变的，并且可以自动扩容 StringBuffer 和 StringBuilder 的默认初始化容量是 16 如何优化 StringBuffer 和 StringBuilder 呢？ 最好在创建前，预测存储字符数量，然后在创建的时候采用指定初始化容量的方式。为了减少底层数组的拷贝，提高效率。 StringBuffer 和 StringBuilder 的区别 前者是线程安全的（可以在多线程的环境下使用，不会出现问题） 后者是非线程安全的（在多线程环境下使用可能出现问题） 12345678910111213141516171819202122public class StringTest02 &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 可以向 StringBuffer 中追加字符串 String[] ins = &#123; "体育", "音乐", "睡觉" &#125;; // 推荐字符串频繁拼接使用 StringBuffer 或 StringBuilder for (int i = 0; i &lt; ins.length; i++) &#123; if (i == ins.length - 1) &#123; sb.append(ins[i]); &#125; else &#123; sb.append(ins[i]); sb.append(","); &#125; &#125; System.out.println(sb); // 体育,音乐,睡觉 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-正则表达式初步]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.4%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9D%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[正则表达式是一门独立的学科 是一种字符模型，专门做字符串格式匹配 正则表达式是通用的 \d 数字\D 非数字\w 英文字母\W 非英文字母]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-字符串常用方法]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.3%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[整理字符串的常用方法 方法名 作用 1 char charAt(int index); 返回指定下标的字符 2 boolean endsWith(String endStr); 判断字符串是否以指定的后缀结束 3 boolean StartsWith(String startStr); 判断字符串是否以指定的前缀开始 4 boolean equals(String anotherString); 字符串相等比较，不忽略大小写 5 boolean equalsIgnoreCase(String anotherString); 字符串相等比较，忽略大小写 6 int indexOf(String str); 取得指定字符在字符串的位置 7 int indexOf(String str, int fromIndex); 8 int lastIndexOf(String str); 返回最后一次字符串出现的位置 9 int lastIndexOf(String str, int fromIndex); 10 int length(); 取得字符串的长度（数组是length属性，String是length()方法） 11 String replaceAll(String s1, String s2); 替换字符串中指定的内容 12 String[] split(String s); 根据指定的表达式拆分字符串 13 String substring(int begin); 截子串 14 String substring(int begin, int endIndex); 子串，包括begin，不包括end 15 char[] toCharArray(); 将此字符串转换成一个新的字符数组 16 String toLowerCase(); 转换成小写 17 String toUpperCase(); 转换成大写 18 String trim(); 去前尾空格 19 String valueOf(Object obj或是其他类型char、boolean等); 将其他类型转换成字符串 20 byte[] getBytes(); 获得字符串中每个字符的Ascll码值]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-创建字符串]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.2%20%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[关于字符串常用构造方法 123456789101112131415161718192021222324252627public class StringTest01 &#123; public static void main(String[] args) &#123; // 1. 直接赋值 String s1 = "abc"; // 2. 采用 new 构造器 String s2 = new String("abc"); // 3. 传入 byte 数组 byte[] bytes = &#123; 97, 98, 99, 100 &#125;; String s3 = new String(bytes); System.out.println(s3); // abcd // 4. 截取 byte 数组中的某一段 String s4 = new String(bytes, 1, 2); System.out.println(s4); // bc // 5. 传入 char 数组 char[] c1 = &#123; 'l', 'i', 'k', 'e' &#125;; String s5 = new String(c1); System.out.println(s5); // like // 6. 截取 char 数组中的某一段 String s6 = new String(c1, 1, 2); System.out.println(s6); // ik &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-String 类]]></title>
    <url>%2F2020%2F02%2F29%2FJava%2F%E8%BF%9B%E9%98%B6%2F12.%20String%20%E7%B1%BB%2F12.1%20String%20%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java.lang.String 是字符串类型 字符串一旦创建不可修改 在 String 类 的源代码中，是这样定义值的 private final char value[]，所以这个值不能二次赋值 不可修改不是说不能重新指向，而是值本身不可变 String s1 = &quot;abc&quot;; 可重新指向 s1 = &quot;cs&quot;; 提升字符串的访问效率：在程序中使用了“缓存”的技术，所以在 Java 中所有使用“双引号”括起来的字符串都会在“字符串常量池”中创建一份。字符串常量池在方法区中被存储 在程序执行过程中，如果程序用到某个字符串，例如“ABC”，那么程序会在字符串常量池中去搜索该字符串，如果没有找到则在字符串常量池中新建一个“ABC”字符串；如果找到就直接拿过来用。（字符串常量池是一个缓存区，为了提高访问字符串的效率） 分析以下程序创建字符串对象的区别： String s1 = &quot;abc&quot;; 只会在字符串常量池中创建一个“abc”字符串对象 String s2 = new String(&quot;hello&quot;); 会在字符串常量池中创建一个“hello”字符串对象，并且会在堆中再创建一个字符串对象 第二种方式比较浪费内存，常用的是第一种方式 使用 String 的时候我们应该注意的问题：尽量不要做字符串频繁的拼接操作。因为字符串一旦创建不可改变，只要频繁拼接，就会在字符串常量池中创建大量的字符串对象，给垃圾回收带来问题 推荐字符串频繁拼接使用 StringBuffer 或 StringBuilder]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-模拟酒店管理系统]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F8.%20%E6%A8%A1%E6%8B%9F%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[需求：显示酒店所有房间列表，预订房间，退房… 已知： 1234567891011121314151617181920212223242526272829303132333435class Room &#123; String no; String type; // "标准间" "双人间" "豪华间" boolean isUse; // true表示占用，false表示空闲&#125;class Hostel &#123; // 规定酒店：5层，每层10个房间 // 1，2层是标准间 // 3，4层是双人间 // 5 是豪华间 Room[][] rooms; // 无参数 Hostel() &#123; this(5, 10); &#125; //有参数 Hostel(int rows, int cols) &#123; rooms = new Room[rows][cols]; /* rooms[0][0] .. rooms[4][9] .. */ &#125; // 对外提供预定方法 // 对外提供退房方法&#125;class Test()&#123; // main&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//酒店的房间public class Room &#123; private String no; private String type; // 标准间 双人间 豪华间 private boolean isUse; // false表示空闲，true表示占用 public Room() &#123; super(); &#125; public Room(String no, String type, boolean isUse) &#123; super(); this.no = no; this.type = type; this.isUse = isUse; &#125; public String getNo() &#123; return no; &#125; public void setNo(String no) &#123; this.no = no; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public boolean isUse() &#123; return isUse; &#125; public void setUse(boolean isUse) &#123; this.isUse = isUse; &#125; public String toString() &#123; return "[" + no + "," + type + "," + (isUse ? "占用" : "空闲") + "]"; &#125;&#125;public class Hotel &#123; // 房间 Room[][] rooms; // Constructor Hotel() &#123; // 5层 每层10个房间 rooms = new Room[5][10]; // 赋值 // 1,2 标准间 // 3 4 双人间 // 5 豪华间 for (int i = 0; i &lt; rooms.length; i++) &#123; for (int j = 0; j &lt; rooms[i].length; j++) &#123; if (i == 0 || i == 1) &#123; rooms[i][j] = new Room(((i + 1) * 100) + j + 1 + "", "标准间", false); &#125; if (i == 2 || i == 3) &#123; rooms[i][j] = new Room(((i + 1) * 100) + j + 1 + "", "双人间", false); &#125; if (i == 4) &#123; rooms[i][j] = new Room(((i + 1) * 100) + j + 1 + "", "豪华间", false); &#125; &#125; &#125; &#125; // 对外提供一个打印酒店房间列表的方法 public void print() &#123; for (int i = 0; i &lt; rooms.length; i++) &#123; for (int j = 0; j &lt; rooms[i].length; j++) &#123; System.out.print(rooms[i][j] + " "); &#125; System.out.println(); &#125; &#125; // 对外提供一个预订酒店的方法 public void order(String no) &#123; for (int i = 0; i &lt; rooms.length; i++) &#123; for (int j = 0; j &lt; rooms[i].length; j++) &#123; if (rooms[i][j].getNo().equals(no)) &#123; // 将该房间的状态改成占用 rooms[i][j].setUse(true); return; &#125; &#125; &#125; &#125;&#125;import java.util.Scanner;public class Test &#123; public static void main(String[] rags) &#123; Scanner s = new Scanner(System.in); System.out.println("欢迎使用酒店管理系统，酒店房间列表如下所示："); // 初始化酒店 Hotel h = new Hotel(); // 输出房间列表 h.print(); while (true) &#123; System.out.print("请输入预订房间的编号："); String no = s.next(); // 预订房间 h.order(no); // 打印酒店列表 h.print(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-Arrays 工具类]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E8%BF%9B%E9%98%B6%2F11.%20%E6%95%B0%E7%BB%84%2F11.5%20Arrays%20%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Arrays 是 SUN 提供的一个工具类：java.util.Arrays该工具类主要针对的是数组的操作：排序、二分查找等 12345678910111213141516import java.util.Arrays;public class ArrayTest01 &#123; public static void main(String[] args) &#123; int[] a = &#123; 3, 1, 6, 2, 5 &#125;; // 排序 Arrays.sort(a); for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; // 对排序后的数据进行二分查找 int index = Arrays.binarySearch(a, 6); System.out.println(index); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-二分法查找]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F7.%20%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分法查找是建立在已经排序的基础之上的在这个数组中找到 7 的下标：1, 3, 4, 5, 7, 8, 10 1234567891011121314151617181920212223242526272829public class MyArrays &#123; public static void main(String[] args) &#123; int[] a = &#123; 1, 3, 4, 5, 7, 8, 10 &#125;; int destElement = 7; int index = binarySearch(a, destElement); System.out.println((index == -1) ? destElement + " 元素不存在!" : destElement + " 在数组中的下标为:" + index); &#125; private static int binarySearch(int[] a, int destElement) &#123; int begin = 0; int end = a.length - 1; while (begin &lt;= end) &#123; int mid = (begin + end) / 2; if (destElement == a[mid]) &#123; return mid; &#125; else if (destElement &lt; a[mid]) &#123; end = mid - 1; &#125; else if (destElement &gt; a[mid]) &#123; begin = mid + 1; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-选择排序]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F6.%20%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择排序：int 类型的数组 3 1 6 2 5 算法：找出最小值，然后这个最小值和最前面的数据交换位置 12345678910111213141516171819202122232425262728public class SelectSort &#123; public static void main(String[] args) &#123; int[] a = &#123; 3, 1, 6, 2, 5 &#125;; // 假设第一个数据是最小值 // 记录最小值元素的下标 int min = 0; for (int i = 0; i &lt; a.length - 1; i++) &#123; for (int j = i; j &lt; a.length; j++) &#123; if (a[j] &lt; a[min]) &#123; // 给min重新赋值 min = j; &#125; &#125; // 交换位置 if (min != i) &#123; int temp = a[min]; a[min] = a[i]; a[i] = temp; &#125; &#125; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; &#125;&#125; 分析思路： 第一次循环：3 1 6 2 5 1 3 6 2 5 第二次循环：3 6 2 5 2 6 3 5 第三次循环 ：6 3 5 3 6 5 第四次循环：6 5 5 6 牢牢记住要在待排序中找到最小值，然后和待排序的第一个元素进行交换！]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-冒泡排序]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F5.%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序：int 类型的数组 3 1 6 2 5 算法：大的冒出来，小的沉下去 12345678910111213141516171819public class BubbleSort &#123; public static void main(String[] args) &#123; int[] a = &#123; 3, 1, 6, 2, 5 &#125;; for (int i = a.length - 1; i &gt; 0; i--) &#123; for (int j = 0; j &lt; i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; // 交换位置 int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; &#125;&#125; 分析思路： 第一次循环：3 1 6 2 5 1 3 6 2 5 1 3 6 2 5 1 3 2 6 5 1 3 2 5 6 第二次循环：1 3 2 5 1 3 2 5 1 2 3 5 1 2 3 5 第三次循环：1 2 3 1 2 3 1 2 3 第四次循环：1 2 1 2 循环4次，逐步变为1，所以外循环i = 4;i--； 里循环，循环为4 3 2 1，如果j&lt;i;j++]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-使用数组模拟栈]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F4.%20%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈：后进先出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Stack类public class Stack &#123; // 使用数组存储数据 Object[] elements; // 指向栈顶元素上方的一个帧 int index; // 栈默认的初始化容量是5 Stack() &#123; this(2); &#125; Stack(int max) &#123; elements = new Object[max]; &#125; // 压栈方法 public void push(Object element) throws StackOperationException &#123; if (index == elements.length) &#123; throw new StackOperationException("栈已满"); &#125; elements[index++] = element; &#125; // 弹栈方法 public Object pop() throws StackOperationException &#123; if (index == 0) &#123; throw new StackOperationException("栈已空！"); &#125; return elements[--index]; &#125;&#125;// 异常类public class StackOperationException extends Exception &#123; public StackOperationException() &#123; &#125; public StackOperationException(String msg) &#123; super(msg); &#125;&#125;// 测试类public class StackTest &#123; public static void main(String[] args) &#123; Stack s = new Stack(); User u1 = new User("Jack", 20); User u2 = new User("Zhang", 21); User u3 = new User("Li", 22); // 压栈 try &#123; s.push(u1); s.push(u2); s.push(u3); &#125; catch (StackOperationException e) &#123; e.printStackTrace(); &#125; // 弹栈 try &#123; System.out.println(s.pop()); System.out.println(s.pop()); // System.out.println(s.pop()); &#125; catch (StackOperationException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User &#123; String name; int age; User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String toString() &#123; return "User[name=" + name + ",age=" + age + "]"; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-接收用户接盘输入]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E8%BF%9B%E9%98%B6%2F11.%20%E6%95%B0%E7%BB%84%2F11.4%20%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[12345678910111213import java.util.Scanner;public class ArrayTest01 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); // 程序执行到此处，停下来，等待用户的输入 String userInput = s.next(); System.out.println("您输入了:" + userInput); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-二维数组]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E8%BF%9B%E9%98%B6%2F11.%20%E6%95%B0%E7%BB%84%2F11.3%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[二维数组是特殊的一维数组 特殊在这个一维数组中每一个元素都是“一维数组” 静态初始化12345int[][] a = &#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125;, &#123;0&#125;&#125; 动态初始化1int[][] a = new int[3][4]; 方法调用时的传递参数123m1(a);m1(new int[][] &#123;&#123;1, 2, 3&#125;, &#123;0&#125;&#125;);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-数组的拷贝]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F3.%20%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[JDK 中提供的方法：System.arraycopy(源数组，源数组的开始下标，目标数组，目标数组的开始下标，拷贝的长度); 1234567891011121314151617181920public class ArrayTest01 &#123; public static void main(String[] args) &#123; int[] src = &#123; 1, 2, 3, 4, 5 &#125;; int[] dest = &#123; 10, 11, 12, 13 &#125;; int[] dest1 = new int[5]; // 把src中的2，3拷贝到dest数组从10开始 System.arraycopy(src, 1, dest, 1, 2); for (int i = 0; i &lt; dest.length; i++) &#123; System.out.println(dest[i]); // 10 2 3 13 &#125; // 把src拷贝到dest1 System.arraycopy(src, 0, dest1, 0, 5); for (int i = 0; i &lt; dest1.length; i++) &#123; System.out.println(dest1[i]); // 1 2 3 4 5 &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-main 方法中的 args 参数]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E8%BF%9B%E9%98%B6%2F11.%20%E6%95%B0%E7%BB%84%2F11.2%20main%20%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%20args%20%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[String[] args 是专门用来接收命令行参数的 例如：java ArryTest01 ab bc JVM 在调用 ArryTest01 类的 main 方法之前，先把 ab bc 这个字符串以“空格”的方式分割，然后存储在String数组中 1234JVM &#123; String[] args = &#123;"ab", "bc"&#125;; ArryTest01.main(args);&#125; 在 eclipse 中怎么传递参数呢？ 右键 run as -&gt; run configuration -&gt; 在 Arguments 中输入参数:(多个元素之间用空格隔开，字符串加不加双引号都可以)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-一维数组]]></title>
    <url>%2F2020%2F02%2F25%2FJava%2F%E8%BF%9B%E9%98%B6%2F11.%20%E6%95%B0%E7%BB%84%2F11.1%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组是一种引用类型 是一种简单的数据结构，线性的结构 是一个容器，可以用来存储其他元素（任意数据类型） 数组分为：一维数组、二维数组、三维数组…多维数组 存储的元素类型是统一的 长度不可改变：一旦创建长度是不可变的，固定的 数组拿首元素的内存地址作为数组对象的内存地址 优点：查找效率高 数组中存储元素的类型是统一的，每一个元素在内存中所占的空间大小是相同的； 知道数组的首元素的内存地址； 要查找的元素只要知道下标就可以快速的计算出偏移量； 通过首元素内存地址加上偏移量快速计算出要查找元素的内存地址； 通过内存地址快速定位该元素 缺点：随意的增删元素效率比较低 当增加元素时，为了保证数组中元素在空间存储是有序的，所以被添加元素位置后面的所有元素都要向后移动 删除元素也是，所有元素都要向前移动 初始化一维数组的方式： 静态初始化 动态初始化 静态初始化数据类型[] 变量名 = {元素1, 元素2...} 12345678int[] a1 = &#123;100, 200, 300&#125;; // 也可以 int a1[] = &#123;100, 200, 300&#125;;boolean[] b1 = &#123;true, false&#125;;String[] strs = &#123;"an", "bn"&#125;;char[] c2 = &#123;'a', 'b'&#125;;Object o1 = new Object();Object o2 = new Object();Object[] objs = &#123;o1, o2&#125;; 动态初始化会先在堆内存中分配这个数组，并且数组中每一个元素都采用默认值 1int[] a1 = new int[4]; 方法调用时的传递参数123456789101112131415public class ArrayTest01 &#123; public static void main(String[] args) &#123; // 第一种： int[] a = &#123; 100, 200, 300 &#125;; m1(a); // 第二种 m1(new int[] &#123; 100, 200, 300 &#125;); &#125; private static void m1(int[] a) &#123; for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-手动使用 throw 抛出异常]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.8%20%E6%89%8B%E5%8A%A8%E4%BD%BF%E7%94%A8%20throw%20%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[自定义“无效名字异常” 编译时异常，直接继承 Exception 运行时异常，直接继承 RuntimeException 12345678910111213141516171819202122232425262728293031323334353637383940414243public class IllegalNameException extends Exception &#123; // 编译时异常 // public class IllegalNameException extends RuntimeException &#123; // 运行时异常 // 定义异常一般提供两个构造方法 public IllegalNameException() &#123; &#125; public IllegalNameException(String msg) &#123; super(msg); &#125;&#125;public class CustomerService01 &#123; public void register(String name) throws IllegalNameException &#123; // 完成注册 if (name.length() &lt; 6) &#123; // 创建异常对象 // IllegalNameException e = new IllegalNameException("用户名长度不少于6位"); // 手动抛出异常 // throw e; throw new IllegalNameException("用户名长度不少于6位"); &#125; // 如果能执行到此，说明用户名合法 System.out.println("注册成功"); &#125;&#125;public class Test01 &#123; public static void main(String[] args) &#123; String username = "jack"; CustomerService01 cs = new CustomerService01(); try &#123; cs.register(username); &#125; catch (IllegalNameException e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-final、finalize 和 finally]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.7%20final%E3%80%81finalize%E5%92%8Cfinally%2F</url>
    <content type="text"><![CDATA[final：关键字，表示 最终的，不可变的 修饰的类无法被继承 方法无法被覆盖 一旦赋值后，不可二次赋值 修饰的实例变量，必须手动赋值，不能采用系统默认值 finalize：Object 的方法，GC 前会调用finally：异常机制的语句块]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-finally 语句块]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.6%20finally%20%E8%AF%AD%E5%8F%A5%E5%9D%97%2F</url>
    <content type="text"><![CDATA[finally 语句块可以直接和 try 语句块联用，try...finally... try...catch...finally... 也可以 在 finally 语句块中的代码是一定会执行的 finally 语句块是一定会执行的，所以通常在程序中为了保证某资源一定会释放，所以一般在语句块中释放资源 基础例子123456789101112131415161718192021222324252627public class ExceptionTest06 &#123; public static void main(String[] args) &#123; // try &#123; // System.out.println("AB"); // AB // return; // &#125; finally &#123; // System.out.println("66"); // 66 // &#125; // try &#123; // FileInputStream fils = new FileInputStream("a"); // // System.out.println("AB"); // 不执行 // &#125; finally &#123; // System.out.println("66"); // 存疑：不输出。但是教程和百度都说会执行，以后再看看 // &#125; // 在执行 finally 语句块之前退出了 JVM，则 finally 语句块不会执行 try &#123; // 退出 JVM System.exit(0); &#125; finally &#123; System.out.println("66"); // 不执行 &#125; &#125;&#125; 深入12345678910111213141516171819package test0222;public class ExceptionTest07 &#123; public static void main(String[] args) &#123; int i = m1(); System.out.println(i); // 10 &#125; private static int m1() &#123; int i = 10; try &#123; return i; &#125; finally &#123; i++; System.out.println("m1的i=" + i); // m1的i=11 &#125; &#125;&#125; 神奇的事发生了，两个i不一样，为啥呢，以下是m1()的执行原理 12345678int i = 10;try &#123; int temp = i; return temp;&#125; finally &#123; i++; System.out.println("m1的i=" + i); // m1的i=11&#125; 释放资源12345678910111213141516171819202122232425262728import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class ExceptionText08 &#123; public static void main(String[] args) &#123; // 必须放在外边声明 FileInputStream fils = null; try &#123; fils = new FileInputStream("a"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; // 为了保证资源一定会被释放 if (fils != null) &#123; try &#123; fils.close(); &#125; catch (IOException e2) &#123; e2.printStackTrace(); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-getMessage和printStackTrace 常用方法]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.5%20getMessage%E5%92%8CprintStackTrace%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[getMessage()：取得异常描述信息printStackTrace()：取得异常的堆栈信息（比较适合于程序调试阶段） 12345678910111213141516171819202122232425262728293031package test0222;import java.io.FileInputStream;import java.io.FileNotFoundException;public class ExceptionTest05 &#123; public static void main(String[] args) &#123; try &#123; FileInputStream fils = new FileInputStream("a"); &#125; catch (FileNotFoundException e) &#123; // e.printStackTrace(); /* * java.io.FileNotFoundException: a (系统找不到指定的文件。) at * java.io.FileInputStream.open0(Native Method) at * java.io.FileInputStream.open(FileInputStream.java:195) at * java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at * java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93) at * test0222.ExceptionTest05.main(ExceptionTest05.java:11) */ String msg = e.getMessage(); System.out.println(msg); // a (系统找不到指定的文件。) &#125; System.out.println("AB"); // AB &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-使用 try..catch... 捕获处理异常]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.4%20%E4%BD%BF%E7%94%A8%20try..catch...%20%E6%8D%95%E8%8E%B7%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1234567try &#123; 可能出现异常的代码；&#125;catch(异常类型1 变量) &#123; 处理异常的代码；&#125;catch(异常类型2 变量) &#123; 处理异常的代码；&#125;... catch 语句块可以写多个 但是从上到下catch，必须从小类型异常到大类型异常进行捕捉 最多执行一个catch 语句块，执行结束后try...catch... 就结束了 12345678910111213141516171819202122import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class ExceptionTest04 &#123; public static void main(String[] args) &#123; try &#123; FileInputStream fils = new FileInputStream("a"); System.out.println("测试"); // 上面的代码出现异常，try 语句块的代码不再继续执行，直接进入 catch 语句块执行 fils.read(); &#125; catch (FileNotFoundException e) &#123; System.out.println("读取的文件不存在"); // 读取的文件不存在 // FileNotFoundException 将 Object 中的 toString 方法重写 System.out.println(e); // java.io.FileNotFoundException: a (系统找不到指定的文件。) &#125; catch (IOException e) &#123; System.out.println("其他IO异常"); &#125; System.out.println("AB"); // AB &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-使用 throws 关键字声明异常]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.3%20%E4%BD%BF%E7%94%A8%20throws%20%E5%85%B3%E9%94%AE%E5%AD%97%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[处理异常有两种方式 声明抛出：throws 捕捉：try…catch… 先研究第一种方式：声明抛出，在方法声明的位置上使用 throws 关键字向上抛出异常 声明抛出12345678910111213141516171819import java.io.FileInputStream;public class ExceptionTest02 &#123; public static void main(String[] args) &#123; // 创建文件输入流，读取文件 FileInputStream fils = new FileInputStream("c:/a.txt"); // Java编译器如何知道以上的代码执行过程中可能出现异常呢？ // 因为 FileInputStream 这个构造方法在声明的位置上使用了 throws FileNotFoundException // 以上编译不通过，必须对其进行捕捉或声明抛出 /* * Exception in thread "main" java.lang.Error: Unresolved compilation problem: * Unhandled exception type FileNotFoundException * * at test0222.ExceptionTest02.main(ExceptionTest02.java:9) */ &#125;&#125; 怎么声明抛出呢？ 12345678910111213141516171819202122import java.io.FileInputStream;public class ExceptionTest02 &#123; // FileNotFoundException &lt; IOException &lt; Exception，包含关系，所以都能够用来声明抛出 // public static void main(String[] args) throws FileNotFoundException &#123; // public static void main(String[] args) throws IOException &#123; public static void main(String[] args) throws Exception &#123; // 创建文件输入流，读取文件 FileInputStream fils = new FileInputStream("c:/a.txt"); // 抛出错误 /* * Exception in thread "main" java.io.FileNotFoundException: c:\a.txt * (系统找不到指定的文件。) at java.io.FileInputStream.open0(Native Method) at * java.io.FileInputStream.open(FileInputStream.java:195) at * java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at * java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93) at * test0222.ExceptionTest02.main(ExceptionTest02.java:12) */ &#125;&#125; 深入 throws 使用throws处理异常不是真正处理异常，而是推卸责任； 谁调用就会抛给谁； 所以以下程序 m1 方法如果出现了异常，因为采用的是上抛，给了 JVM，JVM 遇到这个异常就会退出，所以打印的代码不会执行 1234567891011121314151617181920212223import java.io.FileInputStream;import java.io.FileNotFoundException;public class ExceptionTest03 &#123; public static void main(String[] args) throws FileNotFoundException &#123; m1(); // 不可以打印 System.out.println("测试"); &#125; public static void m1() throws FileNotFoundException &#123; m2(); &#125; private static void m2() throws FileNotFoundException &#123; m3(); &#125; private static void m3() throws FileNotFoundException &#123; new FileInputStream("c:/a.txt"); // FileNotFoundException 构造方法声明位置上使用 throws（向上抛） &#125;&#125; 真正处理可以使用try...catch... 1234567891011121314151617181920212223242526272829import java.io.FileInputStream;import java.io.FileNotFoundException;public class ExceptionTest03 &#123; public static void main(String[] args) &#123; // 真正处理 try &#123; m1(); &#125; catch (FileNotFoundException e) &#123; // TODO: handle exception &#125; // 可以打印 System.out.println("测试"); &#125; public static void m1() throws FileNotFoundException &#123; m2(); &#125; private static void m2() throws FileNotFoundException &#123; m3(); &#125; private static void m3() throws FileNotFoundException &#123; new FileInputStream("c:/a.txt"); // FileNotFoundException 构造方法声明位置上使用 throws（向上抛） &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-异常继承结构详解]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.2%20%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[![image-20200222194933260](10.2 异常继承结构详解.assets/image-20200222194933260.png)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-异常概述]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F10.%20%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F10.1%20%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[异常是什么？ 异常模拟的是现实世界中”不正常的“事件 Java 中采用”类”去模拟异常 类是可以创建对象的 NullPointerException e = 0x1234; e 是引用类型，e 中保存的内存地址指向堆中的“对象”，这个对象是 NullPointerException 类型，这个对象就表示真实存在的异常事件 异常机制的作用 程序发生异常事件之后，为我们输出详细的信息，程序员通过这个信息，可以对程序进行一些处理，使程序更加健壮 以下程序编译通过了，但是运行出现了异常，表示发生了某个异常时间 本质：程序执行过程中发生了 算数异常 这个事件，JVM 为我们创建了一个 ArithmeticException 类型的对象，并且这个对象中包含了详细的异常信息，JVM 将这个对象中的信息输出到控制台 Exception in thread “main” java.lang.ArithmeticException: / by zero at test0222.ExceptionTest01.main(ExceptionTest01.java:9) 123456789101112public class ExceptionTest01 &#123; public static void main(String[] args) &#123; int a = 10; int b = 0; int c = a / b; // ArithmeticException e = 0x2456; // 上面代码出现异常，没有处理，下面的代码不会执行，直接退出 JVM System.out.println("测试"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-is-a、is-like-a、has-a]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F9.%20is-a%E3%80%81is-like-a%E3%80%81has-a%2F</url>
    <content type="text"><![CDATA[is-a：泛化 is-like-a：实现 has-a：关联 is-a123456public classAnimal&#123; public void method1(); &#125;public classDog extendsAnimal &#123; // Dog is a Animal&#125; is-like-a12345678public interface I&#123; public void method1(); &#125; public classA implements I&#123; // A islike a I; public void method1()&#123; // 实现 &#125; &#125; has-a12345public classA &#123; // A has a B; private Bb;&#125;public classB&#123;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-UML依赖关系]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F8.%20UML%2F8.6%20%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[依赖关系是比关联关系弱的关系，在 java 语言中体现为返回值，参数，局 部变量和静态方法调用 用一套带箭头的虚线表示 ![image-20200222182525204](8.6 依赖关系.assets/image-20200222182525204.png) 12345678public class Test &#123; public void m1() &#123; // 局部变量 User u = new User(); // 依赖关系 &#125;&#125;class User&#123;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-UML合成关系]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F8.%20UML%2F8.5%20%E5%90%88%E6%88%90%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[比聚合关系强的关联关系 整体和部分紧密相连，整体的生命周期决定部分的生命周期 使用实心的棱形表示 ![image-20200222182319365](8.5 合成关系.assets/image-20200222182319365.png) 123public class 人 &#123; List&lt;四肢&gt; s;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-UML聚合关系]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F8.%20UML%2F8.4%20%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[是关联关系的一种，是较强的关联关系，是整体和部分的关系 整体不依赖部分，部分也不依赖整体，整体无法决定部分的生命周期 使用空心的棱形表示 ![image-20200222182136466](8.4 聚合关系.assets/image-20200222182136466.png) 12345public class ClassRoom &#123; // ClassRoom 和 List 集合属于关联关系，在同一层次上 // ClassRoom 和 Student 属于聚合关系，一个是整体，一个是部分 List&lt;Student&gt; stus; //Student是部分&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-UML关联关系]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F8.%20UML%2F8.3%20%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[类与类之间的连接，一个类可以知道另一个类的属性和方法，在 java 语言 中使用成员变量体现 用一条直线表示 1234567891011121314151617181920212223242526272829public class Me &#123; String name; // 在当前类中含有其他类的引用 // 在当前对象中含有指向其他对象的引用 Friend f; // Me 和 Friend 就是关联关系 Me(Friend f) &#123; this.f = f; &#125;&#125;public class Test &#123; public static void main(string[] args) &#123; Friend f = new Friend('北京'); // 建立关联关系 Me m = new Me(f); System.out.println(m.f) &#125;&#125;public class Friend &#123; String addr; Friend(String addr) &#123; this.addr = addr; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-UML实现关系]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F8.%20UML%2F8.2%20%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[类对接口的实现 用一条带空心箭头的虚线表示 以上图应为虚线]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-UML泛化关系]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F8.%20UML%2F8.1%20%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[类和类之间的继承关系及接口与接口之间的继承关系 用一条带空心箭头的直线表示]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-匿名内部类]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F7.%E5%86%85%E9%83%A8%E7%B1%BB%2F7.4%20%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[匿名内部类，指 类没有名字 优点：少定义一个类 缺点：无法复用 1234567891011121314151617181920212223242526272829303132public class Test &#123; // 静态方法 public static void t(CustomerService cs) &#123; cs.logout(); &#125; public static void main(String[] args) &#123; // 使用匿名内部类的方法执行 t 方法 // 整个 new CustomerServie()&#123;&#125; 就是一个匿名内部类 t(new CustomerService() &#123; public void logout() &#123; System.out.println("Exit!"); //输出：Exit! &#125; &#125;); // 不用匿名内部类的实现 t(new CustomerServiceImpl()); &#125;&#125;// 接口interface CustomerService &#123; // 退出系统 void logout();&#125;// 编写一个类实现 CustomerServie 接口class CustomerServiceImpl implements CustomerService &#123; public void logout() &#123; System.out.println("Exit!"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-局部内部类]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F7.%E5%86%85%E9%83%A8%E7%B1%BB%2F7.3%20%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[等同于 局部变量 不能有静态声明 重点：在访问局部变量时，局部变量必须使用 final 修饰 调用：需要在方法中调用 1234567891011121314151617181920212223242526272829public class OutClass &#123; // 方法 public void m1() &#123; // 局部变量 final int i = 10; // 局部内部类 // 不能用访问控制权限修饰符修饰 class InnerClass &#123; // 内部类不能有静态声明 // public static void m1() &#123; // &#125; // 成员方法 public void m2() &#123; System.out.println(i); &#125; &#125; // 调用 m2 InnerClass inner = new InnerClass(); inner.m2(); &#125; public static void main(String[] args) &#123; OutClass oc = new OutClass(); oc.m1(); // 输出：10 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-成员内部类]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F7.%E5%86%85%E9%83%A8%E7%B1%BB%2F7.2%20%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[可以等同看作 成员变量 成员内部类中 不能有静态声明 可以访问外部类所有的数据 创建成员内部类方法：OutClass oc1 = new OutClass();InnerClass inner = oc1.new InnerClass(); 12345678910111213141516171819202122232425262728293031323334353637383940public class OutClass &#123; // 静态变量 private static String s1 = "A"; // 成员变量 private String s2 = "B"; // 静态方法 private static void m1() &#123; System.out.println("m1"); &#125; // 成员方法 private void m2() &#123; System.out.println("m2"); &#125; // 成员内部类 // 可以用访问控制权限的修饰符修饰 // publice, protected, private, 缺省 class InnerClass &#123; // 不能有静态声明 // public static void m3() &#123;&#125; // 成员方法 public void m4() &#123; System.out.println(s1); m1(); System.out.println(s2); m2(); &#125; &#125; public static void main(String[] args) &#123; // 创建外部类对象 OutClass oc1 = new OutClass(); InnerClass inner = oc1.new InnerClass(); inner.m4(); // 输出：A m1 B m2 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-静态内部类]]></title>
    <url>%2F2020%2F02%2F22%2FJava%2F%E8%BF%9B%E9%98%B6%2F7.%E5%86%85%E9%83%A8%E7%B1%BB%2F7.1%20%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[静态内部类 可以等同看作 静态变量 作用：可以访问外部类中的静态数据，无法访问成员数据 创建静态内部类方法：InnerClass oc1 = new OutClass.InnerClass(); 1234567891011121314151617181920212223242526272829303132333435363738public class OutClass &#123; // 静态变量 private static String s1 = "A"; // 成员变量 private String s2 = "B"; // 静态方法 private static void m1() &#123; System.out.println("m1"); &#125; // 成员方法 private void m2() &#123; System.out.println("m2"); &#125; // 静态内部类 // 可以用访问控制权限的修饰符修饰 // publice, protected, private, 缺省 static class InnerClass &#123; // 静态方法 public static void m3() &#123; System.out.println(s1); m1(); // 成员数据 无法访问 // System.out.println(s2); // m2(); &#125; &#125; public static void main(String[] args) &#123; // 创建静态内部类对象 InnerClass oc1 = new OutClass.InnerClass(); oc1.m3(); //输出：A m1 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flex布局-换行平均分布]]></title>
    <url>%2F2020%2F02%2F22%2FCss3%2FFlex%E5%B8%83%E5%B1%80-%E6%8D%A2%E8%A1%8C%E5%B9%B3%E5%9D%87%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[有一个需求：多个盒子需要换行布局，单纯使用 flex 的属性，会发现没有办法平均分布，中间会缺，记录一种解决思路 123456// 以下写法，如果盒子数量不是列数的倍数，将会产生空白display: flex;display: -webkit-flex;justify-content: space-between;flex-direction: row;flex-wrap: wrap; 解决办法： 123456789101112131415&lt;van-button v-for=&quot;item in toiletList&quot; :key=&quot;item.id&quot; type=&quot;default&quot; size=&quot;small&quot; @click=&quot;selectToilet(item.id)&quot; :style=&quot;&#123;&apos;background&apos;:toiletChosen === item.id ? &apos;#dcdee0&apos;:&apos;#fff&apos; &#125;&quot; &gt;&#123;&#123;item.value&#125;&#125;&lt;/van-button&gt;&lt;van-button type=&quot;default&quot; size=&quot;small&quot; v-for=&quot;(item, index) in 4&quot; :key=&quot;index&quot; style=&quot;visibility: hidden;height:0;border: 0;margin: 0;&quot; &gt;1&lt;/van-button&gt; 简单地说，就是如果最后一行没满，v-for 循环补齐，并且把 visibility 设置成 hidden ，需要注意：一定要把作为补齐的盒子的高度设置为0 ，不然多出的会挤出来哦]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-填坑笔记]]></title>
    <url>%2F2020%2F02%2F22%2FVue%2FVue-%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录 Vue 开发中遇到的坑 Property or method “artificial1” is not defined on the instance but referenced during render. Make sure that this property is reactive, either in the data option, or for class-based components, by initializing the property. 子组件直接引用了props里的值，这样父组件改变值时子组件会报错 解决方法：将值data中复制一份，子组件引用复制的值 vue + ts 使用 $refs 调用函数报错 代码this.$refs.a.toggle();显示没有toggle()方法，但是打印是有的 解决办法：增加声明 $refs: {quickEntry: HTMLFormElement}]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>填坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-hashCode()]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F6.%20Object%2F6.4%20hashCode()%2F</url>
    <content type="text"><![CDATA[hashCode() 返回的是 该对象的哈希码值，Java 对象的内存地址经过哈希算法得出的 int 类型的数值 123456public class Test03 &#123; public static void main(String[] args) &#123; Test03 t = new Test03(); System.out.println(t.hashCode()); // 2018699554 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-finalize()]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F6.%20Object%2F6.3%20finalize()%2F</url>
    <content type="text"><![CDATA[finalize 方法每个 Java 对象都有 不需要程序员去调用，由系统自动调用 Java 对象如果没有更多的引用指向它，则该对象成为垃圾数据，等待垃圾回收器的回收，垃圾回收器在回收这个对象之前会自动调用该对象的 finalize方法 finalize方法：该对象马上就要被回收了，例如：需要释放资源，则可以在该方法中释放 1234567891011121314151617public class Test03 &#123; public static void main(String[] args) &#123; Person1 p1 = new Person1(); p1 = null; // 没有引用再指向它，等待回收 // 程序员只能“建议”垃圾回收器回收垃圾 System.gc(); // test0220.Person1@3a18f192马上就要被回收了 &#125;&#125;class Person1 &#123; // 重写 finalize 方法 public void finalize() throws Throwable &#123; System.out.println(this + "马上就要被回收了"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-equals()]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F6.%20Object%2F6.2%20equals()%2F</url>
    <content type="text"><![CDATA[Object 中的 equals 方法，设计目的：判断两个对象是否一样 123public boolean equals (Object obj) &#123; return (this == obj);&#125; 但是比较的是内存地址，在现实的业务逻辑中，不应该比较内存地址，应该比较内容，所以 equals 方法也要重写 123456789101112131415161718192021222324252627282930313233343536public class Text02 &#123; public static void main(String[] args) &#123; Object o1 = new Object(); Object o2 = new Object(); boolean b1 = o1.equals(o2); System.out.println(b1); // false Star s1 = new Star(0, "张三"); Star s2 = new Star(0, "张三"); boolean b2 = s1.equals(s2); System.out.println(b2); // false &#125;&#125;class Star &#123; int id; String name; public Star(int id, String name) &#123; this.id = id; this.name = name; &#125; public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj instanceof Star) &#123; Star s = (Star) obj; if (s.id == id &amp;&amp; s.name.equals(name)) &#123; return true; &#125; &#125; return false; &#125;&#125; 注意：在 Java 中比较两个字符串是否一致，不能用”==“，只能调用 String 类的 equals方法 123456789101112public class Test03 &#123; public static void main(String[] args) &#123; String s1 = new String("ABC"); String s2 = new String("ABC"); System.out.println(s1 == s2); // false // String 已经重写了 Object 的 equals 方法，比较的是内容 System.out.println(s1.equals(s2)); // true &#125;&#125; 在开发中，注意equals前后顺序，比如 123"admin".equals(usename);usename.equals("admin");// 选择前面一种，可以避免空指针异常]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-toString()]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F6.%20Object%2F6.1%20toString()%2F</url>
    <content type="text"><![CDATA[关于 Object 中的 toString 方法： SUN 在 Object 类中设计toString方法的目的：返回 Java 对象的字符串表示形式 12345public String toString() &#123; return getClass().getNae() + "@" + Integer.toHexString(hashCode()); // 类名@java对象 的内存地址经过哈希算法得到的int类型值再转换成十六进制 // 可以等同看作 Java 对象在堆中的内存地址&#125; 在现实的开发过程中，这个方法已经不够用了，不能满足自身开发需求，所以这个方法就是要被重写的 123456789101112131415161718192021222324252627public class Text01 &#123; public static void main(String[] args) &#123; Object o1 = new Object(); String oStr = o1.toString(); System.out.println(oStr); // java.lang.Object@7852e922 Person p1 = new Person("刘德华", 50); String pStr = p1.toString(); System.out.println(pStr); // Person[name=刘德华,age=50] &#125;&#125;class Person &#123; String name; int age; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; // 重写 toString() // 根据项目需求定 public String toString() &#123; return "Person[name=" + name + ",age=" + age + "]"; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-接口]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F5.%20%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口也是一种引用类型，可以等同看作 类 语法：[修饰符] interface 接口名{} 只能出现：常量、抽象方法 其实是一个特殊的抽象类，特殊在接口是完全抽象的 没有构造方法，无法被实例化 接口和接口之间可以多继承 一个类可以实现多个接口（这里的”实现“可以等同看作”继承“） 一个非抽象的类实现接口，需要将接口中所有的方法”实现/重写/覆盖“ 接口和抽象类都能完成某个功能，优先选择接口。因为接口可以多实现，多继承，并且一个类除了实现接口之外，还可以去继承其他类（保留了类的继承） 12345678910111213141516171819202122232425262728293031public interface A1 &#123; // 常量（必须用 public static final 修饰，这里可以省略） // public static final double PI = 3.14; double PI = 3.14; // 抽象方法（必须用 public abstract 修饰，这里可以省略） // public abstract void m1(); void m1();&#125;interface B1 &#123; void m1();&#125;interface C1 &#123; void m2();&#125;interface D extends B1, C1 &#123; void m3();&#125;/* * implements 是 实现 的意思，和 extends 意义相同 */class MyClass implements B1, C1 &#123; public void m1() &#123; &#125; public void m2() &#123; &#125;&#125; 例子客户业务接口接口作用： 可以使项目分层，所有层都面向接口开发，开发效率提高了 接口使代码和代码之间的耦合度降低，就像内存条和主板的关系，变得”可插拔“，可以随意切换 1234public interface CustomerService &#123; // 定义一个退出系统的方法 void logout();&#125; 接口的实现类该类的编写完全是面向接口去实现的 123456public class CustomerServiceImpl implements CustomerService &#123; // 对接口中的抽象方法进行实现 public void logout() &#123; System.out.println("成功退出！"); &#125;&#125; 调用12345678public class Test &#123; public static void main(String[] args) &#123; // 以下程序面向接口去调用 CustomerService cs = new CustomerServiceImpl(); cs.logout(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-抽象类]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F4.%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[定义：class 关键字前加 abstract 抽象类无法被实例化 虽然无法实例化，但是抽象类也有构造方法，该构造方法是给子类创建对象用的 抽象类中可以定义抽象方法 语法：在方法的修饰符列表中添加 abstract 关键字，并且抽象方法应该以”；“结束，不能带有”{}“ 例如：public abstract void m1(); 抽象类中不一定有抽象方法，但抽象方法必须出现在抽象类中 一个非抽象类继承抽象类，必须将抽象类的抽象方法覆盖、实现、重写 123456789101112131415161718192021222324public abstract class A &#123; A() &#123; System.out.println("A..."); &#125; // 抽象方法 public abstract void m1(); public static void main(String[] args) &#123; A a = new B(); &#125;&#125;class B extends A &#123; // 继承的抽象方法重写 public void m1() &#123; &#125; B() &#123; super(); System.out.println("B..."); &#125;&#125; 抽象类和抽象方法都不能被final修饰]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-super 关键字]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F3.%20super%20%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[super 代表的是当前子类对象中的父类型特征；不是引用类型，存储的不是内存地址，指向的不是父类对象 什么时候使用 ？ 子类和父类中都有某个数据，例如，子类和父类中都有 name ，如果要在子类中访问父类的 name，需要使用 super. 可以用到什么地方？ 可以用在成员方法中，不能用在静态方法中 可以用在构造方法中 成员方法中的使用1234567891011121314151617181920212223242526272829303132public class Manager extends Employee &#123; // 子类重写父类方法 public void work() &#123; System.out.println("经理在工作！"); &#125; // 成员方法 public void m1() &#123; // this.work(); // 经理在工作! // work(); // 经理在工作! super.work(); // 工人在工作！ &#125; /* * this 和 super 相同，都不能用在静态上下文中 */ // public static void m2() &#123; // super.work(); // &#125; public static void main(String[] args) &#123; Manager man = new Manager(); man.m1(); &#125;&#125;public class Employee &#123; public void work() &#123; System.out.println("工人在工作！"); &#125;&#125; 构造方法中的使用 语法：super(实参); 作用：通过子类的构造方法去调用父类的构造方法，给当前子类对象中的父类型特征赋值 语法规则：一个构造方法第一行如果没有this(...)，也没有显示的去调用super(...)，系统会默认调用super(); 注意： super(...);只能放在构造方法的第一行 不能与this(...);共存 调用了父类中的构造方法，但是不会创建父类对象 在 Java 语言中，只要是创建 Java 对象，那么 Object 中的无参数构造方法一定会执行！]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-单例模式]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F2.%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式——为了保证 JVM 中某一个类型的 Java 对象永远只有一个，节省内存的开销 单例模式要领 构造方法私有化 对外提供一个公开的静态的获取当前类型对象的方法 提供一个当前类型的静态变量 1234567891011121314151617181920212223public class Singleton &#123; // 懒汉式单例 // 静态变量 private static Singleton s; // 将构造方法私有化 private Singleton() &#123;&#125; // 对外提供一个公开获取 Singleton 对象的方法 public static Singleton getInstance() &#123; if (s == null) &#123; s = new Singleton(); &#125; return s; &#125;&#125;public class UserTest &#123; public static void main(String[] args) &#123; Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.println(s1 == s2); &#125;&#125; 分类 饿汉式：在类加载阶段就创建了对象 懒汉式：用到对象的时候才会创建对象 12345678910111213// 饿汉式public class Customer &#123; // 类加载时只执行一次 private static Customer c = new Customer(); //构造方法私有化 private Customer()&#123;&#125; // 提供公开的方法 public static Customer getInstance() &#123; return c; &#125;&#125; 缺点没有子类，无法被继承 12345678public class Servelet &#123; // 构造方法私有 private Servelet()&#123;&#125;&#125;class HttpServlet extends Servlet &#123; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java进阶-等于号]]></title>
    <url>%2F2020%2F02%2F20%2FJava%2F%E8%BF%9B%E9%98%B6%2F1.%20%E7%AD%89%E4%BA%8E%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[两边如果是基本数据类型，比较这两个基本数据类型是否相等；两边如果是引用数据类型，比较的是内存地址 1234567int i = 1;char j = '1';System.out.println(i == j); // falseUser u1 = new User();User u2 = new User();System.out.println(u1 == u2); // false]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java 零基础课程总结]]></title>
    <url>%2F2020%2F02%2F17%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F56.%20Java%20%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言这个寒假注定是不平凡的寒假，全国上下都在和疫情做斗争。作为普通市民，为社会出力最好的办法就是宅在家，别出门。某日，在 B 站 看到了动力节点杜老师的 Java零基础课程，一共159节，放两倍速，非常鬼畜，语气非常生动。杜老师的讲课思路非常符合自己的学习习惯，总是从 是什么、为什么、怎么办 入手，循序渐进，从简到难，非常容易接受，赶紧刷了起来。 学习之路刷视频+做笔记 用时9天，中间有几天在专心写毕设项目，所以一共是11天。采取的学习方法是，先专心看视频，把视频中觉得需要记录的地方截图下来，课后再对截图进行整理成笔记。老师非常厉害，说的关键都写上去了，所以不用担心截图漏了啥。 学成收获Java 其实是大二的一门选修课（还可以选C+），但是那会没有认真听课，只把它作为应试考试的一门课程。真正工作起来，才知道一门强类型语言是多么重要，尽管自己现在是前端，但是掌握一门后端语言，可以为自己今后的编程提供新的思路，新的技巧。 课程从很基础的知识讲起，比如变量，三元表达式，switch运算符等不管哪门语言都通用的知识点，到 Java 语言的特殊语法规范、语法特性，还有Java IDE的使用等等。最重要的是讲解了面向对象的三大特性：封装、继承、多态。之前老是听，但是 JS 说到底只是基于面向对象的语言，所以这三个特性并未好好展示，这次终于体会到它的魅力。 下面记录下，之前打码时候的疑问【都是很基础的知识，当时没有想明白为啥】+技巧 12345// 1. 不能直接写一个三元表达式，因为它不是一个语句！sex ? '男' : '女';// 2. swicth 可以分支合并，会case穿透// 3. for 循环可以命名自己名字// 4. a instanceof b --&gt; a是b的实例 接下来的任务继续学习 Java 进阶的知识，可能学的时间不能这么紧密，因为同一天还安排了毕设项目的开发。也不能学的那么快，下面的才是 Java 的重点、难点，要求自己：老师讲的每一个陌生的例子（自己第一次接触的），都要手动打一下码，感受一下！]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-访问控制权限修饰符]]></title>
    <url>%2F2020%2F02%2F16%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F55.%20%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[访问控制权限修饰符——控制元素的访问范围 包括 public 表示公开的，在任何位置都可以访问 protected 同包，子类 缺省 同包 private 表示私有的，只能在本类中访问 可以修饰类、变量、方法…；其中，类只能采用public和缺省的修饰符进行修饰【内部类除外】 当某个数据只希望子类使用，使用 protected 进行修饰 修饰符的范围：private &lt; 缺省 &lt; protected &lt; publice]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-import 引入]]></title>
    <url>%2F2020%2F02%2F16%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F54.%20import%20%E5%8C%85%E5%BC%95%E5%85%A5%2F</url>
    <content type="text"><![CDATA[import 语句 用来完成导入其他类，同一个包下的类不需要引入，不在同一个包下需要手动导入 语法格式: import 类名； import 包名.*; 语句需要编写到package语句之下，class语句之上 123456789101112package test0215;import com.test.javase.*;public class FinalTest02 &#123; public static void main(String[] args) &#123; // 编译错误 // Cat c = new Cat(); com.test.javase.Cat c = new com.test.javase.Cat(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-package 包机制]]></title>
    <url>%2F2020%2F02%2F16%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F53.%20package%20%E5%8C%85%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java 引用 package 这种语法机制主要是为了方便程序的管理。不同功能的类被分门别类放到不同的软件包当中，查找比较方便，管理比较方便，易维护； 怎么定义包呢？ 在 java 源程序 的第一行上编写 package 语句 package 只能编写一个语句 package 包名; 包名的命名规范 公司域名倒序 + 项目名 + 模块名 + 功能名 采用这种方式重名几率低，因为公司域名具有全球唯一性 例如：org.apache.tomcat.core 包名要求全部小写，包名也是标识符，必须遵守标识符的命名规范 一个包对应一个目录，比如package org.apache.tomcat.core; 四个目录 怎么编译包，怎么运行包呢？ 使用了包机制后，类名不再是Test01了，类名是com.bjpowernode.javase.day11.Test01 第一种方式：需要手动操作一下 编译：javac java源文件路径（在硬盘上生成了一个class文件：Test01.class） 手动方式创建目录，将Test01.class字节码文件放到指定的目录下 运行：java com.bjpowernode.javase.day11.Test01 另一种方式（编译+运行） 编译：javac -d 编译之后存放路径 java源文件的路径 例如：将 F:\Hello.java 文件编译之后放到 C:\ 目录下，java -d C:\ F:\Hello.java 将当前路径中*.java编译之后放到当前目录下：javac -d . *.java 运行：JVM 的类加载器 ClassLoader 默认从当前路径下加载，保证 DOS 命令窗口的路径先切换到 com 所在的路径，执行：java com.bjpowernode.javase.day11.Test01]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-final 关键字]]></title>
    <url>%2F2020%2F02%2F16%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F52.%20final%20%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final 是一个关键字，表示 最终的，不可变的 修饰的类无法被继承 修饰的方法无法被覆盖 一旦赋值后，不可重新赋值【不可二次赋值】 修饰的实例变量，必须手动赋值，不能采用系统默认值 12345678910111213141516171819202122232425public class FinalTest01 &#123; // 成员变量之实例变量 // 实例变量有 默认值 + final 修饰的变量不可二次赋值 // 综合考虑，java 最终规定 实例变量 使用 final 修饰之后，必须手动赋值，不能采用系统默认值 final int age; // 编译错误 // 第一种解决办法 final int age = 10; // 第二种解决方法 final int num; public FinalTest01() &#123; this.num = 200; &#125; // 两种解决方法，本质上是一种方式，都是在构造方法执行过程当中给实例变量赋值 public static void main(String[] args) &#123; final int a; a = 100; // 不可二次赋值 a = 200; &#125;&#125; 修饰的引用，一旦指向某个对象之后，不能再指向其他对象，那么被指向的对象无法被垃圾回收器回收。虽然指向某个对象之后不能指向其他对象，但是所指向的对象内部的内存是可以被修改的 1234567891011121314151617public class FinalTest02 &#123; public static void main(String[] args) &#123; // 创建用户对象 User u = new User(100); // User u = 0x1234; // 又创建一个新的User对象 // 程序执行到此表示以上对象已变成垃圾数据，等待垃圾回收器的回收 u = new User(200); // u = 0x2345; // 创建用户对象 final User user = new User(200); // user = new User(50); // final 修饰的引用，一旦指向某个对象之后，不能再指向其他对象， //被指向的对象无法被垃圾回收器回收 user.id = 50; // 所指向的对象内部的内存可以被修改 &#125;&#125; 修饰的实例变量，一般和 static 联合使用，被称为 常量 public static final 类型 常量名 = 值； Java 规范中要求所有常量的名字全部大写，每个单词之间使用下划线连接]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-多态]]></title>
    <url>%2F2020%2F02%2F16%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F51.%20%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态涉及的几个概念 向上转型(upcasting) 子类型 –&gt; 父类型 又称为：自动类型转换 向下转型(downcasting) 父类型 –&gt; 子类型 又称为：强制类型转换【需要加 强制类型转换符】 无论是向上转型还是向下转型，两种类型之间必须要有继承关系，没有继承关系，程序是无法编译通过的。 结合例子分析1Animal a1 = new Cat(); // 其中 Animal 是父类，Cat 是子类 根据上面的语句，Cat is Animal是合理的。 new Cat()创建的对象类型是Cat，a1 引用的数据类型是 Animal，可见它们进行了类型转换，子类型转换为父类型，称为 向上转型/upcasting，或者自动类型转换。 Java 允许：父类型引用指向子类型对象 1a1.move(); // '猫在走猫步' Java 程序永远分为 编译阶段和运行阶段 先分析编译阶段，再分析运行阶段，编译无法通过，根本是无法运行的 编译阶段编译器检查 a1 这个引用的数据类型为 Animal，由于Animal.class字节码当中有move()方法，所以编译通过了。这个过程，我们称为静态绑定，编译阶段绑定，只有静态绑定成功之后才有后续的运行 在程序运行阶段，JVM 堆内存当中真实创建的对象是 Cat对象，那么以上程序在运行阶段一定会调用Cat对象的move()方法，此时发生了程序的动态绑定，运行阶段绑定 无论Cat 类有没有重写move方法，运行阶段一定调用的是Cat对象的move方法，因为底层真实对象就是Cat对象 父类型引用指向子类型对象这种机制导致程序存在编译阶段和运行阶段绑定两种不同的形态/状态，这种机制可以称为一种多态语法机制 1a1.catchMouse(); 以上程序无法调用，因为编译阶段编译器检查到 a1 的类型是 Animal 类型，但没有在 Animal.class 字节码文件中查找到catchMouse()方法，导致静态绑定失败，也就是说编译失败，更别说运行了 想要调用，可以将 c1 强制类型转换为 Cat类型，a1 的类型是 Animal（父类），转换为Cat（子类），被称为向下转型/downcasting/强制类型转换 注意：向下转型需要两种类型之间必须有继承关系，需要加强制类型转换符 什么时候需要使用向下转型呢？ 当调用的方法是子类中持有，父类不存在的，必须进行向下转型！ 12345Cat a1 = (Cat)c1;//类似于long x = 100L;int i = (int)x; 12Animal a2 = new Bird();Cat a2 = (Cat)a2; 以上程序编译是没有问题的，因为编译器检查到 a2 的数据类型是 Animal ，Animal 和 Cat 之间存在继承关系，并且Animal 是父类型，Cat 是子类型，父类型转换成子类型叫做向下转型，语法合格； 虽然编译通过了，但是程序在运行阶段会出现异常，因为 JVM 堆内存当中真实存在的对象是 Bird类型，Bird对象无法转换成 Cat对象，因为两种类型之间不存在任何继承关系，此时出现了著名的异常：java.lang.ClassCastException 类型转换异常，这种异常总是在“向下转型的时候”出现 instanceof 运算符 向上转型只要编译通过，运行一定不会出现问题：Animal a = new Cat(); 向下转型编译通过，运行可能错误：`Animal a2 = new Bird();Cat a2 = (Cat)a2; 怎么避免向下转型的 ClassCastException 呢？ 使用 instanceof 运算符 instanceof 运算符 （引用 instanceof 数据类型名） 得到布尔值 a instanceof Animal true 表示：a 这个引用指向的对象是一个 Animal类型 false 表示：a 这个引用指向的对象不是一个 Animal类型 Java规范中要求：在进行强制类型转换之前，建议采用 instanceof 运算符进行判断，避免 ClassCastException 异常的发生，这是一种编程好习惯！ 12345678910111213141516publice static void main(String[] args) &#123; // 父类型引用指向子类型对象 // 向上转型 Animal a1 = new Cat(); Animal a2 = new Bird(); // 向下转型【只有当访问子类对象当中特有的方法】 if(a1 instanceof Cat) &#123; // a2是一个Cat类型的对象 Cat a1 = (Cat)a1; a2.catchMouse(); &#125;else if(a2 instanceof Bird) &#123; // a2是一个Bird类型的对象 Bird b1 = (Bird)a2; b2.fly(); &#125;&#125; 多态的作用面向对象编程的核心：定义好类，然后将类实例化为对象，给一个环境驱使一下，让各个对象之间协作起来形成一个系统 多态的作用： 降低程序耦合性，提高程序扩展性 能使用多态，尽量使用 父类型引用指向子类型对象 核心：面向抽象编程，尽量不要面向具体编程！]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-方法覆盖]]></title>
    <url>%2F2020%2F02%2F16%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F50.%20%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[当父类中的方法已经无法满足当前子类的业务需求，子类有必要将父类中继承过来的方法进行重新编写，这个重新编写的过程称为方法重写 / 方法覆盖 发生方法覆盖的条件： 发生在具有继承关系的父子类之间 返回值类型相同， 方法名相同，形参列表相同 访问权限不能更低，可以更高 抛出异常不能更多，可以更少 12345678class A &#123; public void m1() &#123;&#125;&#125;class B extends A &#123; // 子类永远无法抛出比父类更多的异常 public void m1() throws Exception &#123;&#125;&#125; 注意： 建议方法重写的时候，尽量复制粘贴，不要编写，容易出错，导致没有产生覆盖 私有方法与构造方法不能继承，所以不能覆盖 静态方法不存在覆盖 覆盖只针对方法，不针对属性 eclipse 快捷键 右键文件 –&gt; Source –&gt; Override/Implement Methods]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-继承]]></title>
    <url>%2F2020%2F02%2F16%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F49.%20%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[[修饰符列表] class 类名 extends 父类名 { 类体 = 属性 + 方法} 继承的“基本作用”：代码复用，但最“重要”的作用是：有了继承才有了后面的“方法覆盖”和“多态机制”； Java 语言当中只支持单继承，一个类不能同时继承多个类。在C++中支持多继承； 虽然只支持单继承，但是一个类可以间接继承其他类，例如： 1234C extends B &#123;&#125;B extends A &#123;&#125;A extends T &#123;&#125;// C 直接继承B，但是间接继承 T, A类 继承的一些术语：B类继承A类 A类称为：父类、基类、超类、superclass B类称为：子类、派生类、subclass 子类继承父类的哪些数据呢？ 私有的不支持继承 构造方法不支持继承 其他数据都可以被继承 假设一个类没有显示的继承任何类，该类默认继承 JavaSE 库当中提供的 java.lang.Object类。Java 语言中任何一个类中都有 Object 类的特征]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-实例语句块 / 代码块]]></title>
    <url>%2F2020%2F02%2F15%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F48.%20%E5%AE%9E%E4%BE%8B%E8%AF%AD%E5%8F%A5%E5%9D%97%20%20%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[可以编写多个，也是自上而下执行 在 构造方法执行 之前执行，构造方法执行一次，实例代码块对应执行一次 对象初始化时机 执行 12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; // 构造函数 public Test() &#123; System.out.println("Test 类的缺省构造器执行"); &#125; // 实例代码块 &#123; System.out.println("1"); &#125; // 实例代码块 &#123; System.out.println("2"); &#125; // 实例代码块 &#123; System.out.println("3"); &#125; public static void main(String[] args) &#123; System.out.println("main begin!"); new Test(); new Test(); &#125;&#125;//main begin!// 1// 2// 3// Test 类的缺省构造器执行// 1// 2// 3// Test 类的缺省构造器执行]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-静态代码块]]></title>
    <url>%2F2020%2F02%2F15%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F47.%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
    <content type="text"><![CDATA[123static &#123; java 语句;&#125; 静态代码块 在类加载时执行，并且只执行一次； 在一个类中可以编写多个，并且从上到下执行； 作用是？怎么用？用在哪？啥时候用？ 与具体需求有关。例如：项目中要求在类加载的时候执行代码完成日志的记录，那么这段记录日志的代码可以编写在 静态代码块 中，完成日志记录 若希望在类加载时刻执行一段特殊的程序，这段程序可以直接放到静态代码块中 通常在 静态代码块 中完成预备工作，先完成数据的准备工具，例如：初始化连接池，解析 XML 配置文件… 123456789101112131415161718192021222324public class StaticText01 &#123; static &#123; System.out.println("类加载 1"); &#125; static &#123; System.out.println("类加载 2"); &#125; static &#123; System.out.println("类加载 3"); &#125; public static void main(String[] args) &#123; System.out.println("main begin!"); &#125;&#125;// 类加载 1// 类加载 2// 类加载 3// main begin!]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-static 关键字]]></title>
    <url>%2F2020%2F02%2F15%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F46.%20static%20%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[实例变量——所有对象都有这个属性，但是这个属性的值会随着对象的变化而变化【不同对象的这个属性具体的值不同】； 静态变量——所有对象都有这个属性，并且所有对象的这个属性的值都是一样的； 静态方法——当所有对象执行这个动作时，最终产生的影响是一样的，那么这个动作已经不再属于某一个对象的动作了，可以将这个动作提升为类级别的动作，模板级别的动作； 静态方法无法直接访问实例变量和实例方法； 大多数工具类都是静态方法，目的是方便变成，不需要 new 是最方便的了 静态变量在类加载的时候初始化，内存在方法区中开辟; 访问的时候不需要创建对象，直接使用 “类名.静态变量名” 的方式访问；可以采用 “引用.” 的方式访问，但不建议，因为访问静态的数据不需要对象的存在； 是类级别的特征，和具体的对象无关]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-this 关键字]]></title>
    <url>%2F2020%2F02%2F15%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F45.%20this%20%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[this 是一个引用，是一个变量，这个变量保存了指向自身的内存地址； this 存储在 JVM 堆内存 Java 对象内部； 创建 100 个 Java 对象，每一个对象都有 this ,也就是说有 100 个不同的 this； this 可以出现在“实例方法”中，指向当前正在执行这个动作的对象（this 代表当前对象）； 在多数情况下都是可以省略不写的，用来区别局部变量和实例变量时，不能省略； 1234567private int id;public void setId(int id) &#123; // 不可以采用这种方式 // id = id; this.id = id;&#125; 不能使用在带有 static 的方法中； 在带有 static 的方法中不能“直接”访问实例变量和实例方法，因为实例变量和实例方法都需要对象存在。而static 的方法中是没有 this 的，也就是说当前对象是不存在的，自然无法访问当前对象的实例变量和实例方法 12345678910111213141516171819public class ThisText01 &#123; // 实例变量 String name; // 实例方法 public void doSome() &#123; &#125; // 带有 static public static void main(String[] args) &#123; // 没有 this // System.out.println(name) // doSome() ThisText01 tt = new ThisText01(); System.out.println(tt.name); tt.doSome(); &#125;&#125; this用在哪？ 可以使用在实例方法当中，代表当前对象【this.】 可以使用在构造方法当中，通过当前的构造方法调用其他的构造方法【this(实参);】 注意：this(实参);只能出现在构造函数第一行 综合例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package test0215;public class ThisText02 &#123; // 没有 static 的变量 int i = 10; // 带有 static 的方法 public static void doSome() &#123; System.out.println("do some!"); &#125; // 没有 static 的方法 public void doOther() &#123; System.out.println("do other!"); &#125; // 带有 static 的方法 public static void method1() &#123; // 调用 doSome // 使用完整方式调用 ThisText02.doSome(); // 使用省略方式调用 doSome(); // 调用 doOther // 使用完整方式调用 ThisText02 tt1 = new ThisText02(); tt1.doOther(); // 使用省略方式调用 // 访问 i // 使用完整方式调用 System.out.println(tt1.i); // 使用省略方式调用 &#125; // 没有 static 的方法 public void method2() &#123; // 调用 doSome // 使用完整方式调用 ThisText02.doSome(); // 使用省略方式调用 doSome(); // 调用 doOther // 使用完整方式调用 this.doOther(); // 使用省略方式调用 doOther(); // 访问 i // 使用完整方式调用 System.out.println(this.i); // 使用省略方式调用 System.out.println(i); &#125; public static void main(String[] args) &#123; // 要求在这里编写程序调用 method1 // 使用完整方式调用 ThisText02.method1(); // 使用省略方式调用 method1(); // 要求在这里编写程序调用 method2 // 使用完整方式调用 ThisText02 tt = new ThisText02(); tt.method2(); // 使用省略方式调用 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vant 自制主题]]></title>
    <url>%2F2020%2F02%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2FVant%2FVant%20%E8%87%AA%E5%88%B6%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[尽管官方有教程，但是还是踩了坑，记录记录！【本次教程针对 vue-cli 2.x】 安装 插件 1npm i babel-plugin-import -D main.ts 引入 1import 'vant/lib/index.less'; // 注意是less build / utils.js 配置 generateLoaders 123456789less: generateLoaders('less', &#123; modifyVars: &#123; // 定义自己的文件覆盖，采用绝对路径 'hack': `true; @import "$&#123;path.join(__dirname,'../src/common/style/ResetVant.less')&#125;";` &#125;&#125;), sass: generateLoaders('sass', &#123; indentedSyntax: true &#125;), .babelrc 配置 12345678"plugins": ["transform-vue-jsx", "transform-runtime", [ "import", &#123; "libraryName": "vant", "libraryDirectory": "es", "style": true &#125;, "vant"]] 新建一个 .less 文件，复制配置文件，更改相关样式，重新编译，即可生效]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>Vant 框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[router-link 改变默认 a 标签]]></title>
    <url>%2F2020%2F02%2F14%2FVue%2Frouter-link%20%E6%94%B9%E5%8F%98%E9%BB%98%E8%AE%A4%20a%20%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[1&lt;router-link tag=&quot;div&quot; :to=&quot;itemChild.path&quot;&gt;&lt;span&gt;&#123;&#123;itemChild.name&#125;&#125;&lt;/span&gt;&lt;/router-link&gt; 把 tag 改成 div]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Element-自定义主题]]></title>
    <url>%2F2020%2F02%2F14%2FVue%2FElement%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装主题工具安装完 element 后 1npm i element-theme -g 安装chalk主题1npm i element-theme-chalk -D 获取theme的sass文件并修改123et -i //[可以自定义变量文件，默认为element-variables.scss]&gt; ✔ Generator variables file //表示成功 这时根目录下会产生element-variables.scss（或自定义的文件），大致如下： 直接编辑 element-variables.scss 文件，例如修改主题色为自己所需要的颜色 1$--color-primary: purple; 编译主题修改完变量后，要编译主题（如果编译后，再次修改了变量，需要重新编译） 1234et&gt; ✔ build theme font&gt; ✔ build element theme //表示从新编译成功 执行主题编译命令生成主题，根目录会生成一个theme的文件夹 。需要引入这个文件夹里的css、font等资源。theme文件夹里有font文件夹和大量的css文件，css文件只留下index.css,其他的css文件都可以删掉，因为index.css中的样式包含其他全部css文件的样式。 引入自定义主题先把安装element时引入main.js中的主题样式去掉，在main.js中引入 1import '../theme/index.css' 验证在项目中写些样式，看下主题色是否改变，一般是没问题的！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prettier 报错]]></title>
    <url>%2F2020%2F02%2F14%2F%E5%BC%80%E5%8F%91%2FVscode%2FPrettier%20%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[Delete ␍eslint(prettier/prettier) 解决方法： 可以修改 .eslintrc 文件，在 rules 添加一条 1"prettier/prettier": "off"]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Vue 项目中使用 vw 实现移动端适配]]></title>
    <url>%2F2020%2F02%2F14%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F%E5%9C%A8%20Vue%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%20vw%20%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。vw的兼容方案可以参阅《如何在Vue项目中使用vw实现移动端适配》一文。 之前一直没有尝试使用 vw 进行移动端适配，这次希望在毕设项目中运用，记录一番步骤，具体的插件用途可查阅参考文章~ 安装 PostCSS 插件1npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano --S 配置插件在.postcssrc.js文件对新安装的PostCSS插件进行配置： 123456789101112131415161718192021222324252627282930// https://github.com/michael-ciniawsky/postcss-load-configmodule.exports = &#123; "plugins": &#123; "postcss-import": &#123;&#125;, "postcss-url": &#123;&#125;, "postcss-aspect-ratio-mini": &#123;&#125;, "postcss-write-svg": &#123; utf8: false &#125;, "postcss-cssnext": &#123;&#125;, "postcss-px-to-viewport": &#123; viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: 'vw', // 指定需要转换成的视窗单位，建议使用vw selectorBlackList: ['.ignore', '.hairlines'], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换`px` &#125;, "postcss-viewport-units": &#123; filterRule: rule =&gt; rule.nodes.findIndex(i =&gt; i.prop === 'content') === -1, &#125;, "cssnano": &#123; preset: "advanced", autoprefixer: false, "postcss-zindex": false &#125; &#125;&#125; 特别声明：由于cssnext和cssnano都具有autoprefixer,事实上只需要一个，所以把默认的autoprefixer删除掉，然后把cssnano中的autoprefixer设置为false。 特别声明： 由于 cssnext 和 cssnano 都具有 autoprefixer ,事实上只需要一个，所以把默认的 autoprefixer 删除掉，然后把 cssnano 中的 autoprefixer 设置为 false postcss-viewport-units 修改 content ，并不能很好的兼容，会出现以下警告: 1(Emitted value instead of an instance of Error) postcss-viewport-units: ... a:after' already has a 'content' property, give up to overwrite it. 解决办法: 如果没有版本需求，可以考虑去掉; 或者进行过滤，具体如下: 123"postcss-viewport-units": &#123; filterRule: rule =&gt; rule.nodes.findIndex(i =&gt; i.prop === 'content') === -1,&#125;, 使用在不想要把 px 转换为 vw 的时候，首先在对应的元素（html）中添加配置中指定的类名 .ignore 或 .hairlines (.hairlines 一般用于设置 border-width:0.5px 的元素中)： 1&lt;div class="box ignore"&gt;&lt;/div&gt; 写 CSS 时 1234567891011.ignore &#123; margin: 10px; background-color: red;&#125;.box &#123; width: 180px; height: 300px;&#125;.hairlines &#123; border-bottom: 0.5px solid red;&#125; 编译出来的 CSS 1234567891011.box &#123; width: 24vw; height: 40vw;&#125;.ignore &#123; margin: 10px; /*.box元素中带有.ignore类名，在这个类名写的`px`不会被转换*/ background-color: red;&#125;.hairlines &#123; border-bottom: 0.5px solid red;&#125; 上面解决了px到vw的转换计算。那么在哪些地方可以使用vw来适配我们的页面。根据相关的测试： 容器适配，可以使用vw 文本的适配，可以使用vw 大于1px的边框、圆角、阴影都可以使用vw 内距和外距，可以使用vw 参考文章如何在Vue项目中使用vw实现移动端适配(转)]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-参数传递]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F44.%20%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[方法调用的时候，涉及到参数传递的问题，传递的时候，Java 只遵循一种语法机制：将变量中保存的值传递过去，或字面值，或某个对象的内存地址 123456int i = 10;int j = i; //i传递给j，实际上只是将i变量中保存的10传递给j了，j实际上是一块全新的内存空间。User u = 0x1234;User u2 = u; //u传递给u2，实际上是将0x1234这个值赋值给u2了，u和u2实际上是两个不同的局部变量，//但是它们这两个变量指向堆内存中同一个java对象。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-构造方法]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F43.%20%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言构造器又称为 构造函数 / 构造器 / constructor [修饰符列表] 构造方法名（形式参数列表） { 构造方法体；} 普通方法的语法结构： [修饰符列表] 返回值类型 方法名（形式参数列表） { 方法体；} 可以看到，构造方法里没有返回值类型！！ 介绍对于构造方法来说，构造方法的方法名必须和类名保持一致！ 1234567public class test01 &#123; public static void main(String[] args) &#123; // 创建 User 对象 // 调用 User 类的构造方法来完成对象的创建 User u = new User(); &#125;&#125; 作用 创建对象 给实例变量赋值 实例变量的内存空间是在构造方法执行过程当中完成开辟，完成初始化的。系统在默认赋值的时候，也是在构造方法执行过程当中完成的赋值。 调用方法new 构造方法名(实参列表) 另，普通方法中，如果有 static ：类名.方法名(实参列表)；没有static：引用.方法名(实参列表) 返回值每一个构造函数实际上执行结束之后都有返回值，但是这个“return 值；”不需要写； 构造方法结束时 Java 程序自动返回值，并且返回值类型是构造方法所在类的类型； 由于构造方法的返回值类型就是类本身，所以返回值类型不需要缩写 缺省构造器（无参数构造器）缺省构造器——当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法； 当一个类显示的将构造方法定义出来了，那么系统将不再默认为这个类提供缺省构造器，建议开发中手动的为当前类提供无参数构造方法，因为无参数构造方法太常用了。 12345678public class User &#123; private String acto; // 无参数构造器 public Test01() &#123; // 默认初始化实例变量的内存空间 // acto = null; &#125;&#125; 有参数的构造器构造器支持方法重载机制，可以在一个类当中编写多个构造器方法 1234// 创建对象User u1 = new User();User u2 = new User(10);User u2 = new User("zhangwei"); 快速创建构造器：右键 --&gt; Source --&gt; Generate Constructor using Fields... 12345678910// 无参数构造器public Test01() &#123; // 默认初始化实例变量的内存空间 // acto = null;&#125;// 有参数的构造器public Test01(String acto) &#123; super(); this.acto = acto;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-对象和引用的概念]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F42.%20%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[对象：目前在使用new运算符在堆内存中开辟的内存空间称为对象；引用：是一个变量，不一定是局部变量，还可能是成员变量。引用保存了内存地址，指向了堆内存当中的对象；所有访问实例相关的数据，都需要通过“引用.”的方式访问，因为只有通过引用才能找到对象； 只有一个空的引用，访问对象的实例相关的数据会出现空指针异常。 123456class Student&#123; Computer com; //com是一个引用【实例变量】 public static void doSome()&#123; Computer cc; //cc是一个引用【局部变量】 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-面向对象的封装性]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F41.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[面向对象三大特性：封装、继承、多态 封装的好处： 使用者无需关注事物的复杂内部，只需要会操作接口就行了 封装后才会形成真正的“对象”，真正的“独立体” 封装后，复用性强；提高安全性 怎么封装一个类呢？1234public class User &#123; // 属性私有化 private int age;&#125; 所有属性私有化，使用 private 关键字进行修饰。private 表示私有的，修饰的所有数据只能在本类中访问 对外提供简单的操作入口，提供两个公共的方法 set 方法—修改属性 get 方法—读取属性 set 方法的命名规范 123public void setAge(int a) &#123; age = a;&#125; get 方法的命名规范 123public int getAge(int a) &#123; return age;&#125; 注意： setter 和 getter 没有 static 关键字 有 static 关键字修饰的方法：类名.方法名（实参） 没有 static 关键字修饰的方法：引用.方法名（实参） eclipse 封装快捷办法1234public class User &#123; // 属性私有化 private int age;&#125; 右键 –&gt; Source –&gt; Generate Getters and Setters.. –&gt; 选择变量，可快速得到对应的 get、set 方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-关于 eclipse 的使用]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F40.%20%E5%85%B3%E4%BA%8E%20eclipse%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于Java的集成开发环境【集成开发环境简称：IDE】，下面介绍 eclipse 的使用 workspace:工作区 当 eclipse 打开的时候，大多数都是会提示选择工作区 这个工作区可以是已存在的工作区，也可以是新建的工作区 选择工作区之后，将来编写的java代码，自动编译的class文件都会在工作区中找到 myeclipse可以开启两个甚至更多的会话，每一个会话对应不同的workspace 工作区workspace中基本的单元是：Project（工程/项目） .metadata文件夹在workspace工作区当中有一个文件夹：.metadata 在该文件夹当中存储了当前 eclipse 的工作状态 将 .metadata 文件夹删除之后，下一次再次进入这个工作区的时候，是一个全新的开始。但是会发现这个IDE工具当中所有的项目丢失了，没关系，这里只是丢失的 eclipse 的项目，硬盘上真实存储的项目不会丢失 窗口打开myeclipse之后 窗口双击可以最大化或者还原 窗口可以拖动 窗口不小心关闭了，可以再次打开：window --&gt; show view --&gt; Other --&gt; 输入自己要找的窗口 布局方式 企业级开发：JavaEE 开发的专用布局- MyEclipse Java Enterprise 普通java开发的：JavaSE 开发的专用布局 - Java 怎么切换布局？ eclipse 右上角，点击 Open Perspective 当这个布局被破坏之后想复原？ window --&gt; Perspective --&gt; Reset Perspective 重点的窗口介绍 Package Explore / Navigator / Project Explore ：可以看到 Java 源文件 Console：控制台窗口 创建工程在 Package Explor 窗口当中点击右键 --&gt; new --&gt; Java Project【JavaSE工程】：当然还有其它方式 指定 java 工程的名称：一般全部小写 指定 java 工程的存放目录 Java 的运行时环境：JRE的配置【可以选择使用 eclipse 自带的 JRE，也可以选择程序员自己安装的 JRE】 Project layout : 工程的目录布局 多数情况下都是选择：两个独立的文件夹存储源码(src)和字节码(bin) 新建软件包 在 src 目录上点击右键 --&gt; new --&gt; package 给 package 起名：com.bjpowernode.javase; 新建 Java 类 在包上点击鼠标右键 --&gt; new --&gt; class 可以在下面勾选项，如 生成 main 方法 快捷键 ctrl + d 删除一行 alt + / 自动补全 ctrl + 1 纠错 ctrl + alt + down 复制一行，往下粘贴 ctrl + o 查看方法名 ctrl + / 单行注释 ctrl + shift + / 多行注释 alt + shift + a 快速编辑，支持多行同时编辑：块编辑；还可以在上面的 icon 选中使用，标有：Toggle Block Selection Mode ctrl + shift + t 查找类型【Open Type】 ctrl + shift + r 查找资源【Open Resource】 ctrl + shift + o 导入类 注意：eclipse当中的 java 源代码有的时候不保存是不会编译的。所以时刻记住：ctrl + s 运行一个带有主方法的java程序 在java源程序的任何位置点击鼠标右键 –&gt; Run As –&gt; Java Application 点击上面的小icon 保存自动格式化windows--&gt;Preferences--&gt;Java --&gt; Editor--&gt;Save Actions, 勾选“Perform the selected actions on save”，其他选项根据需要自己选择或者配置就可以了 最后 Apply 和 Ok 一下 怎么链接源码打开某个 .class 字节码文件，当没有看到源码的时候 点击“Attached Source” Workspace … 【源码在当前的工作区当中】 External File … 【源码在某个压缩包当中】 External Folder … 【源码在某个目录当中】]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-空指针异常]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F39.%20%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[12345678Student stu = new Student();System.out.println(stu.name);stu = null;// 以下程序可以 编译通过，因为符合语法// 运行出现 空指针 异常,java.lang.NullPointerException// 因为引用的地址变成了空，就没有引用了System.out.println(stu.name); 注意另一种情况： 带有 static 的方法，其实既可以采用类名的方式访问，也可以采用引用的方式访问。但是即使采用引用的方式去访问，实际上执行的时候和引用指向的对象无关。 在 eclips 中开发的时候，使用引用的方式访问带有 static 的方法，程序会发生警告。 所以带有 static 的方法还是建议使用“类名.”的方式访问 12345678910public class Text &#123; public static void main(String[] args) &#123; Test t = new Text(); t.doSome(); t = null; t.doSome(); // 不会出现引用异常，因为与引用指向的对象无关 &#125;&#125; System.out.pringln()内有乾坤 1234567Object[] objs = new Object[3];for(int i = 0;i &lt; objs.length;i++) &#123; Object o = objs[i]; // o.toString(); // 空指针异常，因为引用类型的数组默认值是 null System.out.pringln(o); // null null null&#125; 为什么上面代码输出不会报空指针异常呢？去println的源码看看吗 12345678910public void println(Object x) &#123; String s = String.valueOf(x); synchronized (this) &#123; print(s); newLine(); &#125;&#125;public static String valueOf(Object obj) &#123; return (obj == null) ? "null" : obj.toString(); // 看这里！已经做了兼容处理&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-关于 JVM 内存管理]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F38.%20%E5%85%B3%E4%BA%8E%20JVM%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[![image-20200212175445729](38. 关于 JVM 内存管理.assets/image-20200212175445729.png)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-方法执行内存分析]]></title>
    <url>%2F2020%2F02%2F12%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F37.%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[通过一个类，可以实例化 N 个对象：new 类名(); new 运算符的作用：创建对象，在 JVM 堆内存 当中开辟新的内存空间 方法区内存：在类加载的时候，class 字节码代码片段被加载到该内存空间中栈内存（局部变量）：方法代码片段执行的时候，会给该方法分配内存空间，在 栈内存 中压栈堆内存：new 的对象在 堆内存 中存储 分析下面语句1Student s = new Student(); Student 是一个引用数据类型 s 是一个局部变量（在栈内存中存储），也是一个引用 new Student() 是一个学生对象 什么是对象？？ new 运算符在 堆内存 中开辟的内存空间——对象 什么是引用？？ 引用是一个变量，只不过这个变量中保存了另一个 Java 对象的内存地址 所以，s 是引用，不是对象，new Student() 才是对象，s 保存的是对象的内存地址 Java 中，程序员不能直接操作堆内存，没有指针，不像 C 语言。只能通过 “引用” 去访问堆内存当中对象内部的实例变量 访问实例变量的语法格式 读取数据：引用.变量名 修改数据：引用.变量名 = 值 1234567Student stu = new Student();System.out.println(stu.name);// 编译报错：name 这个实例变量不能直接采用“类名”的方式访问// 因为它是对象级别的变量，变量存储在 Java 对象的内部，必须先有对象// 通过对象才能访问实例变量System.out.println(Student.name);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Npm audit fix 报错]]></title>
    <url>%2F2020%2F02%2F11%2FNpm%2FNpm%20audit%20fix%20%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[在 npm install 的时候，发现有这样的提示 12found 13 vulnerabilities (1 low, 8 moderate, 4 high) run `npm audit fix` to fix them, or `npm audit` for details 如果忽视它，是跑不起项目的。必须正式这个报错，所以按照提示npm audit fix，执行后，又会报错 1(use `npm audit fix --force` to install breaking changes; or refer to `npm audit` for steps to fix these manually) 这时，千万不能--force，因为他会强制安装最新的依赖项，有可能把自己项目的依赖搞乱了。老老实npm audit发现错误吧，按照实际情况，不去纠正错误也是可以运行的，按需？ 12345# 扫描项目漏洞把不安全的依赖项自动更新到兼容性版本npm audit fix# 强制执行 audit fix 安装最新的依赖项（toplevel）npm audit fix --force]]></content>
      <categories>
        <category>Npm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连接MySQL服务器数据库]]></title>
    <url>%2F2020%2F02%2F11%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E8%BF%9E%E6%8E%A5MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前言使用 HeidiSQL 连接服务器数据库，非常简单，选择 MySQL 网络类型，输入用户名、密码即可。但是可能会报这样的错：Can&#39;t connect to MySQL server on &#39;ip地址&#39;(10061)，为什么呢？？ 理由也很简单：服务器没有配置 MySQL ，以下是 CentOS 的教程 安装mysql数据库 下载 mysql 源安装包 wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 安装 mysql 源 yum localinstall mysql57-community-release-el7-8.noarch.rpm 若结尾出现complete!，则说明MySQL源安装完成 检测是否安装完成 yum repolist enabled | grep &quot;mysql.*-community.*&quot; 安装 mysql yum install mysql-community-server 若结尾出现Complete!， 则MySQL安装完成 设置开启启动 mysql 服务 systemctl enable mysqld 查看安装的 mysql 版本 rpm -aq | grep -i mysql 启动 MySQL 服务 systemctl restart mysqld 查看MySQL初始密码 grep &#39;A temporary password&#39; /var/log/mysqld.log 更改MySQL密码 mysqladmin -u root -p&#39;旧密码&#39; password &#39;新密码&#39; 这里更改密码出了问题，更改失败，这是因为密码太过简单的原因。有两个接解决方法： 把密码设置复杂点（这是最直接的方法） 关闭 mysql 密码强度验证(validate_password) 编辑配置文件：vim /etc/my.cnf， 增加这么一行 validate_password=off 编辑后重启 mysql 服务：systemctl restart mysqld 设置 mysql 能够远程访问 登录进 MySQL：mysql -uroot -p密码 执行 use mysql; 增加一个用户给予访问权限：grant all privileges on *.* to &#39;用户名&#39;@&#39;ip地址&#39; identified by &#39;密码&#39; with grant option; //可将ip改为%,表示开启所有的 - 最后需要 flush privileges; 强制刷新权限 配置阿里云服务器在服务器的配置页，点开 安全 —&gt; 防火墙，添加 MYSQL 应用类型； 重启服务器 连接完成以上操作，连接成功！ 其他退出 MySQL 的方法 最简单 \q Exit; 带分号 Quit:]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-乘法递归]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F2.%20%20%E4%B9%98%E6%B3%95%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[使用递归，编写一个程序：5*4*3*2*1 12345678910111213141516public class HelloWorld &#123; public static void main(String[] args) &#123; int n = 5; int result = method(n); System.out.println(result); &#125; public static int method(int n) &#123; if (n == 1) &#123; return 1; &#125; return n * method(n - 1); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java编程题-找素数]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E7%BC%96%E7%A8%8B%E9%A2%98%2F1.%20%E6%89%BE%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[编写 for 循环找出 1~100 中所有的素数【素数：又被称为质数，能够被1和自身整除，不能被其他数字整除的数字】 12345678910111213141516171819public class HelloWorld &#123; public static void main(String[] args) &#123; for (int i = 2; i &lt;= 100; i++) &#123; boolean isSushu = true; for (int j = 2; j &lt; i; j++) &#123; if (i % j == 0) &#123; isSushu = false; break; &#125; &#125; if (isSushu) &#123; System.out.print(i + " "); &#125; &#125; &#125; &#125; 编写 for 循环找出 1~10000 中所有的素数， 要求每 8 个换一行输出 12345678910111213141516171819202122232425public class HelloWorld &#123; public static void main(String[] args) &#123; int count = 0; for (int i = 2; i &lt;= 1000; i++) &#123; boolean isSushu = true; for (int j = 2; j &lt; i; j++) &#123; if (i % j == 0) &#123; isSushu = false; break; &#125; &#125; if (isSushu) &#123; System.out.print(i + " "); count++; if (count == 8) &#123; System.out.println(); count = 0; &#125; &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-类的定义]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F36.%20%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[[修饰符列表] class 类名 { 属性； // 描述对象的状态信息 方法； // 描述对象的动作信息} Java 语言中所有的 class 都属用 引用数据类型； 每一个类都可以编写主方法，但是一般情况下，一个系统只有一个入口，所以主方法一般写一个，比如有一个 StudentTest.class，里面引用了 Student.class，那个只需要在 StudentTest.class 编写主方法即可]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-类和对象]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F35.%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[类 – 【实例化】 – 对象 对象– 【抽象】 – 类 对象 又被称为 实例 / instance]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-面向过程和面向对象的区别]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F34.%20%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[C 语言是纯面向过程的、C++ 半面向对象、Java、C# 纯面向对象、JS 基于对象 面向过程 关注点 实现的具体过程，因果关系【集成显卡的开发思路】 优点 对于业务逻辑比较简单的程序，可以达到快速开发，前期投入成本较低 缺点 很难解决非常复杂的业务逻辑； 耦合性高，扩展性差； 没有独立体的概念，无法达到组件复用 面向对象 关注点 主要关注对象【独立体】能完成哪些功能【独立显卡的开发思路】 优点 耦合度低，扩展性强； 容易解决现实世界中更复杂的业务逻辑； 组件复用性强 缺点 前期投入成本较高； 需要进行独立体的抽取，大量的系统分析与设计 面向对象 更符合人的思维方式 面向对象的三大特征【所有面向对象的编程语言都有这三大特征】 封装 继承 多态 采用面向对象的方式开发一个软件，生命周期当中：【整个生命周期中贯穿使用 OO 面向对象方式】 面向对象的分析：OOA 面向对象的设计：OOD 面向对象的编程：OOP]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-方法递归]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F33.%20%E6%96%B9%E6%B3%95%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[递归——方法自身调用自身 123a() &#123; a();&#125; 递归必须有结束条件，否则一定会发生栈内存溢出错误（java.lang.StackOverflowError）； 即使有了结束条件，也可能发生溢出错误，因为递归的太深了； 递归可以不使用时，尽量别用 1234567891011121314151617public class HelloWorld &#123; public static void main(String[] args) &#123; int n = 5; int result = method(n); System.out.println(result); &#125; // 虽然这块代码重复调用，但是每次调用都会在 栈内存 新分配一块所属的内存空间 public static int method(int n) &#123; if (n == 1) &#123; return 1; &#125; return n * method(n - 1); &#125;&#125; ![image-20200209202045292](33. 方法递归.assets/image-20200209202045292.png)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-方法重载]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F32.%20%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[方法重载又被称为：overload，JavaScript 是没有这个特性的 1234567891011public class U &#123; public static void p(byte b)&#123; System.out.print(b); &#125; public static void p(double b)&#123; System.out.print(b); &#125;&#125;U.p(2);U.p(2.0); 什么时候考虑使用 方法重载？ 当功能相似的时候，尽可能让方法名相同。【功能 不同/不相似 时，尽可能让方法名不同】 什么条件满足之后构成方法重载？ 同一类中 方法名相同 参数列表不同 数量不同 顺序不同 类型不同 方法重载和什么有关系？ 和 方法名+参数列表 有关 和 修饰符列表、返回值类型 无关]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-方法执行内存分析]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F31.%20%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[方法只定义，不调用，是不会执行的，并且 JVM 也不会给该方法分配 “运行所属” 的内存空间。只有在调用这个方法的时候，才会动态的给这个方法分配所属的内存空间。 在 JVM 内存划分上有这样三块主要的内存空间（除此之外还有其他的内存空间） 方法区内存 堆内存 栈内存 分配内存的过程： 方法代码片段 属于 .class 字节码文件的一部分，字节码文件在类加载的时候，将其放到了方法区当中。所以 JVM 中的三块主要的内存空间中 方法区内存 最先存有数据，存放了代码片段 代码片段 虽然在 方法区内存 当中只有一份，但是可以被重复调用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所，在 栈内存 中分配。【栈内存 中分配方法运行的所属内存空间】 方法在调用的瞬间，会给该方法分配内存空间，会在栈中发生 压栈 动作，方法执行结束后，会把该方法分配的内存空间全部释放，此时发生 弹栈 动作 压栈：分配内存 弹栈：释放内存 ![image-20200209202143928](31. 方法执行内存分析.assets/image-20200209202143928.png)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-方法]]></title>
    <url>%2F2020%2F02%2F09%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F30.%20%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[[ 修饰符列表 ] 返回值类型 方法名（形式参数列表） { ​ 方法体； } 修饰符列表 可选项，不是必须的 目前统一写成：public static 如果 修饰符列表 有 static 关键字的话，调用方法：类名.方法名(实际参数列表) 有时候 类名. 也可以省略：当两个方法在同一个类体当中的时候 123m1()&#123; m2();&#125; 返回值类型 任意一种类型都可以，包括 基本数据类型和引用数据类型 当一个方法执行结束之后不返回任何数据的话，返回值类型必须编写： void 关键字 返回值类型 如果不是 void ，表示这个方法执行结束之后必须返回一个具体的数值；当方法执行结束时没有返回任何数据的话编译器报错 返回值类型 是 void 的时候，在方法体当中不能编写 return 值;，可以编写 return ; 只要带有 return 关键字的语句执行，return 语句所在的方法结束 方法名 最好是动词 首字母小写，后面每个单词首字母大写 形式参数列表 形参中起决定性作用的是 形参的数据类型 扩展： 方法定义在类体当中，一个类当中可以定义多个方法，顺序可以随意； 方法体当中不能再定义方法！！！！ 在“同一个作用域”当中，return 语句下面不能编写任何代码，因为这些代码永远执行不到，所以编译报错 1234567// 编译报错：缺少返回语句，因为编译器认为 无法百分百保证 "return 1;" 会执行public static int m() &#123; int a = 10; if(a &gt; 3) &#123; return 1; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vscode-添加 Git 管理]]></title>
    <url>%2F2020%2F02%2F08%2F%E5%BC%80%E5%8F%91%2FVscode%2FVscode-%E6%B7%BB%E5%8A%A0%20Git%20%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[发现 Vscode 的 Git管理区一片空白，还提示 “当前没有源代码管理提供程序进行注册 ”，不能看到更改状态和分支，非常不痛快。 最初以为是插件没装好，安装卸载了几次，发现还是那样，百度了一下，需要配置 git.path file -&gt; preferences -&gt; settings-&gt; 输入git.path -&gt; 点击&quot;edit in settings.json&quot; 在json文件中添加以下代码：（后边为自己的git.exe路径） &quot;git.path&quot;:&quot;D:/install/Git/bin/git.exe&quot; 重启 Vscode]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-while循环]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F29.%20while%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[1234567int i = 10;int j = 3;while (10 &gt; 3) &#123; System.out.println("99");&#125;System.out.println("990"); // 如果前面的 while 判断是 10 &gt;3 或者 true，编译器会检测到该语句永远无法执行，报错；加入循环判断改成 i &gt; j，就不会报错，因为编译器只检查语法，不执行]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-continue语句]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F28.%20continue%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[continue表示：继续 / go on / 下一个 12345678910111213141516171819for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; if (j == 2) &#123; continue; // 本次循环停止，直接进入下一次循环 “继续” 执行 &#125; System.out.println(j); &#125;&#125;/* 0 1 3 0 1 3 0 1 3*/ break 和 continue 的区别： break 表示循环不执行 continue 表示直接进入下一次循环继续执行 可以 “继续” 某个命名循环 12345678910111213141516for1: for (int i = 0; i &lt; 3; i++) &#123; for2: for (int j = 0; j &lt; 4; j++) &#123; if (j == 2) &#123; continue for1; &#125; System.out.println(j); &#125;&#125;/* 0 1 0 1 0 1*/]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-break语句]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F27.%20break%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[break 语句使用在 for、while、do…while 循环语句中，用来跳出循环，终止循环的执行。在循环达到某个条件的时候，终止循环可以提高程序的执行效率 默认情况下：break 语句终止的是离它最近的循环语句 12345678910111213141516for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; if (j == 2) &#123; break; // 这里的 break 不会影响外层的 for循环 &#125; System.out.println(j); &#125;&#125;/* 0 1 0 1 0 1*/ 可以指定终止某个循环，需要给循环起名字break 循环名称; 123456789101112for1: for (int i = 0; i &lt; 3; i++) &#123; for2: for (int j = 0; j &lt; 4; j++) &#123; if (j == 2) &#123; break for1; &#125; System.out.println(j); &#125;&#125;/* 0 1*/]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-do...while循环]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F26.%20do...while%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[do…while循环语句最终有一个”分号“，别丢了！ 123do &#123; java 语句；&#125;while(x &gt; y);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-switch语句]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F25.%20switch%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617switch(int 或 String 类型的字面值或变量) &#123; case int 或 String 类型的字面值或变量 : java 语句; ... break; case int 或 String 类型的字面值或变量 : java 语句; ... break; case int 或 String 类型的字面值或变量 : java 语句; ... break; default : java 语句; ...&#125; case 穿透现象：如果匹配成功的分支语句最后没有break，直接进入下一个分支执行（不会进行匹配） switch 后面和 case 后面只能是 int 或 String 类型的数据 byte、short、char 可以直接写到 switch 和 case 后面，因为它们可以进行自动类型转换，byte、short、char 可以自动转换成 int 类型 case可以合并 12345int i = 1;switch(i) &#123; case 1 : case 2 : case 3 : System.out.println("Test Code!");&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-接收用户键盘输入]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F24.%20%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%2F</url>
    <content type="text"><![CDATA[创建键盘扫描器对象 1java.util.Scanner s = new java.util.Scanner(System.in); 调用 Scanner 对象的 next() 方法接收用户键盘输入 12345String str = s.next();System.out.println(str);// 或int num = s.nextInt();System.out.println(num);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-字符串连接运算符]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F23.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[+ 运算符在 Java 语言中有两个作用 加法运算，求和 字符串的连接运算 当 ”+“ 运算符两边都是数字，一定进行 加法运算； 当 ”+“ 运算符两边只有有一个是字符串，一定进行 字符串连接运算，并且得到的结果还是一个字符串类型 数字 + 数字 –&gt; 数字（求和） 数字 + ”字符串“ –&gt; ”字符串“（字符串连接） 如果一个表达式当中有多个 ”+“ ，在没有添加小括号的前提下，遵循自左向右的顺序依次运算]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-扩展类的赋值运算符]]></title>
    <url>%2F2020%2F02%2F08%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F22.%20%E6%89%A9%E5%B1%95%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[扩展类的赋值运算符【+=、-+、/=、%=…】不改变运算结果类型，假设最初这个变量的类型是 byte类型，无论怎么进行追加或追减，最终该变量的数据类型还是 byte类型 123456789byte x = 10;// 编译报错：大容量转换成小容量，要加强制运算符 =&gt; x = (byte)(x+5)x = x +5;System.out.println(x); //------------byte x = 10;x += 5; // 等同于：x = (byte)(x+5) 而不是 x = x +5System.out.println(x); // 15]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-逻辑与和短路与 区别]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F21.%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E4%B8%8E%E5%92%8C%E7%9F%AD%E8%B7%AF%E4%B8%8E%20%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[运算符 解释 &amp; 逻辑与 | 逻辑非 &amp;&amp; 短路与 || 短路非 逻辑与 和 短路与 的运算结果相同，只不过 短路与 存在短路现象；逻辑或 和 短路或 的运算结果相同，只不过 短路或 存在短路现象； 解释： 123456789int x = 10;int y = 8;// 1. 逻辑与：输出 11，尽管前面的算子为 false，后面还是会执行System.out.println(x &lt; y &amp; ++x &lt;y);System.out.println(x);// 1. 逻辑与：输出 10，前面的算子为 false，后面不会执行，这种现象叫 短路现象System.out.println(x &lt; y &amp;&amp; ++x &lt;y);System.out.println(x); 什么情况下发生短路与？ 第一个表达式执行结果是 false，会发生短路或 什么情况下发生短路或？ 第一个表达式执行结果是 true，会发生短路或 结论： 从某个角度来看，短路与 更智能。由于后面的表达式可能不执行，所以执行效率较高，在实际的开发中使用较多。 但是，在某些特殊的业务逻辑中，要求运算符两边的算子必须全部执行，此时必须使用 逻辑与，不能使用 短路与，使用短路与可能导致右边的表达式不执行。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-单目运算符]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F20.%20%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%8D%95%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[单目运算符：++、–，下面以 ++ 为例进行分析 ++ 运算符可以出现在变量前，也可以出现在变量后，无论是变量前还是变量后，只要 ++ 运算结束，该变量的值一定会自加 1 ++ 出现在变量后：先做赋值运算，再对变量中保存的值进行自加 1 1234int a = 100;int b = a++;System.out.println(a); // 101System.out.println(b); // 100 ++ 出现在变量前：先进行自加 1 运算，再进行赋值操作 1234int m = 20;int n = ++m;System.out.println(m); // 21System.out.println(n); // 21 注意：println 的特殊情况 12345int mm = 500;System.out.println(mm); // 500int e = 100;System.out.println(e++); // 100System.out.println(e); // 101 以上的结果是为啥呢？？ 因为 println 源码如下，x 赋值后，变成 int x = e++ ，先赋值再 + 1 123456public void println(int x) &#123; synchronized (this) &#123; print(x); // 打印x newLine(); // 换行 &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-基本的类型转换]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F19.%20%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[关于基本数据类型之间的互相转换：转换规则 八种基本数据类型当中除布尔类型之外剩下的7种类型之间都可以相互转换 自动类型转换：小容量向大容量转换。容量从小到大排序： byte &lt; short &lt; int &lt; long &lt; float &lt; double ​ chart &lt; 注意：任何浮点类型不管占用多少个字节，都比整数型容量大 ​ chart 和 short 可表示的种类数量相同，但是 chart 可以取更大的正整数 强制类型转换：大容量转换成小容量。需要加强制类型转换符，编译才通过，但是在运行阶段可能会损失精度，所以谨慎使用 当一个==整数字面值没有超过 byte、short、char 的取值范围，可以直接赋值给 byte、short、char类型的变量 byte、short、char 混合运算的时候，各自先转换成 int类型 再做运算 多种数据类型混合运算，先转换成容量最大的那种类型再做运算 注意： byte b = 3; 编译通过，3没有超出 byte 类型取值范围 int i = 10; byte b = i / 3; 编译报错：编译器只检查语法，不会运算 i / 3 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 1. 出现错误，1000 超出了 byte 的范围// byte a = 1000;// 2. 正确，因为 20 没有超出 byte 范围byte a = 20;// 3. 变量不能重名// short a = 1000;// 4. 正确，因为数值 1000 没有超出 short 类型的范围short b = 1000;// 5. 正确，因为默认就是 int，并且没有超出 int 范围int c = 1000;// 6. 正确，可以自动转换long d = c;// 7. 错误，出现精度丢失问题，大类型--&gt;&gt;小类型会出现问题// int e = d;// 8. 将 long 强制转换成 int 类型// 因为值 1000，没有超出 int 范围，所以转换是正确的int e = (int)d;// 9. 因为 java 中的运算会会转成最大类型// 而 10 和 3 默认为 int,所以运算后的最大类型也是 int，所以是正确的int f = 10/3;// 10. 声明 10 为 long 类型long g = 10;// 11. 出现错误，多个数值在运算过程中，会转换成容量最大的类型// 以下示例最大的类型为 double，而 h 为 int// 所以就会出现大类型（long）到小类型（int）的转换，将会出现精度丢失问题//int h = g/3;// 12. 可以强制转换,因为运算结果没有超出 int 范围// int h = (int)g/3;// 13. 可以采用 long 类型来接收运算结果// long h = g/3;// 14. 出现精度损失问题，以下问题主要是优先级的问题// 将 g 转换成 int，然后又将 int 类型的 g 转换成 byte,最后 byte 类型的 g 和 3 运算，// 那么，它的运算结果类型就是 int，所以 int 赋值给 byte 就出现了精度损失问题// byte h = (byte)(int)g/3;// 正确// byte h = (byte)(int)(g/3);// 15. 不能转换,还有因为优先级的问题// byte h = (byte)g/3;// 16. 可以转换，因为运算结果没有超出 byte 范围//byte h = (byte)(g/3);// 17. 可以转换，因为运算结果没有超出 short 范围short h = (short)(g/3);short i = 10;byte j = 5;// 18. 错误，short 和 byte 运算，首先会转换成 int 再运算// 所以运算结果为 int，int 赋值给 short 就会出现精度丢失问题// short k = i + j;// 可以将运算结果强制转换成 short// short k = (short)(i + j);// 19. 因为运算结果为 int，所以可以采用 int 类型接收int k = i + j;// 20. 输出结果为 97，也就是 a 的 ascii 值char l = 'a';System.out.println((byte)l);// 21. 输出结构为 197,取得 a 的 ascii 码值，让后与 100 进行相加运算int m = l + 100;System.out.println(m);// 22. 输出 3.0，因为 10 /3 得到的是 int类型的结果，再转换成 double 类型double dd = 10 /3;System.out.println(dd);// 23. 输出3.3333333333333335，这次得到的结果就是 double类型dd = 10.0 / 3;System.out.println(dd);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-布尔型]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F18.%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%B8%83%E5%B0%94%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[布尔数据类型：boolean在 Java语言中，只有两个值：ture、false，不像 C 语言可以用0、1表示。在底层存储的时候，占用1个字节，因为实际存储的时候 false 底层是 0 ，true 底层是 1 1234// 编译报错：不兼容的类型// boolean flag = 1;boolean flag = true;System.out.println(flag);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-浮点型]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F17.%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%B5%AE%E7%82%B9%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[浮点型数据类型 float 单精度【4个字节】 double 双精度【8个字节，精度较高】 Java 语言中的”浮点型字面值“被默认当作 double 类型来处理 double 的精度太低【相对来说】，不适合做财务软件。 财务涉及到钱的问题，要求的精度较高，所以 SUN 在基础SE类库中为程序员准备了精确度更高的类型，属于引用数据类型：java.math.BigDecimal 其中： SE 类库字节码：C:\Program Files\Java\jdk1.8.0_101\jre\lib\rt.jar SE 类库源码：C:\Program Files\Java\jdk1.8.0_101\src.zip 类型转换 字面值为 double类型，赋值类型也为 double类型 123// 3.0 是 double类型，所以不存在类型转换double d = 3.0;System.out.println(d); 字面值为 double类型，赋值类型为 float类型 12345678// 3.1 是 double类型，大容量向小容量转换需要进行处理// float f = 5.1;// 第一种办法：强制类型转换// float f = (float)5.1;// 第二种办法：没有类型转换float f = 5.1f;System.out.println(f);]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-整数型]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F16.%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E6%95%B4%E6%95%B0%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java 语言中的”整数型字面值“被默认当作 int 类型来处理；要让这个”整数型字面值“被当作 long 类型来处理的话，需要在后面添加 l/L，建议使用大写的 L 类型转换 字面值为 int类型，赋值类型也为 int类型 12345678// 123 是 int类型，i 也是 int类型，不存在类型转换int i = 123;System.out.println(i);// 456 是 int类型 占用4个字节，x 是 long类型 占用8个字节，存在类型转换// 但 小容量可以自动转换成大容量，称为自动类型转换机制long x = 456;System.out.println(x); 字面值为 int类型，赋值类型为 long类型 12345678910long y = 2147483647;System.out.println(w);// 编译出错：2147483648 超出 int类型 范围long z = 2147483648;System.out.println(z);// 解决错误：在字面值后面加 L，一开始便当作 long类型 处理long w = 2147483648L;System.out.println(w); 字面值为 long类型，赋值类型为 int类型 12345678910long xx = 100L;// 编译报错：大容量不能直接赋值给小容量// int yy = xx;// 大容量赋值给小容量，需要进行强制类型转换// 强制类型转换 需要添加“强制类型转换符”// 即使编译通过了，运行阶段可能损失精度// 所以 强制类型转换，需要谨慎使用，因为损失精度之后可能损失很严重int yy = (int) xx;System.out.println(yy); 字面值为 int类型，赋值类型为 byte、short、char类型 123456// 当一个整数字面值没有超过 byte、short、char 的取值范围，这个字面值可以直接赋值给 byte、short、char类型的变量// 这种机制 SUN 允许了，目的是为了方便程序员的编程byte m = 120;// byte m = (byte)120;System.out.println(m); 精度损失计算机在任何情况下底层表示和存储数据的时候采用了补码形式 正数的补码：和原码相同 负数的补码：负数的绝对值对应的二进制码所有二进制位取反，再加1 补码：1000000 原码计算过程： 10000000 - 1 –&gt; 01111111 10000000 –&gt; 128 -128 所以，如果 byte b1 = 128，是一定会损失精度的。原始数据 00000000 00000000 00000000 10000000，强转之后100000000，这是一个补码，按照上面过程，原码就是 -128]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-转义字符]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F15.%20%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[反斜杠 u 联合起来后面的一串数字是某个文字的 unicode 编码，比如： 123char g = '\u4e2d';System.out.println(g);// 中 也解释了前面 chart 数据类型的默认值为啥是 \u0000，是个空值]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-System.out.println()、System.out.print() 区别]]></title>
    <url>%2F2020%2F02%2F07%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F14.%20println()%E3%80%81print()%20%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[println 输出之后换行，print 输出后不换行 1234System.out.println("Hello");System.out.print("World");// Hello// World]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[修改 Vscode 默认的终端]]></title>
    <url>%2F2020%2F02%2F06%2F%E5%BC%80%E5%8F%91%2FVscode%2F%E4%BF%AE%E6%94%B9%20Vscode%20%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BB%88%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[突然发现电脑的 Vscode 终端没有显示分支，使得开发非常容易出错，记录下修改的方法 步骤： 打开设置, 搜索 shell 关键字 找到 Terminal › Integrated › Shell: Windows 设置项 将默认的终端修改为git-bash.exe 的路径]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-字符编码]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F13.%20%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[出现乱码的原因：解码和编码采用的不是同一套对照表 ASCII码： ‘a’ –&gt; 97 ‘A’ –&gt; 65 ‘0’ –&gt; 48 unicode编码： 统一了全球所有的文字，容量较大，有多种具体实现：UTF-8、UTF-16、UTF-32… Java 采用的是 unicode编码方式，所以标识符可以用中文。现在实际开发中，一般使用 UTF-8 编码方式较多【统一编码方式】]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-数据类型]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F12.%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型的作用：不同的数据有不同的类型，不同的数据类型底层会分配不同大小的空间；指导程序在运行阶段应该分配多大的内存空间 分类基本数据类型、引用数据类型（类、接口、数组…） 基本数据类型四大类八小种 整数类型：byte、short、int、long 浮点类型：float、double 布尔类型：boolean 字符类型：chart 类型描述 关键字 占用存储空间（单位：byte 字节） 取值范围 默认值 字节型 byte 1 -128~127 0 短整型 short 2 -32768~32767 0 整型 int 4 -2147483648~2147483647 0 长整型 long 8 0 单精度浮点型 float 4 0.0f 双精度浮点型 double 8 0.0d 布尔型 boolean 1 true/false false【在C语言中，true是1，false是0】 字符型 chart 2 0~65535 `\u0000’ byte 类型最大值：01111111 =&gt; 2 的 7 次方 - 1 = 127 00000000 00000000 00000000 10000000（二进制） 减去 1 结果是 00000000 00000000 00000000 01111111（二进制） byte 类型最小值：128 字节 byte1 Byte = 8 bit 【1个字节 = 8个比特位】 1个比特位表示一个二进制位：1/0 1KB = 1024 Byte 1MB = 1024KB 1GB = 1024MB 1TB = 1024 GB]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-变量]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F11.%20%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[在 Java 类体中不能写 语句，只能写声明 变量的分类根据变量声明的位置： 局部变量 在方法体类的变量 成员变量 在方法体外（类体内）的变量 语法规则必须先声明，再赋值，才能访问； 成员变量没有手动赋值会默认赋值【局部变量不会】]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-字面值]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F10.%20%E5%AD%97%E9%9D%A2%E5%80%BC%2F</url>
    <content type="text"><![CDATA[字面值就是数据，其中有以下分类： 整数类型字面值，如：100、9、-1、0 浮点类型字面值，如：0.1、3.14159、-98.999 字符串类型字面值，如：”你好” 、”北京市大兴区”、 “98”、 “3.19” 字符串：表示一次可以存放0个、1个或多个，但是必须使用英文的双引号引起来 字符类型字面值，如：’a’ 、’6’、 ‘男’ 字符类型：表示一次只能存放一个，并且使用英文的单引号引起来 布尔类型字面值，如：true false]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-标识符]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F9.%20%E6%A0%87%E8%AF%86%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[什么是标识符？在 Java 源程序中，凡是程序员有权利自己命名的单词都是标识符 标识符可以标识：类名、方法名、变量名、接口名、常量名… 命名规则 以字母、下划线 _ 或 $ 开头，其后可以是字母、数字、下划线 _ 或 $，不能含有其他字符 不能数字开头 严格区分大小写 不能使用关键字 标识符的长度不要超过15个字符 命名规范 见名知意 类名、接口名：首字母大写，后面每个单词首字母大写 变量名、方法名、参数名：首字母小写，后面每个单词首字母大写 常量名：全部大写]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-注释]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F7.%20%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[单行注释 1// 单行注释，只注释当前行 多行注释 12345678/*多行注释多行注释多行注释多行注释多行注释.....*/ javadoc注释 123456789/*** javadoc注释* javadoc注释* javadoc注释* javadoc注释* javadoc注释* javadoc注释*/注意：这种注释是比较专业的注释，该注释信息会被javadoc.exe工具解析提取并生成帮助文档。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-public class 和 class的区别]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F8.%20public%20class%20%E5%92%8C%20class%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[一个java源文件当中可以定义多个class，一个class会定义生成一个xxx.class字节码文件 一个java源文件当中public的class不是必须的 一个java源文件当中定义公开的类的话，只能有一个，并且该类名称必须和java源文件名称一致。 每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：java B，想执行X.class当中的main方法：java X 注意：当在命令窗口中执行java Hello，那么要求Hello.class当中必须有主方法。没有主方法会出现运行阶段的错误： 123D:\course\JavaProjects\02-JavaSE\day02&gt;java Hello错误: 在类 B 中找不到主方法, 请将主方法定义为:public static void main(String[] args)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-classpath]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F6.%20ClassPath%2F</url>
    <content type="text"><![CDATA[疑问：ClassLoader 是在哪个位置上搜索 xxx.class 字节码文件的？ 如果我们不配置环境变量 classpath ，类加载器会自动从当前路径下加载 class 字节码文件；如果配置了，就会去指定路径下加载。 我们在环境变量中，可以这样配置，新加一个变量：classpath，值可以写成.，表明在当前目录下加载，如后续有需求，可以在.;otherpath]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-配置环境变量]]></title>
    <url>%2F2020%2F02%2F06%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F5.%20%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[前言Java 如何配置环境变量 原理windows操作系统在查找某个命令的时候是怎么查找的？ 首先会从当前目录下找这个命令 当前目录下不存在这个命令的话，会去环境变量path指定的路径当中查找该命令 还是找不到则出现错误提示信息 配置方法 右键点击“我的电脑”———“属性”——左上角点击“高级系统设置” ![img](5. 配置环境变量.assets/wps1.jpg) 配置 JAVA_HOME, 参考下图 新建 系统变量 不是用户变量 变量名 JAVA_HOME 变量值 C:\Program Files\Java\jdk1.8.0_101 ![img](5. 配置环境变量.assets/wps2.jpg) 配置classpath，参考下图 变量值的 .; 都要复制 变量名 classpath 变量值 .;%JAVA_HOME%\lib; ![img](5. 配置环境变量.assets/wps3.jpg) 编辑path变量 参考下图一和图二 系统变量中找到 path变量 双击 弹出编辑窗口，添加两条变量，分别为 %JAVA_HOME%\bin %JAVA_HOME%\jre\bin ![img](5. 配置环境变量.assets/wps4.jpg) ![img](5. 配置环境变量.assets/wps5.jpg) 完成检测 打开 CMD，分别输入 Java 回车 测试 Javac 回车 测试 如失败则显示‘不是内部命令也不是外部命令’。如成功，结果如下 ![img](5. 配置环境变量.assets/wps7.jpg)]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-加载与执行]]></title>
    <url>%2F2020%2F02%2F04%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F3.%20%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[一个完整的java程序 Java开发的整个生命周期，包括两个重要的阶段，分别是：编译阶段和运行阶段 编译生成的程序被称为：字节码程序。编译生成的文件是：xxx.class文件 编译和运行可以在不同的操作系统中完成。 程序员在xxx.java文件中编写源代码，源代码必须符合java的语法，这些源代码就是高级语言。存放源代码的文件被称为源文件。 过程编译期在windows环境中完成 安装 JDK，配置环境 在硬盘的某个位置创建一个 xxx.java 源文件 打开源文件，在该文件当中编写符合 java 语法的源程序，然后保存。 使用JDK中自带的 javac.exe 命令对以上的 java 源程序进行编译。 编译通过：说明语法没有问题：在硬盘上生成一个或者多个** 字节码文件【xxx.class】** 编译失败：说明源程序某个位置不符合java语法格式。 编译的语法格式：打开DOS命令窗口，输入：javac 源文件路径 运行期可以不在windows中完成，可以换一个操作系统，但前提是该操作系统中已经安装 java 的运行时环境 打开命令窗口，在命令窗口中使用java.exe命令运行java程序，语法格式：java 类名 以上程序的执行原理： java.exe命令执行会启动：JVM JVM启动之后，马上启动“类加载器-Class Loader” ClassLoader负责去硬盘的“某个位置”上搜索“类名.class”字节码文件 找不到这个.class文件，一定会出现程序异常现象 找到了这个.class文件之后将.class文件转换成”二进制”，操作系统可以直接识别二制，操作系统执行二进制码和底层的硬件平台进行交互]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-语言特性]]></title>
    <url>%2F2020%2F02%2F04%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F4.%20%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1、简单性 这里的简单说的是相对于C语言来说的。 例如：C语言当中有指针，C++中多继承 java取消了指针的概念，取消了多继承，只支持单继承。 2、跨平台/可移植 有一种特殊的机制：JVM Java程序并没有和底层的操作系统直接交互，java程序实际上运行在jvm当中，JVM屏蔽了操作系统之间的差异。但是有一个前提：不同的操作系统中必须安装不同版本的JVM。 在可移植性方面表现非常好，一次编译，到处运行。 但是为了达到可移植，必须提前在操作系统中安装JRE，JRE有了之后才会有JVM【JVM不能单独安装】。这方面体验不是特别好。 3、Java号称：开源、免费、跨平台、纯面向对象 开源：开发源代码，SUN公司编写的java类库的源代码普通程序员能看到。众人拾柴火焰高。这样java程序会很健壮。很少的BUG【漏洞/陷阱】 免费 跨平台：依靠JVM机制【java程序不和操作系统交互，java程序运行在JVM中，JVM和操作系统交互。】不同的操作系统有不同版本的JVM。 面向对象：人类在认识现实世界的时候多数是以面向对象的方式认知的。 4、支持多线程 5、自动垃圾回收机制：GC机制 ….]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-发展史]]></title>
    <url>%2F2020%2F02%2F04%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F1.%20%E5%8F%91%E5%B1%95%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[Java分三大块：1999年 J2SE【Java的标准版本】基础，无论是以后走EE还是ME，SE是必须要精通的。J2SE是SUN公司为java程序员准备的一套“基础类库”，这套基础类库学习之后，可以完成最基本的操作，例如，文件的读写、线程的控制…. J2EE【Java的企业版本】这是SUN公司为程序员专门准备的一套“类库”，这套类库可以协助程序员完成企业级软件的开发企业级软件：OA办公系统、进销存系统、超市系统……. J2ME【Java的微型版本】这是SUN公司为java程序员专门准备的另一套“类库”，这套类库可以协助程序员完成微型设备的嵌入式开发，Java最初就是做微型设备嵌入式开发的。 2005年，java诞生十周年的时候，以上的三大模块改名了：JavaSE、JavaEE、JavaME]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java零基础-JDK、JVE、JVM 关系]]></title>
    <url>%2F2020%2F02%2F04%2FJava%2F%E9%9B%B6%E5%9F%BA%E7%A1%80%2F2.%20JDK%E3%80%81JVE%E3%80%81JVM%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[什么是JDK？Java Development Kits Java开发工具箱【Java开发必备】 可以从Oracle的官网上下载。http://www.oracle.com 下载JDK的时候需要注意：JDK的版本，不同的操作系统需要安装不同版本的JDK 关系 JDK【Java开发工具箱】 JRE【Java的运行时环境】 JVM【Java虚拟机】 三者之间的关系： JDK 中包含 JRE，JRE 中包含 JVM]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Window 快捷键]]></title>
    <url>%2F2020%2F02%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FWindow%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[win + r 打开运行窗口z win + d 显示桌面 win + e 打开资源管理器 win + L 锁屏 alt + tab 应用之间的切换]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOS命令]]></title>
    <url>%2F2020%2F02%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FDOS%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[windows操作系统当中常用的DOS命令 打开DOS命令窗口 快捷键：win + r，打开运行窗口 输入cmd回车 查看IP地址： ipconfig ipconfig /all 可以查看更详细的IP信息，这种查看方式可以看到网卡的物理地址。物理地址具有全球唯一性。是在生产网卡的时候，嵌入的编号。 清屏： cls 退出DOS命令窗口： exit 从DOS命令窗口当中复制文本： 任意位置点击鼠标右键–&gt;标记 –&gt; 选择你要复制的文本 –&gt; 点击鼠标右键 （此时已经到剪贴板当中了） –&gt; 找一个位置粘贴即可。 查看两台计算机之间是否可以正常通信： ping 192.168.27.23 【发送和接收数据包4次】 ping 192.168.27.23 -t 【一直不停的发送和接收数据包】 ping www.baidu.com 强行终止DOS命令窗口中正在运行的程序：ctrl + c 创建目录：mkdir abc【表示在当前所在目录下新建一个目录，起名abc】 关于目录切换命令：cd cd 命令的语法格式： cd 路径 自动补全：cd e 【然后按tab键，当前所在的目录下所有以e开始的目录自动补全路径，当这个自动补全的路径不是自己想要的路径，可以继续使用tab键】 回到上级目录：cd .. 【..是一个路径，代表当前路径的上级路径】cd ../../../ 直接回到根路径：cd \ 查看当前目录下所有的子文件和子目录： dir 怎么切换盘符：【不需要使用cd命令】 c: 回车 d: 回车 e: 回车 f: 回车 打开注册表： regedit]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米有品实习感悟]]></title>
    <url>%2F2020%2F01%2F06%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F%E5%B0%8F%E7%B1%B3%E6%9C%89%E5%93%81%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[前言从10月底到1月初，两个多月的北漂，暂时画上句号。第一次在北方生活这么久，北方不一样的气候与不一样的互联网环境，确实给自己带来蛮大的冲击和新鲜的体验。 虽然度过了两个多月的冬天，但是这个冬天格外地具有生命力，格外地顽强。 生活一个人流浪过很多地方后，就会练就出很强的适应能力。 尽管来京前，一直忐忑不安，害怕无法喜欢上这座城市，但是真正到了后，很快就适应了气候问题，并乐于去发现京的美。老实说，外面天气确实挺冻，可穿着轻便的羽绒服，公交上、地铁里、甚至厕所都是暖烘烘的，怎能不觉得这冬天是多么的美好啊： 太阳直直地照耀着每一寸土地，比南方的要耀眼的多；植物落了叶子也要挺着脖子往上仰；傲娇的雪，说来就来说走就走；故宫、颐和园、圆明园、北海公园、雍和宫等宫殿颜色艳丽，仍然在21世纪的今天充满活力；牛街、食宝街、合生汇等美味慰藉着孤单在外人儿的胃；南锣鼓巷、烟袋斜街、北新四桥、五道营等胡同，每次经过都会悄悄地留意与南方不同的建筑生活是怎么样的，又很感叹他们的生活气息是多么的浓厚… 来北京的北方人特别多，在南方的自己是很少能碰上北方人的。果然一寸水土养一寸人，北方人有着北方人的不同，大气、阔达、不扭捏，相处起来特容易，也很能侃。 不过一个人的北漂，要孤单多了。 工作北京的互联网氛围果真很好，可能也与北方人能侃有关？在南方，平时下班后，大家都尽量不谈与工作相关的任何话题；在京，下班后基本都在聊：技术、上班的生活…一开始都被惊呆了。 实习期间没有接触到什么核心的业务，组长戏称：我们来太早了。所以整体工作是在熟悉业务、开发流程，为之后正职做准备，以及项目平台的楼层大改造。 这段实习时间打开了新世界。 动手能力：每个星期都会有分享会、周会，会上分享人会亲自打代码演示，大家的动手能力很强， 也感染了自己，此后每次学习一个什么都会手撸一个 demo，看看是不是如实，可以记得更牢靠。 源码分析能力：最有意思的是，大家分享 源码/原理分析的时候是真的逐行分析。虽然当场没有听懂全部，但是跟着分享人的思路，可以了解到它们的实现大概以及学习到别人是如何分析源码的。 随后，尝试去分析 Vuex + Vue-router，以及几个小库，这么做后，除了对它们的了解更深，自己的专注力、认真度、细致度提高了不少，这是以前没有过的感觉。之前总觉得读源码，分析原理是一件很难、很繁琐的事情，所以觉得源码分析这种学习方法应该不适合我。但是真的沉下心去做了后，才知道，原来自己还有这样的学习能力啊，也摸索出符合自己的学习方法：带着问题去读，沉下心，不急不躁，看懂一行是一行，以回答自己的问题为目标；看不懂的代码放一边，有个大概的思路，可以先记录下来，以后知识储备到了一定程度再回来看，肯定能看懂！ 学习广度扩大：因为工作任务不重，所以每天留给自己学习的时间充裕。组长给我们分享了很多关于后端等的知识，利用空闲时间去学习了如 Redis、Docker、Elastic Search、RPC、NodeJs、TypeScript、设计模式等……这段时间也写了很多篇博客，每天都会学习到之前使用过却没有去了解的东西，非常新鲜，每天都非常充实。 这里的同事们都好认真，好努力啊~是真的有被带动起来！ 最后接下来就是大四的最后一个学期了，听说今年毕业设计会抓的有点严，又或许学校每年都这样讲，想要很认真地完成自己的毕业设计。选定了 青旅 这个主题，运用最近学到的一些新知识围绕它做一个系统，毕竟住了好久，很有感悟，毕业设计选一个能代表自己青春回忆的也不错，对吧。]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>小米有品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome Devtool Memory 使用指南]]></title>
    <url>%2F2020%2F01%2F03%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FChrome%20Devtool%2FMemory%2F</url>
    <content type="text"><![CDATA[前言Memory作用：方便开发人员定位内存泄漏问题，从 内存 着手，提高页面性能 Chrome 任务管理器Chrome 设置 -&gt; 更多工具 -&gt; 任务管理器 -&gt; 右键任务管理器的表格标题处，启用 JavaScript 使用的内存 内存占用空间：原生内存。DOM 节点存储在原生内存中，如果此值正在增大，说明正在创建 DOM 节点 JavaScript 使用的内存：JS堆。包含两个值，关注实时数字（括号中的数字），实时数字表示页面上的可到达对象正在使用的内存量。如果此数字在增大，要么是正在创建新对象，要么是现有对象正在增长 Memory 面板 Heap snapshot：打印堆快照，堆快照文件显示页面的 JavaScript 对象和相关 DOM 节点之间的内存分配 Allocation instrumentation on timeline：在时间轴上记录内存信息，随着时间变化记录内存信息 Allocation sampling：内存信息采样，使用采样的方法记录内存分配。此配置文件类型具有最小的性能开销，可用于长时间运行的操作。它提供了由 JavaScript 执行堆栈细分的良好近似值分配，哪些函数影响了内存的分配，并且该函数所耗内存在内存分配中占比多少 Heap snapshot 区域一： 从左到右有三个操作：查看方式、对象归类的筛选、快照选择 查看（内存快照）方式有： Summary：可以显示按构造函数名称分组的对象。使用此视图可以根据按构造函数名称分组的类型，深入了解对象及其内存使用，适用于跟踪 DOM 泄漏 Comparison：可以显示两个快照之间的不同。使用此视图可以比较两个（或多个）内存快照在某个操作前后的差异。检查已释放内存的变化和参考计数，可以确认是否存在内存泄漏以其原因 Containment：此视图提供了一种对象结构视图来分析内存使用，由顶级对象作为入口 Statistic：内存使用饼状的统计图 区域二： Shallow Size：浅层大小，对象自身占用的内存大小 Retained Size：保留大小，将对象本身联通其无法从 GC 根到达的相关对象一起删除后释放的内存大小 Distance：使用节点到根节点最短路径距离 Comparison 视图比如： 12345678910111213141516171819202122&lt;template&gt;&lt;div class=&quot;hello&quot;&gt; &#123;&#123;testArray&#125;&#125; &lt;div @click=&quot;click&quot;&gt;增加&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; testArray: [&#123; value: &quot;hello&quot; &#125;] &#125;; &#125;, methods: &#123; click() &#123; this.testArray.push(&#123; value: &quot;:::::::::&quot; &#125;); &#125; &#125; &#125;;&lt;/script&gt; 点击 增加 按钮前，打印一下堆快照；点击 增加 按钮后，打印一次堆快照，选择 Comparison 视图，会与快照 1 进行比较 分析：Retainers 就是这个值的保留树，表明这个值存储在内存位置为（345883）的 VNode 的 text 键上，这个 VNode 又位于 Array （345887）的 0号位上，Array 是一个 children 位于 VNode 上 闭包（closure） 闭包可以通过一对正反操作进行比较，比如点击造成了一个闭包，再点击一次释放一个闭包，查看闭包所占内存。闭包情况很常见，一般情况下只要闭包没有滥用就不会有什么问题 Containment 视图 Distance：从 window 出发的最短保留路径上的属性引用数量 文档 DOM 树：由可以通过遍历文档到达的所有原生 DOM 节点组成 内存图从根开始，根可能是浏览器的 window 对象或者 Node 的 Global 对象，我们无法控制此根对象的垃圾回收方式。任何无法从根到达的对象都会被 GC 回收 Size 指 Js 堆，原生对象不会在 Js 堆中表示，所以大小为 0 Allocation instrumentation on timeline比如： 12345678click() &#123; // 每次点击 字符串长度都以上一次为基础增加到5倍，拉大差异突出效果，并且之后在字符串头部加上count值做区分 this.count *= 5; var str = new Array(this.count * 10).join(":"); this.testArray.push(&#123; value: this.count + str &#125;);&#125; 每条线的高度与最近分配的对象大小对应 竖线的颜色：这些对象是否仍然显示在最终的堆快照中 蓝色竖线：在时间线最后对象仍然显示 灰色竖线：对象已在时间线期间分配，但曾对其进行垃圾回收 Allocation sampling 可以通过 Chart、Tree、Heavy 不同的形式，查看函数调用栈、函数占用的内存、引用内存等，点击可以跳转到具体的 source 代码处]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>Chrome Devtool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 切面流程]]></title>
    <url>%2F2020%2F01%2F02%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHTTP%20%E5%88%87%E9%9D%A2%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言介绍 Http、Koa.js 的切面流程 HTTP 生命过程 http 请求 路由操作 权限处理 数据安全 业务操作 数据操作 书查查询 http 响应 响应操作 Koa.js 的 HTTP 旅程 请求 中间件 响应]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向切面编程 AOP]]></title>
    <url>%2F2020%2F01%2F02%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2F%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%20AOP%2F</url>
    <content type="text"><![CDATA[前言AOP 像 OOP 一样，只是一种编程范式，AOP 并没有规定说，实现 AOP 协议的代码，要用什么方式去实现。 是什么 AOP 即面向切面编程，是 OOP 编程的有效补充； AOP 是 Spring 提供的关键特性之一； AOP可以将那些与业务无关，却为业务模块所共同调用的逻辑或责任。比如事务处理、日志管理、权限控制等。封装起来，便于降低系统的反复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。 相关概念Aspect 切面：切入系统的一个切面。比如日志管理是一个切面，权限管理也是一个切面； Join point 连接点：也就是可以进行横向切入的位置； Advice 通知：切面在某个连接点执行的操作(分为: 前置通知 Before advice , 后置返回通知 After returning advice , 后置异常通知 After throwing advice , 后置终于通知 After (finally) advice , 围绕通知 Around advice )； Pointcue 切点：真正被切入的地方 分类静态 AOP：指AspectJ实现的AOP，将切面代码直接编译到Java类文件中。 动态AOP：将切面代码进行动态织入实现的AOP。 Spring的AOP为动态AOP。]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于Promise的知识]]></title>
    <url>%2F2020%2F01%2F02%2FEs6%2F%E5%85%B3%E4%BA%8EPromise%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言看到一篇文章，关于 Promise 的 9 个面试题，发现了知识盲点，记录一下 1. 多个.catch1234567var p = new Promise((resolve, reject) =&gt; &#123; reject(Error('The Fails!'))&#125;)p.catch(error =&gt; console.log(error.message))p.catch(error =&gt; console.log(error.message))// The Fails!// The Fails! 解析： 使用构造函数方法创建一个 Promise ，并通过 reject回调立即触发错误。.catch工作方式类似于 DOM 的 .addEventListener(event, callback) 或 Event Emitter 的.on(event, callback)，其中可以添加多个回调。每个都用同样的参数进行调用。 2. 多个.catch123456var p = new Promise((resolve, reject) =&gt; &#123; return Promise.reject(Error('The Fails!'))&#125;)p.catch(error =&gt; console.log(error.message))p.catch(error =&gt; console.log(error.message))// VM697:2 Uncaught (in promise) Error: The Fails! 解析： 使用 Promise 构造函数时，必须调用resolve()或reject()回调。 Promise 构造函数不使用自己定义的返回值，所以不会再收到由 Promise.reject() 创建的其他 Promise。 3. 链接.then和.catch1234567var p = new Promise((resolve, reject) =&gt; &#123; reject(Error('The Fails!'))&#125;).catch(error =&gt; console.log(error)).then(error =&gt; console.log(error))// Error: The Fails!// undefined 解析： 每个.then都接收一个.then返回的值作为其参数。但是如果步骤遇到错误，则任何后续的.then的步骤都将被跳过，直到遇到.catch。如果要覆盖错误，可以返回一个非错误值，可以通过任何随后的.then访问。 4. 链接.catch123456var p = new Promise((resolve, reject) =&gt; &#123; reject(Error('The Fails!'))&#125;).catch(error =&gt; console.log(error)).catch(error =&gt; console.log(error))// Error: The Fails! 解析： 当链接.catch时，每个仅处理先前的.then或.catch中引发的错误。在此例中，第一个.catch返回 console.log，只能通过在两个.catch之后添加.then()来访问。 123456789101112var p = new Promise((resolve, reject) =&gt; &#123; reject(Error('The Fails!'))&#125;).catch(error =&gt; &#123; console.log(error); return 1;&#125;).then(error =&gt; &#123; console.log(error); // 接收上面的返回值 throw Error;&#125;).catch(error =&gt; console.log(error)) // 接收上面的 Error 5. 多个.catch1234567891011new Promise((resolve, reject) =&gt; &#123; resolve('Success!')&#125;) .then(() =&gt; &#123; throw Error('Oh noes!')&#125;) .catch(error =&gt; &#123; return "actually, that worked"&#125;) .catch(error =&gt; console.log(error.message))// 不打印任何内容 提示： .catch可以简单地返回一个常规值来忽略（或覆盖）错误。该技巧仅在随后的 .then 接收该值时有效。 6. .then之间的流程12345678Promise.resolve('Success!') .then(data =&gt; &#123; return data.toUpperCase()&#125;) .then(data =&gt; &#123; console.log(data)&#125;)// SUCCESS! 提示： .then依次传递数据，从 return value到下一个.then(value =&gt; /* handle value */)，为了将值传递给下一个.then，return是关键 所以，以下例子就非常容易理解了 123456789101112131415161718Promise.resolve('Success!') .then(data =&gt; &#123; return data.toUpperCase()&#125;) .then(data =&gt; &#123; console.log(data) return data&#125;) .then(console.log(data))// SUCCESS!// SUCCESS!Promise.resolve('Success!') .then(data =&gt; &#123; data.toUpperCase()&#125;) .then(console.log(data))// undefined 7. .then和.catch之间的流程123456789101112Promise.resolve('Success!') .then(() =&gt; &#123; throw Error('Oh noes!') // 因为是resolve，执行 then ,抛出错误&#125;) .catch(error =&gt; &#123; return 'actually, that worked' // 接收 第一个then 抛出的错误，return 覆盖抛出的错误&#125;) .then(data =&gt; &#123; throw Error('The fails!') // 接收上面 第一个catch的 return ，又抛出错误&#125;) .catch(error =&gt; console.log(error.message)) // 接收上面 第二个then 抛出的错误// The fails! 总结 使用 Promise 构造函数时，必须调用resolve()或reject()回调，后面可以添加多个回调。 .then可以接收 resolve 的回调；以及前一个.then或.catch的返回值，如果没有返回值，则是 undefined 。 多个连续的链接.catch只会执行一个，接收 reject 回调，除非后面有所处理 .catch可以简单地返回一个常规值来忽略（或覆盖）错误。该技巧仅在随后的 .then 接收该值时有效。 .then依次传递数据，有return，就能接收。]]></content>
      <categories>
        <category>Es6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019 年度总结]]></title>
    <url>%2F2020%2F01%2F02%2F%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F2019%20%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言本来没有写的想法，因为不是很想回忆过去一年中发生的一些痛苦的事情。但也有很多美好的记忆，2019 可是勇敢的一年。 2019 时间轴一月份： 自己去了一趟北方-西安游玩5天。因为是第一次自己旅行，第一次去北方，第一次住青旅…所以去之前心理很忐忑，害怕会遇到什么奇怪的事情、担心会玩的很孤独。结果完全相反，爱上了一个人旅行的自由感，西安真是个旅游的好去处，博物馆、兵马俑、钟楼…很喜欢它的历史感，喜欢它的包容性，之后去的博物馆都没有让我这么震撼，虽然吃的不是很合胃口 &gt;-&lt;。 二月份： 春节，还在实习中，所以放假比较短，回家后再去上班真的万分不舍，原以为自己不是一个恋家的人。悲伤了一阵，后面没忍住，在某个周末回家了一趟，心里就舒服多了。 三月份、四月份： 水逆时段，非常非洲人。那会边实习，边参加春招，压力很大，实习的leader是个非常友善的人，一直在帮助我，但是自己好像不太给力。比如参加腾讯的春招，大概快10次，已经面到自闭，后面觉得自己应该是不行的，可又有面试官说自己之前的面试评价还不错？或许这就是没有缘分把。 害，那段时间非常黑暗。恰逢感情出了问题，对方有点pua，陷入了不断怀疑自己，不断否定自己的循环。试过在工作的时候，突然情绪上头，躲在厕所里面痛哭；试过在回家的路上，看着泛黄的路灯，心理非常忧伤，眼泪就掉下来了；试过在租的小房子里蜷缩着身体，失眠，心痛，感觉自己快要融进床里，感觉自己就像一根羽毛，在这人世间飘啊飘；试过脑海里有无数想要自杀的念头，但是想着父母会成为失独，还是一遍又一遍地说服自己继续活下去… 那会心理非常不健康，可是一般来说，正常的自己怎么可能会被不顺的春招打败？只是去不了大厂，也不必到了想要结束生命的地步吧？这也太脆弱了，不像以往的自己呀。心里明白这点，还是无法控制自己乱想的头脑，和恐慌难受的心。 其实自己知道崩溃的原因，是感情，太喜欢一个人了，太卑微了，想要为他做任何可以或者不可以的事情，可是不良感情就会造成不良情绪，不良心理，到轻度抑郁。这种还是挺常见的。 五月份： 拿到了蘑菇街的 offer，停下了春招。可是在杭州，纠结了一会（其实就是为了感情）。后面对方越来越过分，越来越过分，这时觉得自己再继续下去可能就要废了。于是选择了求助，求助了心理学专业的辅导员，求助了父母，把自己悲伤的事情与他们述说，这应该是我做过最正确的事情。辅导员很是耐心地听我说，也很是真诚地劝说我；父母也非常开明的接受我所说的事情，然后每天陪伴我，鼓励我。虽然情伤不是一时半会就能走出来，但是我确实有了想要走出去的念头，并真的踏出去了第一步。 月底，踏上了杭漂的旅程。 六月份、七月份、八月份： 结束了不健康的情感后，重新变成了新的、勇敢的自己。 杭州的实习日子非常开心，同事很友好，自己也非常快的适应了杭州的生活。每周会出去游玩，后面把杭州差不多玩遍了，又开始去上海，苏州等地探索新鲜事物。 旅行的意义是什么呢？现在的答案是，把思绪寄托在路上，寄托在云中，寄托在美好的食物中，会更清楚自己是谁，自己想要什么。 开心 果真是件非常容易的事。 八月中旬通过了蘑菇街的转正面试，结束暑期实习，开始暑假生活。 九月份、十月份： 在家里呆了2个多月，边享受生活，边参加秋招。 每天早起去买早餐，带回去和家人一起吃；每天自己做减肥餐，健康饮食；每天运动一个多小时，还把妈妈带动起来；偶尔和朋友一起去爬山，傍晚去散步…真是悠哉悠哉的生活啊~ 十月份接受小米的 offer，出发北漂。 十一月份、十二月份： 北漂的生活确实不易，租房压力会比其他城市大很多。因为是短期实习，所以选择了青旅，条件就比杭州时的要差太多了，6个人一屋，房间也很小，同一屋里会有很多人，厕所是男女共用的，这是最具有挑战性的北漂一环！ 不过，除此之外，都挺好的！ 北京的互联网环境果真出色，比如：下班后/吃饭，大家都会聊起工作上的事情，讨论技术、分享职场生活…在南方，大家下了班大多都闭口不谈工作的事情，基本闲聊，所以一开始感觉很震惊。 周末出去打卡北京景点，故宫、恭王府、颐和园、圆明园、北大清华…最喜欢颐和园了！文化确实浓厚，来之前还担心自己会不会不喜欢这座城市。 看到了初雪，感受了大雪纷飞，白雪皑皑的城市有着自己的魅力，是南方不具备的气候。 虽然北方的冬天很长也很冷，但是北方的天真的很蓝，阳光很广，每次出太阳的日子心情都非常愉快；虽然大树们都光秃秃，但是它们却依然骄傲地往上延展，非常佩服且欣赏它们的生命力！ 结交了好朋友，北漂的人儿大多都来自北方，在南方是比较少接触到北方人的，他们的爽朗我真的非常喜爱。 奔波的一年就这么过去了，做了很多以前没有想过的（杭漂、北漂…），以前很想做的（旅行、自律生活…），做过最棒的事应该就是离开不健康的感情，勇敢拥抱未来的生活。 2020 计划不开心的事情，不做。 想做的事情，认真且努力地去做。 开心最重要！]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[forEach为何不能结束循环&&不支持async/await]]></title>
    <url>%2F2019%2F12%2F31%2FJavaScript%2FforEach%E4%B8%BA%E4%BD%95%E4%B8%8D%E8%83%BD%E7%BB%93%E6%9D%9F%E5%BE%AA%E7%8E%AF%26%26%E4%B8%8D%E6%94%AF%E6%8C%81asyncawait%2F</url>
    <content type="text"><![CDATA[前言很好奇为啥 forEach 不能结束循环 &amp;&amp; 不支持 async/await，今天去找了找原因 问题1234567891011121314151617function test() &#123; let arr = [3, 2, 1]; arr.forEach(async item =&gt; &#123; const res = await fetch(item); console.log(res); &#125;); console.log("end");&#125;function fetch(x) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(x); &#125;, 500 * x); &#125;);&#125;test(); 期望值： 3 2 1，实际上： 1 2 3 原理为什么呢？以下是 forEach 的源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Production steps of ECMA-262, Edition 5, 15.4.4.18// Reference: http://es5.github.io/#x15.4.4.18if (!Array.prototype.forEach) &#123; Array.prototype.forEach = function(callback /*, thisArg*/) &#123; var T, k; if (this == null) &#123; throw new TypeError("this is null or not defined"); &#125; // 1. Let O be the result of calling toObject() passing the // |this| value as the argument. var O = Object(this); // 2. Let lenValue be the result of calling the Get() internal // method of O with the argument "length". // 3. Let len be toUint32(lenValue). var len = O.length &gt;&gt;&gt; 0; // 4. If isCallable(callback) is false, throw a TypeError exception. // See: http://es5.github.com/#x9.11 if (typeof callback !== "function") &#123; throw new TypeError(callback + " is not a function"); &#125; // 5. If thisArg was supplied, let T be thisArg; else let // T be undefined. if (arguments.length &gt; 1) &#123; T = arguments[1]; &#125; // 6. Let k be 0. k = 0; // 7. Repeat while k &lt; len. while (k &lt; len) &#123; var kValue; // a. Let Pk be ToString(k). // This is implicit for LHS operands of the in operator. // b. Let kPresent be the result of calling the HasProperty // internal method of O with argument Pk. // This step can be combined with c. // c. If kPresent is true, then if (k in O) &#123; // i. Let kValue be the result of calling the Get internal // method of O with argument Pk. kValue = O[k]; // ii. Call the Call internal method of callback with T as // the this value and argument list containing kValue, k, and O. callback.call(T, kValue, k, O); &#125; // d. Increase k by 1. k++; &#125; // 8. return undefined. &#125;;&#125; 主要看这里 12345678910111213/* O 为传入数组len 为传入数组长度callback 为传入回调函数*/while (k &lt; len) &#123; var kValue; if (k in O) &#123; kValue = O[k]; callback.call(T, kValue, k, O); &#125; k++;&#125; 可以看到 callback 是我们传入的一个被 async 封装的 promise 对象，而 Array.prototype.forEach 内部并没有对这个 promise 对象做任何处理；而且在 callback 使用 break 也不能结束循环。 尝试改造一下，让它支持 async, awiat： 12345Array.prototype.forEach = async function(callback /*, thisArg*/) &#123; // ……… await callback.call(T, kValue, k, O); // ………&#125;; 所以面对 async await 的需求或者跳出循环，使用 for…of 或者 for 循环 for…of为啥 for…of 可以呢？机制不同，forEach 是直接调用回调函数，for…of 是通过迭代器的方式去遍历 123456789101112async function test() &#123; let arr = [3, 2, 1]; const iterator = arr[Symbol.iterator](); let res = iterator.next(); while (!res.done) &#123; const value = res.value; const res1 = await fetch(value); console.log(res1); res = iterator.next(); &#125; console.log("end");&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[总结-23种设计模式]]></title>
    <url>%2F2019%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E6%80%BB%E7%BB%93-23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言设计模式——可以重复利用的解决方案 终于把23种设计模式看了一遍，现在总结一次，并加上自己的白话文理解与现实中使用过的场景，以便记忆。 六大原则 开闭原则 里氏替换原则 依赖倒置原则 单一职责原则 迪米特法则（最少知道原则） 接口分离原则 开闭原则是最基本的原则，里氏替换原则、依赖倒置原则是开闭原则的实现，结合6个原则看，我们在编程中最好都是抽象，低耦合，细微粒度。 模式分类1. 创建型 主要用于描述如何创建对象。将模块中对象的创建和对象的使用分离。外界只需要知道接口，不需要知道具体的实现细节，符合单一职责原则 简单工厂模式 定义一个工厂类负责管理创建其他类的实例，根据创建方法的参数返回不同类的实例。被创建的实例通常具有共同的父类。 比如在工厂方法中写swicth，匹配拿到某个产品实例。 工厂方法模式 不同的工厂子类创建不同的产品对象。比如再定义几个产品工厂，不同的产品工厂生产对应的产品。 抽象工厂模式 提供一个创建一系列相关或相互依赖对象的接口。 比如在工厂方法的基础上，又定义几个依赖产品的工厂，不同的依赖产品工厂生产不同的依赖产品。如果一个工厂需要生产不同的产品，应该选用抽象工厂模式而不是工厂模式，工厂模式适合生产一种产品的情况。 单例模式 一个类只有一个实例，并且提供一个全局访问点。比如我们的登录框，点击后只能弹出一个。 生成器模式 又叫创建者模式/建筑模式，构建复杂的对象模式，把对象的构建与表现分离，使得同样的构建过程可以创建不同的表示。 比如在一个类中定义多个对象的组成部分，定义一个导向类根据不同需求组装对象。 原型模式 根据原对象复印一个新对象，并根据需求对新对象进行微调。在JS原型链的领域上，经常会引申出：实现继承的五种方法 2. 结构型 主要用于描述如何实现类或对象的组合。 类结构型模式关心类的组合：由多个类组合成一个更大的系统，一般只存在继承关系和实现关系 对象结构型关心类与对象的组合：通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。 外观模式 又叫门面模式，定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。 比如做兼容的时候，把各种浏览器、移动端判断处理封装在一个文件，然后暴露出主接口，之后直接调用主接口就ok。 适配器模式 又叫包装器模式，将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 原来我们平时修改参数（后端返回的参数不是我们想要的样子，把它们整成自己想要的样子）就是适配器模式。。但适配器模式本质上是一个亡羊补牢的模式，它解决的是现存的两个接口之间不兼容的问题，不应该在软件的初期开发阶段使用该模式；尽量在设计之初就规划好接口的一致性。 桥接模式 将抽象部分与它的实现部分分离，使他们都可以独立地变化。 桥接模式可以让我们提取多个底层功能模块，再拼装，在动画上用的就很多，比如设置走路模块，跑步模块，跳跃模块...人物需要时再拼装。 代理模式 为某个对象提供一个代理，并由这个代理对象控制对原有对象的访问。相当于房产中介，es6里面的proxy也可以实现。 装饰者模式 不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。可以试着在vue装babel，搭es7环境，使用@decorator写装饰器，非常方便~ 享元模式 运用共享技术复用大量细粒度的对象。 之前那些复用的功能函数，似乎就是这个模式，在网上发现利用这个模式，能够实现一个叫通用对象池的东西，这个类管理一个装载空闲对象的数组，如果外部需要一个对象，直接从对象池中获取，而不是通过new操作。 3. 行为型 主要用于描述类或对象怎样交互及怎样分配职责 职责链模式 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 express 就使用了责任链模式，避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，无论是作用域链、原型链、express、还是DOM节点中的事件冒泡，都能从中找到职责链的影子。但是有可能请求没有被正确处理或者进入死循环 命令模式 将一个请求封装成一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 业务出现了 (回退操作)(重做操作)的需求的时候，就可以考虑使用这个模式。和之前代理模式中的举例有些相似，不过命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。例如遥控器是一个调用者，不同按钮代表不同的命令，而电视是接收者。 解释器模式 定义一个语言（使用规定格式和语法的代码）的文法，并且建立一个解释器来解释该语言钟的句子。我们的编译器，在对代码进行编译的时候也用到了该模式。就是对一条指令进行翻译，比如 up 5,需要写up做的事情，5代表啥。 迭代器模式 又叫游标（Cursor），提供一个方法来访问聚合对象，而不用暴露这个对象的内部表示。 迭代器模式，在我们的各种循环很常见，比如 each等，只要被迭代的聚合对象拥有length属性而且可以用下标访问，那么它就是迭代器。Javascript中的类数组对象也是迭代器。 中介者模式 又叫调停者模式，用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。它与外观模式，代理模式有点像。可以在下面的链接看看他们的区别。 备忘录模式 又叫 Token，在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 也可以看成缓存器，可以利用它进行撤销操作，还可以利用该模式做分页：点击下一页获取新的数据，点击上一页时又重新获取数据，会造成流量浪费，这时可以对数据进行缓存 观察者模式 又叫 发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者模式（Dependents）。定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 vue发布订阅模式 状态模式 又叫 状态对象，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。常使用switch判断应用某个状态。 策略模式 又叫 政策模式，定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化。 根据需要选择相应的算法或行为 模板方法模式 先定义父类，子类继承通用的方法，特殊的方法在子类重写。 访问者模式 访问者模式是一种较为复杂的行为型设计模式，包含 访问者 和 被访问元素 两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 违背 “开闭模式” ：简单工厂模式、外观模式、状态模式、访问者模式 不推荐：适配器模式 附录 [外观模式、代理模式、中介者模式区](http://super-wei.top/2019/12/25/设计模式/行为型/5.1 外观模式、代理模式、中介者模式区别/) 使用策略模式&amp;代理模式进行表单验证]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter-入门]]></title>
    <url>%2F2019%2F12%2F25%2FFlutter%2F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。Flutter可以与现有的代码一起工作。 简单来说，Flutter是一款移动应用程序SDK，包含框架、控件和一些工具，可以用一套代码同时构建Android和iOS应用，并且性能可以达到原生应用一样的性能。 Flutter 用Dart作为开发框架和widget的语言。 Mac 安装]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTML5的pushState、replaceState与popState]]></title>
    <url>%2F2019%2F12%2F25%2FHtml%2FpushState%E3%80%81replaceState%E4%B8%8EpopState%2F</url>
    <content type="text"><![CDATA[简介HTML5引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate 配合使用。 pushState()方法的例子 假设在 http://mozilla.org/foo.html 中执行了以下 JavaScript 代码，浏览器地址显示为 http://mozilla.org/bar.html，但并不会导致浏览器加载 bar.html ，甚至不会检查bar.html 是否存在 1234let stateObj = &#123; foo: "bar",&#125;;history.pushState(stateObj, "page 2", "bar.html"); 假设现在用户访问 http://google.com，然后点击了返回按钮。此时，地址栏将显示 http://mozilla.org/bar.html，`history.state` 中包含了 stateObj 的一份拷贝。页面此时展现为bar.html。且因为页面被重新加载了，所以popstate事件将不会被触发。 如果我们再次点击返回按钮，页面URL会变为http://mozilla.org/foo.html，文档对象document会触发另外一个 popstate 事件，这一次的事件对象state object为null。 这里也一样，返回并不改变文档的内容，尽管文档在接收 popstate 事件时可能会改变自己的内容，其内容仍与之前的展现一致。 pushState()方法pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL. 让我们来解释下这三个参数详细内容： 状态对象 — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。 标题 — Firefox 目前忽略这个参数，但未来可能会用到。在此处传一个空字符串应该可以安全的防范未来这个方法的更改。或者，你可以为跳转的state传递一个短标题。 URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。 pushState()方法相比hash的优点在某种意义上，调用 pushState() 与 设置 window.location = &quot;#foo&quot; 类似，二者都会在当前页面创建并激活新的历史记录。但 pushState() 具有如下几条优点： pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，故只可设置与当前同文档的 URL pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈钟 pushState() 通过 stateObject 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串 pushState() 可额外设置 title 属性供后续使用 注意 pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。 replaceState()方法history.replaceState() 的使用与 history.pushState() 非常相似，区别在于 replaceState() 是修改了当前的历史记录项而不是新建一个。 popstate事件每当处于激活状态的历史记录条目发生变化时，popstate 事件就会在对应window对象上触发。 如果当前处于激活状态的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝。 我们也可以直接在history对象上获取state，如下： 1var currentState = history.state; 需要注意的是，调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。 popstate事件只会在浏览器某些行为下触发， 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法)。 popstate 事件的例子假如当前网页地址为 http://example.com/example.html ,则运行下述代码后: 12345678910window.onpopstate = function(event) &#123; alert("location: " + document.location + ", state: " + JSON.stringify(event.state));&#125;;//绑定事件处理函数. history.pushState(&#123;page: 1&#125;, "title 1", "?page=1"); //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1history.pushState(&#123;page: 2&#125;, "title 2", "?page=2"); //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2history.replaceState(&#123;page: 3&#125;, "title 3", "?page=3"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3history.back(); // 弹出 "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"history.back(); // 弹出 "location: http://example.com/example.html, state: nullhistory.go(2); // 弹出 "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125; 参考文章‘pushState’、’replaceState’MDN文档(中文翻译版) ‘onpopstate’MDN文档(中文翻译版)]]></content>
      <categories>
        <category>Html</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[行为型-模块方法模式]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F10.%20%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模块方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 简单地说，就是 先定义父类，子类继承通用的方法，特殊的方法在子类重写。 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * 模板模式 */class Game &#123; constructor() &#123; &#125; init() &#123;&#125; start() &#123;&#125; end() &#123;&#125; play() &#123; this.init() this.start() this.end() &#125;&#125;class Cricket extends Game &#123; init() &#123; console.log('Cricket Game Initialized! Start playing') &#125; start() &#123; console.log('Cricket Game Started. Enjoy the game!') &#125; end() &#123; console.log('Cricket Game Finished!') &#125;&#125;class Football extends Game &#123; init() &#123; console.log('Football Game Initialized! Start playing') &#125; start() &#123; console.log('Football Game Started. Enjoy the game!') &#125; end() &#123; console.log('Football Game Finished!') &#125;&#125;&#123; let game = new Cricket() game.play() game = new Football() game.play()&#125; 优点 在父类中形式化地定义一个算法，而它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序 一种代码复用技术，提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，鼓励我们恰当使用继承来实现代码复用 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行 符合 ”单一职责原则“ 和 ”开闭原则“ 缺点 需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用策略模式&代理模式进行表单验证]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F9.1%20%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%26%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[前言在学习 策略模式 的时候，发现可以用 策略模式&amp;代理模式 进行表单验证，之前自己一直是使用条件语句进行判断，设计模式给自己提供了很好的思路，记录一下这两种模式的大致实现。 原先的实现123456789101112&lt;form action="http://xxx.com/register" id="registerForm" method="post"&gt; &lt;div class="form-group"&gt; &lt;label for="user"&gt;请输入用户名:&lt;/label&gt; &lt;input type="text" class="form-control" id="user" name="userName"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="pwd"&gt;请输入密码:&lt;/label&gt; &lt;input type="password" class="form-control" id="pwd" name="passWord"&gt; &lt;/div&gt; &lt;button type="button" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; 123456789101112131415let registerForm = document.querySelector('#registerForm')registerForm.addEventListener('submit', function() &#123; if (registerForm.userName.value === '') &#123; alert('用户名不能为空！') return false &#125; if (registerForm.userName.length &lt; 6) &#123; alert('用户名长度不能少于6位！') return false &#125; if (registerForm.passWord.value === '') &#123; alert('密码不能为空！') return false &#125;&#125;, false) 这样会有很多缺点： if-else 语句会很多，这些语句需要覆盖所有的校验规则 违反 “开闭原则”，如果需要增加一种新的校验规则或者更改校验规则，需要在函数内部进行修改 复用性很差，其他表格也需要类似的校验时，可能需要各种复制粘贴 策略模式 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* Validator类 */class Validator &#123; constructor() &#123; this.cache = [] //保存校验规则 &#125; add(dom, rules) &#123; for (let rule of rules) &#123; let strategyAry = rule.strategy.split(':') // 例如['minLength',6] let errorMsg = rule.errorMsg // '用户名不能为空' this.cache.push(() =&gt; &#123; let strategy = strategyAry.shift() // 用户挑选的strategy strategyAry.unshift(dom.value) // 把input的value添加进参数列表 strategyAry.push(errorMsg) // 把errorMsg添加进参数列表，[dom.value,6,errorMsg] return strategies[strategy].apply(dom, strategyAry) &#125;) &#125; &#125; start() &#123; for (let validatorFunc of this.cache) &#123; let errorMsg = validatorFunc()// 开始校验，并取得校验后的返回信息 if (errorMsg) &#123;// 如果有确切返回值，说明校验没有通过 return errorMsg &#125; &#125; &#125;&#125;/* 客户端调用代码 */let registerForm = document.querySelector('#registerForm')const validatorFunc = () =&gt; &#123; let validator = new Validator() validator.add(registerForm.userName, [&#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空！' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于6位！' &#125;]) validator.add(registerForm.passWord, [&#123; strategy: 'isNonEmpty', errorMsg: '密码不能为空！' &#125;]) let errorMsg = validator.start() return errorMsg&#125;registerForm.addEventListener('submit', function() &#123; let errorMsg = validatorFunc() if (errorMsg) &#123; alert(errorMsg) return false &#125;&#125;, false) 代理模式 实现策略模式 写的有点多，使用 Proxy 实现一下：（记得要装 babel 哦！） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 利用proxy拦截不符合要求的数据function validator(target, validator, errorMsg) &#123; return new Proxy(target, &#123; _validator: validator, set(target, key, value, proxy) &#123; let errMsg = errorMsg if (value == '') &#123; alert(`$&#123;errMsg[key]&#125;不能为空！`) return target[key] = false &#125; let va = this._validator[key] if (!!va(value)) &#123; return Reflect.set(target, key, value, proxy) &#125; else &#123; alert(`$&#123;errMsg[key]&#125;格式不正确`) return target[key] = false &#125; &#125; &#125;)&#125;// 负责校验的逻辑代码const validators = &#123; name(value) &#123; return value.length &gt; 6 &#125;, passwd(value) &#123; return value.length &gt; 6 &#125;, moblie(value) &#123; return /^1(3|5|7|8|9)[0-9]&#123;9&#125;$/.test(value) &#125;, email(value) &#123; return /^\w+([+-.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/.test(value) &#125;&#125;// 客户端调用代码const errorMsg = &#123; name: '用户名', passwd: '密码', moblie: '手机号码', email: '邮箱地址' &#125;const vali = validator(&#123;&#125;, validators, errorMsg)let registerForm = document.querySelector('#registerForm')registerForm.addEventListener('submit', function() &#123; let validatorNext = function*() &#123; yield vali.name = registerForm.userName.value yield vali.passwd = registerForm.passWord.value yield vali.moblie = registerForm.phoneNumber.value yield vali.email = registerForm.emailAddress.value &#125; let validator = validatorNext() validator.next(); !vali.name || validator.next(); //上一步的校验通过才执行下一步 !vali.passwd || validator.next(); !vali.moblie || validator.next();&#125;, false)]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[行为型-策略模式]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F9.%20%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Strategy Pattern：又叫 政策模式，定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化。 使用策略模式时，我们可以定义一些策略类，每一个策略类中封装一种具体的算法。在这里，每一个封装算法的类我们都可以称之为一种策略，根据传入不同的策略类，使环境类执行不同策略类中的算法 使用这里举例我们的表单验证，平时验证的时候，我会使用条件语句，如下： 123456789101112&lt;form action="http://xxx.com/register" id="registerForm" method="post"&gt; &lt;div class="form-group"&gt; &lt;label for="user"&gt;请输入用户名:&lt;/label&gt; &lt;input type="text" class="form-control" id="user" name="userName"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="pwd"&gt;请输入密码:&lt;/label&gt; &lt;input type="password" class="form-control" id="pwd" name="passWord"&gt; &lt;/div&gt; &lt;button type="button" class="btn btn-default"&gt;Submit&lt;/button&gt;&lt;/form&gt; 123456789101112131415let registerForm = document.querySelector('#registerForm')registerForm.addEventListener('submit', function() &#123; if (registerForm.userName.value === '') &#123; alert('用户名不能为空！') return false &#125; if (registerForm.userName.length &lt; 6) &#123; alert('用户名长度不能少于6位！') return false &#125; if (registerForm.passWord.value === '') &#123; alert('密码不能为空！') return false &#125;&#125;, false) 这样会有很多缺点： if-else 语句会很多，这些语句需要覆盖所有的校验规则 违反 “开闭原则”，如果需要增加一种新的校验规则或者更改校验规则，需要在函数内部进行修改 复用性很差，其他表格也需要类似的校验时，可能需要各种复制粘贴 使用策略模式后： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* Validator类 */class Validator &#123; constructor() &#123; this.cache = [] //保存校验规则 &#125; add(dom, rules) &#123; for (let rule of rules) &#123; let strategyAry = rule.strategy.split(':') // 例如['minLength',6] let errorMsg = rule.errorMsg // '用户名不能为空' this.cache.push(() =&gt; &#123; let strategy = strategyAry.shift() // 用户挑选的strategy strategyAry.unshift(dom.value) // 把input的value添加进参数列表 strategyAry.push(errorMsg) // 把errorMsg添加进参数列表，[dom.value,6,errorMsg] return strategies[strategy].apply(dom, strategyAry) &#125;) &#125; &#125; start() &#123; for (let validatorFunc of this.cache) &#123; let errorMsg = validatorFunc()// 开始校验，并取得校验后的返回信息 if (errorMsg) &#123;// 如果有确切返回值，说明校验没有通过 return errorMsg &#125; &#125; &#125;&#125;/* 客户端调用代码 */let registerForm = document.querySelector('#registerForm')const validatorFunc = () =&gt; &#123; let validator = new Validator() validator.add(registerForm.userName, [&#123; strategy: 'isNonEmpty', errorMsg: '用户名不能为空！' &#125;, &#123; strategy: 'minLength:6', errorMsg: '用户名长度不能小于6位！' &#125;]) validator.add(registerForm.passWord, [&#123; strategy: 'isNonEmpty', errorMsg: '密码不能为空！' &#125;]) let errorMsg = validator.start() return errorMsg&#125;registerForm.addEventListener('submit', function() &#123; let errorMsg = validatorFunc() if (errorMsg) &#123; alert(errorMsg) return false &#125;&#125;, false) 优点 符合 ”开闭原则“：可以灵活地增加新的算法或行为 提供了管理相关的算法族的办法：策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码 提供了一种可以替换继承关系的办法：如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换 可以避免多重条件选择语句：多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后 提供了一种算法的复用机制：由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类 缺点 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。换句话说，策略模式只适用于客户端知道所有的算法或行为的情况 将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-状态模式]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F8.%20%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 State Pattern：又叫 状态对象，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 状态模式用于解决复杂对象的状态转换以及不同状态下行为的封装问题。 当系统中某个对象存在多个状态，这些状态之间可以进行转换，所以对象在不同状态下具有不同行为时可以使用状态模式。 状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。 使用123456789101112131415161718192021222324252627class Menu &#123; constructor(state)&#123; this.num = 1 this.menuStates = &#123; hide:function () &#123; console.log("hide") &#125;, show: function () &#123; console.log("show") &#125;, left: function () &#123; console.log("left") &#125;, right: function () &#123; console.log("right") &#125; &#125; &#125; toggle (state) &#123; state() &#125;&#125;var menu = new Menu()console.log(menu)menu.toggle(menu.menuStates.show)menu.toggle(menu.menuStates.hide) 优点 封装了状态的转换规则，在状态模式中可以将状态的转换代码在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散到一个个业务方法中 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数 缺点 必然会增加系统中类和对象的个数，导致系统运行开销增大 结构和实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度 对开闭原则的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需要修改对应类的源代码]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式、代理模式、中介者模式区别]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F5.1%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E3%80%81%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言外观模式、代理模式、中介模式，都挺像，统一起来记录一下它们的区别吧~ 外观模式 Facade Pattern：又叫门面模式，定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。 代理模式 Proxy Pattern：为某个对象提供一个代理，并由这个代理对象控制对原有对象的访问。 消息队列就是这种模式 中介者模式 Mediator Pattern：又叫调停者模式，用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。所有成员通过中介者交互，方便拓展新的成员。 外观模式 PK 代理模式 代理模式中的代理角色和真实角色都继承于同一个类；而外观模式是多个类的集合 代理角色与真实角色接口相同，功能一致，代理角色实现的是真实角色的功能；外观这模式的子系统功能不同，根据不同需要由外观类统一配置 外观模式 PK 中介者模式 外观模式是结构型模式；中介者模式是行为型模式 外观模式是对子系统提供统一的接口；中介者模式是用一个中介对象来封装一系列同事对象的交互行为 外观模式协议是单向；中介者模式协议是双向 外观模式所有的请求处理都委托给子系统完成；中介者模式则由中心协调同事类和中心本身共同完成业务 代理模式 PK 中介者模式 代理模式是结构型模式；中介者模式是行为型模式 代理模式是一对一，一个代理只能代表一个对象；中介者模式是一对多，一个中介者对应多个客户 代理模式只能代理一方，如果 PB 是 A 的代理，那么 C 可以通过 PB 访问 A ，但是 A 不能通过 PB 访问 C；中介者模式钟，A 可以通过中介访问 C，C 也可以通过中介访问 A]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[行为型-观察者模式]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F7.%20%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Observer Pattern：又叫 发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者模式（Dependents）。 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Observer &#123; constructor(fns) &#123; this.fns = fns || []; &#125; // 订阅 subscribe(fn) &#123; this.fns.push(fn); &#125; // 取消订阅 unsubscribe(fn) &#123; this.fns = this.fns.filter((el) =&gt; &#123; return el !== fn; &#125;); &#125; // 发射 update(o) &#123; this.fns.forEach((fn) =&gt; &#123; fn(o); &#125;) &#125;&#125;// 测试var o = new Observer;var f1 = function (data) &#123; console.log('Robbin: ' + data + ', 赶紧干活了！');&#125;;var f2 = function (data) &#123; console.log('Randall: ' + data + ', 找他加点工资去！');&#125;;// 添加观察者 o.subscribe(f1);o.subscribe(f2);// 通知观察者并更新o.update("Tom回来了！", '666'); // Robbin: Tom回来了！, 赶紧干活了！ // Randall: Tom回来了！, 找他加点工资去！// 退订f1o.unsubscribe(f1);// 再来验证o.update("Tom回来了！"); // Randall: Tom回来了！, 找他加点工资去！o.unsubscribe(f2);o.update("Tom回来了！"); // 无打印，因为取消了所有的订阅 优点 可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色 在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次 支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度 符合开闭原则，增加新的具体观察者无须不改原有系统代码 缺点 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-访问者模式]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F11.%20%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Vistor Pattern：提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 访问者模式是一种较为复杂的行为型设计模式，包含 访问者 和 被访问元素 两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为「对象结构」，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。 比如下面：访问者有财务部门FADepartment和 HR 部门HRDepartment，通过访问雇员Employee来查看雇员的工作情况。 使用12345678910111213141516171819202122232425262728293031323334// 访问者抽象类class IVisitor &#123; visit(element) &#123;&#125;;&#125;// 元素类抽象类class IElement &#123; accept(visitor) &#123;&#125;;&#125;// 具体访问者class Cashier extends IVisitor &#123; visit(element) &#123; console.log(`【Goods】Title: $&#123;element.title&#125;, price: $&#123;element.price&#125;`); &#125;&#125;// 具体元素类class Goods extends IElement &#123; constructor(title, price) &#123; super() this.title = title; this.price = price; &#125; accept(visitor) &#123; visitor.visit(this); &#125;&#125;// 客户端let pencil = new Goods('铅笔', 2.5);let cashier = new Cashier();pencil.accept(cashier); // 【Goods】Title: 铅笔, price: 2.5 优点 符合 “开闭原则”：增加新的访问操作意味着增加一个新的具体访问者类，实现简单，无须修改源代码 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类钟，类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作 缺点 增加新的元素类很困难：每增加一个新的元素类意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背 “开闭原则” 破坏封装：要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-中介者模式]]></title>
    <url>%2F2019%2F12%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F5.%20%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Mediator Pattern：又叫调停者模式，用一个中介对象（中介者）来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。所有成员通过中介者交互，方便拓展新的成员。 使用12345678910111213141516171819202122232425262728class ChatRoom &#123; constructor() &#123;&#125; static showMessage(user, message) &#123; console.log(new Date(), user.getName(), message); &#125;&#125;class User &#123; constructor(name) &#123; this.name = name; &#125; setName() &#123; this.name = name; &#125; getName() &#123; return this.name; &#125; sendMessage(message) &#123; ChatRoom.showMessage(this, message); &#125;&#125;let tom = new User("Tom Zhang");tom.sendMessage("My name is Tom");let jack = new User("Jack Chen");jack.sendMessage("My name is Jack"); 优点 简化了对象之间的交互，用一对多交互代替原来的多对多交互 解耦，增加新的中介者和新的同事类都比较方便，符合开闭原则 可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展 缺点 在具体中介者类中包含了大量同事之间的交互细节，可能导致具体中介者类非常复杂，使得系统难以维护]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router源码分析(HashHistory与HTML5History)]]></title>
    <url>%2F2019%2F12%2F24%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvue-router%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2F6.%20HashHistory%E4%B8%8EHTML5History%2F</url>
    <content type="text"><![CDATA[前言”更新视图但不重新请求页面“ 是前端路由原理的核心之一，目前在浏览器环境中这一功能的实现主要有两种方式 利用 URL 中的 hash（#） 利用 History interface 在 HTML5 中新增的方法 下面看看在 Vue-router 中是如何通过这两种方式实现前端路由 匹配模式创建 VueRouter 的实例对象时，mode 以构造函数参数的形式传入 实例化 VueRouter1234567891011121314151617181920212223242526272829303132333435363738394041export default class VueRouter &#123; constructor(options: RouterOptions = &#123;&#125;) &#123; // ... // 根据 mode 采取不同的路由方式 let mode = options.mode || "hash"; // 通过supportsPushState判断浏览器是否支持 HTML5 特性 this.fallback = mode === "history" &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false; // 如果浏览器不支持，'history'模式需回滚为’hash‘模式 if (this.fallback) &#123; mode = "hash"; &#125; // 如果不在浏览器环境下运行，强制为'abstract'模式 if (!inBrowser) &#123; mode = "abstract"; &#125; this.mode = mode; /** 根据mode确定history实际的类并实例化,之后的push replace等调的是具体history对象的方法 * @Router 实例 * @base 应用的基路径 * @fallback History 模式，但不支持 History 而被转成 Hash 模式 */ switch (mode) &#123; case "history": this.history = new HTML5History(this, options.base); break; case "hash": this.history = new HashHistory(this, options.base, this.fallback); break; case "abstract": this.history = new AbstractHistory(this, options.base); break; default: if (process.env.NODE_ENV !== "production") &#123; assert(false, `invalid mode: $&#123;mode&#125;`); &#125; &#125; &#125;&#125; 初始化路由123456789101112131415161718192021222324252627init(app: any /* Vue component instance */) &#123; const history = this.history; // 判断路由模式，并根据不同路由模式进行跳转。hashHistory需要监听hashchange、popshate两个事件，而html5History监听popstate事件 if (history instanceof HTML5History) &#123; history.transitionTo(history.getCurrentLocation()); &#125; else if (history instanceof HashHistory) &#123; // 添加 hashchange 监听 const setupHashListener = () =&gt; &#123; history.setupListeners(); &#125;; // 路由跳转 history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ); &#125; // 该回调会在 transitionTo 中调用 // 对组件的 _route 属性进行赋值，触发组件渲染；且将apps中的组件的_route全部更新至最新的 history.listen(route =&gt; &#123; this.apps.forEach(app =&gt; &#123; app._route = route; &#125;); &#125;);&#125; HashHistoryhttp://www.example.com/index.html#print # 符号本身以及它后面的字符称为 hash，可通过 window.location.hash 属性读取 特点： hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，它是用来指导浏览器动作的，对服务端完全无用。因此，改变 hash 不会重新加载页面 可以为 hash 的改变添加监听事件 window.addEventListener(&#39;hashchange&#39;, funcRef, false) 每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录 push()跳转的方式会判断是否需要滚动，需要，将会使用 pushState 改变路由；否则对 window 的 hash 进行直接赋值 hash 的改变会自动添加到浏览器的访问历史记录中 12345678910111213141516171819push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo( location, route =&gt; &#123; pushHash(route.fullPath) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort )&#125;function pushHash (path) &#123; if (supportsPushState) &#123; pushState(getUrl(path)) &#125; else &#123; window.location.hash = path &#125;&#125; 实现视图更新先上结论，从设置路由改变到视图更新的流程 $router.push() --&gt; HashHistory.push() --&gt; History.transitionTo() --&gt;History.updateRoute() --&gt; {app._route = route} --&gt; vm.render() 我们现在看父类 History 中 transitionTo() 的实现 1234567891011121314151617transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const route = this.router.match(location, this.current) this.confirmTransition(route, () =&gt; &#123; this.updateRoute(route) ... &#125;)&#125;updateRoute (route: Route) &#123; this.cb &amp;&amp; this.cb(route) &#125;listen (cb: Function) &#123; this.cb = cb&#125; 当路由变化时，调用了 this.cb 方法， this.cb 方法是通过 History.listen(cb) 进行设置的。让我们看看 cb 在哪里传入 12345678910init (app: any /* Vue component instance */) &#123; this.apps.push(app) history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; app._route = route &#125;) &#125;)&#125; 可以看到，在路由初始化的函数中，会传入修改app._route = route的 cb ，有什么作用呢？？在 install.js 里面会全局注册一个混合，给所有 Vue实例的 beforeCreate 钩子定义了响应式的 _route属性，所以，当 _route 改变时，会自动调用 Vue 实例的 render() 方法，更新视图 replace()如果浏览器支持 HTML5 特性，将会使用 replaceState 改变路由；否则调用 window.location.replace 方法将路由进行替换 不会把新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由 12345678910111213141516171819replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo( location, route =&gt; &#123; replaceHash(route.fullPath) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort )&#125;function replaceHash (path) &#123; if (supportsPushState) &#123; replaceState(getUrl(path)) &#125; else &#123; window.location.replace(getUrl(path)) &#125;&#125; setupListeners() 监听地址栏用户除了使用push与replace改变路由，而可以直接在浏览器地址栏中输入改变路由，所以 VueRouter 还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为 在 HashHistory 中通过setupListeners方法实现 跳转时会判断是否需要滚动行为，如果需要，则监听浏览器 popstate 事件，否则监听浏览器 hashchange 事件，调用 replaceHash 函数，即在浏览器地址栏中直接输入路由相当于代码调用了 replace() 方法 1234567891011121314151617181920212223242526272829setupListeners () &#123; const router = this.router const expectScroll = router.options.scrollBehavior const supportsScroll = supportsPushState &amp;&amp; expectScroll if (supportsScroll) &#123; setupScroll() &#125; // 当 hash 路由发生的变化，即页面发生了跳转时，首先取保路由是以斜杠开头的，然后触发守卫导航，最后更换新的 hash 路由 window.addEventListener( supportsPushState ? 'popstate' : 'hashchange', () =&gt; &#123; const current = this.current // 确保路由是以斜杠开头的 if (!ensureSlash()) &#123; return &#125; this.transitionTo(getHash(), route =&gt; &#123; if (supportsScroll) &#123; handleScroll(this.router, route, current, true) &#125; if (!supportsPushState) &#123; replaceHash(route.fullPath) &#125; &#125;) &#125; )&#125; HTML5HistoryHistory interface 是浏览器历史记录栈提供的接口，通过 back() ，forward() ，go() 等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作 从 HTML5 开始，History interface 提供了两个新的方法：pushState() ，replaceState() 使得我们可以对浏览器历史记录栈进行修改 1234567/*** stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本* title: 所添加记录的标题* URL: 所添加记录的 URL*/window.history.pushState(stateObject, title, URL)window.history.replaceState(stateObject, title, URL) 这两个方法有个共同的特点：当调用它们修改浏览器历史记录栈时，虽然当前 URL 改变了，但浏览器不会立刻发送请求该 URL，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础 push() 与 replace()VueRouter 中的实现：会发现代码结构以及更新视图的逻辑与 hash 模式基本类似，区别是：将 window.location.hash window.location.replace() 改为调用 window.history.pushState() window.history.replaceState() 12345678910111213141516171819202122232425262728293031323334353637383940push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; pushState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; replaceState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;export function pushState (url?: string, replace?: boolean) &#123; // 保存当前页面的滚动位置 saveScrollPosition() // try...catch the pushState call to get around Safari // DOM Exception 18 where it limits to 100 pushState calls const history = window.history try &#123; // 判断是哪种操作动作 if (replace) &#123; // preserve existing history state as it could be overriden by the user const stateCopy = extend(&#123;&#125;, history.state) stateCopy.key = getStateKey() history.replaceState(stateCopy, '', url) &#125; else &#123; history.pushState(&#123; key: setStateKey(genStateKey()) &#125;, '', url) &#125; &#125; catch (e) &#123; window.location[replace ? 'replace' : 'assign'](url) &#125;&#125;export function replaceState (url?: string) &#123; pushState(url, true)&#125; 监听地址栏在 HTML5History 中添加对修改浏览器地址栏 URL 的监听是直接在构造函数中执行的，注意只监听 popstate 事件 12345678910111213141516171819202122232425262728export class HTML5History extends History &#123; constructor (router: Router, base: ?string) &#123; super(router, base) const expectScroll = router.options.scrollBehavior const supportsScroll = supportsPushState &amp;&amp; expectScroll if (supportsScroll) &#123; setupScroll() &#125; window.addEventListener('popstate', e =&gt; &#123; const current = this.current // Avoiding first `popstate` event dispatched in some browsers but first // history route not updated since async guard at the same time. const location = getLocation(this.base) if (this.current === START &amp;&amp; location === initLocation) &#123; return &#125; this.transitionTo(location, route =&gt; &#123; // 判断配置是否有 scrollBehavior 与 支持HTML5新特性，有就调用 handleScroll 方法进行处理 if (supportsScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;) &#125; handleScroll 处理滚动123456789101112131415// 实现滚动的两个小办法// 1. 在main.js入口文件中写入router.afterEach(() =&gt; &#123; document.body.scrollTop = 0; document.documentElement.scrollTop = 0;&#125;// 2. 在实例router对象的时候设置export default new Router(&#123; mode: 'hash', // base: '/dist/', crollBehavior: () =&gt; (&#123; y: 0 &#125;), //路由跳转后页面回到顶部 routes: []&#125;) 滚动行为：使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持在原先的滚动位置，就像重新加载页面那样。VueRouter 可以自定义路由切换时页面如何滚动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export function handleScroll(router: Router, to: Route, from: Route, isPop: boolean) &#123; &lt;!-- 等待页面渲染完才进行滚动的操作 --&gt; router.app.$nextTick(() =&gt; &#123; &lt;!-- 初始化数据 --&gt; const position = getScrollPosition() const shouldScroll = behavior.call(router, to, from, isPop ? position : null) if (!shouldScroll) &#123; return &#125; &lt;!-- 判断是否是Promise,官网说支持异步 --&gt; if (typeof shouldScroll.then === 'function') &#123; shouldScroll.then(shouldScroll =&gt; &#123; scrollToPosition((shouldScroll: any), position) &#125;).catch(err =&gt; &#123; if (process.env.NODE_ENV !== 'production') &#123; assert(false, err.toString()) &#125; &#125;) &#125; else &#123; scrollToPosition(shouldScroll, position) &#125; &#125;)&#125;)/** * getElementPosition：获取元素坐标* isValidPosition：验证坐标是否有效* normalizePosition：格式化坐标*/function scrollToPosition (shouldScroll, position) &#123; const isObject = typeof shouldScroll === 'object' // 对position进行初始化的操作 if (isObject &amp;&amp; typeof shouldScroll.selector === 'string') &#123; const el = document.querySelector(shouldScroll.selector) if (el) &#123; let offset = shouldScroll.offset &amp;&amp; typeof shouldScroll.offset === 'object' ? shouldScroll.offset : &#123;&#125; offset = normalizeOffset(offset) position = getElementPosition(el, offset) &#125; else if (isValidPosition(shouldScroll)) &#123; position = normalizePosition(shouldScroll) &#125; &#125; else if (isObject &amp;&amp; isValidPosition(shouldScroll)) &#123; position = normalizePosition(shouldScroll) &#125; // 使用window.scrollTo来进行滚动处理 if (position) &#123; window.scrollTo(position.x, position.y) &#125;&#125; supportsPushState 检查浏览器是否支持 HTML5 特性HTML5History 用到了 HTML5 的特性，需要特定浏览器版本的支持，浏览器是否支持是通过变量 supportsPushState 来检查的： 12345678910111213141516export const supportsPushState = inBrowser &amp;&amp; (function () &#123; const ua = window.navigator.userAgent if ( (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &amp;&amp; ua.indexOf('Mobile Safari') !== -1 &amp;&amp; ua.indexOf('Chrome') === -1 &amp;&amp; ua.indexOf('Windows Phone') === -1 ) &#123; return false &#125; return window.history &amp;&amp; 'pushState' in window.history &#125;)() 总结hash模式与 history模式都是通过浏览器接口实现，除此之外，VueRouter 还为非浏览器环境准备了一个 abstract模式，原理：用一个数组 stack 模拟浏览器历史记录栈的功能 两种模式的比较history 模式的优点 如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档 在 MDN 的介绍中，是这样描述的： 在某种意义上，调用 pushState() 与 设置 window.location = &quot;#foo&quot; 类似，二者都会在当前页面创建并激活新的历史记录。但 pushState() 具有如下几条优点： pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，故只可设置与当前同文档的 URL pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈钟 pushState() 通过 stateObject 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串 pushState() 可额外设置 title 属性供后续使用 注意 pushState() 绝对不会触发 hashchange 事件，即使新的URL与旧的URL仅哈希不同也是如此。 history 模式的一个问题对于单页面应用来说，理想的使用场景是仅在进入应用时加载 index.html，后续的网络操作通过 Ajax 完成，不会根据 URL 重新请求页面。但是如果遇到特殊情况：用户直接在地址栏中输入并按回车，浏览器重启重新加载应用等 hash 模式仅改变 hash 部分的内容，而hash 部分不会包含在 HTTP 请求中。所以在 hash 模式下遇到特殊情况不会有问题 1http://oursite.com/#/user/id // 如重新请求只会发送http://oursite.com/ 而history 模式会将整个 URL 重新发送请求，如果后端没有配置对应 /user/id 的路由处理，则会返回 404 错误 1http://oursite.com/user/id 官方推荐的解决办法是：在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 同时，我们要给一个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面 123456const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;) 或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情可查阅官网]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-迭代器模式]]></title>
    <url>%2F2019%2F12%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F4.%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Iterator Pattern：别名为游标（Cursor），提供一个方法来访问聚合对象，而不用暴露这个对象的内部表示。 使用 内部迭代器：内部定义好了迭代规则，完全接手了整个过程，外部只需要调用一次。但是它只能迭代一个数组，要想迭代两个数组必须改变内部函数的实现，违反了开闭原则 1234567891011121314// 实现一个each函数，第一个参数是数组，第二个参数是每一步的处理函数let each = function (arr, callback) &#123; for(let i = 0,l = arr.length; i &lt; l;i++) &#123; callback.call(arr[i], i, arr[i]); &#125;&#125;// testeach([1, 2, 3], function(i, n) &#123; console.log([i, n])&#125;)// [0, 1]// [1, 2]// [2, 3] 外部迭代器：必须显式的请求迭代下一个元素，增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，因此我们可以手动地控制整个迭代过程 12345678910111213141516171819202122var Iterator = function (obj) &#123; var current = 0; var next = function () &#123; current += 1; &#125;; var isDone = function () &#123; return current &gt;= obj.length; &#125;; var getCurrItem = function () &#123; return obj[current]; &#125;; return &#123; next: next, isDone: isDone, getCurrItem: getCurrItem, length: obj.length &#125;;&#125; 从上面的迭代器实现可以看出，只要被迭代的聚合对象拥有length属性而且可以用下标访问，那么它就是迭代器。Javascript中的类数组对象也是迭代器。 优点 支持以不同的方式遍历一个聚合对象，同一个聚合对象可以定义多种遍历方式 简化了聚合类：在原有的聚合对象中不需要再自行提供数据遍历等方法 增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则 缺点 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，一定程度上增加了系统的复杂性 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-解释器模式]]></title>
    <url>%2F2019%2F12%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F3.%20%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Interpreter Pattern：定义一个语言（使用规定格式和语法的代码）的文法，并且建立一个解释器来解释该语言钟的句子。 使用我们的编译器，在对代码进行编译的时候也用到了该模式 下面做一个简单的解释器，一个给机器人下发指令的解释器 命令 参数 direction 移动方向 ‘up’ ‘down’ ‘left’ ‘right’ action 移动方式 ‘move’ ‘run’ distance 移动距离 an integer 表达式终结符号 ‘;’ 我们在代码中，写上以上命令的具体实现，通过建立一个映射关系，比如传入 up run 5; 可以很快将指令转换成行为，表示向上跑5米 优点 易于改变和扩展文法 每一条文法规则都可以表示为一个类，所以可以很方便地实现一个简单的语言 增加新的解释表达式较为方便，符合开闭原则 实现文法较为容易：在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码 缺点 对于复杂文法难以维护：每一个规则至少需要定义一个类，所以如果一个语言包含太多文法规则，类的个数会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式 执行效率较低：因为解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-备忘录模式]]></title>
    <url>%2F2019%2F12%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F6.%20%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Memento Pattern：又叫 Token，在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，当前很多软件都提供了撤销操作，其中就使用了备忘录模式 使用备忘录模式也可以看成缓存器，除了撤销操作，我们还可以利用该模式做分页：点击下一页获取新的数据，点击上一页时又重新获取数据，会造成流量浪费，这时可以对数据进行缓存 12345678910111213141516// 备忘录模式伪代码var Page = function () &#123; // 通过cache对象缓存数据 var cache = &#123;&#125; return function (page, fn) &#123; if (cache[page]) &#123; showPage(page, cache[page]) &#125; else &#123; $.post('/url', function (data) &#123; showPage(page, data) cache[page] = data &#125;) &#125; fn &amp;&amp; fn() &#125;&#125; 优点 提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作 缺点 资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态就需要消耗一定的系统资源]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-命令模式]]></title>
    <url>%2F2019%2F12%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F2.%20%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Command Pattern：将一个请求封装成一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 业务出现了 (回退操作)(重做操作)的需求的时候，就可以考虑使用这个模式。 和之前代理模式中的举例有些相似，不过命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。例如遥控器是一个调用者，不同按钮代表不同的命令，而电视是接收者。 使用123456789101112131415161718192021222324252627282930313233343536373839var command1 = &#123; execute: function()&#123; console.log(1); &#125;&#125;; var command2 = &#123; execute: function()&#123; console.log(2); &#125;&#125;;var command3 = &#123; execute: function()&#123; console.log(3); &#125;&#125;;// 定义宏命令，command.add方法把子命令添加进宏命令对象，// 当调用宏命令对象的execute方法时，会迭代这一组命令对象，// 并且依次执行他们的execute方法。var command = function()&#123; return &#123; commandsList: [], add: function(command)&#123; this.commandsList.push(command); &#125;, execute: function()&#123; for(var i = 0,commands = this.commandsList.length; i &lt; commands; i+=1) &#123; this.commandsList[i].execute(); &#125; &#125; &#125;&#125;;// 初始化宏命令var c = command();c.add(command1);c.add(command2);c.add(command3);c.execute(); // 1,2,3 优点 降低系统的耦合度：请求者与接收者之间不存在直接引用，两者之间具有良好的独立性 新的命令可以很容易加入到系统中，且不会影响其他类，符合开闭原则 可以比较容易地设计一个命令队列或宏命令（组合命令） 为请求的撤销和恢复操作提供了一种设计和实现方案 缺点 可能导致某些系统有过多的具体命令类：因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的设计]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行为型-责任链模式]]></title>
    <url>%2F2019%2F12%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A1%8C%E4%B8%BA%E5%9E%8B%2F1.%20%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Chain of Responsibility Pattern：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 无论是作用域链、原型链、express、还是DOM节点中的事件冒泡，都能从中找到职责链的影子。 使用123456789101112131415161718192021222324function getActiveUploadObj() &#123; try&#123; return new ActiveObject("TXFTNActiveX.FTNUpload"); // IE上传控件 &#125;catch(e) &#123; return "nextSuccessor"; &#125;&#125;function getFlashUploadObj() &#123; if(supportFlash().f === 1) &#123; // supportFlash见《JavaScript设计模式--迭代器模式》 var str = '&lt;object type="application/x-shockwave-flash"&gt;&lt;/object&gt;'; return $(str).appendTo($("body")); &#125; return "nextSuccessor";&#125;function getFormUploadObj() &#123; var str = '&lt;input name="file" type="file" class="ui-file" /&gt;'; return $(str).appendTo($("body"));&#125;var getUploadObj = getActiveUploadObj.after(getFlashUploadObj).after(getFormUploadObj);console.log(getUploadObj()); 优点 一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理的引用，可简化对象的相互连接 在给对象分派职责时，职责链可以给我们更多地灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责 在系统中增加一个新的具体请求处理者时无需修改原有系统的代码，只需要在客户端重新建链即可，符合开闭原则 缺点 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便 如果建链不当，可能会造成循环调用，将导致系统陷入死循环]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>行为型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome Devtool Performance 使用指南]]></title>
    <url>%2F2019%2F12%2F20%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FChrome%20Devtool%2Fperforemance%2F</url>
    <content type="text"><![CDATA[前言还记得距离上一次学习Devtool功能时，是在大二上学期，那会还叫profile。许久未见，Devtool强大了不少，今天探究一下全新 Chrome Devtool Performance 的使用。 Performance作用：分析运行时性能表现，可以根据提示去改善我们的代码，提高性能 测试 匿名模式下，打开DEMO 打开Devtools，点击Performance 确保 Screenshots checkbox 被选（打开截图功能） 点开右边的小齿轮，我们可以选择模拟 4倍的 CPU 点击录制按钮（黑点），开始记录此段时间内页面运行性能 点击stop停止 面板功能分析 区域一：控制面板 Screenshots截图：默认勾选，每一帧都会截图 Memory内存消耗记录：勾选后可以看到各种内存消耗曲线 【以下配置是用来模拟手机、慢网络下使用】 Disable javaScript samples关闭javaScript样本：减少在手机运行时的开销，模拟手机运行时勾选 Network网络模拟：可以模拟在3G（自定义）等网络条件下运行页面 Enable advanced paint instrumentation(slow)记录渲染事件的细节：选中后，选择frames中的一块，可以看到区域四多了Layers CPU限制：模拟底CPU下的运行性能 区域二：概览面板 1. FPS 每帧秒数，对于动画而言标准是保持在60FPS FPS（frames per second）：用来分析动画的一个主要性能指标，让页面效果能够达到 &gt;=60fps(帧)/s的刷新频率以避免出现卡顿。能保持在60的FPS的话，那么用户体验就是不错的。 为什么是60FPS呢？ 因为这和目前大多数显示器的刷新率相吻合（60Hz），如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次渲染的时间不能超过16.66毫秒 分析： 绿色越高越好，出现红色说明FPS低——页面卡顿的位置，可以在区域三的Frames中看到具体的FPS值 2. CPU 处理各个任务花费的时间，选择一段CPU统计可以在区域四的Summary看到统计表格 Scirpting脚本 Rendering渲染 Painting绘制 Loading加载 ldle闲置 分析：比重占的大的颜色可能有问题，着重注意 3. NET 各个请求花费的时间，可以在区域三的Network里查看 网络请求详细请求 分析：每条彩色横杠表示一种资源。横杠越长，检索资源所需的时间越长。每个横杠的浅色部分表示等待时间（从请求资源到第一个字节下载完成的时间） 区域三：线程面板 1. Frames帧线程，鼠标悬浮绿色块可以看到FPS 2. Main主线程，负责执行javaScript，解析HTML/CSS，完成绘制。可以看到主线程调用栈和耗时情况，每个长条都是一个事件，悬浮可以看到耗时和事件名 x轴：时间 y轴：调用栈，上面的event调用下面的子event，越到下面数量越少（瀑布，倒立的火焰图） 颜色代表各个事件类型（更多可看附录一） 分析： 在事件长条的右上角，如果出现了红色小三角，说明这个事件是存在问题的，需要特别注意 双击带有红色小三角的事件，在Summary面板可以看到详细信息，注意reveal这个链接，双击它会让高亮触发这个事件的event。如果点击了app.js:94这个链接，会跳转到对应的代码处 在app.update这个事件的长条下方，有很多被触发的紫色长条，如果放大它们，可以看到每个都带有红色小三角。点击其中一个紫色事件长条，Summary面板展示了更多关于这个事件的信息 在Summary面板里点击app.js:70链接，就会自动跳转到需要优化的代码处 3. RasterRaster线程，负责完成某个layer或者某个块的绘制 区域四：统计面板统计面板会因点击选择不同的目标，统计的内容不同 Summary统计图：展示各个事件阶段耗费的时间 Bottom-Up排序：事件时长排序 self-time：除去子事件这个事件本身消耗的时间 total-time：这个事件从开始到结束消耗的时间（包含子事件） Call Tree调用栈：事件调用排序，Main中选择一个事件，可以看到整个事件的调用栈（从最顶层到最底层，而不是只有当前事件） Event Log事件日志：事件发生的先后顺序 多了一个start time，指事件在多少毫秒开始触发的 右边有事件描述信息 开启实时监控 ctrl+shift+p打开命令行 搜索Show Rendering 勾选FPS Meter 附录一1. Loading事件 事件 描述 Parse HTML 浏览器执行HTML解析 Finish Loading 网络请求完毕事件 Receive Data 请求的响应数据到达事件，如果响应数据很大（拆包），可能会多次触发该事件 Receive Response 响应头报文到达时触发 Send Request 发送网络请求时触发 2. Scripting事件 事件 描述 Animation Frame Fired 一个定义好的动画帧发生并开始回调处理时触发 Cancel Animation Frame 取消一个动画帧时触发 GC Event 垃圾回收时触发 DOMContentLoaded 当页面中的DOM内容加载并解析完毕时触发 Evaluate Script A script was evaluated. Event js事件 Function Call 只有当浏览器进入到js引擎中时触发 Install Timer 创建计时器（调用setTimeout()和setInterval()）时触发 Request Animation Frame A requestAnimationFrame() call scheduled a new frame Remove Timer 当清除一个计时器时触发 Time 调用console.time()触发 Time End 调用console.timeEnd()触发 Timer Fired 定时器激活回调后触发 XHR Ready State Change 当一个异步请求为就绪状态后触发 XHR Load 当一个异步请求完成加载后触发 3. Rendering事件 事件 描述 Invalidate layout 当DOM更改导致页面布局失效时触发 Layout 页面布局计算执行时触发 Recalculate style Chrome重新计算元素样式时触发 Scroll 内嵌的视窗滚动时触发 4. Painting事件 事件 描述 Composite Layers Chrome的渲染引擎完成图片层合并时触发 Image Decode 一个图片资源完成解码后触发 Image Resize 一个图片被修改尺寸后触发 Paint 合并后的层被绘制到对应显示区域后触发]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>Chrome Devtool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构型-适配器模式]]></title>
    <url>%2F2019%2F12%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%2F6.%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Adapter Pattern：又叫包装器模式，将一个接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 使用在前端开发中，我们可能会遇到这样的场景：当我们试图调用某个模块或者对象的接口时，发现这个接口的格式不符合我们的需求。 这时有两种解决办法： 第一种：修改原来的接口实现。但是如果原来的代码很复杂，例如一个库或者框架，更改代码不现实 第二种：创建一个适配器，将原接口转换成客户希望的另一个接口，客户只需要使用适配器即可 123456789101112131415161718192021222324252627282930// 老接口const oldCity = (function() &#123; return [ &#123; name: 'hangzhou', id: 11, &#125;, &#123; name: 'jinhua', id: 12 &#125; ]&#125;())// 新接口希望是下面形式// &#123;// hangzhou: 11,// jinhua: 12// &#125;// 这时候就可采用适配者模式const adaptor = function(oldCity) &#123; const obj = &#123;&#125;; for (let city of oldCity) &#123; obj[city.name] = city.id &#125; return obj&#125;;console.log(adaptor(oldCity)); // &#123;hangzhou: 11, jinhua: 12&#125; 优点 符合开闭原则：不需要改变现有类，提高类的复用性 目标类和适配器类解耦，提高程序扩展性 缺点 增加了系统的复杂性 适配器模式本质上是一个亡羊补牢的模式，它解决的是现存的两个接口之间不兼容的问题，不应该在软件的初期开发阶段使用该模式；尽量在设计之初就规划好接口的一致性]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构型-桥接模式]]></title>
    <url>%2F2019%2F12%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%2F5.%20%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Bridge Pattern：将抽象部分与它的实现部分分离，使他们都可以独立地变化。 使用比如提取多个底层功能模块，如运动、着色、说话模块，球类有运动和着色模块，人类有运动和说话模块，实现模块的快速组合，将实现和抽象分离，提高创建对象的灵活性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Speed &#123; // 运动模块 constructor(x, y) &#123; this.x = x; this.y = y; &#125; run() &#123; console.log(`运动起来 $&#123;this.x&#125; + $&#123;this.y&#125;`) &#125;&#125;class Color &#123; // 着色模块 constructor(cl) &#123; this.color = cl; &#125; draw() &#123; console.log(`绘制颜色 $&#123;this.color&#125;` ) &#125;&#125;class Speak &#123; // 说话模块 constructor(wd) &#123; this.word = wd; &#125; say() &#123; console.log(`说话 $&#123;this.word&#125;` ) &#125;&#125;class Ball &#123; // 创建球类，可以着色和运动 constructor(x, y, cl) &#123; this.speed = new Speed(x, y) this.color = new Color(cl) &#125; init() &#123; this.speed.run() this.color.draw() &#125;&#125;class Man &#123; // 创建人类，可以运动和说话 constructor(x, y, wd) &#123; this.speed = new Speed(x, y) this.speak = new Speak(wd) &#125; init() &#123; this.speed.run() this.speak.say() &#125;&#125;const man = new Man(1, 2, 'zw')const ball = new Ball(1, 2, '#333333')man.init() // 运动起来 1 + 2 说话 zwball.init() // 运动起来 1 + 2 绘制颜色 #333333 优点 扩展性好，符合开闭原则 将抽象与实现分离，二者可以独立变化 缺点 在设计前，需要识别出两个独立变化的维度]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构型-享元模式]]></title>
    <url>%2F2019%2F12%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%2F4.%20%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Flyweight Pattern：运用共享技术复用大量细粒度的对象，降低程序内存的占用，提高程序的性能。 享元模式提醒我们讲一个对象的属性划分为内部和外部状态 内部状态：可以被对象集合共享，通常不会改变 外部状态：根据应用场景经常改变 享元模式是利用时间换取空间的优化模式 使用以下用Es6实现一个“通用对象池”类-ObjectPool，这个类管理一个装载空闲对象的数组，如果外部需要一个对象，直接从对象池中获取，而不是通过new操作；模拟File类，“文件下载”操作。 对于File类，内部状态是pool属性和download方法；外部状态是name和src。借助对象池，实现了File类的复用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 对象池class ObjectPool &#123; constructor() &#123; this._pool = []; // &#125; // 创建对象 create(Obj) &#123; return this._pool.length === 0 ? new Obj(this) // 对象池中没有空闲对象，则创建一个新的对象 : this._pool.shift(); // 对象池中有空闲对象，直接取出，无需再次创建 &#125; // 对象回收 recover(obj) &#123; return this._pool.push(obj); &#125; // 对象池大小 size() &#123; return this._pool.length; &#125;&#125;// 模拟文件对象class File &#123; constructor(pool) &#123; this.pool = pool; &#125; // 模拟下载操作 download() &#123; console.log(`+ 从 $&#123;this.src&#125; 开始下载 $&#123;this.name&#125;`); setTimeout(() =&gt; &#123; console.log(`- $&#123;this.name&#125; 下载完毕`); // 下载完毕后, 将对象重新放入对象池 this.pool.recover(this); &#125;, 100); &#125;&#125;/****************** 以下是测试函数 **********************/let objPool = new ObjectPool();let file1 = objPool.create(File);file1.name = "文件1";file1.src = "https://download1.com";file1.download();let file2 = objPool.create(File);file2.name = "文件2";file2.src = "https://download2.com";file2.download();let file3 = objPool.create(File);file3.name = "文件3";file3.src = "https://download3.com";file3.download();setTimeout( () =&gt; console.log( `$&#123;"*".repeat(50)&#125;\n下载了3个文件，但其实只创建了$&#123;objPool.size()&#125;个对象` ), 1000);// 因为js是并发操作，所以创建3个对象，假如把file3这样写，就是创建2个，/*setTimeout(() =&gt; &#123; let file3 = objPool.create(File); file3.name = "文件3"; file3.src = "https://download3.com"; file3.download();&#125;, 200);*/ 优点 减少内存中对象的数量，使相同对象或相似对象在内存中只保存一份，降低系统的使用内存，提高性能 可以使外部状态相对独立，而且不会影响其内部状态，从而使享元对象可以在不同的环境中被共享 缺点 需要分离出内部状态和外部状态，使程序的逻辑复杂化 对象在缓冲池中的复用需要考虑线程问题]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构型-代理模式]]></title>
    <url>%2F2019%2F12%2F19%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%2F3.%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Proxy Pattern：为某个对象提供一个代理，并由这个代理对象控制对原有对象的访问。 消息队列就是这种模式 使用ES6提供了Proxy构造函数能够让我们轻松地使用代理模式 var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例 target参数表示所有拦截的目标对象 handler参数也是一个对象，用来定制拦截行为 123456789101112131415161718var target = &#123; name: 'wei'&#125;var logHandler = &#123; get: function(target, key) &#123; console.log(`$&#123;key&#125; 被读取`); return target[key]; &#125;, set:function(target, key, value) &#123; console.log(`$&#123;key&#125; 被设置为 $&#123;value&#125;`); target[key] = value; &#125;&#125;var targetWithLog = new Proxy(target, logHandler);targetWithLog.name; // name 被读取targetWithLog.name = 'zhang'; // name 被设置为 zhangconsole.log(target.name); // zhang 优点 降低了系统的耦合度 不同类型的代理可以让客户端对目标对象的访问进行不同的控制： 远程代理：让客户端可以访问在远程对象上的对象。远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求 虚拟代理：通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度 保护代理：可以控制客户端对真实对象的使用权限 缺点 由于增加了代理对象，可能会让客户端请求的速度变慢]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker]]></title>
    <url>%2F2019%2F12%2F17%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FDocker%2F</url>
    <content type="text"><![CDATA[Docker是什么一个开源的应用容器引擎，可从Docker Hub里下载需要的镜像，比如：mongoDB，使用一句简单的命令，就可以在Docker跑起来，类似于虚拟机。 可使用KBS管理Docker，比如Docker挂了，属于自动化运维的范畴，因为比较难，先只做了解。 与虚拟机的区别一个很典型的区别：Docker可以实现资源隔离，分多少内存就只用多少，不会吃其他地方的内存；而虚拟机即使你分了固定的内存，一旦内存泄漏，还是会吃其他地方的内存，然后卡死。 Mac安装123456789101112$ brew cask install docker==&gt; Creating Caskroom at /usr/local/Caskroom==&gt; We'll set permissions properly so we won't need sudo in the futurePassword: # 输入 macOS 密码==&gt; Satisfying dependencies==&gt; Downloading https://download.docker.com/mac/stable/21090/Docker.dmg######################################################################## 100.0%==&gt; Verifying checksum for Cask docker==&gt; Installing Cask docker==&gt; Moving App 'Docker.app' to '/Applications/Docker.app'.&amp;#x1f37a; docker was successfully installed! 在载入 Docker app 后，点击 Next，可能会询问你的 macOS 登陆密码，你输入即可。之后会弹出一个 Docker 运行的提示窗口，状态栏上也有有个小鲸鱼的图标（）。 例子：安装MongoDB镜像1. 拉取镜像先去Docker Hub搜索镜像，可以根据Tags选择版本，会有命令提示 1docker pull mongo 2. 查看本地镜像1docker images 3. 运行容器例如：mongoDB 12345678$ docker run -itd --name mongo -p 44:27017 mongo --authee91398c42556c3409fb8e69fc9df52b56678a930e28e65a40ae84b7eca68d53# 假如提示：docker: Error response from daemon: Conflict. The container name "/mongo" is already in use by container "c85def91c800e8dd8d3d05a858cffa0228d41db43651ebbbac4ecd853983afd7". You have to remove (or rename) that container to be able to reuse that name.# 使用rm删除容器$ docker rm mongo -p 27017:27017 ：映射容器服务的 44 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务 –auth：需要密码才能访问容器服务 4. 安装成功通过docker ps可以查看容器的运行信息 123$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESee91398c4255 mongo "docker-entrypoint.s…" About a minute ago Up About a minute 0.0.0.0:44-&gt;27017/tcp mongo Dockerfile 创建镜像 用来创建镜像的文本内容，文本内容包含一条条构建镜像所需的指令和说明 简单的案例1234567891011$ mkdir Dockerfile$ cd Dockerfile/$ vi Dockerfile/# 以下是内容FROM nginxRUN echo '&lt;h1&gt;hello, docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html$ docker build -t nginx:test .# 查看新建的镜像$ docker images 常用指令 RUN 在 docker build时运行 CMD 在docker run 时运行 12345678910111213141516171819202122# 基于centos镜像FROM centos# 维护人的信息MAINTAINER The CentOS Project &lt;303323496@qq.com&gt;# 安装httpd软件包RUN yum -y updateRUN yum -y install httpd# 开启80端口EXPOSE 80# 复制网站首页文件至镜像中web站点下ADD index.html /var/www/html/index.html# 复制该脚本至镜像中，并修改其权限ADD run.sh /run.shRUN chmod 775 /run.sh# 当启动容器时执行的脚本文件CMD ["/run.sh"] Dockerfile结构大致分为四个部分： 基础镜像信息 维护者信息 镜像操作指令 容器启动时执行指令 更详细的介绍，参考这篇文章：你必须知道的Dockerfile Docker常用命令123456789101112131415161718192021222324252627282930313233docker build -t friendlyname . # 使用此目录的“Dockerfile”创建镜像docker run -p 4000:80 friendlyname # 将4000 端口映射到80端口docker run -d -p 4000:80 friendlyname # 后台运行"friendlyname" 镜像并将4000 端口映射到80端口docker ps # 查看我们正在运行的容器docker stop &lt;hash&gt; # 停止指定的容器docker ps -a # 查看所有的容器，包括没有运行的容器docker kill &lt;hash&gt; # 强制关闭指定的容器docker rm &lt;hash&gt; # 删除指定的容器docker rm $(docker ps -a -q) # 删除所有容器 docker images -a # 查看所有镜像docker rmi &lt;imagename&gt; # 删除指定的镜像docker rmi $(docker images -q) # 删除所有的镜像docker login # 使用您的 Docker 凭证登录此 CLI 会话docker tag &lt;image&gt; username/repository:tag # 标记 &lt;image&gt; 以上传到镜像库docker push username/repository:tag # 将已标记的镜像上传到镜像库docker run username/repository:tag # 运行镜像库中的镜像docker info # 查看Docker信息]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结构型-外观模式]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%2F1.%20%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Facade Pattern：又叫门面模式，定义了一个高层接口，为子系统中的一组接口提供一个统一的接口。 使用经常用在做兼容的时候，将跨浏览器差异全部集中放置到一个外观模式实例中来提供一个对外接口。 123456789101112131415var addEvent = function( dom, type, fn )&#123; //对于支持DOM2级事件处理程序addEvenetListener方法的浏览器 if( dom.addEventListener )&#123; dom.addEventListener( type, fn, false ); &#125;else if( dom.attachEvent )&#123; dom.attachEvent( "on" + type, fn ); &#125;else&#123; dom[ on + "type" ] = fn; &#125;;&#125; var myp = document.getElementById('myp');addEvent(myp,'click',function()&#123; console.log('hahah');&#125;) 优点 解耦：用户无需知道子系统的接口，简化客户端调用子系统的调用过程，使得子系统使用起来更加容易。同时便于子系统的扩展和维护。 符合迪米特法则（最少知道原则）：子系统只需要将需要外部调用的接口暴露给外观类即可 缺点 违背了开闭原则：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端代码]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构型-装饰模式]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%BB%93%E6%9E%84%E5%9E%8B%2F2.%20%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Decorator Pattern：不改变原有对象的前提下，动态地给一个对象增加一些额外的功能。 运用了AOP设计思想，用途广泛，比如logger，防抖…给系统，函数扩展新功能，先拦截再处理。 使用现在Es7的一个提案：Decorator，Babel转码器已经支持。因为很多浏览器还不支持，在项目中，需要babel转化成Es5。 下面是vue项目中的使用： npm安装依赖 1npm install babel-core babel-loader babel-plugin-transform-decorators babel-plugin-transform-decorators-legacy babel-preset-env 配置.babelrc文件 1234&#123; "presets": ["env"], "plugins": ["transform-decorators-legacy"]&#125; 在webpack.config.js中添加babel-loader 12345module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, loader: "babel-loader" &#125; ],&#125; 如果为VsCode，可能还需要在项目根目录下添加以下tsconfig.json文件来组织一个ts检查的报错 123456789&#123; "compilerOptions": &#123; "experimentalDecorators": true, "allowJs": true, "lib": [ "es6" ], &#125;&#125; 举例借鉴淘宝前端团队写的文章：ES7 Decorator写了一下例子 下面实现，为钢铁侠装备盔甲（纯粹的装饰模式，不增加对原有类的接口）和增加飞行能力（半透明的装饰模式，有点像适配器模式） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 装备盔甲function decorateArmour(target, key, descriptor) &#123; // taget 装饰的对象，这里是 Man类 // key 被装饰的具体方法，这里是 init // descriptor 方法特性值的描述对象，这里返回的是 /*&#123; configurable: true enumerable: false value: ƒ init(def, atk, hp) writable: true __proto__: Object &#125; */ const method = descriptor.value; let moreDef = 100; let ret; descriptor.value = (...args) =&gt; &#123; args[0] += moreDef; ret = method.apply(target,args); return ret; &#125; return descriptor;&#125;// 增加飞行能力function addFly(canFly) &#123; return function(target) &#123; // target 装饰的对象，这里是 Man类 target.canFly = canFly; let extra = canFly ? '(增加飞行能力)' : ''; let method = target.prototype.toString; target.prototype.toString = (...args) =&gt; &#123; return method.apply(target.prototype, args) + extra; &#125; return target; &#125;&#125;@addFly(true)class Man &#123; constructor(def = 2, atk = 3, hp = 3) &#123; this.init(def, atk, hp); &#125; @decorateArmour init(def, atk, hp) &#123; this.def = def; // 防御值 this.atk = atk; // 攻击力 this.hp = hp; // 血量 &#125; toString() &#123; return `防御力:$&#123;this.def&#125;,攻击力:$&#123;this.atk&#125;,血量:$&#123;this.hp&#125;`; &#125;&#125;var tony = new Man();console.log(`tony:当前状态 ===&gt; `, tony.toString()); 优点 比继承灵活：继承是在编译器起作用，装饰者模式可以在运行时扩展一个对象的功能；另外也可以通过配置文件在运行时选择不同的装饰器，从而实现不同的行为；也通过不同的组合，实现不同的效果。 符合开闭原则：不用更改原有对象，只需要添加新的在装饰类，就可以达到增强的效果 缺点 需要创建一些具体装饰类，会增加系统的复杂度]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型-抽象工厂模式]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%2F3.%20%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 与工厂模式的区别抽象工厂模式中：生产产品的工厂是抽象的。比如，可口可乐生产可乐的同时，还要生产可口可乐的瓶子、箱子，百事可乐也一样，所以要把工厂抽象出来，专门生产同一主题的不同商品 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 可乐抽象类class Cola &#123; // &#125;// 瓶子抽象类class Bottle &#123; //&#125;// 箱子抽象类class Box &#123; //&#125;// 工厂抽象类class Factory &#123; creatCola() &#123; return new Cola(); &#125;&#125;// 可口可乐主题工厂class CocaColaFactory extends Factory &#123; creatCola() &#123; return new CocaCola(); &#125; creatBottle() &#123; return new CocaColaBottle(); &#125; creatBox() &#123; return new CocaColaBox(); &#125;&#125;// 可口可乐产品类class CocaCola extends Cola &#123; product (type) &#123; return `生产可口可乐` &#125;&#125;// 可口可乐瓶子类class CocaColaBottle extends Cola &#123; product (type) &#123; return `生产可口可乐瓶子` &#125;&#125;// 可口可乐箱子类class CocaColaBox extends Cola &#123; product (type) &#123; return `生产可口可乐箱子` &#125;&#125;// 百世可乐主题工厂class PesiColaFactory extends Factory &#123; creatCola() &#123; return new PesiCola(); &#125; creatBottle() &#123; return new PesiColaBottle(); &#125; creatBox() &#123; return new PesiColaBox(); &#125;&#125;// 百世可乐产品类class PesiCola extends Cola &#123; product (type) &#123; return `生产百世可乐` &#125;&#125;// 百世可乐瓶子类class PesiColaBottle extends Cola &#123; product (type) &#123; return `生产百世可乐瓶子` &#125;&#125;// 百世可乐箱子类class PesiColaBox extends Cola &#123; product (type) &#123; return `生产百世可乐箱子` &#125;&#125;// 生产可口可乐let cocaCola = new CocaColaFactory().creatCola();let cocaColaBottle = new CocaColaFactory().creatBottle();let cocaColaBox = new CocaColaFactory().creatBox();// 生产百世可乐let pesiCola = new PesiColaFactory().creatCola();let pesiColaBottle = new PesiColaFactory().creatBottle();let pesiColaBox = new PesiColaFactory().creatBox(); 优点 具有工厂模式的优点，还可以在类中对产品族进行约束，如果产品比较多，更应该使用抽象工厂模式而不是工厂模式（适合只要一个产品） 缺点 扩展性比较费力，尤其是系统比较庞大的时候，产品族需要增加一个新的产品，就要在工厂类进行修改]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型-生成器模式]]></title>
    <url>%2F2019%2F12%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%2F5.%20%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Builder Pattern：又叫创建者模式/建筑模式，构建复杂的对象模式，把对象的构建与表现分离，使得同样的构建过程可以创建不同的表示。 模式结构 builder 生成器：创建对象的各个组成部分 director 导向器：组装对象的各个组成部分 Product 对象，对象实例，不需要关心部分如何生成 使用1234567891011121314151617181920212223class Builder &#123; constructor(params) &#123; this.params = params; &#125; buildA() &#123; // 构建A部分 return this; &#125; buildB() &#123; // 构建B部分 return this; &#125;&#125;class Director &#123; constructor(params) &#123; const builder = new Builder(params); builder.buildA(); builder.buildB(); &#125;&#125;const product = new Director('params') 优点 构建与表现分离，代码可复用性强 扩展性强 缺点 如果产品之间的差异性大，则不适合使用这种模式 如果产品很复杂，可能会导致需要很多具体建造者来实现部分，导致系统很庞大]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router源码分析(base.js)]]></title>
    <url>%2F2019%2F12%2F17%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvue-router%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2F5.%20base.js%2F</url>
    <content type="text"><![CDATA[base.jssrc/history/base.js 定义了History类，VueRouter中的history，根据mode，可能是HTML5History、HashHistory或Abstract实例，其中HTML5History、HashHistory等都是继承自History类。 History类提供了一些路由操作的基本方法： Listen——监听callback onReady ——监听路由是否ready，ready时，将所有cb装进readyCbs列表 onError transitionTo ——路由的跳转，会判断跳转to的路径是否在路由表中：是，才进行组件替换，调用confirmTransition 1. constructor构造函数12345678910111213constructor(router: Router, base: ?string) &#123; // 获取当前router this.router = router; // 获取路由base this.base = normalizeBase(base); // 由createRoute生成的基础路由，path:'/' this.current = START; this.pending = null; this.ready = false; this.readyCbs = []; this.readyErrorCbs = []; this.errorCbs = [];&#125; 2. transitionTo路由跳转函数路由的跳转，会判断跳转to的路径是否在路由表中：是，才进行组件替换，调用confirmTransition 123456789101112131415161718192021222324252627282930313233343536373839404142434445transitionTo( location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; // 调用 match 得到匹配的 route 对象 const route = this.router.match(location, this.current); // 确认过渡 this.confirmTransition( route, () =&gt; &#123; // 更新路由信息，对组件的 _route 属性进行赋值，触发组件渲染 // 调用 afterHooks 中的钩子函数 this.updateRoute(route); // 添加 hashchange 监听 onComplete &amp;&amp; onComplete(route); // 子类实现的更新url地址 // 对于 hash 模式的话 就是更新 hash 的值 // 对于 history 模式的话 就是利用 pushstate / replacestate 来更新 // 更新 URL this.ensureURL(); // 只执行一次 ready 回调 if (!this.ready) &#123; this.ready = true; this.readyCbs.forEach(cb =&gt; &#123; cb(route); &#125;); &#125; &#125;, err =&gt; &#123; // 错误处理 if (onAbort) &#123; onAbort(err); &#125; if (err &amp;&amp; !this.ready) &#123; this.ready = true; this.readyErrorCbs.forEach(cb =&gt; &#123; cb(err); &#125;); &#125; &#125; );&#125; match路由匹配函数 src/create-matcher.js 先看如何匹配路由获得路由信息：判断两步，命名路由，非命名路由，因为带有params只能用命名路由引入，非命名路由不用判断parmas， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162function match(raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location): Route &#123; // 序列化 url // 比如对于该 url 来说 /abc?foo=bar&amp;baz=qux#hello // 会序列化路径为 /abc // 哈希为 #hello // 参数为 foo: 'bar', baz: 'qux' const location = normalizeLocation(raw, currentRoute, false, router); const &#123; name &#125; = location; // 如果是命名路由，就判断记录中是否有该命名路由配置 if (name) &#123; const record = nameMap[name]; if (process.env.NODE_ENV !== "production") &#123; warn(record, `Route with name '$&#123;name&#125;' does not exist`); &#125; // 没找到表示没有匹配的路由 if (!record) return _createRoute(null, location); // 获取所有必须的params。如果optional为true说明params不是必须的 const paramNames = record.regex.keys .filter(key =&gt; !key.optional) .map(key =&gt; key.name); // 参数处理 if (typeof location.params !== "object") &#123; location.params = &#123;&#125;; &#125; if (currentRoute &amp;&amp; typeof currentRoute.params === "object") &#123; for (const key in currentRoute.params) &#123; if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) &#123; location.params[key] = currentRoute.params[key]; &#125; &#125; &#125; location.path = fillParams( record.path, location.params, `named route "$&#123;name&#125;"` ); return _createRoute(record, location, redirectedFrom); &#125; else if (location.path) &#123; // 非命名路由处理 location.params = &#123;&#125;; for (let i = 0; i &lt; pathList.length; i++) &#123; // 查找记录 const path = pathList[i]; const record = pathMap[path]; // 如果匹配路由，则创建路由 // pathMap[path] = 路由记录 if (matchRoute(record.regex, location.path, location.params)) &#123; return _createRoute(record, location, redirectedFrom); &#125; &#125; &#125; // 没有匹配的路由 return _createRoute(null, location);&#125; _createRoute根据上面match函数条件的不同创建不同的路由 12345678910111213141516// 根据条件创建不同的路由function _createRoute(record: ?RouteRecord, location: Location, redirectedFrom?: Location): Route &#123; // 重定向和别名逻辑 if (record &amp;&amp; record.redirect) &#123; return redirect(record, redirectedFrom || location); &#125; if (record &amp;&amp; record.matchAs) &#123; return alias(record, location, record.matchAs); &#125; // 创建路由对象 return createRoute(record, location, redirectedFrom, router);&#125; createRoute创建路由对象src/util/route.js 12345678910111213141516171819202122232425262728293031323334353637383940414243export function createRoute( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter): Route &#123; const stringifyQuery = router &amp;&amp; router.options.stringifyQuery; // 克隆参数 let query: any = location.query || &#123;&#125;; try &#123; query = clone(query); &#125; catch (e) &#123;&#125; // 创建路由对象 const route: Route = &#123; name: location.name || (record &amp;&amp; record.name), meta: (record &amp;&amp; record.meta) || &#123;&#125;, path: location.path || "/", hash: location.hash || "", query, params: location.params || &#123;&#125;, fullPath: getFullPath(location, stringifyQuery), // 根据记录层级的得到所有匹配的 路由记录 matched: record ? formatMatch(record) : [] &#125;; if (redirectedFrom) &#123; route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery); &#125; // 让路由对象不可修改 return Object.freeze(route);&#125;// 获得包含当前路由的所有嵌套路径片段的路由记录// 包含从根路由到当前路由的匹配记录，从上至下function formatMatch(record: ?RouteRecord): Array&lt;RouteRecord&gt; &#123; const res = []; while (record) &#123; res.unshift(record); record = record.parent; &#125; return res;&#125; 3. confirmTransition确认过渡函数负责控制所有的路由守卫的执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051confirmTransition(route: Route, onComplete: Function, onAbort?: Function) &#123; const current = this.current; // 中断跳转路由函数 const abort = err =&gt; &#123; // after merging https://github.com/vuejs/vue-router/pull/2771 we // When the user navigates through history through back/forward buttons // we do not want to throw the error. We only throw it if directly calling // push/replace. That's why it's not included in isError if (!isExtendedError(NavigationDuplicated, err) &amp;&amp; isError(err)) &#123; if (this.errorCbs.length) &#123; this.errorCbs.forEach(cb =&gt; &#123; cb(err); &#125;); &#125; else &#123; warn(false, "uncaught error during route navigation:"); console.error(err); &#125; &#125; onAbort &amp;&amp; onAbort(err); &#125;; // 如果是相同 直接返回 if ( isSameRoute(route, current) &amp;&amp; // in the case the route map has been dynamically appended to route.matched.length === current.matched.length ) &#123; this.ensureURL(); return abort(new NavigationDuplicated(route)); &#125; // 下面分析 const &#123; updated, deactivated, activated &#125; = resolveQueue( this.current.matched, route.matched ); // 下面分析 const queue: Array&lt;?NavigationGuard&gt; = [].concat(...); // 下面分析 const iterator = (hook: NavigationGuard, next) =&gt; &#123; // ... &#125;; // 下面分析 runQueue(queue, iterator, () =&gt; &#123; // ... &#125;); &#125; 路由守卫的原理和组件的生命周期的钩子不同，路由守卫将重点放在路由上，能够控制路由跳转，一般用在页面级别的路由跳转时控制跳转的逻辑，比如在路由守卫中检查用户是否有进入当前页面的权限，没有则跳转到授权页面，亦或是在离开页面时警告用户有未确认的信息，确认后才能跳转等等 在路由守卫中，一般会接收3个参数，to，from，next，前两个分别是跳转后和跳转前页面路由的 $route 对象，第三个参数 next 是一个函数，当执行 next 函数后会进行跳转，如果一个包含 next 参数的路由守卫里没有执行该函数，页面会无法跳转。 resolveQueue函数 获取所有需要激活、更新、销毁的路由1234const &#123; updated, deactivated, activated &#125; = resolveQueue( this.current.matched, route.matched); 根据跳转前和跳转后的route对象的matched数组(当前 $route 对象以及所有父级的路由记录)，返回这2个数组包含的路由记录的区别 12345678910111213141516171819202122232425function resolveQueue( current: Array&lt;RouteRecord&gt;, next: Array&lt;RouteRecord&gt;): &#123; updated: Array&lt;RouteRecord&gt;, activated: Array&lt;RouteRecord&gt;, deactivated: Array&lt;RouteRecord&gt;&#125; &#123; let i; const max = Math.max(current.length, next.length); for (i = 0; i &lt; max; i++) &#123; // 当前路由路径和跳转路由路径不同时跳出遍历 if (current[i] !== next[i]) &#123; break; &#125; &#125; return &#123; // 可复用的组件对应路由 updated: next.slice(0, i), // 需要渲染的组件对应路由 activated: next.slice(i), // 失活的组件对应路由 deactivated: current.slice(i) &#125;;&#125; queue函数 获取所有需要执行的路由守卫数组中的守卫排列顺序是设计好的，对应vue-router官方文档中提到的路由导航解析流程 导航被触发 在失活的组件里调用离开守卫 调用全局的beforeEach守卫 在重用的组件里调用beforeRouteUpdate守卫(2.2+) 在路由配置里调用beforeEnter 解析异步路由组件 在被激活的组件里调用beforeRouteEnter 调用全局的beforeResolve守卫(2.5) 导航被确认 调用全局的afterEach钩子 触发DOM更新 用创建好的实例调用beforeRouteEnter守卫中传给next的回调函数 12345678910111213141516171819/* NavigationGuard是一个标准的路由守卫的签名，经过 queue 数组内部这些函数的转换最终会返回路由守卫组成的数组 declare type NavigationGuard = ( to: Route, from: Route, next: (to?: RawLocation | false | Function | void) =&gt; void ) =&gt; any */const queue: Array&lt;?NavigationGuard&gt; = [].concat( // 返回离开组件的 beforeRouteLeave 钩子函数 （数组：子 =&gt; 父） extractLeaveGuards(deactivated), // 返回路由实例（全局）的 beforeEach 钩子函数 （数组） this.router.beforeHooks, // 返回当前组件的 beforeRouteUpdate 钩子函数 （数组：父 =&gt; 子） extractUpdateHooks(updated), // 返回当前组件的 beforeEnter 钩子函数 （数组） activated.map(m =&gt; m.beforeEnter), // 解析异步路由组件（同样会返回一个导航守卫函数的签名，但是用不到 to,from 这两个参数） resolveAsyncComponents(activated)); 分析：extractLeaveGuards执行函数先分析queue数组里的第一个执行函数extractLeaveGuards，经过一层封装，最终会执行通用函数extractGuards 123456789101112131415161718192021222324252627282930/*** @records 删除的路由记录** @name beforeRouteLeave，即最终触发的是beforeRouteLeave守卫*/function extractGuards(records: Array&lt;RouteRecord&gt;, name: string, bind: Function, reverse?: boolean): Array&lt;?Function&gt; &#123; /* ** @def 视图名对应的组件配置项（因为 vue-router 支持命名视图所以可能会有多个视图名，大部分情况为 default，及使用默认视图），当是异步路由时，def为异步返回路由的函数 ** @instance 组件实例 ** @match 当前遍历到的路由记录 ** @key 视图名 */ const guards = flatMapComponents(records, (def, instance, match, key) =&gt; &#123; // 找出组件中对应的钩子函数 const guard = extractGuard(def, name); if (guard) &#123; // 给每个钩子函数添加上下文对象为组件自身 return Array.isArray(guard) ? guard.map(guard =&gt; bind(guard, instance, match, key)) : bind(guard, instance, match, key); &#125; &#125;);// 数组降维，并且判断是否需要翻转数组// 因为某些钩子函数需要从子执行到父return flatten(reverse ? guards.reverse() : guards);&#125; flatMapComponents通用函数：遍历records数组，每次执行第二个回调函数，类似于数组的map方法 在回调函数内部会执行extractGuard函数 12345678910function extractGuard( def: Object | Function, key: string): NavigationGuard | Array&lt;NavigationGuard&gt; &#123; if (typeof def !== "function") &#123; // extend now so that global mixins are applied. def = _Vue.extend(def); &#125; return def.options[key];&#125; def为组件配置项，通过Vue核心库的函数extend将配置项转为组件构造器（虽然配置项中就能拿到对应的路由守卫，但是官方注释只有转为构造器后才能拿到一些全局混入的钩子），在生成构造器时，Vue会将配置项赋值给构造器的静态属性options，最后返回配置项中对应的路由守卫函数，即如果我们在跳转后的组件中定义了beforeRouteLeave 的话这里就会返回这个函数 最后拿到返回值guard后会经过一层处理，例如扁平化，绑定this指向；根据reverse参数决定是否要反转数组（因为matched中路由记录顺序是父=》子，而beforeRouteLeave 需要从最里层子组件触发，所以需要进行反转保证守卫触发顺序） 分析：resolveAsyncComponents解析异步组件 异步组件：通俗来说，是指使用路由懒加载返回的路由，我们可以使用import()去动态加载 JS 文件，放到 vue-router 中，实现异步加载组件配置项 component: ()=&gt;import(&#39;./components/comp1) resolveAsyncComponents函数最终会返回一个函数，并且符合路由守卫的函数签名（可能只是为了保证返回函数的一致性，实质上在这个函数中，并不会用到 to from 这两个参数） 这个函数只是被定义了，并没有执行 首先通过flatMapComponents遍历新增的路由记录，每次遍历都执行第二个回调函数 在回调函数里，会定义一个resolve函数，当异步组件加载完成后，会通过 then 的形式解析 promise，最终会调用 resolve函数并传入异步组件的配置项作为参数，resolve函数接收到组件配置项后会像 Vue 中一样将配置项转为构造器，同时将值赋值给当前路由记录的 components 属性中（key 属性默认为 default） 另外resolveAsyncComponents函数会通过闭包保存一个 pending 变量：代表接收的异步组件数量，在flatMapComponents遍历的过程中，每次会将 pending 加一，而当异步组件被解析完毕后，再将 pending 减一，当 pending 为0时，代表异步组件全部解析完成，随即执行 next 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export function resolveAsyncComponents(matched: Array&lt;RouteRecord&gt;): Function &#123; return (to, from, next) =&gt; &#123; let hasAsync = false; let pending = 0; let error = null; flatMapComponents(matched, (def, _, match, key) =&gt; &#123; // vue-router 没使用 Vue 核心库解析异步组件的函数，原因是希望能够实现停止路由跳转知道懒加载的组件被解析成功 // 判断是否是异步组件 if (typeof def === "function" &amp;&amp; def.cid === undefined) &#123; hasAsync = true; pending++; // 成功回调 // once 函数确保异步组件只加载一次 const resolve = once(resolvedDef =&gt; &#123; if (isESModule(resolvedDef)) &#123; resolvedDef = resolvedDef.default; &#125; // 判断是否是构造函数 // 不是的话通过 Vue 来生成组件构造函数 def.resolved = typeof resolvedDef === "function" ? resolvedDef : _Vue.extend(resolvedDef); // 赋值组件 // 如果组件全部解析完毕，继续下一步 match.components[key] = resolvedDef; pending--; if (pending &lt;= 0) &#123; next(); &#125; &#125;); // 失败回调 const reject = once(reason =&gt; &#123; const msg = `Failed to resolve async component $&#123;key&#125;: $&#123;reason&#125;`; process.env.NODE_ENV !== "production" &amp;&amp; warn(false, msg); if (!error) &#123; error = isError(reason) ? reason : new Error(msg); next(error); &#125; &#125;); let res; try &#123; // 执行异步组件函数 res = def(resolve, reject); &#125; catch (e) &#123; reject(e); &#125; if (res) &#123; // 下载完成执行回调 if (typeof res.then === "function") &#123; res.then(resolve, reject); &#125; else &#123; // new syntax in Vue 2.3 const comp = res.component; if (comp &amp;&amp; typeof comp.then === "function") &#123; comp.then(resolve, reject); &#125; &#125; &#125; &#125; &#125;); // 不是异步组件直接下一步 if (!hasAsync) next(); &#125;;&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型-工厂方法模式]]></title>
    <url>%2F2019%2F12%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%2F2.%20%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Factory Method Pattern：又称工厂模式，不同的工厂子类创建不同的产品对象。 与简单工厂的区别简单工厂是一个工厂生产不同的产品，工厂模式是对工厂抽象化，不同的产品由专门的具体工厂来生产。比如可口可乐工厂专门生产可口可乐 使用123456789101112131415161718192021222324252627282930313233343536373839404142// 可乐抽象类class Cola &#123; // &#125;// 工厂抽象类class Factory &#123; creatCola() &#123; return new Cola(); &#125;&#125;// 可口可乐工厂class CocaColaFactory extends Factory &#123; creatCola() &#123; return new CocaCola(); &#125;&#125;// 可口可乐产品类class CocaCola extends Cola &#123; product (type) &#123; return `生产可口可乐` &#125;&#125;// 百世可乐工厂class PesiColaFactory extends Factory &#123; creatCola() &#123; return new PesiCola(); &#125;&#125;// 百世可乐产品类class PesiCola extends Cola &#123; product (type) &#123; return `生产百世可乐` &#125;&#125;// 生产可口可乐let cocaCola = new CocaColaFactory().creatCola();// 生产百世可乐let pesiCola = new PesiColaFactory().creatCola(); 优点 用户不需要关系产品的创建细节，也不需要知道具体产品类的类名，只需要关心其所需产品对应的具体工厂是哪一个即可 当系统加入新产品，只需要添加一个具体工厂和其对应的具体产品即可，符合开闭原则 缺点 当添加新产品时，需要提供新的产品类和具体工厂类，因此系统中类的个数成对增加，增加了系统的复杂度]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router源码分析(VueRouter内部方法)]]></title>
    <url>%2F2019%2F12%2F16%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvue-router%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2F3.%20%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[VueRouter内部方法 1. match使用：this.$router.match(&#39;/count&#39;) 输入参数raw（/user/4739284722这种形式,类似route的path），current，redirectedFrom，结果返回匹配route 123match(raw: RawLocation, current?: Route, redirectedFrom?: Location): Route &#123; return this.matcher.match(raw, current, redirectedFrom);&#125; 2. currentRoute使用：this.$router.currentRoute用于获取当前history.current，也就是当前route，包括path、component、meta等 123get currentRoute(): ?Route &#123; return this.history &amp;&amp; this.history.current;&#125; 3. init4. 全局路由钩子在路由切换时被调用，经常在router/index.js中，进行路由守卫：router.beforeEach((to,from,next)=&gt;{}) 1234567891011121314// 将回调方法fn注册到beforeHooks里。registerHook会返回，fn执行后的callback方法，功能是将fn从beforeHooks删除beforeEach(fn: Function): Function &#123; return registerHook(this.beforeHooks, fn);&#125;// 将回调方法fn注册到resolveHooks里。registerHook会返回，fn执行后的callback方法，功能是将fn从resolveHooks删除beforeResolve(fn: Function): Function &#123; return registerHook(this.resolveHooks, fn);&#125;// 将回调方法fn注册到afterHooks里。registerHook会返回，fn执行后的callback方法，功能是将fn从afterHooks删除afterEach(fn: Function): Function &#123; return registerHook(this.afterHooks, fn);&#125; registerHook将callback（参数fn）插入list，返回一个方法，方法实现的是从list中删除fn。也就是在callback执行后，通过调用这个方法，可以将fn从list中移除 1234567function registerHook(list: Array&lt;any&gt;, fn: Function): Function &#123; list.push(fn); return () =&gt; &#123; const i = list.indexOf(fn); if (i &gt; -1) list.splice(i, 1); &#125;;&#125; 5. 改变路由1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 将回调方法fn注册到afterHooks里。registerHook会返回，fn执行后的callback方法，功能是将fn从afterHooks删除afterEach(fn: Function): Function &#123; return registerHook(this.afterHooks, fn);&#125;// 添加一个回调函数，它会在首次路由跳转完成时被调用，此方法通常用于等待异步的导航钩子完成，比如在进行服务端渲染中onReady(cb: Function, errorCb?: Function) &#123; this.history.onReady(cb, errorCb);&#125;// 报错onError(errorCb: Function) &#123; this.history.onError(errorCb);&#125;// 新增路由跳转push(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; // $flow-disable-line if (!onComplete &amp;&amp; !onAbort &amp;&amp; typeof Promise !== "undefined") &#123; return new Promise((resolve, reject) =&gt; &#123; this.history.push(location, resolve, reject); &#125;); &#125; else &#123; this.history.push(location, onComplete, onAbort); &#125;&#125;// 路由替换replace(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; // $flow-disable-line if (!onComplete &amp;&amp; !onAbort &amp;&amp; typeof Promise !== "undefined") &#123; return new Promise((resolve, reject) =&gt; &#123; this.history.replace(location, resolve, reject); &#125;); &#125; else &#123; this.history.replace(location, onComplete, onAbort); &#125;&#125;// 前进n条路由go(n: number) &#123; this.history.go(n);&#125;// 后退一步back() &#123; this.go(-1);&#125;// 前进一步forward() &#123; this.go(1);&#125; 6. getMatchedComponents使用：this.$router.getMatchedComponents(&quot;/&quot;)或者this.$router.getMatchedComponents({path: &quot;/count&quot;,name: &quot;count&quot;})，返回匹配的组件 123456789101112131415161718getMatchedComponents(to?: RawLocation | Route): Array&lt;any&gt; &#123; const route: any = to ? to.matched ? to : this.resolve(to).route: this.currentRoute;if (!route) &#123; return [];&#125;return [].concat.apply( [], route.matched.map(m =&gt; &#123; return Object.keys(m.components).map(key =&gt; &#123; return m.components[key]; &#125;); &#125;));&#125; resolve如果this.$router.getMatchedComponents(&quot;/&quot;)参数是个path，会来到这里解析 123456789101112131415161718192021222324252627resolve( to: RawLocation, current?: Route, append?: boolean): &#123; location: Location, route: Route, href: string, // for backwards compat normalizedTo: Location, resolved: Route&#125; &#123; current = current || this.history.current; const location = normalizeLocation(to, current, append, this); const route = this.match(location, current); const fullPath = route.redirectedFrom || route.fullPath; const base = this.history.base; const href = createHref(base, fullPath, this.mode); return &#123; location, route, href, // for backwards compat normalizedTo: location, resolved: route &#125;;&#125; creatHref建立路由在浏览器中显示的格式 1234function createHref(base: string, fullPath: string, mode) &#123; var path = mode === "hash" ? "#" + fullPath : fullPath; return base ? cleanPath(base + "/" + path) : path;&#125; 7. addRoutes动态新增路由 1234567addRoutes(routes: Array&lt;RouteConfig&gt;) &#123; this.matcher.addRoutes(routes); // START是啥？？？？？？？ if (this.history.current !== START) &#123; this.history.transitionTo(this.history.getCurrentLocation()); &#125;&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router源码分析(路由初始化)]]></title>
    <url>%2F2019%2F12%2F16%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvue-router%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2F2.%E8%B7%AF%E7%94%B1%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[路由初始化进行路由的跳转，改变URL，渲染对应的组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859init(app: any /* Vue component instance */) &#123; // assert是个断言，测试install.installed是否为真，为真，则说明vueRouter已经安装了 process.env.NODE_ENV !== "production" &amp;&amp; assert( install.installed, `not installed. Make sure to call \`Vue.use(VueRouter)\` ` + `before creating root instance.` ); // 保存组件实例：将vue实例推到apps列表中，install里面最初是将vue根实例推进去的 this.apps.push(app); // set up app destroyed handler // https://github.com/vuejs/vue-router/issues/2639 // app被destroyed时候，会$emit ‘hook:destroyed’事件，监听这个事件，执行下面方法 // 从apps 里将app移除 app.$once("hook:destroyed", () =&gt; &#123; // clean out app from this.apps array once destroyed const index = this.apps.indexOf(app); if (index &gt; -1) this.apps.splice(index, 1); // ensure we still have a main app or null if no apps // we do not release the router so it can be reused if (this.app === app) this.app = this.apps[0] || null; &#125;); // 如果根组件已经有了就返回 if (this.app) &#123; return; &#125; // 赋值路由模式 this.app = app; const history = this.history; // 判断路由模式，并根据不同路由模式进行跳转。hashHistory需要监听hashchange和popshate两个事件，而html5History监听popstate事件 if (history instanceof HTML5History) &#123; history.transitionTo(history.getCurrentLocation()); &#125; else if (history instanceof HashHistory) &#123; // 添加 hashchange 监听 const setupHashListener = () =&gt; &#123; history.setupListeners(); &#125;; // 路由跳转 history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ); &#125; // 该回调会在 transitionTo 中调用 // 对组件的 _route 属性进行赋值，触发组件渲染；且将apps中的组件的_route全部更新至最新的 history.listen(route =&gt; &#123; this.apps.forEach(app =&gt; &#123; app._route = route; &#125;); &#125;);&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型-简单工厂模式]]></title>
    <url>%2F2019%2F12%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%2F1.%20%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Simple Factory Pattern：专门定义一个工厂类负责管理创建其他类的实例。根据创建方法的参数返回不同类的实例，被创建的实例通常具有共同的父类。 使用1234567891011121314151617181920212223242526272829303132333435// 可乐抽象类class Cola &#123; // &#125;// 可口可乐产品类class CocaCola extends Cola &#123; product (type) &#123; return `生产可口可乐` &#125;&#125;// 百世可乐产品类class PesiCola extends Cola &#123; product (type) &#123; return `生产百世可乐` &#125;&#125;// 简单工厂实现class SimpleFactory &#123; createColaWithType(type) &#123; switch (type) &#123; case 0: return new CocaCola(); case 1: return new PesiCola(); default: break; &#125; &#125;&#125;// 生产可口可乐let cocaCola = new SimpleFactory().createColaWithType(0);// 生产百世可乐let pesiCola = new SimpleFactory().createColaWithType(1); 优点 使用者只需要给工厂类传入一个约定好的参数，就能获取到想要的对象，不需要知道其创建的细节，一定程度上减少系统的耦合 客户端只需要知道具体产品类对应的参数即可，减少开发者的记忆成本 缺点 如果业务上需要添加新产品，需要修改工厂类原有的判断逻辑，违背开闭原则 产品类型较多的情况下，有可能造成工厂逻辑过于复杂，简单工厂类型适合产品种类少且增加的概率低的情况]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router源码分析(实例化)]]></title>
    <url>%2F2019%2F12%2F13%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvue-router%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2F4.%20VueRouter%20%E5%AE%9E%E4%BE%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[VueRouter 构造函数创建一个路由匹配对象，根据mode来采取不同的路由方式 1234567891011121314151617181920212223242526272829303132333435363738constructor(options: RouterOptions = &#123;&#125;) &#123; this.app = null; this.apps = []; this.options = options; this.beforeHooks = []; this.resolveHooks = []; this.afterHooks = []; // 创建路由匹配对象 this.matcher = createMatcher(options.routes || [], this); // 根据 mode 采取不同的路由方式 let mode = options.mode || "hash"; this.fallback = mode === "history" &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false; if (this.fallback) &#123; mode = "hash"; &#125; if (!inBrowser) &#123; mode = "abstract"; &#125; this.mode = mode; switch (mode) &#123; case "history": this.history = new HTML5History(this, options.base); break; case "hash": this.history = new HashHistory(this, options.base, this.fallback); break; case "abstract": this.history = new AbstractHistory(this, options.base); break; default: if (process.env.NODE_ENV !== "production") &#123; assert(false, `invalid mode: $&#123;mode&#125;`); &#125; &#125;&#125; 1. createMatcher 创建匹配函数匹配函数是由 src/create-matcher.js 中的 createMatcher 创建的： 根据传入的 routes 配置生成对应的路由 map，然后直接返回了 match 匹配函数和添加路由的函数addRoutes 123456789101112131415161718192021222324252627282930313233343536373839/* @flow */// ... import &#123; createRouteMap &#125; from "./create-route-map";// ...export function createMatcher(routes: Array&lt;RouteConfig&gt;, router: VueRouter): Matcher &#123; // 创建路由映射表 const &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes); function addRoutes(routes) &#123; // ... &#125; // 路由匹配 function match(raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location): Route &#123; // ... &#125; function redirect(record: RouteRecord, location: Location): Route &#123; // ... &#125; function alias(record: RouteRecord, location: Location, matchAs: string): Route &#123; // ... &#125; // 根据条件创建不同的路由 function _createRoute(record: ?RouteRecord, location: Location, redirectedFrom?: Location): Route &#123; // ... &#125; return &#123; match, addRoutes &#125;;&#125; 2. createRouteMap 创建路由映射函数 src/create-route-map.js 根据传入的 routes 配置生成对应的路由 map 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export function createRouteMap(routes: Array&lt;RouteConfig&gt;, oldPathList?: Array&lt;string&gt;, oldPathMap?: Dictionary&lt;RouteRecord&gt;, oldNameMap?: Dictionary&lt;RouteRecord&gt;): &#123; pathList: Array&lt;string&gt;, pathMap: Dictionary&lt;RouteRecord&gt;, nameMap: Dictionary&lt;RouteRecord&gt;&#125; &#123; // 创建映射表 const pathList: Array&lt;string&gt; = oldPathList || []; // path 路由 map const pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || Object.create(null); // name 路由 map const nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || Object.create(null); // 遍历路由配置，为每个配置添加路由记录 routes.forEach(route =&gt; &#123; addRouteRecord(pathList, pathMap, nameMap, route); &#125;); // 确保通配符在最后 for (let i = 0, l = pathList.length; i &lt; l; i++) &#123; if (pathList[i] === "*") &#123; pathList.push(pathList.splice(i, 1)[0]); l--; i--; &#125; &#125; if (process.env.NODE_ENV === "development") &#123; // warn if routes do not include leading slashes const found = pathList // check for missing leading slash .filter(path =&gt; path &amp;&amp; path.charAt(0) !== "*" &amp;&amp; path.charAt(0) !== "/"); if (found.length &gt; 0) &#123; const pathNames = found.map(path =&gt; `- $&#123;path&#125;`).join("\n"); warn( false, `Non-nested routes must include a leading slash character. Fix the following routes: \n$&#123;pathNames&#125;` ); &#125; &#125; return &#123; pathList, pathMap, nameMap &#125;;&#125; addRouteRecord添加路由记录函数给routes里的每个route添加路由记录； 如果route有children，给每个child添加路由记录； 如果路由有别名的话，给别名也添加路由记录; 建立pathMap，nameMap映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129function addRouteRecord( pathList: Array&lt;string&gt;, pathMap: Dictionary&lt;RouteRecord&gt;, nameMap: Dictionary&lt;RouteRecord&gt;, route: RouteConfig, parent?: RouteRecord, matchAs?: string) &#123; // 获得路由配置下的属性 const &#123; path, name &#125; = route; if (process.env.NODE_ENV !== "production") &#123; assert(path != null, `"path" is required in a route configuration.`); assert( typeof route.component !== "string", `route config "component" for path: $&#123;String( path || name )&#125; cannot be a ` + `string id. Use an actual component instead.` ); &#125; // 编译正则的选项 const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || &#123;&#125;; // 格式化 url，会删除末尾的/，如果route是子级，会连接父级和子级的path，形成一个完整的path const normalizedPath = normalizePath( path, parent, pathToRegexpOptions.strict ); // 匹配规则是否大小写敏感？(默认值：false) if (typeof route.caseSensitive === "boolean") &#123; pathToRegexpOptions.sensitive = route.caseSensitive; &#125; // 生成记录对象 const record: RouteRecord = &#123; path: normalizedPath, regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), components: route.components || &#123; default: route.component &#125;, instances: &#123;&#125;, name, parent, matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || &#123;&#125;, props: route.props == null ? &#123;&#125; : route.components ? route.props : &#123; default: route.props &#125; &#125;; if (route.children) &#123; // 递归路由配置的 children 属性，添加路由记录 if (process.env.NODE_ENV !== "production") &#123; if ( route.name &amp;&amp; !route.redirect &amp;&amp; route.children.some(child =&gt; /^\/?$/.test(child.path)) ) &#123; warn( false, `Named Route '$&#123;route.name&#125;' has a default child route. ` + `When navigating to this named route (:to="&#123;name: '$&#123;route.name&#125;'"), ` + `the default child route will not be rendered. Remove the name from ` + `this route and use the name of the default child route for named ` + `links instead.` ); &#125; &#125; route.children.forEach(child =&gt; &#123; // matchAs 路由别名 const childMatchAs = matchAs ? cleanPath(`$&#123;matchAs&#125;/$&#123;child.path&#125;`) : undefined; addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs); &#125;); &#125; if (!pathMap[record.path]) &#123; pathList.push(record.path); pathMap[record.path] = record; &#125; // 如果路由有别名的话 // 给别名也添加路由记录 if (route.alias !== undefined) &#123; const aliases = Array.isArray(route.alias) ? route.alias : [route.alias]; for (let i = 0; i &lt; aliases.length; ++i) &#123; const alias = aliases[i]; if (process.env.NODE_ENV !== "production" &amp;&amp; alias === path) &#123; warn( false, `Found an alias with the same value as the path: "$&#123;path&#125;". You have to remove that alias. It will be ignored in development.` ); // skip in dev to make it work continue; &#125; const aliasRoute = &#123; path: alias, children: route.children &#125;; addRouteRecord( pathList, pathMap, nameMap, aliasRoute, parent, record.path || "/" // matchAs ); &#125; &#125; // 命名路由添加记录 if (name) &#123; if (!nameMap[name]) &#123; nameMap[name] = record; &#125; else if (process.env.NODE_ENV !== "production" &amp;&amp; !matchAs) &#123; warn( false, `Duplicate named routes definition: ` + `&#123; name: "$&#123;name&#125;", path: "$&#123;record.path&#125;" &#125;` ); &#125; &#125;&#125; normalizePath函数格式化 url，会删除末尾的/，如果route是子级，会连接父级和子级的path，形成一个完整的path 12345678910function normalizePath( path: string, parent?: RouteRecord, strict?: boolean): string &#123; if (!strict) path = path.replace(/\/$/, ""); if (path[0] === "/") return path; if (parent == null) return path; return cleanPath(`$&#123;parent.path&#125;/$&#123;path&#125;`);&#125; cleanPath函数双斜杠全局替换成单斜杠 123export function cleanPath(path: string): string &#123; return path.replace(/\/\//g, "/");&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router源码分析(路由注册)]]></title>
    <url>%2F2019%2F12%2F13%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvue-router%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2F1.%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[路由注册/src/install.js 首先先看 install 函数，Vue.use()注册插件时会找到这个install函数进行执行。 作用： 给组件混入钩子函数和全局注册两个路由组件 注意在这里，所有Vue组件的_router都是同一个Vue-router实例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// router-view router-link 组件import View from "./components/view";import Link from "./components/link";// export 一个 Vue 引用export let _Vue;// 安装函数export function install(Vue) &#123; // 确保 install 调用一次 if (install.installed &amp;&amp; _Vue === Vue) return; install.installed = true; // 把 Vue 赋值给全局变量 _Vue = Vue; const isDef = v =&gt; v !== undefined; // 从父节点拿到registerRouteInstance，注册路由实例 const registerInstance = (vm, callVal) =&gt; &#123; let i = vm.$options._parentVnode; // 这是一个类似链式调用的方式 // 目的是确保能确定到this.$options._parentVnode.data.registerRouteInstance是不是存在？ // 如果找到了那么就自然而然的把i赋值为这个方法，然后执行它 if ( isDef(i) &amp;&amp; isDef((i = i.data)) &amp;&amp; isDef((i = i.registerRouteInstance)) ) &#123; i(vm, callVal); &#125; &#125;; // 给每个组件的 `beforeCreate`钩子函数 混入实现 // 初始化路由 Vue.mixin(&#123; beforeCreate() &#123; // this.$options.router存在吗？==》 是不是已经绑定_routerRoot的根节点，只有根节点有this.$options.router if (isDef(this.$options.router)) &#123; // 根节点的_routerRoot就是根节点的vue component this._routerRoot = this; // 赋值 _router this._router = this.$options.router; // 初始化路由 this._router.init(this); // 监控 router数据变化，这里为更新router-view Vue.util.defineReactive(this, "_route", this._router.history.current); &#125; else &#123; // 如果没有这个属性 ==》 两种情况 还没绑定这个属性的根节点、不是根节点 // 未绑定属性的根节点组件，（根节点组件怎么会有爸爸呢）它不存在$parent属性、所以还是指向了自己 // 不是根节点组件，那就找它爸爸的_routerRoot属性，用它爸爸的 // vue的子组件beforeCreate肯定晚于父组件beforeCreate所以 // 所有的组件就像一棵组件树以一样大家，从根向所有树枝树杈去传递这个属性 // 大家都是用一个属性所以每个组件的_routerRoot都是根节点组件 this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this; &#125; registerInstance(this, this); &#125;, destroyed() &#123; registerInstance(this); &#125; &#125;); // 注入 $router Object.defineProperty(Vue.prototype, "$router", &#123; get() &#123; return this._routerRoot._router; &#125; &#125;); // 注入 $route Object.defineProperty(Vue.prototype, "$route", &#123; get() &#123; return this._routerRoot._route; &#125; &#125;); // 全局注册组件 router-link 和 router-view Vue.component("RouterView", View); Vue.component("RouterLink", Link); const strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;&#125; 为啥要 export 一个 Vue 引用？ 插件在打包的时候是肯定不希望把 vue 作为一个依赖包打进去的，但是呢又希望使用 Vue 对象本身的一些方法，此时就可以采用上边类似的做法，在 install 的时候把这个变量赋值 Vue ，这样就可以在其他地方使用 Vue 的一些方法而不必引入 vue 依赖包（前提是保证 install 后才会使用）。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-UML类图]]></title>
    <url>%2F2019%2F12%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言介绍UML类图的几个概念 1. 继承用一条带空心箭头的直线表示 2. 实现用一条带空心箭头的虚线表示 3. 组合表示整体由部分构成的语义，是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了 4. 聚合表示整体由部分构成的语义，例如一个部门由多个员工组成。与组合关系不同的是，整体和部分不是强依赖的，即整体不存在了，部分仍然存在 5. 关联用一条直线表示，描述不同类的对象之间的结构关系，它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的。它一般用来定义对象之间静态的、天然的结构， 所以，关联关系是一种“强关联”的关系。 比如，乘车人和车票之间就是一种关联关系，学生和学校就是一种关联关系，关联关系默认不强调方向，表示对象间相互知道。 6. 依赖用一套带箭头的虚线表示，如A依赖于B，他描述一个对象在运行期间会用到另一个对象的关系。 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化。显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[设计模式-六大原则+模块分类]]></title>
    <url>%2F2019%2F12%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2B%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[前言介绍设计模式的六大原则与模块分类 六大原则1. 开闭原则 对扩展开放，对修改关闭，即软件实体应尽量在不修改原有代码的情况下进行扩展 2. 里氏替换原则 所有引用基类对象的地方能够透明地使用其子类的对象 是实现 开闭原则 的重要方式之一，在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，对子类对象来替换父类对象 3. 依赖倒置原则 抽象不应该依赖具体类，具体类应当依赖于抽象 在程序中尽量使用抽象层进行编程，将具体类写在配置文件中。如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，无需修改原有系统的源代码，满足开闭原则的要求 4. 单一职责原则 一个类(大到模块，小到方法)只负责一个功能领域中的相应职责 5. 迪米特法则（最少知道原则） 一个软件实体应当尽可能少地与其他实体发生相互作用 需要注意： 在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，越有利于复用 在类的结构设计上，每个类都应当尽量降低其成员变量和成员函数的访问权限 在类的设计上，只要有可能，一个类型应当设计成不变类。 对其他类的引用上，一个对象对其他对象的引用应当降到最低 6. 接口分离原则 使用多个专门的接口，而不使用单一的总接口 需要注意控制接口的粒度： 接口不能太小，如果太小会导致系统中接口泛滥，不利于维护 接口也不能太大 总结里氏替换原则、依赖倒置原则是开闭原则的实现，结合6个原则看，我们在编程中最好都是抽象，低耦合，细微粒度 模式分类 创建型 主要用于描述如何创建对象 结构型 主要用于描述如何实现类或对象的组合 行为型 主要用于描述类或对象怎样交互及怎样分配职责 根据某个模式主要用于处理类之间的关系还是对象之间的关系，还可以分为：类模式、对象模式 经常将两种分类方式结合使用，如单例模式是对象创建型模式，模块方法模式是类行为型模式 1. 创建型 主要用于描述如何创建对象。将模块中对象的创建和对象的使用分离。外界只需要知道接口，不需要知道具体的实现细节，符合单一职责原则 简单工厂模式 工厂方法模式 抽象工厂模式 单例模式 生成器模式 原型模式 2. 结构型 主要用于描述如何实现类或对象的组合。 类结构型模式关心类的组合：由多个类组合成一个更大的系统，一般只存在继承关系和实现关系 对象结构型关心类与对象的组合：通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。 外观模式 适配器模式 桥接模式 代理模式 装饰者模式 享元模式 3. 行为型 主要用于描述类或对象怎样交互及怎样分配职责 职责链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[创建型-工厂方法模式]]></title>
    <url>%2F2019%2F12%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%2F4.%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Singleton Pattern：确保某一个类只有一个实例，并提供一个全局访问点。 使用单例模式在我们实际开发中会经常使用到，比如点击登录框，只会弹出有且只有一个登录框 以下是 JS 的例子，Java 例子需前往 –&gt;Java进阶-单利模式 1234567891011121314151617181920class Singleton &#123; constructor(name) &#123; this.name = name; // 一个标记，用来判断是否已经创建了该类的实例 this.instance = null; &#125; // 提供一个静态方法，用户可以直接在类上调用 static getInstance(name) &#123; // 没有实例化的时候创建一个该类的实例 if(!this.instance) &#123; this.instance = new Singleton(name); &#125; // 已经实例化了，返回第一次实例化对象的引用 return this.instance; &#125;&#125;let a = Singleton.getInstance('111')let b = Singleton.getInstance('222')console.log(a, b, a === b);// Singleton &#123;name: "111", instance: null&#125; Singleton &#123;name: "111", instance: null&#125; true 优点 节约系统资源：该类在系统内存中只存在一个对象 提供对唯一实例的受控访问：单例类封装了唯一实例 缺点 由于单例模式中没有抽象类，因此单例类很难进行扩展 对于有垃圾回收系统的语言 Java，C# 来说，如果对象长时间不被利用，则可能会被回收。那么如果这个单例持有一些数据的话，在回收后重新实例化时就不复存在了]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建型-原型模式]]></title>
    <url>%2F2019%2F12%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E5%88%9B%E5%BB%BA%E5%9E%8B%2F6.%20%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 Prototype Pattern：类似复印，根据原对象复印一个新对象，并根据需求对新对象进行微调。 使用123456789101112131415161718@interface Student : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *age;@property (nonatomic, copy) NSString *class;@property (nonatomic, copy) NSString *school;@end// 原对象Student *lily = [Student alloc] init];lily.name = @"lily";lily.age = @"13";lily.class = @"五年一班";lily.school = @"实现学校";// 复制原对象Student *tom = [lily copy];// 在原对象基础上微调tom.name = @"tom"; 比如js可以通过原型链，实现继承的五种方法 优点 简化对象的创建过程 缺点 对象包含的所有对象都需要配备一个克隆的方法，这就使得在对象层级比较多的情况下，代码量会很大，也更加复杂]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CI & CD]]></title>
    <url>%2F2019%2F12%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FCI%26CD%2F</url>
    <content type="text"><![CDATA[简单地说，CI持续集成，需要开发人员尽可能快的提交代码，新提交的代码在最终合并之前会经过编译与自动化测试进行验证；CD持续部署，开发人员点击部署，通过自动化的构建、测试、部署可以快速发布到线上；CD持续交付，可以在持续部署前进行，为持续部署做准备。 实现它们的前提都要有强大的测试用例，和强大的自动化服务。 想起在之前的实习单位，实现部署是在一个平台上，点击部署，上面提示进程：编译、测试、部署…如果中间某个环节出错，就会停止。看来是CD？ 持续集成（CONTINUOUS INTEGRATION）在CI环境中，开发人员可以频繁地向主干提交代码，这些新提交的代码在最终合并到主干前，会经过编译和自动化测试流进行验证。 持续集成过程中很重视自动化测试验证结果，以保障所有的提交在合并到主干的质量，对可能出现的问题进行预警。 需要具备的条件 团队需要为每个新功能、代码改进、或者问题修复创建自动化测试用例 需要一个持续集成服务器，它可以监控代码提交情况，对每个新的提交进行自动化测试 研发团队需要尽可能快的提交代码，至少每天一次提交 好处 通过自动化测试可以提早拿到回归测试的结果，避免将一些问题提交到交付生产中 发布编译将会更加容易，因为合并之初已经将所有问题都规避了 减少工作问题切换，研发可以很快获得构建失败的消息，在开始下一个任务之前就可以很快解决 测试成本大幅降低，你的CI服务器可以在几秒钟之内运行上百条测试。 QA团队花费在测试上面的时间会大幅缩短，将会更加侧重于质量文化的提升上面。 持续部署（CONTINUOUS DELIVERY）在CD环境中，通过自动化的构建、测试和部署循环来快速交付高质量的产品。 某种程度上代表了一个开发团队工程化的程度，任何修改通过了所有已有的工作流就会直接和客户见面，只有当一个修改在工作流中构建失败才能阻止它部署到产品线。 基本上，当开发人员在主分支中合并一个提交时，这个分支将被构建、测试，如果一切顺利，则部署到生产环境中。 需要具备的条件 研发团队测试理念比较完善。测试单元的健壮性直接决定交付质量 文档和部署频率要保持一致 特征标志成为发布重大变化过程的固有部分，以确保您可以与其他部门（支持，市场营销，公关…）协调 好处 发布频率更快，因为你不需要停下来等待发布。每一处提交都会自动触发发布流 在小批量发布的时候，风险降低了，发现问题也可以很轻松的修复 客户每天都可以看到我们的持续改进和提升，而不是每个月或者每季度，或者每年 持续交付（CONTINUOUS DEPLOYMENT）有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。 需要具备的条件 需要有强大的持续集成组件和足够多的测试项可以满足你代码的需求 部署需要自动化。触发是手动的，但是部署一旦开始，就不能人为干预 团队可能需要接受特性开关，没有完成的功能模块不会影响到线上产品 好处 繁琐的部署工作没有了。团队不在需要花费几天的时间去准备一个发布 可以更快的进行交付，这样就加快了与客户之间的反馈环 轻松应对小变更，加速迭代]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集群、负载均衡、分布式、微服务区别]]></title>
    <url>%2F2019%2F12%2F11%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E9%9B%86%E7%BE%A4%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[简单的说： 集群：同一业务部署在多个服务器上 负载均衡：在集群的概念中，选择更适合的服务器进行访问 分布式：一个业务拆分成多个子业务，部署在不同的服务器上 微服务：与分布式相比，拥有更细的微粒度，且不一定是分散在多个服务器上，它也可以是同一个服务器]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex源码分析(辅助函数)]]></title>
    <url>%2F2019%2F12%2F09%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0)%2F</url>
    <content type="text"><![CDATA[辅助函数vuex/src/helper.js mapState为组件创建计算属性以返回 Vuex store 中的状态 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;String&#125; [namespace] - Module's namespace * @param &#123;Object|Array&#125; states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it. * @param &#123;Object&#125; */export const mapState = normalizeNamespace((namespace, states) =&gt; &#123; const res = &#123;&#125;; // 非生产环境 判断参数 states 必须是数组或者是对象 if (process.env.NODE_ENV !== "production" &amp;&amp; !isValidMap(states)) &#123; console.error( "[vuex] mapState: mapper parameter must be either an Array or an Object" ); &#125; normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedState() &#123; let state = this.$store.state; let getters = this.$store.getters; // 传了参数 namespace if (namespace) &#123; // 用 namespace 从 store 中找一个模块 const module = getModuleByNamespace(this.$store, "mapState", namespace); if (!module) &#123; return; &#125; state = module.context.state; getters = module.context.getters; &#125; return typeof val === "function" ? val.call(this, state, getters) : state[val]; &#125;; // 标记为 vuex 方便在 devtools 显示 res[key].vuex = true; &#125;); return res;&#125;); normalizeNamespace 函数标准化统一命名空间 123456789101112131415161718192021222324/** * @param &#123;Function&#125; fn * @return &#123;Function&#125; */function normalizeNamespace(fn) &#123; return (namespace, map) =&gt; &#123; // 命名空间没传，交换参数，namespace 为空字符串 if (typeof namespace !== "string") &#123; map = namespace; namespace = ""; &#125; else if (namespace.charAt(namespace.length - 1) !== "/") &#123; // 如果是字符串，最后一个字符不是 / 添加 / // 因为 _modulesNamespaceMap 存储的是这样的结构。 /** * _modulesNamespaceMap: cart/: &#123;&#125; products/: &#123;&#125; &#125; * */ namespace += "/"; &#125; return fn(namespace, map); &#125;;&#125; isValidMap 函数1234567/** * @param &#123;*&#125; map * @return &#123;Boolean&#125; */function isValidMap(map) &#123; return Array.isArray(map) || isObject(map);&#125; normalizeMap 函数标准化统一 map，最终返回的是数组 1234567891011121314/** * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ] * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: 'a', val: 1 &#125;, &#123; key: 'b', val: 2 &#125;, &#123; key: 'c', val: 3 &#125; ] * @param &#123;Array|Object&#125; map * @return &#123;Object&#125; */function normalizeMap(map) &#123; if (!isValidMap(map)) &#123; return []; &#125; return Array.isArray(map) ? map.map(key =&gt; (&#123; key, val: key &#125;)) : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;));&#125; getModuleByNamespace 函数1234567891011121314151617/** * Search a special module from store by namespace. if module not exist, print error message. * @param &#123;Object&#125; store * @param &#123;String&#125; helper * @param &#123;String&#125; namespace * @return &#123;Object&#125; */function getModuleByNamespace(store, helper, namespace) &#123; // _modulesNamespaceMap 这个变量在 class Store installModule 函数中赋值的 const module = store._modulesNamespaceMap[namespace]; if (process.env.NODE_ENV !== "production" &amp;&amp; !module) &#123; console.error( `[vuex] module namespace not found in $&#123;helper&#125;(): $&#123;namespace&#125;` ); &#125; return module;&#125; 例子123456789101112131415computed: &#123; ...mapState("a", &#123; count: state =&gt; state.count &#125;),&#125;,// 转化成computed: &#123; count: this.$store._modulesNamespaceMap.['a/'].context.count&#125;, computed: &#123; ...mapState(['a']),&#125;,// 转化成computed: &#123; count: this.$store.state.count&#125;, mapGetters为组件创建计算属性以返回 getter 的返回值 123456789101112131415161718192021222324252627282930313233343536373839/** * @param &#123;String&#125; [namespace] - Module's namespace * @param &#123;Object|Array&#125; getters * @return &#123;Object&#125; */export const mapGetters = normalizeNamespace((namespace, getters) =&gt; &#123; const res = &#123;&#125;; // 省略代码：非生产环境 判断参数 getters 必须是数组或者是对象 if (process.env.NODE_ENV !== "production" &amp;&amp; !isValidMap(getters)) &#123; console.error( "[vuex] mapGetters: mapper parameter must be either an Array or an Object" ); &#125; normalizeMap(getters).forEach((&#123; key, val &#125;) =&gt; &#123; // The namespace has been mutated by normalizeNamespace val = namespace + val; res[key] = function mappedGetter() &#123; if ( namespace &amp;&amp; !getModuleByNamespace(this.$store, "mapGetters", namespace) ) &#123; return; &#125; // 省略代码：匹配不到 getter if ( process.env.NODE_ENV !== "production" &amp;&amp; !(val in this.$store.getters) ) &#123; console.error(`[vuex] unknown getter: $&#123;val&#125;`); return; &#125; return this.$store.getters[val]; &#125;; // 标记为 vuex 方便在 devtools 显示 res[key].vuex = true; &#125;); return res;&#125;); 举例1234567891011computed: &#123; ...mapGetters('cart', &#123; products: 'cartProducts', total: 'cartTotalPrice' &#125;)&#125;,// 转换成：computed: &#123; products: this.$store.getters['cart/cartProducts'], total: this.$store.getters['cart/cartTotalPrice'],&#125; mapActions创建组件方法分发 action 1234567891011121314151617181920212223242526272829303132333435/** * @param &#123;String&#125; [namespace] - Module's namespace * @param &#123;Object|Array&#125; mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function. * @return &#123;Object&#125; */export const mapMutations = normalizeNamespace((namespace, mutations) =&gt; &#123; const res = &#123;&#125;; // 省略代码： 非生产环境 判断参数 actions 必须是数组或者是对象 if (process.env.NODE_ENV !== "production" &amp;&amp; !isValidMap(mutations)) &#123; console.error( "[vuex] mapMutations: mapper parameter must be either an Array or an Object" ); &#125; normalizeMap(mutations).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedMutation(...args) &#123; // Get the commit method from store let commit = this.$store.commit; if (namespace) &#123; const module = getModuleByNamespace( this.$store, "mapMutations", namespace ); if (!module) &#123; return; &#125; commit = module.context.commit; &#125; return typeof val === "function" ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args)); &#125;; &#125;); return res;&#125;); 举例1234567891011121314151617&#123; methods: &#123; ...mapMutations(['inc']), ...mapMutations('ruochuan', ['dec']), &#125;&#125;// 转换成&#123; methods: &#123; inc(...args)&#123; return this.$store.dispatch.apply(this.$store, ['inc'].concat(args)) &#125;, dec(...args)&#123; return this.$store._modulesNamespaceMap.['ruochuan/'].context.dispatch.apply(this.$store, ['dec'].concat(args)) &#125; &#125;&#125; mapMutations创建组件方法提交 mutation 12345678910111213141516171819202122232425262728293031323334/** * @param &#123;String&#125; [namespace] - Module's namespace * @param &#123;Object|Array&#125; actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function. * @return &#123;Object&#125; */export const mapActions = normalizeNamespace((namespace, actions) =&gt; &#123; const res = &#123;&#125;; if (process.env.NODE_ENV !== "production" &amp;&amp; !isValidMap(actions)) &#123; console.error( "[vuex] mapActions: mapper parameter must be either an Array or an Object" ); &#125; normalizeMap(actions).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedAction(...args) &#123; // get dispatch function from store let dispatch = this.$store.dispatch; if (namespace) &#123; const module = getModuleByNamespace( this.$store, "mapActions", namespace ); if (!module) &#123; return; &#125; dispatch = module.context.dispatch; &#125; return typeof val === "function" ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args)); &#125;; &#125;); return res;&#125;); 举例1234567891011121314151617&#123; methods: &#123; ...mapActions(['actionA']) ...mapActions('ruochuan', ['actionB']) &#125;&#125;// 转换成&#123; methods: &#123; actionA(...args)&#123; return this.$store.commit.apply(this.$store, ['actionA'].concat(args)) &#125; actionB(...args)&#123; return this.$store._modulesNamespaceMap.['ruochuan/'].context.commit.apply(this.$store, ['actionB'].concat(args)) &#125; &#125;&#125; createNamespacedHelpers创建基于命名空间的组件绑定辅助函数 1234567891011/** * @param &#123;String&#125; namespace * @return &#123;Object&#125; */export const createNamespacedHelpers = namespace =&gt; (&#123; // bind(null) 严格模式下，mapState等的函数 this 指向就是 null mapState: mapState.bind(null, namespace), mapGetters: mapGetters.bind(null, namespace), mapMutations: mapMutations.bind(null, namespace), mapActions: mapActions.bind(null, namespace)&#125;);]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elastic Search进阶]]></title>
    <url>%2F2019%2F12%2F06%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FElastic%20Search%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[ES是什么一个基于Lucene的开源的、实时分布式搜索和分析引擎，他可以用于全文搜索、结构化搜索和分析以及将三者混合使用。在搜索方面非常优秀，又快又准，还能根据相关性返回、搜索纠错等。 它使用了RESTful API的语法风格，所以使用它也非常简单易上手。提供了kibanaWeb应用程序实现可视化界面，让开发人员及管理者更加方便地查看及管理自己的页面。不过多研究如何使用，需要时翻开API手册即可。 ES的倒排索引是啥一般我们说的检索是正排索引，即通过文章，逐个遍历找到对应关键词的位置。倒排索引是通过分词策略，形成词和文章的映射关系表，即从词出发，记载词在哪些文档中出现，最后形成的词典+映射表即为倒排索引。 因为倒排索引的底层实现是基于FST数据结构，可以实现O(1)时间复杂度的效率检索文章，极大提高了检索效率！ ES的更新和删除文档的过程因为ES里面的文档是不可变的，所以不能被删除或者更改。 如果需要更新已存在的文档，可以通过重建索引或者替换掉它。如果是这样，文档的_version将增加。在内部，ES标记旧文档为删除并添加一个完整的新文档。旧文档不会立刻消失，但是我们不能访问到，尽管该文档依然能被匹配查询，但是会在结果中被过滤掉。ES在我们继续索引更多数据时会清理被删除的文档。 删除操作同理，删除文档后不会立刻在磁盘上移除，只是被标记成已删除，后续再后台清理掉。]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex疑问自答]]></title>
    <url>%2F2019%2F12%2F06%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2Fvuex%E7%96%91%E9%97%AE%E8%87%AA%E7%AD%94%2F</url>
    <content type="text"><![CDATA[看完源码后，脑子还是比较乱，通过给自己提问题理清思路 疑问1：vuex的store是如何挂载注入到组件中呢？？首先在store/index.js里面安装vuex 12import Vuex from 'vuex';Vue.use(vuex);// vue的插件机制 其中Vue.use(vuex);是利用了vue的插件机制，会调用vuex的Install方法，装载vuex，install方法里有一个applyMixin方法使用vue混入机制，在beforeCreated钩子函数内混入vueInit方法，VueInit方法实现store注入vue组件实例，并注册vuex store的引用属性$store 疑问2：为啥可以通过this.$store.dispatch等调用方法？？因为每个组件(vue实例)在beforeCreate生命周期(1.x在_init方法中)混入vuexInit()，将同一个Store实例作为vue实例属性$store 疑问3：怎么实现state响应式的？？在 resetStoreVM()里面，通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed 12345678910function resetStoreVM (store, state, hot) &#123;// 省略若干代码store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed &#125;) // 省略若干代码&#125; 然后我们在获取state的时候，就拿的是vm.$_store._vm._data.$$state，这个变量是响应式的 疑问4：为啥actions中可以处理异步函数？vuex需要项目支持promise，不支持会在创建store实例时报错？？在源码 注册mutation registerAction中，判断了函数是否是一个Promise，不是Promise会把它Promise化 疑问5：为啥要用commit提交mutation来修改state呢？？试验了一下：非严格模式下，直接修改state，是不会报错的，但是vue调试工具无法记录每一次state的变化。严格模式下，直接修改state，会报错。 源码中，严格模式下，会watch state的变化然后断言store._committing的值，默认为false，如果直接修改state，这个值就是false，就会报错。执行c ommit提交，在commit函数内部，由this._commit()函数来修改state，this._commit()函数会把store._committing设置成true，再修改state，所以严格模式下不会报错。 所以，我们最好设置成严格模式，使用commit修改state，这样不会报错且vue调试工具能够记录每次state的变化，方便调试 疑问6：为啥把异步操作放在actions，同步放在mutations？？试验了一下：把mutations里面的操作改成Promise 3秒后执行，然后直接commit，发现也可以执行成功(严格模式下会报错)，但是devtools追踪的状态不准，无法捕捉是什么时候变化。 根据尤雨溪在知乎的回答，说明：这样做的原因是为了能用 devtools 追踪状态变化。事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，在里面想干嘛都可以，只要最后触发 mutation 就行。 vuex 真正限制你的只有 mutation 必须是同步的这一点，同步的意义在于每一个 mutation 执行完成后都可以对应到一个新的状态，这样 devtools 就可以清准的打出state的变化。 如果开着 devtool 调用一个异步的 action，就可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。 同时把异步操作放在actions，也可以更清晰的管理mutations 疑问7：有一些属性，为什么要加_ 用于辨别属性，_就表示内部属性，我们在外部调用这些属性的时候，就需要小心 疑问8：如何本地调试vuex源码？？？123456789101112131415// 1. 先把下载的vuex卸载掉，不然运行时会自动在包里寻找 npm uninstall vuex// 2. 把vuex包中src的文件取出来，放在项目的src里面// 3. 在 webpack.base.conf.js 中配置vuex路径resolve: &#123; extensions: [".js", ".vue", ".json"], alias: &#123; vue$: "vue/dist/vue.esm.js", vuex$: resolve("src/vuex/index.esm.js"), vuex: resolve("src/vuex"), "@": resolve("src") &#125;&#125;,]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elastic Search基础]]></title>
    <url>%2F2019%2F12%2F06%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FElastic%20Search%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[安装 Mac 安装教程https://blog.csdn.net/Sibylsf/article/details/90636509 杀掉ES进程 查找ES进程 1ps -ef | grep elastic 杀掉ES进程 1kill -9 2382（进程号） 重启ES 1sh elasticsearch -d kibanahttps://www.cnblogs.com/yangxiaoyi/p/7234222.html 简介Elasticsearch是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。它用于全文搜索、结构化搜索、分析以及将这三者混合使用： 维基百科使用Elasticsearch提供全文搜索并高亮关键字，以及输入实时搜索(search-as-you-type)和搜索纠错(did-you-mean)等搜索建议功能。 英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。 StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。 Github使用Elasticsearch检索1300亿行的代码。 集群和节点 节点(node)是一个运行着的Elasticsearch实例。 集群(cluster)是一组具有相同cluster.name的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能，当然一个节点也可以组成一个集群。你最好找一个合适的名字来替代cluster.name的默认值，比如你自己的名字，这样可以防止一个新启动的节点加入到相同网络中的另一个同名的集群中。 索引(indexing)：存储数据的行为 索引(index)：在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index) Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; ColumnsElasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; FieldsElasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。 索引（名词） 如上文所述，一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方，index的复数是indices 或indexes。 索引（动词） 「索引一个文档」表示把一个文档存储到索引（名词）里，以便它可以被检索或者查询。这很像SQL中的INSERT关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档。 倒排索引 传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用一种叫做倒排索引(inverted index)的数据结构来达到相同目的。默认情况下，文档中的所有字段都会被索引（拥有一个倒排索引），只有这样他们才是可被搜索的。 索引12345678910111213141516171819202122232425262728293031PUT /megacorp/employee/2&#123; "first_name" : "Jane", "last_name" : "Smith", "age" : 32, "about" : "I like to collect rock albums", "interests": [ "music" ]&#125;GET /megacorp/employee/2 // 可以看到内容在source中&#123; "_index" : "megacorp", "_type" : "employee", "_id" : "2", "_version" : 1, "_seq_no" : 1, "_primary_term" : 1, "found" : true, "_source" : &#123; "first_name" : "Jane", "last_name" : "Smith", "age" : 32, "about" : "I like to collect rock albums", "interests" : [ "music" ] &#125;&#125;DELETE /megacorp/_doc/2 删除 搜索简单搜索GET /megacorp/employee/_search 检查表中所有文档，默认情况下搜索会返回前10个结果 GET /megacorp/employee/_search?q=last_name:Smith 将查询语句传递给参数q=。这样就可以得到所有姓氏为Smith的结果 使用DSL语句查询为了避免通过命令行搜索的局限性(简单搜索 返回全部)，我们可以使用DSL语句查询：DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现。 12345678GET /megacorp/employee/_search&#123; "query" : &#123; "match" : &#123; "last_name" : "Smith" &#125; &#125;&#125; 使用match语句 使用match语句 更复杂的搜索添加过滤器(filter), 1234567891011121314151617GET /megacorp/employee/_search&#123; "query" : &#123; "bool" : &#123; "filter" : &#123; "range" : &#123; "age" : &#123; "gt" : 30 &#125; &lt;1&gt; &#125; &#125;, "must" : &#123; "match" : &#123; "last_name" : "smith" &lt;2&gt; &#125; &#125; &#125; &#125;&#125; &lt;1&gt; 这部分查询属于区间过滤器(range filter),它用于查找所有年龄大于30岁的数据——gt为”greater than”的缩写。 &lt;2&gt; 这部分查询与之前的match语句(query)一致。 全文搜索12345678GET /megacorp/employee/_search&#123; "query" : &#123; "match" : &#123; "about" : "rock climbing" &#125; &#125;&#125; 会根据相关性对结果集进行排序，以上案例返回第一个””I love to go rock climbing” 和 第二个””I like to collect rock albums” 短语搜索确切的匹配若干个单词或者短语(phrases)。例如我们想要查询同时包含”rock”和”climbing”（并且是相邻的）的员工记录。只要将match查询变更为match_phrase查询即可: 12345678GET /megacorp/employee/_search&#123; "query" : &#123; "match_phrase" : &#123; "about" : "rock climbing" &#125; &#125;&#125; 和上面的全文搜索相比，就没有”I like to collect rock albums” 高亮搜索12345678910111213GET /megacorp/employee/_search&#123; "query" : &#123; "match_phrase" : &#123; "about" : "rock climbing" &#125; &#125;, "highlight": &#123; "fields" : &#123; "about" : &#123;&#125; &#125; &#125;&#125; 当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做highlight，这里包含了来自about字段中的文本，并且用来标识匹配到的单词 聚合类似于sql的GROUP BY 12345678GET /megacorp/employee/_search&#123; "aggs": &#123; "all_interests": &#123; "terms": &#123; "field": "interests.keyword" &#125; &#125; &#125;&#125; 会得出匹配总和数 12345678910111213141516171819202122&#123; ... "hits": &#123; ... &#125;, "aggregations": &#123; "all_interests": &#123; "buckets": [ &#123; "key": "music", "doc_count": 2 &#125;, &#123; "key": "forestry", "doc_count": 1 &#125;, &#123; "key": "sports", "doc_count": 1 &#125; ] &#125; &#125;&#125; 缩小范围如果我们想缩小范围，只需要再加一层query 搜索一下即可 123456789101112131415GET /megacorp/employee/_search&#123; "query": &#123; "match": &#123; "last_name": "smith" &#125; &#125;, "aggs": &#123; "all_interests": &#123; "terms": &#123; "field": "interests.keyword" &#125; &#125; &#125;&#125; 聚合中分级汇总123456789101112131415161718192021222324252627282930313233343536373839GET /megacorp/employee/_search&#123; "aggs" : &#123; "all_interests" : &#123; "terms" : &#123; "field" : "interests.keyword" &#125;, "aggs" : &#123; "avg_age" : &#123; "avg" : &#123; "field" : "age" &#125; &#125; &#125; &#125; &#125;&#125;..."all_interests": &#123; "buckets": [ &#123; "key": "music", "doc_count": 2, "avg_age": &#123; "value": 28.5 &#125; &#125;, &#123; "key": "forestry", "doc_count": 1, "avg_age": &#123; "value": 35 &#125; &#125;, &#123; "key": "sports", "doc_count": 1, "avg_age": &#123; "value": 25 &#125; &#125; ]&#125; 文档文档元数据一个文档不只有数据。它还包含了元数据(metadata)——关于文档的信息。三个必须的元数据节点是： 节点 说明 _index 文档存储的地方 _type 文档代表的对象的类 _id 文档的唯一标识 索引使用自己的ID12345PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;&#123; "field": "value", ...&#125; 自增ID注意使用的是POST 123456POST /website/blog/&#123; "title": "My second blog entry", "text": "Still trying this out...", "date": "2014/01/01"&#125; 获取12345678// 具体获取某个ID文档，pretty表美化GET /website/blog/123?pretty// 返回_source的一部分GET /website/blog/123?_source=title,text// 只要_source字段，不要其他元数据GET /website/blog/123/_source 删除如果文档被找到，返回200并且_version会增加。没找到要删除的文档，会得到404 1DELETE /website/blog/123 删除一个文档也不会立即从磁盘上移除，它只是被标记成已删除。Elasticsearch将会在你之后添加更多索引的时候才会在后台进行删除内容的清理。]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack 路径问题]]></title>
    <url>%2F2019%2F12%2F05%2F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2FWebpack%2Fwebpack%20%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在分析 Vuex 源码的时候，为了方便调试，引入了本地的 Vuex 包，并更改 Webpack 配置的路径，其中有个 vuex$ vue$的路径配置挺有意思，为什么要配这个呢？ 1234567891011// 在 webpack.base.conf.js中resolve: &#123; extensions: [".js", ".vue", ".json"], alias: &#123; vue$: "vue/dist/vue.esm.js", vuex$: resolve("src/vuex/index.esm.js"), vuex: resolve("src/vuex"), "@": resolve("src") &#125;&#125;, // 为啥？？ 首先看vuex/src/index.js &amp;&amp; index.esm.js这两个文件，可以看出index.ems.js只多了export对象 我们代码里是这样：import { mapState, mapGetters, mapActions } from &quot;vuex&quot;; 就得使用index.esm.js，因为es6的写法 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125; import crc32 from 'crc32'; // 输入 // 第二组export function crc32() &#123; // 输出 // ...&#125;; import &#123;crc32&#125; from 'crc32'; // 输入 所以要获取mapState等函数就要使用vuex$进行精准查找到index.ems.js文件。但是我们想要vuex文件夹的其他文件，就需要再定义vuex，才能找到，比如 12import devtoolPlugin from "vuex/plugins/devtool.js";console.log(devtoolPlugin); 所以需要配置 vuex$和vuex两个路径，当然，也可以在import Vuex form &#39;相对路径&#39;]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Commit Message 规范]]></title>
    <url>%2F2019%2F12%2F05%2FGit%2FCommit%20Message%20%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[git commit也有自己的规范，让git 树更加清晰 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 scope：影响范围（可不写） subject：对改变的正常描述，最好以动词开头语（尽量详细，必填） body：详细描述（个人认为没必要，可不写） footer：修改不兼容变动以及关闭 Issue时（个人认为没必要，可不写）]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git 重命名文件]]></title>
    <url>%2F2019%2F12%2F05%2FGit%2FGit%20%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言看了胜凯发的关于git 文件重命名的文章，自己尝试了一下 首先：直接更改文件名，git status ，追踪不到更改 方法一1234567891011121314151617$ git mv src/components/rename.vue src/components/Rename.vue$ git status # 位于分支 master# 您的分支与上游分支 'origin/master' 一致。# # 要提交的变更：# （使用 "git restore --staged &lt;文件&gt;..." 以取消暂存）# 重命名： src/components/rename.vue -&gt; src/components/Rename.vue$ git commit -m '把rename改成Rename'# [master c05b49d] 把rename改成Rename# 1 file changed, 0 insertions(+), 0 deletions(-)# rename src/components/&#123;rename.vue =&gt; Rename.vue&#125; (100%) // 注意这个地方$ git push$ git pull 刷新一下就出来新命名的了 在 git 中使用 mv 命令的时候，会自动 add 所以不用额外敲 git add . 方法二12345678910111213141516171819$ git config core.ignorecase false # 改文件名$ git status# 位于分支 master# 您的分支与上游分支 'origin/master' 一致。# # 未跟踪的文件:# （使用 "git add &lt;文件&gt;..." 以包含要提交的内容）# src/components/Rename.vue# # 提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪）git add . git commit -m '把rename改成Rename 测试方法2 全局设计 git config core.ignorecase false'# [master 23280e5] 把rename改成Rename 测试方法2 全局设计 git config core.ignorecase false# 1 file changed, 18 insertions(+)# create mode 100644 src/components/Rename.vue // 注意这个地方 可以看出它是新增了一个文件，看一些文章显示不同的系统可能会出现两个文件，不推荐]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex源码分析(插件)]]></title>
    <url>%2F2019%2F12%2F05%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E6%8F%92%E4%BB%B6)%2F</url>
    <content type="text"><![CDATA[插件vuex/src/plugins/devtool 1234567891011121314151617181920212223242526272829/* 从window对象的__VUE_DEVTOOLS_GLOBAL_HOOK__中获取devtool插件 */const target = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : &#123;&#125;;const devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;export default function devtoolPlugin(store) &#123; if (!devtoolHook) return; /* devtoll插件实例存储在store的_devtoolHook上 */ store._devtoolHook = devtoolHook; /* 出发vuex的初始化事件，并将store的引用地址传给deltool插件，使插件获取store的实例 */ devtoolHook.emit("vuex:init", store); /* 监听travel-to-state事件 */ devtoolHook.on("vuex:travel-to-state", targetState =&gt; &#123; /* 重制state */ store.replaceState(targetState); &#125;); /* 订阅store的变化 */ store.subscribe((mutation, state) =&gt; &#123; devtoolHook.emit("vuex:mutation", mutation, state); &#125;);&#125; 如果安装了devtool插件，会在windows对象上暴露一个VUE_DEVTOOLS_GLOBAL_HOOK，可以用window.__VUE_DEVTOOLS_GLOBAL_HOOK__打印出来。 vuex在初始化的时候，会触发“vuex:init”事件通知插件，然后通过on方法监听“vuex:travel-to-state”事件来重置state。最后通过Store的subscribe方法来添加一个订阅者，在触发commit方法修改mutation数据以后，该订阅者会被通知，从而触发“vuex:mutation”事件。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[delete和Vue.delete删除数组的区别]]></title>
    <url>%2F2019%2F12%2F04%2FVue%2Fdelete%E5%92%8CVue.delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在unregisterModule函数(注销动态组件)中，发现了 12/* 从父级中删除 */Vue.delete(parentState, path[path.length - 1]); 为啥使用Vue.delete删除呢？？ 官方文档中是这样介绍的 1234Vue.delete( target, propertyName/index )// 用法：// 删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。 与delete的区别就是： delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变 Vue.delete 直接删除了数组 改变了数组的键值]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex源码分析(严格模式)]]></title>
    <url>%2F2019%2F12%2F04%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F)%2F</url>
    <content type="text"><![CDATA[严格模式123const store = new Vuex.Store(&#123; strict: true)&#125; 在Store类的option中设置strict参数为true，严格模式下，所有修改state的操作必须通过mutation实现，否则会抛出错误。 12345678910111213141516171819/* 使用严格模式 */function enableStrictMode(store) &#123; console.log(store._committing); store._vm.$watch( function() &#123; return this._data.$$state; &#125;, () =&gt; &#123; if (process.env.NODE_ENV !== "production") &#123; /* 检测store中的_committing的值，如果是false代表不是通过mutation的方法修改的 */ assert( store._committing, `do not mutate vuex store state outside mutation handlers.` ); &#125; &#125;, &#123; deep: true, sync: true &#125; );&#125; 作用：利用vm去watch state，在被修改时进入回调；通过assert断言检测store._committing，如果为false，触发断言，抛出异常 在Store构造类的commit方法内，执行mutation的语句是这样的 12345this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator(handler) &#123; handler(payload); &#125;);&#125;); _withCommit1234567/* 调用withCommit修改state的值时会将store的committing值置为true，内部会有断言检查该值，在严格模式下只允许使用mutation来修改store中的值，而不允许直接修改store的数值 */_withCommit(fn) &#123; const committing = this._committing; this._committing = true; fn(); this._committing = committing;&#125; store._committing默认为false，这里控制执行mutation修改state时，会变成true，所以严格模式下就不会报错。如果不是在mutation修改，store._committing就还是false，抛出异常]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex源码分析(Store实例方法)]]></title>
    <url>%2F2019%2F12%2F04%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(Store%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95)%2F</url>
    <content type="text"><![CDATA[Vuex.Store 实例方法 commit(mutation) 根据type找到并调用_mutations中的所有type对应的mutation方法，所以当没有namespace的时候，commit方法会触发所有module中的mutation方法 执行完所有的mutation之后会执行_subscribers中的所有订阅者 1234567891011121314151617181920212223242526272829303132333435/* 调用mutation的commit方法 */commit(_type, _payload, _options) &#123; // 校验参数 // 统一成对象风格 const &#123; type, payload, options &#125; = unifyObjectStyle( _type, _payload, _options ); const mutation = &#123; type, payload &#125;; /* 取出type对应的mutation的方法 */ const entry = this._mutations[type]; if (!entry) &#123; if (process.env.NODE_ENV !== "production") &#123; console.error(`[vuex] unknown mutation type: $&#123;type&#125;`); &#125; return; &#125; /* 执行mutation中的所有方法 */ this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator(handler) &#123; handler(payload); &#125;); &#125;); /* 通知所有订阅者 */ this._subscribers.forEach(sub =&gt; sub(mutation, this.state)); if (process.env.NODE_ENV !== "production" &amp;&amp; options &amp;&amp; options.silent) &#123; console.warn( `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` + "Use the filter functionality in the vue-devtools" ); &#125;&#125; subscribersStore给外部提供了一个subscribe方法，用以注册一个订阅函数，会push到Store实例的_subscribers中，同时返回一个从_subscribers中注销该订阅者的方法。 在commit结束以后则会调用这些_subscribers中的订阅者，这个订阅者模式提供给外部一个监视state变化的可能。state通过mutation改变时，可以有效捕获这些变化。 12345678910111213141516// 订阅 store 的 mutationsubscribe(fn) &#123; return genericSubscribe(fn, this._subscribers);&#125;/* 收集订阅者:注册一个订阅函数，返回取消订阅的函数 */function genericSubscribe(fn, subs) &#123; if (subs.indexOf(fn) &lt; 0) &#123; subs.push(fn); &#125; return () =&gt; &#123; const i = subs.indexOf(fn); if (i &gt; -1) &#123; subs.splice(i, 1); &#125; &#125;;&#125; unifyObjectStyleunifyObjectStyle函数将参数统一，返回 { type, payload, options }。 1234567891011121314151617// 统一成对象风格function unifyObjectStyle(type, payload, options) &#123; if (isObject(type) &amp;&amp; type.type) &#123; options = payload; payload = type; type = type.type; &#125; if (process.env.NODE_ENV !== "production") &#123; assert( typeof type === "string", `expects string as the type, but found $&#123;typeof type&#125;.` ); &#125; return &#123; type, payload, options &#125;;&#125; commit 支持多种方式。比如： 12345678store.commit('increment', &#123; count: 10&#125;)// 对象提交方式store.commit(&#123; type: 'increment', count: 10&#125;) dispatch(action)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* 调用action的dispatch方法 */dispatch(_type, _payload) &#123; // 获取到type和payload参数 const &#123; type, payload &#125; = unifyObjectStyle(_type, _payload); // 声明 action 变量 等于 type和payload参数 const action = &#123; type, payload &#125;; /* actions中取出type对应的ation */ const entry = this._actions[type]; if (!entry) &#123; if (process.env.NODE_ENV !== "production") &#123; console.error(`[vuex] unknown action type: $&#123;type&#125;`); &#125; return; &#125; try &#123; this._actionSubscribers .filter(sub =&gt; sub.before) .forEach(sub =&gt; sub.before(action, this.state)); &#125; catch (e) &#123; if (process.env.NODE_ENV !== "production") &#123; console.warn(`[vuex] error in before action subscribers: `); console.error(e); &#125; &#125; /* 是数组则包装Promise形成一个新的Promise，只有一个则直接返回第0个 */ const result = entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload); return result.then(res =&gt; &#123; try &#123; this._actionSubscribers .filter(sub =&gt; sub.after) .forEach(sub =&gt; sub.after(action, this.state)); &#125; catch (e) &#123; if (process.env.NODE_ENV !== "production") &#123; console.warn(`[vuex] error in after action subscribers: `); console.error(e); &#125; &#125; return res; &#125;);&#125; registerAction 将push进_actions的action进行一层封装（wrappedActionHandler）， 然后判断封装好的res是否是一个Promise，不是则转化为Promise对象 dispatch时则从_actions中取出，只有一个的时候直接返回，否则用Promise.all处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 注册 mutation * @param &#123;Object&#125; store 对象 * @param &#123;String&#125; type 类型 * @param &#123;Function&#125; handler 用户自定义的函数 * @param &#123;Object&#125; local local 对象 */function registerAction(store, type, handler, local) &#123; /* 取出type对应的action */ const entry = store._actions[type] || (store._actions[type] = []); // payload 是actions函数的第二个参数 entry.push(function wrappedActionHandler(payload) &#123; /** * 也就是为什么用户定义的actions中的函数第一个参数有 * &#123; dispatch, commit, getters, state, rootGetters, rootState &#125; 的原因 * actions: &#123; * checkout (&#123; commit, state &#125;, products) &#123; * console.log(commit, state); * &#125; * &#125; */ let res = handler.call( store, &#123; dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state &#125;, payload ); /* 判断是否是Promise */ /** * export function isPromise (val) &#123; return val &amp;&amp; typeof val.then === 'function' &#125; * 判断如果不是Promise Promise 化，也就是为啥 actions 中处理异步函数 也就是为什么构造函数中断言不支持promise报错的原因 vuex需要Promise polyfill assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) */ if (!isPromise(res)) &#123; /* 不是Promise对象的时候转化称Promise对象 */ res = Promise.resolve(res); &#125; // devtool 工具触发 vuex:error if (store._devtoolHook) &#123; // catch 捕获错误 return res.catch(err =&gt; &#123; store._devtoolHook.emit("vuex:error", err); // 抛出错误 throw err; &#125;); &#125; else &#123; // 然后函数执行结果 return res; &#125; &#125;);&#125; registerModule我们可以在页面动态注册模块，像如下： 123this.$store.registerModule("c", &#123; state: &#123; count: 3 &#125;&#125;); 以下是实现过程： 12345678910111213141516171819202122232425262728293031/** * 注册一个动态module，当业务进行异步加载的时候，可以通过该接口进行注册动态module * @param &#123;Array|String&#125; path 路径 * @param &#123;Object&#125; rawModule 原始未加工的模块 * @param &#123;Object&#125; options 参数选项 */registerModule(path, rawModule, options = &#123;&#125;) &#123; /* 转化称Array */ if (typeof path === "string") path = [path]; if (process.env.NODE_ENV !== "production") &#123; assert(Array.isArray(path), `module path must be a string or an Array.`); assert( path.length &gt; 0, "cannot register the root module by using registerModule." ); &#125; // 手动调用 模块注册的方法 this._modules.register(path, rawModule); /* 初始化module */ installModule( this, this.state, path, this._modules.get(path), options.preserveState ); /* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */ resetStoreVM(this, this.state);&#125; 重点还是installModule与resetStoreVM unregisterModule动态注销模块 1this.$store.unregisterModule("c"); 实现方法是先从state中删除对应模块，然后用resetStore来重制store 1234567891011121314151617181920212223/** * 注销模块 * @param &#123;Array|String&#125; path 路径 */unregisterModule(path) &#123; /* 转化称Array */ if (typeof path === "string") path = [path]; if (process.env.NODE_ENV !== "production") &#123; assert(Array.isArray(path), `module path must be a string or an Array.`); &#125; // 手动调用模块注销 this._modules.unregister(path); this._withCommit(() =&gt; &#123; /* 获取父级的state */ const parentState = getNestedState(this.state, path.slice(0, -1)); /* 从父级中删除 */ Vue.delete(parentState, path[path.length - 1]); &#125;); /* 重制store */ resetStore(this);&#125; resetStore将store中的_actions等进行初始化以后，重新执行installModule与resetStoreVM来初始化module以及用Vue特性使其“响应式化”，这跟构造函数中的是一致的 123456789101112/* 重制store */function resetStore(store, hot) &#123; store._actions = Object.create(null); store._mutations = Object.create(null); store._wrappedGetters = Object.create(null); store._modulesNamespaceMap = Object.create(null); const state = store.state; // init all modules installModule(store, state, [], store._modules.root, true); // reset vm resetStoreVM(store, state, hot);&#125; watchvuex提供了一个watch实例方法，使用：this.$store.watch() 12345678910111213141516171819/** * 观测某个值 * @param &#123;Function&#125; getter 函数 * @param &#123;Function&#125; cb 回调 * @param &#123;Object&#125; options 参数对象 */watch(getter, cb, options) &#123; if (process.env.NODE_ENV !== "production") &#123; assert( typeof getter === "function", `store.watch only accepts a function.` ); &#125; return this._watcherVM.$watch( () =&gt; getter(this.state, this.getters), cb, options );&#125; 关键是_watcherVM，它一个Vue的实例，所以watch就可以直接采用了Vue内部的watch特性提供了一种观察数据getter变动的方法 hotUpdate热替换新的 action 和 mutation 1234567// 热加载hotUpdate (newOptions) &#123; // 调用的是 ModuleCollection 的 update 方法，最终调用对应的是每个 Module 的 update this._modules.update(newOptions) // 重置 Store resetStore(this, true)&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex源码分析(Store构造函数)]]></title>
    <url>%2F2019%2F12%2F03%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(Store%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)%2F</url>
    <content type="text"><![CDATA[Vuex.Store 构造函数 判断是否自动安装vue 初始化内部变量，将dispatch与commit调用的this绑定为store对象本身，否则在组件内部this.dispatch时的this会指向组件的vm 是否严格模式 执行installModule（初始化module） 执行resetStoreVM（通过VM使store“响应式”） 调用插件、devtool 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788export class Store &#123; constructor(options = &#123;&#125;) &#123; // 判断window.vue是否存在，如果不存在那么就安装 if (!Vue &amp;&amp; typeof window !== "undefined" &amp;&amp; window.Vue) &#123; install(window.Vue); &#125; // 开发过程的判断：创建store实例之前必须先使用这个方法Vue.use(Vuex)，并且判断promise是否可用 if (process.env.NODE_ENV !== "production") &#123; // 必须使用 Vue.use(Vuex) 创建 store 实例 assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`); // 因为vuex中使用了Promise，Promise是es6的语法，但是有的浏览器并不支持es6所以我们需要在package.json中加入babel-polyfill用来支持es6 assert( typeof Promise !== "undefined", `vuex requires a Promise polyfill in this browser.` ); // Store 函数必须使用 new 操作符调用 assert( this instanceof Store, `store must be called with the new operator.` ); &#125; // 提取参数 const &#123; /* 插件默认是空数组，包含应用在 store 上的插件方法。这些插件直接接收 store 作为唯一参数，可以监听 mutation（用于外部地数据持久化、记录或调试）或者提交 mutation （用于内部数据，例如 websocket 或 某些观察者）*/ plugins = [], /* 默认是false，使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。*/ strict = false &#125; = options; // 初始化store内部状态 /* 用来判断严格模式下是否是用mutation修改state的 */ this._committing = false; /* 存放action */ this._actions = Object.create(null); // 用来存储所有对 action 变化的订阅者 this._actionSubscribers = []; /* 存放mutation */ this._mutations = Object.create(null); /* 存放getter */ this._wrappedGetters = Object.create(null); // 模块收集器，构造模块树形结构 this._modules = new ModuleCollection(options); /* 根据namespace存放module */ this._modulesNamespaceMap = Object.create(null); // 用来存储所有对 mutation 变化的订阅者 this._subscribers = []; // 用于使用 $watch 观测 getters this._watcherVM = new Vue(); // 用来存放生成的本地 getters 的缓存 this._makeLocalGettersCache = Object.create(null); /* 将dispatch与commit调用的this绑定为store对象本身，否则在组件内部this.dispatch时的this会指向组件的vm */ const store = this; const &#123; dispatch, commit &#125; = this; /* 为dispatch与commit绑定this（Store实例本身） */ this.dispatch = function boundDispatch(type, payload) &#123; return dispatch.call(store, type, payload); &#125;; this.commit = function boundCommit(type, payload, options) &#123; return commit.call(store, type, payload, options); &#125;; // 严格模式 this.strict = strict; const state = this._modules.root.state; this._wrappedGetters; // 初始化根模块，递归注册所有的子模块，收集所有module的getter到_wrappedGetters中去，this._modules.root代表根module才独有保存的Module对象 installModule(this, state, [], this._modules.root); // 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed resetStoreVM(this, state); // apply plugins // 执行每个插件里边的函数 plugins.forEach(plugin =&gt; plugin(this)); /* devtool插件 */ const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools; if (useDevtools) &#123; devtoolPlugin(this); &#125; &#125;&#125; class ModuleCollection上面有句this._modules = new ModuleCollection(options); 作用：收集模块，构造模块树结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061export default class ModuleCollection &#123; constructor(rawRootModule) &#123; // 注册根模块 参数 rawRootModule 也就是 Vuex.Store 的 options 参数 // 未加工过的模块（用户自定义的），根模块 this.register([], rawRootModule, false); &#125; get(path) &#123; return path.reduce((module, key) =&gt; &#123; return module.getChild(key); &#125;, this.root); &#125; getNamespace(path) &#123; let module = this.root; return path.reduce((namespace, key) =&gt; &#123; module = module.getChild(key); return namespace + (module.namespaced ? key + "/" : ""); &#125;, ""); &#125; update(rawRootModule) &#123; update([], this.root, rawRootModule); &#125; /** * 注册模块 * @param &#123;Array&#125; path 路径 * @param &#123;Object&#125; rawModule 原始未加工的模块 * @param &#123;Boolean&#125; runtime runtime 默认是 true，动态注册的模块runtime为false */ register(path, rawModule, runtime = true) &#123; // 非生产环境 断言判断用户自定义的模块是否符合要求 if (process.env.NODE_ENV !== "production") &#123; assertRawModule(path, rawModule); &#125; const newModule = new Module(rawModule, runtime); if (path.length === 0) &#123; this.root = newModule; &#125; else &#123; const parent = this.get(path.slice(0, -1)); parent.addChild(path[path.length - 1], newModule); &#125; // 递归注册子模块 if (rawModule.modules) &#123; forEachValue(rawModule.modules, (rawChildModule, key) =&gt; &#123; this.register(path.concat(key), rawChildModule, runtime); &#125;); &#125; &#125; unregister(path) &#123; const parent = this.get(path.slice(0, -1)); const key = path[path.length - 1]; if (!parent.getChild(key).runtime) return; parent.removeChild(key); &#125;&#125; class Module接下来看看Module的实例 12345678910111213141516// store 的模块 基础数据结构，包括一些属性和方法export default class Module &#123; constructor(rawModule, runtime) &#123; // 接收参数 runtime this.runtime = runtime; // 存储子模块 this._children = Object.create(null); // 存储原始未加工的模块 this._rawModule = rawModule; // 模块 state const rawState = rawModule.state; // 原始Store 可能是函数，也可能是是对象，是假值，则赋值空对象。 this.state = (typeof rawState === "function" ? rawState() : rawState) || &#123;&#125;; &#125;&#125; installModule 函数 为module加上namespace名字空间（如果有） 注册mutation、action以及getter，同时递归安装所有子module。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* 初始化module *//* @store: 表示当前Store实例/* @rootState: 表示根state/* @path: 我们可以将一个store实例看成module的集合。每一个集合也是store的实例。那么path就可以想象成一种层级关系，当你有了rootState和path后，就可以在Path路径中找到local State。然后每次getters或者setters改变的就是localState/* @module:表示当前安装的模块/* @hot：当动态改变modules或者热更新的时候为true */function installModule(store, rootState, path, module, hot) &#123; /* 是否是根module */ const isRoot = !path.length; /* 获取module的namespace */ const namespace = store._modules.getNamespace(path); /* 如果有namespace，检查是否重复，不重复则在_modulesNamespaceMap中注册 */ if (module.namespaced) &#123; if ( store._modulesNamespaceMap[namespace] &amp;&amp; process.env.NODE_ENV !== "production" ) &#123; console.error( `[vuex] duplicate namespace $&#123;namespace&#125; for the namespaced module $&#123;path.join( "/" )&#125;` ); &#125; store._modulesNamespaceMap[namespace] = module; &#125; // 注册state // 如果不是根并且不是热重载的情况 if (!isRoot &amp;&amp; !hot) &#123; /* 获取父级的state */ const parentState = getNestedState(rootState, path.slice(0, -1)); // 模块名称 const moduleName = path[path.length - 1]; // state 注册 store._withCommit(() =&gt; &#123; if (process.env.NODE_ENV !== "production") &#123; // 有相同的模块名会报错 if (moduleName in parentState) &#123; console.warn( `[vuex] state field "$&#123;moduleName&#125;" was overridden by a module with the same name at "$&#123;path.join( "." )&#125;"` ); &#125; &#125; /* 将子module设置称响应式的 */ Vue.set(parentState, moduleName, module.state); &#125;); &#125; /** * module.context 这个赋值主要是给 helpers 中 mapState、mapGetters、mapMutations、mapActions四个辅助函数使用的。 * 生成本地的dispatch、commit、getters和state。 * 主要作用就是抹平差异化，不需要用户再传模块参数。 */ const local = (module.context = makeLocalContext(store, namespace, path)); /* 遍历注册mutation */ module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key; registerMutation(store, namespacedType, mutation, local); &#125;); /* 遍历注册action */ module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key; const handler = action.handler || action; registerAction(store, type, handler, local); &#125;); /* 遍历注册getter */ module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key; registerGetter(store, namespacedType, getter, local); &#125;); /* 递归安装mudule */ module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot); &#125;);&#125; resetStoreVM 函数 遍历wrappedGetters，使用Object.defineProperty方法为每一个getter绑定上get方法，这样我们就可以在组件里访问this.$store.getter.test就等同于访问store._vm.test 然后new一个Vue对象来实现数据的“响应式化”，运用Vue.js内部提供的数据双向绑定功能来实现store的数据与视图的同步更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */function resetStoreVM(store, state, hot) &#123; /* 存放之前的vm对象 */ const oldVm = store._vm; // 绑定 store.getter store.getters = &#123;&#125;; // 重置 本地getters的缓存 store._makeLocalGettersCache = Object.create(null); // 注册时收集的处理后的用户自定义的 wrappedGetters const wrappedGetters = store._wrappedGetters; // 声明 计算属性 computed 对象 const computed = &#123;&#125;; /* 通过Object.defineProperty为每一个getter方法设置get方法，比如获取this.$store.getters.test的时候获取的是store._vm.test，也就是Vue对象的computed属性 */ forEachValue(wrappedGetters, (fn, key) =&gt; &#123; // use computed to leverage its lazy-caching mechanism // direct inline function use will lead to closure preserving oldVm. // using partial to return function with only arguments preserved in closure environment. computed[key] = partial(fn, store); Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters &#125;); &#125;); // 使用一个 Vue 实例对象存储 state 树 // 阻止警告 用户添加的一些全局mixins // 声明变量 silent 存储用户设置的静默模式配置 const silent = Vue.config.silent; /* Vue.config.silent暂时设置为true的目的是在new一个Vue实例的过程中不会报出一切警告 */ Vue.config.silent = true; /* 这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed */ store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed &#125;); Vue.config.silent = silent; /* 使能严格模式，保证修改store只能通过mutation */ if (store.strict) &#123; enableStrictMode(store); &#125; if (oldVm) &#123; /* 解除旧vm的state的引用，以及销毁旧的Vue对象 */ if (hot) &#123; // 热加载为 true // 设置 oldVm._data.$$state = null store._withCommit(() =&gt; &#123; oldVm._data.$$state = null; &#125;); &#125; // 实例销毁 Vue.nextTick(() =&gt; oldVm.$destroy()); &#125;&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分享】vue原理分析]]></title>
    <url>%2F2019%2F12%2F03%2FVue%2F%E3%80%90%E5%88%86%E4%BA%AB%E3%80%91vue%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言海南分享了vue的核心原理，从源码出发回答经常遇到的一些问题，比如为啥不能检测到对象/数组属性的变化等。记录几个get到的小点： 为啥多次赋值操作，页面只显示最后一个值？？？ vue有个数据队列，根据dom的deep算法，进行更新 为啥this.data.num可以用this.num表示？？？ object.defineProperty又劫持了data，并且把它的属性扩展到vue的实例中，所以可以直接使用this.num；methods也一样 vue的生命周期为啥是那个顺序？？？ 源码中就规定了这样的顺序，首先整出data，然后created，initwatch，complie(编译挂载dom)，mounted(可以操作dom) 性能优化：如果之后不会用到的属性不要放在data里面，因为在data里面的属性都会被劫持，影响性能。我们可以在data外用const接收，下面一样能够使用到变量。vue3.0将没有这个问题，用了某个属性才会被劫持(海南补充：性能优化是3.0是用proxy实现，用了WeakMap，存储data与劫持后的对象的映射关系) 了解了一下computed的大概原理：比如 c(){return a+b} c这个属性会被识别为computed，然后有一系列的回调处理，主要是收集a 和 b的依赖，达到a、b被set后，c能监听到，然后变化 vuex为什么能管理vue？？？ vuex会new一个vue实例，然后对state进行劫持，靠vue实例的原理达到更新。所以此时有两个vue实例，两个dep(依赖收集)，如果不是大的项目就不太必要使用vuex，两个vue实例性能会有影响 以上小点是当时听分享看ppt得出的结论，或许会有偏差，自己也记录了一些不太懂的地方，之后还是需要阅读vue源码，再到回来看看~ 下面补充分享内容~干货！ 开始 VueJs 原理分析Vue会遇到的一些问题 点击修改不生效的例子 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt;&lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.a&#125;&#125; &lt;button @click=&quot;change(index)&quot;&gt;修改数组元素&lt;/button&gt; &lt;button @click=&quot;change2(index)&quot;&gt;修改数组元素内的属性值&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data () &#123; return &#123; arr: [ &#123;a: 111, b: 222&#125;, &#123;a: 111, b: 222&#125;, &#123;a: 111, b: 222&#125;, &#123;a: 111, b: 222&#125;, ], num: 1 &#125; &#125;, methods: &#123; change(index)&#123; this.arr[index] = &#123;a: 444&#125; // this.$set(this.arr,index,&#123;a: 555&#125;) &#125;, change2(index)&#123; this.num++ this.arr[index].a = this.num &#125; &#125; &#125;&lt;/script&gt; 弹窗例子 改变数组或者对象中的值，但是视图没有更新，为什么用set可以，看源码 数组方法 使用refs调用弹窗中的方法，报错，未找到该方法 多次赋值，为什么页面只显示最后的值，this.a = ‘111’; this.a = ‘222’看源码 nextTick还是setTimeout看源码 v-show,v-if到底用哪个好 v-html里写插值为什么不生效 … 开始原理百度“vue原理”这个关键词，90%的几率你会看到类似的一句话： “vue使用Object.defineProperty对数据进行getter与setter的转化，但由于ie8及以下的浏览器不支持Object.defineProperty这个属性，所以vue不兼容ie8及以下的浏览器” 那么，Object.defineProperty到底是个什么东西呢？ mdn的解释 value：属性对应的值,可以使任意类型的值，默认为undefined writable：属性的值是否可以被重写 enumerable：此属性是否可以被枚举 configurable：是否可以删除目标属性或是否可以再次修改属性的特性 get：获取对象值的时候触发 set：设置对象值的时候触发 123456789101112131415161718var data = &#123; name: 'lhl'&#125;Object.keys(data).forEach((key) =&gt; &#123; Object.defineProperty(data, key, &#123; enumerable:true, configurable:true, get()&#123; console.log('get'); &#125;, set(val)&#123; console.log('监听到数据发生了变化'); &#125; &#125;)&#125;)；data.name //控制台会打印出 “get”data.name = 'hxx' //控制台会打印出 "监听到数据发生了变化" 发布订阅12345678910111213141516171819202122var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = []; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function( fn )&#123; // 增加订阅者 this.clientList.push( fn ); // 订阅的消息添加进缓存列表&#125;;salesOffices.trigger = function()&#123; // 发布消息 for( var i = 0, fn; fn = this.clientList[ i++ ]; )&#123; fn.apply( this, arguments ); // (2) // arguments 是发布消息时带上的参数 &#125;&#125;;salesOffices.listen( function( price, squareMeter )&#123; // 小明订阅消息 console.log( '价格= ' + price ); console.log( 'squareMeter= ' + squareMeter );&#125;);salesOffices.listen( function( price, squareMeter )&#123; // 小红订阅消息 console.log( '价格= ' + price ); console.log( 'squareMeter= ' + squareMeter );&#125;);salesOffices.trigger( 2000000, 88 ); // 输出：200 万，88 平方米salesOffices.trigger( 3000000, 110 ); // 输出：300 万，110 平方米 看看核心的图) vue的三个核心类 Observer：用来劫持并监听所有属性，如果有变动的，就通知订阅者 Dep：Observer与Watcher的中转站，对依赖进行收集并通知变化 Watcher：可以收到属性的变化通知并执行相应的函数，从而更新视图 ObserverObserver的核心是通过Obeject.defineProperty()来监听数据的变动，这个函数内部可以定义setter和getter，每当数据发生变化，就会触发setter。这时候Observer就要通知订阅者，订阅者就是Watcher。 WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是： 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 CompileCompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 手摸手写一个简易版vuejs帮助理解以下几点 实现数据双向绑定 实现事件监听 实现生命周期 实现watch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.16/vue.js&quot;&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;num&quot;&gt; &lt;button @click=&quot;change&quot;&gt;change&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // Dep的作用是作为Observer与Watcher的中转站，接收Observer发出的变化通知，转告给Watcher并进行变化后相应的处理 class Dep&#123; constructor()&#123; // subs是一个依赖池，里面放了所有的Watcher this.subs = [] &#125; addSub(watcher)&#123; this.subs.push(watcher) &#125; // notify用来通知变化给Watcher notify(val, oldVal)&#123; for (const watcher of this.subs) &#123; watcher.update(val, oldVal) &#125; &#125; &#125; // Watcher的作用是接收变化的通知，并且执行相应的函数 class Watcher&#123; constructor(vm, key, cb)&#123; this.vm = vm this.key = key this.cb = cb this.get() &#125; // 当数据发生变化的时候就会触发这个事件 update(val, oldVal)&#123; this.cb.call(this.vm , val, oldVal) &#125; // 当我new的时候就触发这个函数，把自己丢进Dep中 get()&#123; Dep.target = this let value = this.vm[this.key] Dep.target = null &#125; &#125; // Observer的作用将数据进行getter与setter的转化，使其变为可响应的 class Observer&#123; constructor(data)&#123; this.data = data this.init(this.data) &#125; init(data)&#123; // init方法使用核心的Object.defineProperty进行实际的转化操作 if( !data || typeof(data) !== &apos;object&apos;) return for (const key in data) &#123; this.defiReactive(data, key, data[key]) // 递归调用数据层级别比较深的数据 this.init(data[key]) &#125; &#125; defiReactive(data, key, val)&#123; let oldVal = val let dep = new Dep() Object.defineProperty(data, key, &#123; enumerable:true, configurable:true, get()&#123; // console.log(&apos;get&apos;); // 为保证不会重复添加依赖，使用Dep.target进行判断 if(Dep.target)&#123; dep.addSub(Dep.target) &#125; return oldVal &#125;, set(val)&#123; // 进行简单的值对比，相同就不触发后续操作 if(oldVal === val) return dep.notify(val, oldVal) // console.log(val, &apos;监听到数据发生了变化&apos;); oldVal = val &#125; &#125;) &#125; &#125; // Complie是用于进行模板解析的（这部分和源码完全不同，纯粹是为了简单实现渲染） class Compile&#123; constructor(vm, el, data)&#123; this.vm = vm this.el = el this.data = data // childNodes可以用来获取dom下的所有子节点 let nodes = document.querySelector(el).childNodes this.compileNodes(nodes) &#125; compileNodes(nodes)&#123; for (const node of nodes) &#123; // 判断节点的类型，1为标签类型，3为文本类型 switch (node.nodeType) &#123; case 1: this.compileNode(node) break; case 3: this.compileText(node) break; default: break; &#125; // 这里判断是否有标签嵌套情况，然后进行递归 node.childNodes &amp;&amp; node.childNodes.length &amp;&amp; this.compileNodes(node.childNodes) &#125; &#125; // 对于文本类型，我们需要解析内部的属性，用来填充内部的文本 compileText(node)&#123; let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/ if(node.textContent !== &apos;&apos; &amp;&amp; reg.test(node.textContent))&#123; // 获取文本绑定的data属性的key let key = reg.exec(node.textContent)[1] node.textContent = this.vm[key] // new Watcher用来进行依赖的收集，当我绑定的这个值发生改变的时候再执行相应的函数 new Watcher(this.vm, key, (val) =&gt; &#123; node.textContent = val &#125;) &#125; &#125; // 对于标签类型，我们需要解析attr属性用来获取标签上监听了什么事件 compileNode(node)&#123; let attrs = node.attributes for (const attr of attrs) &#123; if(attr.name.indexOf(&apos;@&apos;) &gt; -1)&#123; let event = attr.name.split(&apos;@&apos;)[1] let key = attr.value node.addEventListener(event, () =&gt; &#123; this.vm[key]() &#125;) &#125; if(attr.name.indexOf(&apos;v-model&apos;) &gt; -1)&#123; let key = attr.value node.value = this.vm[key] node.addEventListener(&apos;input&apos;, (event) =&gt; &#123; this.vm[key] = event.target.value &#125;) new Watcher(this.vm, key, (val) =&gt; &#123; node.value = this.vm[key] &#125;) &#125; &#125; &#125; &#125; class Vue&#123; constructor(&#123;el, data, methods, watch, created, mounted&#125;)&#123; this.el = el this.data = data() this.methods = methods this.watch = watch // 用来代理vue的各种属性 this.proxy() // 进行数据劫持 new Observer(this.data) created &amp;&amp; created.call(this) // 初始化watch this.initWatch() // 模板解析 new Compile(this, el, this.data) mounted &amp;&amp; mounted.call(this) &#125; initWatch()&#123; for (const key in this.watch) &#123; console.log(this.watch[key], &apos;wawawa&apos;) new Watcher(this, key, this.watch[key]) &#125; &#125; // 代理vue，用来实现this.title替代this.data.title的效果 proxy()&#123; for (const key in this.data) &#123; Object.defineProperty(this, key, &#123; enumerable:false, configurable:true, get()&#123; // console.log(&apos;get&apos;); return this.data[key] &#125;, set(val)&#123; // console.log(val, &apos;监听到数据发生了变化&apos;); this.data[key] = val &#125; &#125;) &#125; for (const key in this.methods) &#123; Object.defineProperty(this, key, &#123; enumerable:false, configurable:true, get()&#123; // console.log(&apos;get&apos;); return this.methods[key] &#125;, set(val)&#123; // console.log(val, &apos;监听到数据发生了变化&apos;); this.methods[key] = val &#125; &#125;) &#125; &#125; &#125; var vm = new Vue(&#123; el: &apos;#app&apos;, data()&#123; return &#123; msg: &apos;hello vue&apos;, msg2: &apos;hello vue2&apos;, num: 1 &#125; &#125;, methods: &#123; change()&#123; // console.log(e) console.log(&apos;click&apos;) this.num++ this.msg = &apos;hello one&apos; &#125; &#125;, watch: &#123; num(val, oldVal)&#123; console.log(val,&apos;watch&apos;) &#125; &#125;, created()&#123; console.log(&apos;created&apos;) &#125;, mounted()&#123; console.log(&apos;mounted&apos;) &#125; &#125;) vm.num = 444 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 源码推荐阅读Vue技术内幕 学习源码能收获什么 带着问题去看源码，在真实的开发阶段使代码提高多少简洁度和代码可改善度 在看源码的当中，学到了什么，对于一些数据处理，一些代码的小技巧，对于自己开发学可以有哪些借鉴之处。 整体的代码思路，和逻辑化分，代码的组织能力又有那里值得我们去学习。 从中我们可以拓展出那些其它api的关联和了解，深入对其它api的理解和运用。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex源码分析(原理与安装)]]></title>
    <url>%2F2019%2F12%2F03%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%89%8B%E5%86%8C%2Fvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E8%A3%85)%2F</url>
    <content type="text"><![CDATA[原理每个组件（也就是Vue实例）在beforeCreate的生命周期中都混入（Vue.mixin）同一个Store实例 作为属性 $store，所以我们能够使用this.$store； 里面有一个resetStoreVM()方法，通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed，我们在获取state的时候，拿的是vm.$_store._vm._data.$$state，这个变量是响应式的 Vue.use 安装因为Vue使用插件时，插件必须提供一个install方法 install 函数vuex/src/store.js 防止Vuex被重复安装 执行applyMixin，目的是执行vuexInit方法初始化Vuex 如果是Vue1.0，Vuex会将vuexInit方法放入Vue的_init方法中 如果是Vue2.0，则会将vuexinit混淆进Vue的beforeCreacte钩子中 12345678910111213141516171819/* 暴露给外部的插件install方法，供Vue.use调用安装插件 *//* 当window上有Vue对象的时候，就会手动编写install方法，并且传入Vue的使用。*/export function install(_Vue) &#123; if (Vue &amp;&amp; _Vue === Vue) &#123; /* 避免重复安装（Vue.use内部也会检测一次是否重复安装同一个插件）*/ if (process.env.NODE_ENV !== "production") &#123; console.error( "[vuex] already installed. Vue.use(Vuex) should be called only once." ); &#125; return; &#125; /* 保存Vue，同时用于检测是否重复安装 */ Vue = _Vue; /* 将vuexInit混淆进Vue的beforeCreate(Vue2.0)或_init方法(Vue1.0) */ /* vueInit 是对vuex的初始化，把$store属性添加到vue实例上，所以我们平常写代码可以使用this.$store，这里的store就是我们实例化Vue的时候传进去的store */ applyMixin(Vue);&#125; applyMixin 函数vuex/src/mixin.js 在vue的声明周期中进行vuex的初始化，并且对vue的各种版本进行了兼容。vuexInit就是对vuex的初始化。为什么我们能在使用vue.$store这种方法呢，因为在vuexInit中为vue的实例添加了$store属性 123456789101112131415161718192021222324252627282930313233export default function(Vue) &#123; // 判断Vue的版本 const version = Number(Vue.version.split(".")[0]); // 如果vue的版本大于2，那么beforeCreate钩子 对vuex进行初始化 if (version &gt;= 2) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;); &#125; else &#123; // 兼容vue 1的版本，将vuexInit方法放入Vue的_init方法中 const _init = Vue.prototype._init; Vue.prototype._init = function(options = &#123;&#125;) &#123; options.init = options.init ? [vuexInit].concat(options.init) : vuexInit; _init.call(this, options); &#125;; &#125; /** * Vuex的init钩子，会存入每一个Vue实例等钩子列表 */ // 给vue的实例注册一个$store的属性，类似咱们使用vue.$route function vuexInit() &#123; const options = this.$options; // store injection if (options.store) &#123; /* 存在store其实代表的就是Root节点，直接执行store（function时）或者使用store（非function）*/ this.$store = typeof options.store === "function" ? options.store() : options.store; &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; /* 子组件直接从父组件中获取$store，这样就保证了所有组件都公用了全局的同一份store */ this.$store = options.parent.$store; &#125; &#125;&#125; 这里的store就是Vuex.Store，我们通常在store/index.js里面声明的： 12345const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;)&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-跳转]]></title>
    <url>%2F2019%2F12%2F02%2FVue%2F%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[如果直接使用a标签，href=’变量’，打开的链接会是router跳转，地址不对，可以@click，window.open(url)；另window.location.href = url会在当前页面打开链接，不适用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Arr-flatten]]></title>
    <url>%2F2019%2F12%2F02%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FArr-flatten%2F</url>
    <content type="text"><![CDATA[介绍将多维数组一维化 使用1234$ npm install --save arr-flattenvar flatten = require('arr-flatten');flatten(['a', ['b', ['c']], 'd', ['e']]); //=&gt; ['a', 'b', 'c', 'd', 'e'] 代码逻辑 主函数flat里面递归，参数为：arr 和结果数组 res 函数内循环遍历数组内的每个元素，if 元素是数组，那么递归flat，传入当前的元素及 res；else 把元素 push 到 res 内 最后返回 res 学习 var len = arr.length &gt;&gt;&gt; 0;无符号右移运算符，保证 len 有意义（为数字类型），且为正整数，在有效的数组范围内（0~0xFFFFFFFF）,且在无意义的情况下缺省值为 0 +num +号使字符串数字快速转成数字]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Array-first]]></title>
    <url>%2F2019%2F11%2F29%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FArray-first%2F</url>
    <content type="text"><![CDATA[介绍从头部截取指定个数的数组元素 使用123456$ npm install --save array-lastvar first = require('array-first');first(['a', 'b', 'c', 'd', 'e', 'f']); //=&gt; 'a'first(['a', 'b', 'c', 'd', 'e', 'f'], 1); //=&gt; 'a'first(['a', 'b', 'c', 'd', 'e', 'f'], 3); //=&gt; ['a', 'b', 'c'] 代码逻辑 If 不为数组，throw 出错误 If 数组长度为 0，返回 null 把参数传入slice库，if 是数字或者字符数字，push（slice库实现的逻辑太繁琐，不如下面array-last简洁） Else 默认截取头一位 学习 使用了 +num，因为代码中判断数字的逻辑中，无论是 number 还是 string，返回的是布尔值，需要把字符数字转变成数字 使用了var len = arr.length &gt;&gt;&gt; 0;无符号右移运算符，保证 len 有意义（为数字类型），且为正整数，在有效的数组范围内（0~0xFFFFFFFF）,且在无意义的情况下缺省值为 0]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Array-last]]></title>
    <url>%2F2019%2F11%2F29%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FArray-last%2F</url>
    <content type="text"><![CDATA[介绍从尾部截取指定个数的数组元素 使用123456$ npm install --save array-lastvar last = require('array-last');last(['a', 'b', 'c', 'd', 'e', 'f']); //=&gt; 'f'last(['a', 'b', 'c', 'd', 'e', 'f'], 1); //=&gt; 'f'last(['a', 'b', 'c', 'd', 'e', 'f'], 3); //=&gt; ['d', 'e', 'f'] 代码逻辑 If 不为数组，throw 出错误 If 数组长度为 0，返回 null If 输入的参数是 数字或者字符数字 定义辅助数组 while 循环，赋值给辅助数组，最后返回 1234while (n--) &#123; // n为输入的参数 res[n] = arr[--len];&#125; Else 不是数字或者字符数字 默认截取最后一位元素 学习 while的用法]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Is-sorted]]></title>
    <url>%2F2019%2F11%2F28%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FIs-sorted%2F</url>
    <content type="text"><![CDATA[介绍判断一个数组是否是顺序或者倒序的 使用1234567$ npm install --save is-sortedvar sorted = require('is-sorted')console.log(sorted([1, 2, 3])) // =&gt; trueconsole.log(sorted([3, 1, 2])) // =&gt; false// supports custom comparatorsconsole.log(sorted([3, 2, 1], function (a, b) &#123; return b - a &#125;)) // =&gt; true 代码逻辑 If 不为数组，throw 出错误 定义了一个默认的判断排序的方法：升序，可以传入自定义判断方法 循环数组，调用判断方法，假如 不满足 则返回 false 123456// 默认判断方法function defaultComparator(a, b) &#123; return a - b;&#125;// 循环判断 不管是哪种判断方法，都是小的减大的，升序a-b，降序b-a，所以出现大于0的时候，就跳出，说明不是顺序排序if (comparator(array[i - 1], array[i]) &gt; 0) return false;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Slice.js]]></title>
    <url>%2F2019%2F11%2F28%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FSlice.js%2F</url>
    <content type="text"><![CDATA[介绍按照输入的参数截取数组或者字符串，参数可以是数字，或者字符 ‘开始:结尾:step’ 使用1234567891011$ npm install slice.jsimport slice from 'slice.js';// for array， string一样const arr = slice([1, '2', 3, '4', 5, '6', 7, '8', 9, '0']);arr[-2]; // 9arr['2:5']; // [3, '4', 5]arr[':-2']; // [1, '2', 3, '4', 5, '6', 7, '8']arr['-2:']; // [9, '0']arr['1:5:2']; // ['2', '4']arr['5:1:-2']; // ['6', '4'] 代码逻辑 If 不为数组或者字符串，throw 出错误 使用 Proxy 代理，重构 get 方法 检测输入的分隔符是否是数字，比如-2 或者 ‘2:5:3’ if 是数字：正数，直接返回 v[n]，如果不是正数，返回 v[n+l] 即倒数第 n 个数。注意 n=2，输出的是 v[2]，n=-2，输出的是 v[l-2]，倒数第 2 个数，不太一样 else 是字符串 需要先处理一下字符串：把字符如 ’2：4：2‘ 分割开来，弄成 start end step，没有传入的为 undefined 或 NaN（需要赋默认值） 把处理好的 start end step，传入 slice()，循环 push 进结果数组 学习 new Proxy() 代理 修改某些操作的默认行为，给目标对象之前架设一层拦截的es6 proxy对象，外部所有的访问都必须先通过这层拦截。 12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;); 重新定义属性的获取和设置 扩展运算符与解构结合 1234567const r = slice(v, ...parseSliceString(path, l));const parseSliceString = (path, l) =&gt; &#123; return [start, end, step];&#125;;// 就依次能拿到start, end, stepconst slice = (v, start, end, step) =&gt; &#123;&#125;;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洋葱圈模型]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2F%E6%B4%8B%E8%91%B1%E5%9C%88%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[学习Egg的时候，对洋葱圈模型很疑惑，不知道它有啥好处，听了组长的讲解，确实大有好处，记录记录 看例子 1234567891011121314151617181920212223242526272829303132// app.js const Koa = require('koa2');const app = new Koa(); // loggerapp.use(async (ctx, next) =&gt; &#123; console.log('第一层洋葱 - 开始') await next(); const rt = ctx.response.get('X-Response-Time'); console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;rt&#125;`); console.log('第一层洋葱 - 结束')&#125;); // x-response-timeapp.use(async (ctx, next) =&gt; &#123; console.log('第二层洋葱 - 开始') const start = Date.now(); await next(); const ms = Date.now() - start; ctx.set('X-Response-Time', `$&#123;ms&#125;ms`); console.log('第二层洋葱 - 结束')&#125;); // responseapp.use(async ctx =&gt; &#123; console.log('第三层洋葱 - 开始') ctx.body = 'Hello World'; console.log('第三层洋葱 - 结束')&#125;); app.listen(8000); 分析首先看到它相比于express的责任链模型，多了async await这样方便的语法，摒弃了express的callback写法，使代码看起来更加优雅简洁。 然后因为有了await，对stream支持度更高，对错误处理更加友好。比如请求1-2-3，返回3-2-1，便可以在返回的途中进行数据处理，而express是不行的。]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NodeJs中的Eventloop]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FNode.js%2FNodeJs%E4%B8%AD%E7%9A%84Eventloop%2F</url>
    <content type="text"><![CDATA[NodeJs中的EventLoop图 1234567891011121314151617181920212223242526 ┌───────────────────────┐┌─&gt;│ timers │&lt;————— 执行 setTimeout()、setInterval() 的回调│ └──────────┬────────────┘| |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调│ ┌──────────┴────────────┐│ │ pending callbacks │&lt;————— 执行由上一个 Tick 延迟下来的 I/O 回调（待完善，可忽略）│ └──────────┬────────────┘| |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调│ ┌──────────┴────────────┐│ │ idle, prepare │&lt;————— 内部调用（可忽略）│ └──────────┬────────────┘ | |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调| | ┌───────────────┐│ ┌──────────┴────────────┐ │ incoming: │ - (执行几乎所有的回调，除了 close callbacks 以及 timers 调度的回调和 setImmediate() 调度的回调，在恰当的时机将会阻塞在此阶段)│ │ poll │&lt;─────┤ connections, │ │ └──────────┬────────────┘ │ data, etc. │ │ | | | | | └───────────────┘| |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调| ┌──────────┴────────────┐ │ │ check │&lt;————— setImmediate() 的回调将会在这个阶段执行│ └──────────┬────────────┘| |&lt;-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调│ ┌──────────┴────────────┐└──┤ close callbacks │&lt;————— socket.on('close', ...) └───────────────────────┘ 先执行所有类型为 timers 的 MacroTask，然后执行所有的 MicroTask（注意 NextTick 要优先哦）； 进入 poll 阶段，执行几乎所有 MacroTask，然后执行所有的 MicroTask； 再执行所有类型为 check 的 MacroTask，然后执行所有的 MicroTask； 再执行所有类型为 close callbacks 的 MacroTask，然后执行所有的 MicroTask； 至此，完成一个 Tick，回到 timers 阶段；如此反复，无穷无尽…… 浏览器的EventLoop12345 ┌───────────────────────┐┌─&gt;│ timers │&lt;————— 执行一个 MacroTask Queue 的回调│ └──────────┬────────────┘| |&lt;-- 执行所有 MicroTask Queue 的回调| ────────────┘ 先执行一个 MacroTask，然后执行所有的 MicroTask； 再执行一个 MacroTask，然后执行所有的 MicroTask；如此反复，无穷无尽…… 举一个栗子12345678910111213setTimeout(()=&gt;&#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(()=&gt;&#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0) 浏览器环境下 1234timer1promise1timer2promise2 NodeJs环境下 1234timer1timer2promise1promise2 setTimeout 与 setImmediate 的顺序在Node环境下，他们的执行顺序是不确定的。（顺便一提，浏览器永远是immediate先） 因为虽然 setTimeout 延时为 0，但是一般情况 Node 把 0 会设置为 1ms，所以，当 Node 准备 event loop 的时间大于 1ms 时，进入 timers 阶段时，setTimeout 已经到期，则会先执行 setTimeout；反之，若进入 timers 阶段用时小于 1ms，setTimeout 尚未到期，则会错过 timers 阶段，先进入 check 阶段，而先执行 setImmediate 1234567setTimeout(() =&gt; &#123; console.log('timeout')&#125;, 0)setImmediate(() =&gt; &#123; console.log('immediate')&#125;) 想要固定顺序，可以这样 1234567891011const fs = require('fs')fs.readFile('test.txt', () =&gt; &#123; console.log('readFile') setTimeout(() =&gt; &#123; console.log('timeout') &#125;, 0) setImmediate(() =&gt; &#123; console.log('immediate') &#125;)&#125;) 此时 setTimeout 和 setImmediate 是写在 I/O callbacks 中的，这意味着，都是处于 poll 阶段，然后是 check 阶段，所以这时无论 setTimeout 到期多么迅速，都会先执行 setImmediate]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[消息队列]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[什么是消息队列？消息队列——MQ(Message Queue)。可以看成是一个存放消息的容器，当我们需要使用消息时候可以取出消息供自己使用。 优点1. 解耦利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息，订阅者消费者不直接接触，而是通过消息队列进行处理数据输出数据。 另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。 2. 异步将不是必须的业务逻辑，异步处理，提高性能 3. 削峰/限流流量削锋是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛 a、可以控制活动的人数b、可以缓解短时间内高流量压垮应用 用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。秒杀业务根据消息队列中的请求信息，再做后续处理 4. 日志处理将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下日志采集客户端，负责日志数据采集，定时写受写入Kafka队列Kafka消息队列，负责日志数据的接收，存储和转发日志处理应用：订阅并消费kafka队列中的日志数据 5. 消息通讯消息通讯是指，消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等点对点通讯：客户端A和客户端B使用同一队列，进行消息通讯。 x：客户端A，客户端B，客户端N订阅同一主题，进行消息发布和接收。实现类似聊天室效果。 以上实际是消息队列的两种消息模式，点对点或发布订阅模式 缺点1. 系统可用性降低万一MQ挂了。。。 2. 系统复杂性降低需要保证消息没有被重复消费，保证不被丢失，保证顺序性等等 3. 一致性问题在异步的情况下，假如消费者没有正常消费，就会出现数据不一致的情况 选型关于选型，因为自己还没有实践经验，摘录了网上原文，以供记录： ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。 RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的 kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RPC]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FRPC%2F</url>
    <content type="text"><![CDATA[什么是RPCRPC(Remote Procedure Call：远程过程调用)：一种进程间通信方式，允许像调用本地服务一样调用远程服务。 RPC框架负责屏蔽底层的传输方式（TCP或者UDP）、序列化方式（XML/JSON/二进制）和通信细节。主要目标就是让远程服务调用更简单、透明。开发人员在使用的时候只需要了解谁在什么位置提供了什么样的远程服务接口即可，并不需要关心底层通信细节和调用过程。 RPC架构 客户端(client)：服务调用方 服务端(server)：服务提供方 客户端存根(client stub)：将客户端请求参数打包成网络消息，再发给服务方 服务端存根(server stub)：接收客户端发来的消息，将消息解包，并调用本地方法 与HTTP区别 RPC主要基于TCP/UDP协议，HTTP协议是应用层协议，是构建在传输层协议TCP之上的，从效率来看的话RPC更胜一筹 RPC长连接：不必每次通信都像http一样去三次握手，减少网络开销； HTTP服务开发迭代更快：在接口不多，系统与系统之间交互比较少的情况下，http就显得更加方便；相反，在接口比较多，系统与系统之间交互比较多的情况下，http就没有RPC有优势 如何选择一般来说，RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。 流行的RPC框架 gRPC：Google 公布的开源软件，基于HTTP 2.0 协议 Thrift： Facebook 的开源 RPC 框架，主要是一个跨语言的服务开发框架，基于TCP协议 Dubo：阿里集团开源的一个Java RPC 框架，基于TCP协议]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F11%2F25%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FRedis%2F</url>
    <content type="text"><![CDATA[Redis是一个key-value存储系统，数据存储在内存中，通常被称为数据结构服务器 优点 性能极高，速度很快 纯内存操作，是已知性能最快的key-value数据库：读的速度是110000次/s,写的速度是81000次/sHashMap 的查找和操作的时间复杂度均为O(1) 单线程操作，避免了频繁的上下文切换 采用了非阻塞I/O多路复用机制：我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。 丰富的数据类型 5种 - Strings(字符串)、List(列表)、 Hash(哈希)、Set(集合)、Sorted Set(有序集合) 丰富的特性 订阅发布 Pub / Sub 功能 Key 过期策略 事务 原子性(事务中的命令要么全部被执行，要么全部都不执行) 一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断 支持多个 DB 计数 持久化存储 可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用 缺点 由于是内存数据库，所以，单台机器存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务 redis是单线程的，单台服务器无法充分利用多核服务器的CPU 缓存穿透、雪崩、击穿问题 数据类型Strings(字符串)最基本的数据类型，value可以包含任何数据，比如jpg图片 1234127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; get foo"bar" List(列表)可以在头部(左边)或尾部(右边)添加新元素，利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好 1234567891011LPUSH citylist Beijing Shanghai(integer) 2127.0.0.1:6379&gt; LPUSH citylist Guangzhou(integer) 3127.0.0.1:6379&gt; LPUSH citylist Guangzhou(integer) 4127.0.0.1:6379&gt; lrange citylist 0 41) "Guangzhou"2) "Guangzhou"3) "Shanghai"4) "Beijing" Hash(哈希)键值对集合，一个string类型的field和value的映射表，特别适合用于存储对象，比如存cookieId 12345127.0.0.1:6379&gt; HMSET cityhash Beijing GuangzhouOK127.0.0.1:6379&gt; HGETALL cityhash1) "Beijing"2) "Guangzhou" Set(集合)堆放的是一堆不重复值的集合，通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1) 12345678910127.0.0.1:6379&gt; SADD cityset Beijing Guangzhou(integer) 2127.0.0.1:6379&gt; SADD cityset Shanghai(integer) 1127.0.0.1:6379&gt; SADD cityset Beijing(integer) 0127.0.0.1:6379&gt; SMEMBERS cityset1) "Guangzhou"2) "Shanghai"3) "Beijing" Sorted Set(有序集合)与集合一样，存放不重复值的集合。但是每个元素都会关联一个double类型的分数，集合中的元素能够按score进行排列。可以做排行榜应用 123456789101112131415127.0.0.1:6379&gt; ZADD cityzset 0 Beijing(integer) 1127.0.0.1:6379&gt; ZADD cityzset 1 Guangzhou(integer) 1127.0.0.1:6379&gt; ZADD cityzset 2 Shanghai(integer) 1127.0.0.1:6379&gt; ZADD cityzset 3 Beijing(integer) 0127.0.0.1:6379&gt; ZRANGE cityzset 0 10 WITHSCORES1) "Guangzhou"2) "1"3) "Shanghai"4) "2"5) "Beijing"6) "3" 过期策略与内存淘汰机制Redis采用的是定期删除+惰性删除策略。不采用定时删除的原因是：虽然Key到了过期时间及时释放，但是十分消耗CPU资源，在大并发请求中，CPU不能集中时间做要紧的事情，还要花时间删除Key。并且定时器的创建会影响性能。 定期删除是Redis默认每100ms检查，是否有过期的Key，过期则删除。注意不是将所有的Key都检查，而是随机抽取进行检查。如果只采用这种策略，将导致很多过期的Key过期没有被删除。 惰性删除是获取到Key的时候，检查一下，如果过期就删除返回null。 当然，两种策略还是不能保证所有到期的Key被删除，当Redis的内存不足以容纳新写入数据时，走内存淘汰机制 12// 在redis.conf中有一行配置# maxmemory-policy volatile-lru noeviction：新写入操作会报错(不推荐) allkeys-lru：移除最近最少使用的Key(推荐，最常用) allkeys-random：随机移除某个Key(不推荐) volatile-lru：在设置了过期时间Key中，移除最近最少使用的Key(不推荐) volatile-random：在设置了过期时间Key中，随机移除某个Key(不推荐) volatile-ttl：在设置了过期时间Key中，有更早过期的Key优先移除(不推荐) ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。 内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。 缓存穿透、雪崩、击穿问题缓存穿透用户不断请求缓存和数据库中都没有的数据，导致数据库压力过大 解决方案： 利用互斥锁：缓存失效的时候，先去获得锁，得到锁，再去请求数据库。没得到锁，则休眠一段时间重试 提供一个能迅速判断请求是否有效的拦截机制，比如：利用布隆过滤器，内部维护一系列合法有效的key，迅速判断，请求所携带的key是否合法。如果不合法，直接返回 如果查询返回的数据为空（不管数据是否存在，或系统故障），仍把这个空结果进行缓存，设置很短的过期时间 缓存击穿并发请求 缓存中没有或过期但数据库中有的数据，导致数据库压力过大 解决方案： 设置热点数据永不过期 加互斥锁（以下是伪代码） 从缓存取数据 如果结果没有为null，去获取锁，获取成功，去数据库获取数据 把数据库中获取的数据存到缓存，释放锁 如果获取锁失败，暂停100ms再重新去获取数据 缓存雪崩缓存同一时间大面积的失效，这个时候又来了一波请求，导致数据库压力过大甚至down机。和缓存击穿不同，缓存击穿指并发查同一条数据，雪崩是很多数据 解决方案： 过期时间设置随机，防止同一时间大面积失效现象发生 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中 设置热点数据永不过期 利用互斥锁 数据库双写一致性本来想看懂redis与数据库双写一致性问题，太复杂了，太绕了，没试过，整蒙圈了，又是先删缓存再更新数据库，又是先更新数据库再删缓存，完了这两种都有弊端，没有确切的答案。挣扎了一番，我决定以后再看！先po文章链接：链接]]></content>
      <categories>
        <category>后端知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存硬盘寄存器]]></title>
    <url>%2F2019%2F11%2F25%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%86%85%E5%AD%98%E7%A1%AC%E7%9B%98%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[内存与硬盘的区别CPU是处理器，是大脑和核心，内存和硬盘都是存储器，受CPU的指挥 内存 硬盘 性质 计算机的工作场所 存放暂时不用的信息 制作材料 半导体材料 磁性材料 信息保存 会随电而丢失 可以长久保存 容量 一般为6GB 一般容量为1TB即931GB 作用 CPU和硬盘数据之间的缓冲，CPU只能读取内存里的数据 作为存储空间 存储器与寄存器的区别存储器是内存或外设内存；寄存器是CPU存储数据的地方，与CPU离得近，所以CPU在运算时通常会把寄存器当中转站。把数据由内存调到寄存器，然后执行指令。 简单地说：寄存器是操作数据的地方，存储器是存放数据的地方 存储器 寄存器 功能 存放指令和数据，并能由中央处理器（CPU）直接随机存取 可将寄存器内的数据执行算术及逻辑运算；存于寄存器内的地址可用来指向内存的某个位置，即寻址；可以用来读写数据到电脑的周边设备。 速度 主存储器中的数据必须放入寄存器材能够进行操作 速度比主存储器的速度要快很多，由于寄存器的容量有限，所以将不需要操作的数据存放在主存储器中 位置 一般在CPU外部，不过CPU内的Cache与单片机内都有存储器 CPU内]]></content>
      <categories>
        <category>计算机</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[观察者与发布订阅者模式]]></title>
    <url>%2F2019%2F11%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%A7%82%E5%AF%9F%E8%80%85%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言介绍观察者模式与发布订阅者模式。 观察者模式观察者模式有两个角色：Subject(目标)用来维护一个 observer 列表、Observer(观察者)在 observer 中定义了一个具体的 update 方法，用来执行相关操作。 整个过程：当某个值发生变化后，Subject 调用 notify 方法，实际上就是循环调用 observer 列表中每个 observer 的 uodate 方法，并把新的值作为 update 的参数传递进去。就像房东和租客直接直接联系的场景。 1234567891011121314151617181920212223242526272829303132333435363738394041// 观察者class Observer &#123; constructor() &#123;&#125; update(val) &#123;&#125;&#125;// 观察者列表class ObserverList &#123; constructor() &#123; this.observerList = []; &#125; add(observer) &#123; return this.observerList.push(observer); &#125; remove(observer) &#123; this.observerList = this.observerList.filter(ob =&gt; ob != observer); &#125; count() &#123; return this.observerList.length; &#125; get(index) &#123; return this.observerList[index]; &#125;&#125;// 目标class Subject &#123; constructor() &#123; this.observers = new ObserverList(); &#125; addObserver(observer) &#123; this.observers.add(observer); &#125; removeObserver(observer) &#123; this.observers.remove(observer); &#125; notify(...args) &#123; let obCount = this.observers.count(); for (let index = 0; index &lt; obCount; index++) &#123; this.observers.get(i).update(...args); &#125; &#125;&#125; 发布订阅者模式观察者模式中，目标和观察者直接进行交互。发布者订阅者模式中统一用 调度中心 进行处理任务，订阅者发布者互不干扰，一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。就像房东中介租客的场景。 123456789101112131415161718192021222324class PubSub &#123; constructor() &#123; this.subscribers = &#123;&#125;; &#125; subscribe(type, fn) &#123; if(!Object.prototype.hasOwnProperty.call(this.subscribers, type)) &#123; this.subscribers[type] = []; &#125; this.,subscribers[type].push(fn); &#125; unsubscribe(type, fn) &#123; let listeners = this.subscribers[type]; if(!listeners || !listeners.length) return; this.subscribers[type] = listeners.filter(v =&gt; v !== fn); &#125; publish(type, ...args) &#123; let listeners = this.subscribers[type]; if(!listeners || !listeners.length) return; listeners.forEach(fn =&gt; fn(...args)); &#125;&#125;let ob = new PubSub();ob.subscribe('add', (val) =&gt; console.log(val));ob.publish('add', 1); 总结 观察者模式 由具体目标调度，每个被订阅的目标里面都需要有对观察者的处理，会造成代码的冗余 观察者是知道 Subject 的，Subject 一直保持对观察者进行记录 大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法 发布订阅模式 任务统一由调度中心处理，消除了发布者和订阅者之间的依赖 发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信 大多数时候是异步的（使用消息队列）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者模式]]></title>
    <url>%2F2019%2F11%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言属于面向过程编程模式的一种。产生数据-生产者，处理数据-消费者，中间还有一个缓冲区，作为一个中介，生产者把数据放入缓冲区，而消费者从缓冲区取出数据。 关键就是内存缓冲区为空的时候消费者必须等待，而内存缓冲区满的时候，生产者必须等待，从而达到动态平衡， 缓冲区的优点 降低耦合度，生产者和消费者都依赖缓冲区，而不直接依赖彼此 支持并发，生产者和消费者是两个独立的并发主体，在工作的时候，谁也不用去等谁 支持忙闲不均，当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。 与发布者订阅者模式的区别生产消费者模式 生产者推送消息到消息中心，消费者取出消息消费，同一类别下，所有消费者取到的数据是相同的 生产者生产消息放到队列里，多个消费者同时监听队列，谁先抢到消息谁就会从队列中取走消息；即对于每个消息只能被最多一个消费者拥有 订阅发布模式 本质是一种生产者消费者模式，不同点：订阅者先向消息中心订阅自己感兴趣的类型数据，发布者推送消息到消费中心，订阅者最后获取到自己感兴趣的数据(更细粒度的控制) 发布者生产消息放到队列里，多个监听队列的消费者都会收到同一份消息；即正常情况下每个消费者收到的消息应该都是一样的]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于Node的几个小点]]></title>
    <url>%2F2019%2F11%2F22%2F%E5%90%8E%E7%AB%AF%E7%9F%A5%E8%AF%86%2FNode.js%2F%E5%85%B3%E4%BA%8ENode%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E7%82%B9%2F</url>
    <content type="text"><![CDATA[node作为中间层，是怎么衔接后端的？ 通过node中的http模块，向接口发起请求，可以在node中做一些数据的处理、接口的合并等等。 如果前端是上传文件，node作为中间层，需要存储文件吗？这个上传整个流的传输过程。 node不用存储文件，通过流的特性可以将这个请求转发给后台。 为什么一般是node+mongodb，是因为mongodb的非关系数据库特点还是非sql语句的写法或者其他？ mongodb是基于js脚本语言的，也可以说是非sql语句的写法，因为mongodb主要是通过调用api的形式完成数据库的操作。]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-14种通讯方式]]></title>
    <url>%2F2019%2F11%2F21%2FVue%2F14%E7%A7%8D%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍14种通讯方式~ 1 props12345678910111213props:&#123; inpVal:&#123; type:Number, //传入值限定类型 // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认 required: true, //是否必传 default:200, //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=&gt;[] validator:(value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125;&#125; 2 $emit1234// 父组件&lt;home @title="title"&gt;// 子组件this.$emit('title',[&#123;title:'这是title'&#125;]) 3 vuex12345678state:定义存贮数据的仓库 ,可通过this.$store.state 或mapState访问getter:获取 store 值,可认为是 store 的计算属性,可通过this.$store.getter 或 mapGetters访问mutation:同步改变 store 值,为什么会设计成同步,因为mutation是直接改变 store 值, vue 对操作进行了记录,如果是异步无法追踪改变.可通过mapMutations调用action:异步调用函数执行mutation,进而改变 store 值,可通过 this.$dispatch或mapActions 访问modules:模块,如果状态过多,可以拆分成模块,最后在入口通过...解构引入 4 attrs和listeners2.4.0新增attrs 获取父传子中未在props中定义的值，如果在props中定义了，则获取的是剔除定义的值 适用场景：假如子组件想获取父组件的name属性，孙子组件想获取父组件的age属性，用props就需要把name和age都通过props传递到子组件，子组件再通过props传递给孙子组件；子组件绑定attrs，孙子组件就能获取除了name属性外的父组件的其他属性，如果孙子属性也想获取name属性，那么绑定name即可 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;childcom :name=&quot;name&quot; :age=&quot;age&quot; :sex=&quot;sex&quot;&gt;&lt;/childcom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; &apos;name&apos;:&apos;test&apos;, props:[], data()&#123; return &#123; &apos;name&apos;:&apos;张三&apos;, &apos;age&apos;:&apos;30&apos;, &apos;sex&apos;:&apos;男&apos; &#125; &#125;, components:&#123; &apos;childcom&apos;:&#123; props:[&apos;name&apos;], template:`&lt;div&gt; &lt;div&gt;我是子组件 &#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;grandcom v-bind=&quot;$attrs&quot;&gt;&lt;/grandcom&gt; &lt;/div&gt;`, components: &#123; &apos;grandcom&apos;:&#123; template:`&lt;div&gt;我是孙子组件&#123;&#123;$attrs.age&#125;&#125;&lt;/div&gt;`, &#125; &#125; &#125; &#125;&#125;&lt;/script&gt; inheritAttrs默认值为true，父组件传给子组件的属性，即使没有定义在props，也会被作为普通html属性被渲染。设置为false，未被props定义的属性就不会被当成普通html属性渲染 适用场景：假如父元素传递了一个type=&#39;text&#39;，子组件为input type=&#39;number&#39;，如果不设置成false，就会被覆盖，我们可以设置成false，再用attrs进行获取父元素传过来的type值 1234567891011121314151617181920212223242526&lt;template&gt; &lt;childcom :name="name" :age="age" type="text"&gt;&lt;/childcom&gt;&lt;/template&gt;&lt;script&gt;export default &#123; 'name':'test', props:[], data()&#123; return &#123; 'name':'张三', 'age':'30', 'sex':'男' &#125; &#125;, components:&#123; 'childcom':&#123; inheritAttrs:false, props:['name','age'], template:`&lt;input type="number" style="border:1px solid blue"&gt;`, created () &#123; console.log(this.$attrs.type) &#125; &#125; &#125;&#125;&lt;/script&gt; *listeners *子组件改变父组件的值，在创建更高层次的组件时非常有用 适用场景：想在孙子组件更改父组件的值 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;childcom :name=&quot;name&quot; :age=&quot;age&quot; :sex=&quot;sex&quot; @testChangeName=&quot;changeName&quot;&gt;&lt;/childcom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; &apos;name&apos;:&apos;test&apos;, props:[], data()&#123; return &#123; &apos;name&apos;:&apos;张三&apos;, &apos;age&apos;:&apos;30&apos;, &apos;sex&apos;:&apos;男&apos; &#125; &#125;, components:&#123; &apos;childcom&apos;:&#123; props:[&apos;name&apos;], template:`&lt;div&gt; &lt;div&gt;我是子组件 &#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;grandcom v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/grandcom&gt; &lt;/div&gt;`, components: &#123; &apos;grandcom&apos;:&#123; template:`&lt;div&gt;我是孙子组件-------&lt;button @click=&quot;grandChangeName&quot;&gt;改变名字&lt;/button&gt;&lt;/div&gt;`, methods:&#123; grandChangeName()&#123; this.$emit(&apos;testChangeName&apos;,&apos;kkkkkk&apos;) &#125; &#125; &#125; &#125; &#125; &#125;, methods:&#123; changeName(val)&#123; this.name = val &#125; &#125;&#125;&lt;/script&gt; 5 provide和inject2.2.0新增provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。 inject 通常是一个字符串数组。 适用场景：单向传值（由provide的组件传递给inject的组件），尤其是祖父组件–孙组件等有跨度的组件间传值。注意：provide 和 inject 绑定并不是可响应的（官方刻意），想要响应，应该传入数组/对象（引用类型） 123456789101112131415//父组件:provide: &#123; //provide 是一个对象,提供一个属性或方法 foo: '这是 foo', fooMethod:()=&gt;&#123; console.log('父组件 fooMethod 被调用') &#125;&#125;,// 子或者孙子组件inject: ['foo','fooMethod'], //数组或者对象,注入到子组件mounted() &#123; this.fooMethod() console.log(this.foo)&#125;//在父组件下面所有的子组件都可以利用inject 6 parent和children并不保证顺序，也不是响应式的，只能拿到一级父组件和子组件 1234567891011//父组件mounted()&#123; console.log(this.$children) //可以拿到 一级子组件的属性和方法 //所以就可以直接改变 data,或者调用 methods 方法&#125;//子组件mounted()&#123; console.log(this.$parent) //可以拿到 parent 的属性和方法&#125; 7 $refs123456// 父组件&lt;home ref="home"/&gt;mounted()&#123; console.log(this.$refs.home) //即可拿到子组件的实例,就可以直接操作 data 和 methods&#125; 8 $root123456// 父组件mounted()&#123; console.log(this.$root) //获取根实例,最后所有组件都是挂载到根实例上 console.log(this.$root.$children[0]) //获取根实例的一级子组件 console.log(this.$root.$children[0].$children[0]) //获取根实例的二级子组件&#125; 9 路由传参1234567891011121314151617181920212223242526272829// 路由定义&#123; path: '/describe/:id', name: 'Describe', component: Describe&#125;// 页面传参 1 参数拼接在后面，安全性低this.$router.push(&#123; path: `/describe/$&#123;id&#125;`,&#125;)// 页面传参 2 同上this.$router.push(&#123; path: '/describe', query: &#123; id: id &#125;)// 页面获取 1 2this.$route.query.id // 页面传参 3 参数不会拼接在路由后面，页面刷新参数丢失this.$router.push(&#123; name: 'Describe', params: &#123; id: id &#125;&#125;)// 页面获取this.$route.params.id 10 .sync2.3.0+实现简单”双向绑定“的语法糖 1234// 父组件&lt;home :title.sync="title" /&gt;// 编译时会被扩展为&lt;home :title="title" @update:title="val =&gt; title = val"/&gt; prop是单向下行绑定，父组件的prop更新会流到子组件，但是反过来不会，使用prop做双向绑定，需要在父组件绑定一个事件和一个值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;wrd&quot;&gt; &lt;box @incre=&quot;boxIncremend&quot; :word=&quot;word&quot;&gt;&lt;/box&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import box from &apos;./box&apos;export default &#123; name: &apos;HelloWorld&apos;, data() &#123; return &#123; word: &apos;&apos; &#125; &#125;, methods: &#123; boxIncremend(newword) &#123; this.word = newword &#125; &#125;, components: &#123; box &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;str&quot;&gt; &lt;h2&gt;&#123;&#123; word &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;box&apos;, props: &#123; word: &apos;&apos; &#125;, watch: &#123; str: function(newword) &#123; //往父级发射incre事件 this.$emit(&apos;incre&apos;, newword) &#125; &#125;,&#125;&lt;/script&gt; 使用.sync，父组件可以少写一个自定义事件，子组件直接$emit以实现父组件中数据的变化 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 父组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;wrd&quot;&gt; &lt;box :word.sync=&quot;wrd&quot;&gt;&lt;/box&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import box from &apos;./box&apos;export default &#123; name: &apos;HelloWorld&apos;, data() &#123; return &#123; wrd: &apos;&apos; &#125; &#125;, components: &#123; box &#125;&#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;str&quot;&gt; &lt;h2&gt;&#123;&#123; word &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;box&apos;, props: &#123; word: &apos;&apos; &#125;, watch: &#123; str: function(newword) &#123; //往父级更新 this.$emit(&apos;update:word&apos;, newword) // 注意update后面跟的是子组件那个值 &#125; &#125;,&#125;&lt;/script&gt; 11 broadcast和dispatch2.x 已弃用 12 EventBus实质就是创建一个vue实例，通过一个空的vue实例作为桥梁实现vue组件间的通信。它是实现兄弟组件通信的一种解决方案。类似于vuex，只适用于极小的项目 项目中创建一个js文件（通常为bus.js），引入vue，创建一个vue实例，导出这个实例 12import Vue from "Vue";export default new Vue(); 需要通信的组件中分别引入这个bus.js 发送数据的组件通过$emit发送事件名称和数据；接收数据的组件通过$on监听事件和接收数据 1234Bus.$emit('click',data)Bus.$on("click", target =&gt; &#123; // 发送和接收的事件名必须一致 console.log(target);&#125;); 清除事件总线eventBus 不手动清除，它是一直会存在的，就会导致反复进入到接受数据的组件内操作获取数据的时候，原本只执行一次的获取的操作将会有多次操作。 所以需要在vue生命周期beforeDestroy或者destroyed中用vue实例的$off方法清除eventBus 123beforeDestroy()&#123; Bus.$off('click');&#125; 13 Vue.observable2.6.0新增实现一个简易的vuex。将一个对象作为入参传给 Vue.observable() ，经过处理之后，这个对象在 Vue 内就可以实时更新，其返回值可以直接用于 render 和 computed 中，并且会在发生改变时触发相应的更新 1234567891011121314151617181920212223242526272829303132333435// 文件路径 - /store/store.jsimport Vue from 'vue'export const store = Vue.observable(&#123; count: 0 &#125;) //定义一个变量export const mutations = &#123; setCount (count) &#123; store.count = count //定义一个方法，将来在组件中调用这个方法从而能改变上面的变量count值 &#125;&#125;//使用&lt;template&gt; &lt;div&gt; &lt;label for="bookNum"&gt;数 量&lt;/label&gt; &lt;button @click="setCount(count+1)"&gt;+&lt;/button&gt; &lt;span&gt;&#123;&#123;count&#125;&#125;&lt;/span&gt; &lt;button @click="setCount(count-1)"&gt;-&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; store, mutations &#125; from '../store/store' // Vue2.6新增API Observableexport default &#123; name: 'Add', computed: &#123; count () &#123; return store.count //用于去渲染之前Observable中定义的变量count &#125; &#125;, methods: &#123; setCount: mutations.setCount &#125;&#125;&lt;/script&gt; 14 v-slot 2.6.0新增在vue v2.6.0中，新引入了v-slot指令，取代了slot和slot-scope这两个目前已经被废弃但是未被移除的特性，简化了一些复杂的语法 适用场景： A. 有时候我们希望在指定的位置上输出我们的子元素：组件中可以使用template标签，加v-slot指令制定具名插槽；如果没有指明插槽name时，默认出口会带有隐含的名字default B. 作用域插槽：子组件内的数据可以被父组件拿到（解决了数据只能从父组件传递给子组件） v-slot ：后边是插槽名称，=后边是组件内部绑定作用域值的映射(取什么名字不重要，拿到的是子组件绑定变量的合集) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 根组件&lt;template&gt; &lt;div&gt; &lt;mo&gt; &lt;template v-slot:header=&quot;slotProps&quot;&gt; &lt;h1&gt;&#123;&#123;slotProps.user + &apos; &apos; + msg&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; // 相当于 v-slot:default &lt;p&gt;And another one.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here&apos;s some contact info&lt;/p&gt; &lt;/template&gt; &lt;/mo&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import mo from &apos;./module.vue&apos; export default &#123; components: &#123; mo &#125;, data() &#123; return &#123; msg: &apos;这是根组件的消息&apos; &#125; &#125; &#125;&lt;/script&gt;// 子组件&lt;template&gt; &lt;div&gt; --header start-- &lt;header&gt; &lt;slot name=&quot;header&quot; :header=&quot;header&quot;&gt;&lt;/slot&gt; &lt;/header&gt; --header over-- &lt;div&gt;&lt;/div&gt; --default start-- &lt;slot&gt;&lt;/slot&gt; // 匹配default --default over-- &lt;div&gt;&lt;/div&gt; --footer start-- &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; --dooter over-- &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; header: &apos;来自子组件的头部消息&apos;, user: &apos;9999&apos; &#125; &#125; &#125;&lt;/script&gt;// 输出9999 这是根组件的消息--header over----default start--A paragraph for the main content.And another one.--default over----footer start--Here&apos;s some contact info--dooter over-------------------]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-watch]]></title>
    <url>%2F2019%2F11%2F21%2FVue%2Fwatch%2F</url>
    <content type="text"><![CDATA[立即执行场景：比如搜索框，一般会在页面生成created()或mounted()生命周期调用接口方法获取全部数据，然后watch输入的value，再调用一次接口方法。代码如下 1234567891011121314151617181920212223export default &#123; data()&#123; return &#123; sarchValue:"" &#125; &#125;, created():&#123; this.getList(); &#125;, methods:&#123; getList()&#123; server.getList(&#123; serachValue:this.searchValue &#125;) &#125; &#125;, watch:&#123; serachValue()&#123; this.getList() //getList里面通过searchValue去搜索数据库 &#125; &#125;&#125; 适用immediate:true，可以初始化时立即执行，也就是说data里面定义了value就立即执行handle，改后 123456789101112131415161718192021222324export default &#123; data()&#123; return &#123; sarchValue:"" &#125; &#125;, created():&#123; &#125;, methods:&#123; getList()&#123; server.getList(&#123; serachValue:this.searchValue &#125;) &#125; &#125;, watch:&#123; serachValue:&#123; //使用watch值是对象的第三种情况 handler:"getList" //getList里面通过searchValue去搜索数据库 immediate:true &#125; &#125;&#125; 深度监听12345678watch:&#123; inpValObj:&#123; handler(newVal,oldVal)&#123; console.log(newVal, oldVal) &#125;, deep:true &#125;&#125; 深度监听可以监听对象的变化，但是无法监听具体对象的属性变化：如我们改变了inpValObj的属性，确实可以打印出newVal, oldVal，但是并不能看到具体属性的变化。 方法：直接监听对象的属性 12345watch: &#123; 'obj.name'(curVal, oldVal) &#123; // TODO &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-页面需要引入多个组件技巧]]></title>
    <url>%2F2019%2F11%2F21%2FVue%2Frequire.context()%2F</url>
    <content type="text"><![CDATA[场景：页面需要引入多个组件 123456789101112131415161718const files = require.context('@/components/home', false, /\.vue$/)// 在 ts 文件中报错：Property 'context' does not exist on type 'NodeRequire'. // 改成：require['context']() 即可const modules = &#123;&#125;function getFloorConfigName(path) &#123; return path.match(/([\w-]+)\.vue/)[1];&#125; //([\w-]+) ： 匹配数字和字母下划线，中划线的多个字符files.keys().forEach(key =&gt; &#123; modules[getFloorConfigName(key)] = files(key).default || files(key)&#125;)conosle.log(modules)// 使用modules['HomePage']]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node+TypeScript 项目]]></title>
    <url>%2F2019%2F11%2F20%2FTypeScript%2FNode%2BTypeScript%20%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在 Node+TypeScript 项目中，自己新建了一个分支，尝试把js文件改成ts文件。发现了几个有趣的地方： ts文件使用import引入外部资源，js文件使用require：node.js module是commonjs ，ts 一般推荐使用es6 规范 Argument of type &#39;any&#39; is not assignable to parameter of type &#39;never&#39;.一般出现在数组报错，需要给数组定义类型 实操后还是能亲身感受到typescript的便利性：可编译时检测，定义类型，减少出错的几率，提高开发的效率]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在一台电脑使用两个github账号]]></title>
    <url>%2F2019%2F11%2F20%2FGit%2F%E5%9C%A8%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AAgithub%E8%B4%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[本来想着在自己本身的github上拉一个项目，发现没有权限，emmmm，确实，这个电脑的git账号用的公司的账号，当然clone不成功。在同一台电脑上使用多个github账号，这个情景以后应该会用的蛮多，所以学习了一下，下面记录： 步骤1234567891011121314151617181920212223$ cd ~/.ssh# 为个人账号生成 SSH Key$ ssh-keygen -t rsa -C 'personal@maiil.com' -f id_rsa_personal # 查看生成的 SSH Key，复制到github仓库，添加SSH$ cat ~/.ssh/id_rsa_personal.pub# 测试 SSH Key$ ssh -T git@github.com# 把Key加到SSH agent上，因为不是使用默认的.ssh/id_rsa，所以需要告诉 SSH agent新Key的位置$ sh-add ~/.ssh/id_rsa_personal# 配置.ssh/config，先ls看看有没有config文件，没有就要touch config#default githubHost github.com HostName github.com IdentityFile ~/.ssh/id_rsa Host github_wei HostName github.com IdentityFile ~/.ssh/id_rsa_personal 之后通过使用别名github_wei来明确说明使用id_rsa_personal的SSH key来连接github 123456# clone到本地$ git clone git@github_wei:xxxx/test.git# push到github上去$ git remote add origin git@github_wei:xxxx/test.git$ git push origin master 也可以通过特定的repo下执行下面的命令 12345$ git config user.name 'newname'$ git config user.email 'newemail'# git config --global --unset user.name 取消全局设置# git config --global --unset user.email 取消全局设置 在用个人账号pull,push操作时出现的问题12345678910$ git push --set-upstream origin master# Enter passphrase for key '/Users/wei/.ssh/id_rsa_personal': # Enter passphrase for key '/Users/wei/.ssh/id_rsa_personal': # Enter passphrase for key '/Users/wei/.ssh/id_rsa_personal': # To github_wei:ZhangWei2222/analysis-code.git# ! [rejected] master -&gt; master (non-fast-forward)# error: 推送一些引用到 'git@github_wei:ZhangWei2222/analysis-code.git' 失败# 提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。# 提示：再次推送前，先与远程变更合并（如 'git pull ...'）。详见# 提示：'git push --help' 中的 'Note about fast-forwards' 小节。 原因： 远程仓库和本地不同步引起的 解决： 123$ git remote add origin https://github.com/yuanzb/yuanzb.git $ git fetch origin //获取远程更新$ git merge origin/master //把更新的内容合并到本地分支 然后在merge的时候发现 12$ git merge origin/master$ fatal: 拒绝合并无关的历史 原因： 本地初始化的项目 与 github 版本不一致, 导致无法提交 解决： 在pull 时候, 添加–allow-unrelated-histories参数 即可. 123$ git pull origin master --allow-unrelated-histories # 有冲突，解决，再add commit git pull git push…$ git push --set-upstream origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue + TypeScript 项目搭建步骤]]></title>
    <url>%2F2019%2F11%2F20%2FTypeScript%2FVue%20%2B%20TypeScript%20%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[前言【2020.2.11】更新：决定在毕设项目中采用 Vue + TypeScript 搭建前端项目，在搭建的过程过，完善步骤、记录坑。 搭建起手 Vue-Cli npm 版本查看及升级 12$ npm -v # 查看版本$ npm install -g npm # 升级版本 安装 Vue 123$ npm install vue # 最新稳定版$ npm install --global vue-cli # 安装vue-cli脚手架构建工具$ vue -V # 查看版本号 安装 Webpack 123$ npm install --global webpack$ npm install --global webpack-cli$ webpack -v 新建项目 1$ vue init webpack 项目名字【选填】 运行项目，访问 http://localhost:8080/ 1$ npm run dev Vue 引入 TypeScript12345# 安装vue的官方插件$ npm i vue-class-component vue-property-decorator --save# ts-loader typescript $ npm i ts-loader typescript tslint tslint-loader tslint-config-standard --save-dev 注意：安装完，删掉 node_module ，重新 npm install vue-class-component：强化 Vue 组件，使用 TypeScript/装饰器 增强 Vue 组件 vue-property-decorator：在 vue-class-component 上增强更多的结合 Vue 特性的装饰器 ts-loader：TypeScript 为 Webpack 提供了 ts-loader，其实就是为了让webpack识别 .ts .tsx文件 tslint-loader跟tslint：在.ts .tsx文件 约束代码格式（作用等同于eslint） tslint-config-standard：tslint 配置 standard风格的约束 配置 webpack./build/webpack.base.conf.js 配置三个地方：entry、resolve、module 12345678910111213141516171819202122232425262728293031323334353637383940entry: &#123; app: './src/main.ts'&#125;resolve: &#123; extensions: ['.js', '.vue', '.json', '.ts'], alias: &#123; '@': resolve('src') &#125;&#125;module: &#123; rules: [ &#123; test: /\.(js|vue)$/, loader: 'eslint-loader', enforce: 'pre', include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; &#125;,// 从这里复制下面的代码就可以了 &#123; test: /\.ts$/, exclude: /node_modules/, enforce: 'pre', loader: 'tslint-loader' &#125;, &#123; test: /\.tsx?$/, loader: 'ts-loader', exclude: /node_modules/, options: &#123; appendTsSuffixTo: [/\.vue$/], &#125; &#125;,// 复制以上的 &#125;&#125; ts-loader 会检索当前目录下的 tsconfig.json 文件，根据里面定义的规则来解析.ts文件（就跟.babelrc的作用一样） tslint-loader 作用等同于 eslint-loader 添加 tsconfig.json在根路径下创建tsconfig.json文件 这里有一份参考的 tsconfig.json 配置，完成的配置请点击 tsconfig.json： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 编译选项 "compilerOptions": &#123; // 输出目录 "outDir": "./output", // 是否包含可以用于 debug 的 sourceMap "sourceMap": true, // 以严格模式解析 "strict": true, // 采用的模块系统 "module": "esnext", // 如何处理模块 "moduleResolution": "node", // 编译输出目标 ES 版本 "target": "es5", // 允许从没有设置默认导出的模块中默认导入 "allowSyntheticDefaultImports": true, // 将每个文件作为单独的模块 "isolatedModules": false, // 启用装饰器 "experimentalDecorators": true, // 启用设计类型元数据（用于反射） "emitDecoratorMetadata": true, // 在表达式和声明上有隐含的any类型时报错 "noImplicitAny": false, // 不是函数的所有返回路径都有返回值时报错。 "noImplicitReturns": true, // 从 tslib 导入外部帮助库: 比如__extends，__rest等 "importHelpers": true, // 编译过程中打印文件名 "listFiles": true, // 移除注释 "removeComments": true, "suppressImplicitAnyIndexErrors": true, // 允许编译javascript文件 "allowJs": true, // 解析非相对模块名的基准目录 "baseUrl": "./", // 指定特殊模块的路径 "paths": &#123; "jquery": [ "node_modules/jquery/dist/jquery" ] &#125;, // 编译过程中需要引入的库文件的列表 "lib": [ "dom", "es2015", "es2015.promise" ] &#125;&#125; 参考配置123456789101112131415161718192021222324&#123; "include": [ "src/**/*" ], "exclude": [ "node_modules" ], "compilerOptions": &#123; "allowSyntheticDefaultImports": true, "experimentalDecorators": true, "allowJs": true, "module": "esnext", "target": "es5", "moduleResolution": "node", "isolatedModules": true, "lib": [ "dom", "es5", "es2015.promise" ], "sourceMap": true, "pretty": true &#125;&#125; 添加 tslint.json在根路径下创建 tslint.json 文件：引入 ts 的 standard 规范 1234567&#123; "extends": "tslint-config-standard", "globals": &#123; "require": true &#125;, "defaultSeverity": "none" // 关掉 tslint，不然老是报错，好像现在 tslint 已经交给 eslint 来做，tslint 已经不维护了。注意配置后，要重新 run 才会生效&#125; 让 ts 识别 .vue由于 TypeScript 默认并不支持 *.vue 后缀的文件，所以在 vue 项目中引入的时候需要创建一个 vue-shim.d.ts 文件，放在项目项目对应使用目录下，例如 src/vue-shim.d.ts 1234declare module "*.vue" &#123; import Vue from "vue"; export default Vue;&#125; 意思是告诉 TypeScript *.vue 后缀的文件可以交给 vue 模块来处理。 而在代码中导入 *.vue 文件的时候，需要写上 .vue 后缀。原因还是因为 TypeScript 默认只识别 *.ts 文件，不识别 *.vue 文件： 1import Component from &apos;components/component.vue&apos; 开始修改App.vue文件 在script 标签上加上 lang=&quot;ts&quot;, 意思是让webpack将这段代码识别为typescript 而非javascript 修改 vue 组件的构造方式( 跟react组件写法有点类似, 详见官方 )， 如下图 用vue-property-decorator语法改造之前代码 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img src=&quot;./assets/logo.png&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &apos;vue&apos;import Component from &apos;vue-class-component&apos;@Component(&#123;&#125;)export default class App extends Vue &#123;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; 接下来用相同的方式修改HelloWorld.vue即可 或者（两种写法） 123456789// HelloWorld.vue&lt;script lang="ts"&gt;import &#123; Vue, Component &#125; from 'vue-property-decorator'@Component(&#123;&#125;)export default class HelloWorld extends Vue &#123; msg:string = 'Welcome to Your Vue.js AppAAA'&#125;&lt;/script&gt; 降级 ts-loader 至3.5.0此时直接 npm run dev 是会报错的 Module build failed: Error: You may be using an old version of webpack; please check you’re using at least version 4 这是由于 ts-loader 的版本较高的原因，所以需要将 ts-loader 降级到3.5.0 1$ npm i ts-loader@3.5.0 --save-dev 修改 main.ts再次 npm run dev ，可能会看到 warning in ./src/main.ts[10, 1]: unused expression, expected an assignment or function call 那么看看 main.ts, 改为 ： 123456export default new Vue(&#123; el: &apos;#app&apos;, router, components: &#123; App &#125;, template: &apos;&lt;App/&gt;&apos;&#125;) npm run dev这个时候应该 毛闷题 了！ 支持 es6 / es7在 tsconfig.json中，添加对es6 / es7的支持，更多的配置请见tsconfig - 编译选项 1234567"lib": [ "dom", "es5", "es6", "es7", "es2015.promise"] 接入 Vuex 安装 Vuex 1npm i vuex vuex-class --save vuex-class ：在 vue-class-component 写法中 绑定 vuex 在 src 目录下，新建一个 store 目录，在目录下新建一个 index.ts，配置和之前写法一样 1234567891011121314151617181920212223242526272829303132333435import Vue from "vue";import Vuex from "vuex";Vue.use(Vuex);const store = new Vuex.Store(&#123; strict: true, state: &#123; count: 1 &#125;, getters: &#123; getStateCount(state) &#123; return state.count + 1; &#125; &#125;, mutations: &#123; add(state) &#123; state.count = state.count + 1; &#125;, reduction(state) &#123; state.count = state.count - 1; &#125; &#125;, actions: &#123; addFun(context) &#123; context.commit("add"); &#125;, reductionFun(context) &#123; context.commit("reduction"); &#125; &#125; // modules: &#123; a: moduleA, b: moduleB &#125;&#125;);export default store; 在 main.ts 引入 1234567891011121314import Vue from "vue";import App from "./App.vue"; import store from "./store"; // 添加Vue.config.productionTip = false;/* eslint-disable no-new */export default new Vue(&#123; el: "#app", router, store, // 添加 components: &#123; App &#125;, template: "&lt;App/&gt;"&#125;); 引用例子12345678910111213141516171819202122232425262728293031323334353637import Vue from 'vue'import Component from 'vue-class-component'import &#123; State, Getter, Action, Mutation, namespace&#125; from 'vuex-class'const ModuleGetter = namespace('path/to/module', Getter)@Componentexport class MyComp extends Vue &#123; @State('foo') stateFoo @State(state =&gt; state.bar) stateBar @Getter('foo') getterFoo @Action('foo') actionFoo @Mutation('foo') mutationFoo @ModuleGetter('foo') moduleGetterFoo // If the argument is omitted, use the property name // for each state/getter/action/mutation type @State foo @Getter bar @Action baz @Mutation qux created () &#123; this.stateFoo // -&gt; store.state.foo this.stateBar // -&gt; store.state.bar this.getterFoo // -&gt; store.getters.foo this.actionFoo(&#123; value: true &#125;) // -&gt; store.dispatch('foo', &#123; value: true &#125;) this.mutationFoo(&#123; value: true &#125;) // -&gt; store.commit('foo', &#123; value: true &#125;) this.moduleGetterFoo // -&gt; store.getters['path/to/module/foo'] &#125;&#125; 接入 SCSS 安装 12npm install node-sass --save-devnpm install sass-loader --save-dev 在 ./build/webpack.base.conf.js 的 module 添加如下模块 1234&#123; test: /\.scss$/, loaders: ["style", "css", "sass"]&#125;安装后，运行时报错 Modele build failed: TypeError: this.getResolve is not a function at Object.loader… 这是因为当前sass的版本太高，webpack编译时出现了错误，这个时候只需要换成低版本的就行，很简单，如下，找到 package.json 文件，里面的 “sass-loader”的版本更换掉就行了。 可以将 “sass-loader”: “^8.0.0”，更换成 “sass-loader”: “^7.3.1”，最后重新 run 以下就好了 接入 Axios 安装 1npm install --save axios vue-axios main.ts引入 123456789101112131415161718import Vue from "vue";import axios from "axios"; // 添加import VueAxios from "vue-axios"; // 添加import App from "./App.vue";import router from "./router/index";import store from "./store";Vue.use(VueAxios, axios); // 添加Vue.config.productionTip = false;/* eslint-disable no-new */export default new Vue(&#123; el: "#app", router, store, components: &#123; App &#125;, template: "&lt;App/&gt;"&#125;); Axios 是一个库，并不是 vue 中的第三方插件，使用时不能通过 Vue.use() 安装插件 在 mian.js 中引用 axios，vue-axios，通过全局方法 Vue.use()使用插件，就相当于调用 install 方法 接入 Element 安装 1npm i element-ui -S main.ts 12345678910111213141516import Vue from "vue";import ElementUI from "element-ui"; // 添加import "element-ui/lib/theme-chalk/index.css"; // 添加import App from "./App.vue";Vue.use(ElementUI); // 添加Vue.config.productionTip = false;/* eslint-disable no-new */export default new Vue(&#123; el: "#app", router, store, components: &#123; App &#125;, template: "&lt;App/&gt;"&#125;); 接入 Express + NodeJs 安装 1npm install express cors body-parser mysql 新建一个 server.ts 12345678910111213141516171819202122232425262728293031323334353637"use strict";/* 引入express框架 */const express = require("express");const app = express();/* 引入cors */const cors = require("cors");app.use(cors());/* 引入body-parser */const bodyParser = require("body-parser");app.use(bodyParser.json());app.use( bodyParser.urlencoded(&#123; extended: false &#125;));/* 引入mysql */const mysql = require("mysql");const conn = mysql.createConnection(&#123; host: "101.133.132.172", user: "root", password: "123456", database: "hostel", multipleStatements: true&#125;);conn.connect();/* 监听端口 */app.listen(4444, () =&gt; &#123; console.log("——————————服务已启动——————————");&#125;);app.get("/", (req, res) =&gt; &#123; res.send('&lt;p style="color:red"&gt;服务已启动&lt;/p&gt;');&#125;); 使用 nodemon 热加载 NodeJs文件1npm install -g nodemon 安装后只要nodemon server.ts即可 运行时，发现有报错，需要安装一个@type/node，以及在 tsconfig.json 的compilerOptions配置&quot;types&quot;: [&quot;node&quot;]，跟着提示走就好了。 但是可能还会报： Type error: Cannot compile namespaces when the ‘–isolatedModules’ flag is provided. 那么，在 tsconfig.json 的compilerOptions配置&quot;isolatedModules&quot;: false，就没问题 取消 eslint 校验实在是烦…先取消了 在根目录创建vue.config.js 123module.exports = &#123; lintOnSave: false&#125; 统一代码格式为了快速编码，决定启用 保存后自动格式化，需要在 首选项-设置 添加 12// #每次保存的时候自动格式化"editor.formatOnSave": true, 这里有个坑，之前开启了 eslint 校验，又开了 prettier ，vetur，导致格式化和报错一直打架，因为方便完成自己的毕设，所以关掉了 eslint，但是格式化又在打架，查阅，发现 prettier 在存在 vetur 的前提下，并不生效，所以我决定把 prettier 先关掉！ 下面只要注重 Vetur 的配置就好了，同样在 首选项-设置 找 Vetur，想要改啥配置，百度一下吧~ 查阅资料vscode中eslint插件的配置（prettier配置无效） 使用ESLint+Prettier来统一前端代码风格 插件使用指南vue-class-componentvue-class-component 对 Vue 组件进行了一层封装，让 Vue 组件语法在结合了 TypeScript 语法之后更加扁平化： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;input v-model=&quot;msg&quot;&gt; &lt;p&gt;msg: &#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p&gt;computed msg: &#123;&#123; computedMsg &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import Vue from &apos;vue&apos; import Component from &apos;vue-class-component&apos; @Component export default class App extends Vue &#123; // 初始化数据 msg = 123 // 声明周期钩子 mounted () &#123; this.greet() &#125; // 计算属性 get computedMsg () &#123; return &apos;computed &apos; + this.msg &#125; // 方法 greet () &#123; alert(&apos;greeting: &apos; + this.msg) &#125; &#125;&lt;/script&gt; 上面的代码跟下面的代码作用是一样的 1234567891011121314151617181920212223242526export default &#123; data () &#123; return &#123; msg: 123 &#125; &#125; // 声明周期钩子 mounted () &#123; this.greet() &#125; // 计算属性 computed: &#123; computedMsg () &#123; return 'computed ' + this.msg &#125; &#125; // 方法 methods: &#123; greet () &#123; alert('greeting: ' + this.msg) &#125; &#125;&#125; vue-property-decoratorvue-property-decorator 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器： @Emit @Inject @Model @Prop @Provide @Watch @Component (从 vue-class-component 继承) 在这里列举几个常用的@Prop/@Watch/@Component, 更多信息，详见官方文档 1234567891011121314151617181920import &#123; Component, Emit, Inject, Model, Prop, Provide, Vue, Watch &#125; from &apos;vue-property-decorator&apos;@Componentexport class MyComponent extends Vue &#123; @Prop() propA: number = 1 @Prop(&#123; default: &apos;default value&apos; &#125;) propB: string @Prop([String, Boolean]) propC: string | boolean @Prop(&#123; type: null &#125;) propD: any @Watch(&apos;child&apos;) onChildChanged(val: string, oldVal: string) &#123; &#125;&#125; 上面的代码相当于： 12345678910111213141516171819202122export default &#123; props: &#123; checked: Boolean, propA: Number, propB: &#123; type: String, default: &apos;default value&apos; &#125;, propC: [String, Boolean], propD: &#123; type: null &#125; &#125; methods: &#123; onChildChanged(val, oldVal) &#123; &#125; &#125;, watch: &#123; &apos;child&apos;: &#123; handler: &apos;onChildChanged&apos;, immediate: false, deep: false &#125; &#125;&#125; 参考链接vue + typescript 项目起手式 vue + typescript 进阶篇]]></content>
      <categories>
        <category>Vue</category>
        <category>TypeScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表单样式更改]]></title>
    <url>%2F2019%2F11%2F19%2FVue%2FElement%2F%E8%A1%A8%E5%8D%95%E6%A0%B7%E5%BC%8F%E6%9B%B4%E6%94%B9%2F</url>
    <content type="text"><![CDATA[前言记录 Element 表单样式更改 更改头部123456789101112131415161718192021222324252627282930313233343536373839// 1. 函数写法&lt;el-table :header-cell-style="rowClass"&gt;&lt;/el-table&gt;//在method里面写上方法rowClass(&#123; row, rowIndex&#125;) &#123; console.log(rowIndex) //表头行标号为0 return 'background:red'&#125;// 2. 对象写法&lt;el-table :header-cell-style="&#123;background:'red'&#125;"&gt;&lt;/el-table&gt;// 更改表格中某个单元格的样式// 1. 函数写法&lt;el-table :cell-style="cellStyle"&gt;&lt;/el-table&gt;//在method里面写上方法cellStyle(&#123;row, column, rowIndex, columnIndex&#125;)&#123; if(rowIndex === 1 &amp;&amp; columnIndex === 2)&#123; //指定坐标 return 'background:pink' &#125;else&#123; return '' &#125;&#125;// 2. 对象写法&lt;el-table :cell-style="&#123;background:'pink'&#125;"&gt;&lt;/el-table&gt;cellStyle(&#123;row, column, rowIndex, columnIndex&#125;)&#123; if(columnIndex === 1)&#123;//指定列号 return 'background:pink' &#125;else&#123; return '' &#125; &#125; // 3. className&lt;el-table :row-class-name="tabRowClassName"&gt; tabRowClassName(&#123; rowIndex &#125;) &#123; const index = rowIndex + 1; if (index % 2 === 0) &#123; return 'even-row'; &#125;&#125; 表单内容1234567891011121314151617// 居中.el-table td,.el-table th &#123; text-align: center !important;&#125;// 设置表头和行高度.el-table__header tr,.el-table__header th &#123; padding: 0; height: 40px;&#125;.el-table__body tr,.el-table__body td &#123; padding: 0; height: 40px;&#125; 实现某列居中：&lt;el-table-colum align=&quot;center&quot;&gt;&lt;/el-table-column&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理与反向代理]]></title>
    <url>%2F2019%2F11%2F18%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言介绍正向代理与反向代理的区别 正向代理 作用在客户端，代理访问外部资源，比如我们访问一个外国网站，直接访问是访问不到的，可以通过一个正向代理服务器，请求发到代理服务器，代理服务器能访问外国网站，就能取到访问数据，返回给我们，我们也因此能够访问到外国网站 可以访问外网 做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录，对外隐藏用户信息 反向代理 作用在服务端，是一个虚拟ip（VIP）。代理服务器接受客户端的请求，然后再把请求转发到内部网络的服务器，得到的结果再返回到客户端 实现负载均衡 保证内网安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，web服务器是内网 总结 正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.（买票的黄牛） 反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端（租房代理）]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Cherry-pick]]></title>
    <url>%2F2019%2F11%2F18%2FGit%2FCherry-pick%2F</url>
    <content type="text"><![CDATA[git cherry-pick可以理解为”挑拣”提交，它会获取某一个分支的单笔提交，并作为一个新的提交引入到你当前分支上。 当我们需要在本地合入其他分支的提交时，如果我们不想对整个分支进行合并，而是只想将某一次提交合入到本地当前分支上，那么就要使用git cherry-pick了 当前功能分支 git log 拿到commitId checkout到主分支 git pull git cherry-pick commitId 如果没有冲突，直接 git push &amp; npm run publish 有冲突，解决，git add&amp; git cherry-pick --continue]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cors跨域]]></title>
    <url>%2F2019%2F11%2F18%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2Fcors%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信，即为了解决跨域问题。 请求类型 简单请求 非简单请求 简单请求一般包括下面两种情况，如果不同时满足下面两个条件，就是非简单请求。 请求方法 HEAD / GET / POST HTTP 头信息（不超过以下几个字段） Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求的 CORS 流程当 AJAX 请求是个简单请求，浏览器会自动在头信息中，增加一个 Origin 字段。 Origin 字段用来说明本次请求的来源（包括协议 + 域名 + 端口号），服务端根据这个值来决定是否同意此次请求。 当 Origin 指定的源不在许可范围，服务器会返回一个正常的 HTTP 回应，但浏览器会在响应头中发现 Access-Control-Allow-Origin 字段，便抛出异常。 当 Origin 指定的源在许可范围，服务器返回的响应头中会多出几个头信息字段。 三个相关头信息： Access-Control-Allow-Origin 该字段是必须的。表示许可范围的域名，通常有两种值：请求时 Origin 字段的值或者 *（星号）表示任意域名。 Access-Control-Allow-Credentials 该字段可选。布尔值，表示是否允许在 CORS 请求之中发送 Cookie 。若不携带 Cookie 则不需要设置该字段。 当设置为 true 则 Cookie 包含在请求中，一起发送给服务器。还需要在 AJAX 请求中开启 withCredentials 属性，否则浏览器也不会发送 Cookie 。 12let xhr = new XMLHttpRequest();xhr.withCredentials = true; Access-Control-Expose-Headers 该字段可选。可以设置需要获取的字段。因为默认 CORS 请求时，XMLHttpRequest 对象的getResponseHeader()方法只能拿到以下 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。 非简单请求的 CORS 流程在非简单请求发出 CORS 请求时，会在正式通信之前增加一次 “预检”请求（OPTIONS方法），来询问服务器，本次请求的域名是否在许可名单中，以及使用哪些头信息。 当 “预检”请求 通过以后，才会正式发起 AJAX 请求，否则报错。 预检请求123456OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderUser-Agent: Mozilla/5.0...... “预检”请求 信息中包含两个特殊字段： Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是 PUT。2. Access-Control-Request-Headers 指定浏览器 CORS 请求额外发送的头信息字段，上例是 X-Custom-Header。 预检响应1234567HTTP/1.1 200 OKAccess-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Connection: Keep-Alive... 当预检请求通过以后，在预检响应头中，会返回 Access-Control-Allow- 开头的信息，其中 Access-Control-Allow-Origin 表示许可范围，值也可以是 *。 当预检请求拒绝以后，在预检响应头中，不会返回 Access-Control-Allow- 开头的信息，并在控制台输出错误信息。、、]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[javascript高阶]]></title>
    <url>%2F2019%2F11%2F18%2FJavaScript%2Fjavascript%E9%AB%98%E9%98%B6(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[类数组 arguments 转化数组？arguments(类数组) 是一个对象，属性从0开始，依次为1，2，3…有callee和length属性 常见的类数组 用getElementByTagName/ClassName/Name() 获得的HTMLCollection 用querySlector获得的nodeList 1、Array.prototype.slice.call()12345function sum(a, b) &#123; let args = Array.prototype.slice.call(arguments); console.log(args.reduce((sum, cur) =&gt; sum + cur));&#125;sum(1, 2) //3 2、Array.from()12345function sum(a, b) &#123; let args = Array.from(arguments); console.log(args.reduce((sum, cur) =&gt; sum + cur));&#125;sum(1, 2) //3 3、ES6展开运算符12345function sum(a, b) &#123; let args = [...arguments]; console.log(args.reduce((sum, cur) =&gt; sum + cur));&#125;sum(1, 2) //3 4、利用 concat+apply12345function sum(a, b) &#123; let args = Array.prototype.concat.apply([], arguments); console.log(args.reduce((sum, cur) =&gt; sum + cur));&#125;sum(1, 2) //3 5、最原始、粗暴用for循环把类数组的每个属性值放到里面 怎么中断forEach循环？forEach不能中断循环，可以使用以下两种方法： 使用 try 监视代码块，在需要中断的地方抛出异常 （官方推荐，替换方法）用every或some代替 every 与 some 区别 every一旦发现有一个不符合条件，就不会继续下去 some一旦找到符合条件，就不会继续下去 12345678910let arr = [1, 2, 3, 4];arr.every(item =&gt; &#123; console.log(item) return item &gt; 2;&#125;) // 1 falsearr.some(item =&gt; &#123; console.log(item) return item &gt; 2;&#125;) // 1 2 3 true 判断数组是否包含某个值？1、array.indexOf如果存在，返回数组元素的下标，否则返回 -1 123let arr = [1, 2, 3, 4];let index = arr.indexOf(3);console.log(index); //2 2、array.includes如果存在，返回true，否则返回false 12345let arr = [1, 2, 3, 4];if(arr.includes(3)) console.log('存在')；else console.log('不存在')； 3、array.find返回数组中满足条件的第一个元素的值，否则返回undefined 12345let arr = [1, 2, 3, 4];let result = arr.find(item =&gt; &#123; return item &gt; 3;&#125;)console.log(result); // 4 4、array.findIndex返回数组中满足条件的第一个元素的下标，否则返回-1 12345let arr = [1, 2, 3, 4];let result = arr.findIndex(item =&gt; &#123; return item &gt; 3;&#125;)console.log(result); // 3 数组扁平化 多层数组转化为一级数组？12let arr = [1, 2, [3, [4, 5]], 6];let str = JSON.stringify(arr); 1、ES6的flat方法1arr = arr.flat(Infinity); // [1, 2, 3, 4, 5, 6] 2、replace+split1arr = str.replace(/(\[&#125;\])/g,'').split(',') 3、replace+JSON.parse123str = str.replace(/(\[&#125;\])/g,'');str = '[' + str + ']';arr = JSON.parse(str); 4、普通递归1234567891011let result = [];let fn = function(ary) &#123; for(let i = 0;i &lt; ary.length; i++) &#123; let item = ary[i]; if(Array.isArray(ary[i]))&#123; fn(item); &#125;else &#123; result.push(item) &#125; &#125;&#125; 5、利用reduce函数迭代123456function flatten(ary) &#123; return ary.reduce((pre, cur) =&gt; &#123; return pre.concat(Array.isArray(cur) ? flatten(cur) : cur); &#125;,[]);&#125;console.log(flatten(arr)); 6、扩展运算符123while(arr.some(Array.isArray())) &#123; arr = [].concat(...arr);&#125; 高阶函数 一个函数可以接收另一个函数作为参数 或 返回值为一个函数 1、map参数 两个参数：回调函数，回调函数的this(可选) 回调函数默认传入三个值：依次为 当前元素、当前索引、整个数组 对原来数组没有影响；新建一个数组，数组中的每个元素都是原来数组元素调用回调函数返回的结果 123456let nums = [1, 2, 3];let obj = &#123;val: 5&#125;;let newNums = nums.map(function(item, index, array) &#123; return item + index + array[index] + this.val;&#125;,obj);console.log(newNums); // [7, 10, 13] 2、reduce参数 两个参数：回调函数，初始值 回调函数三个默认参数，依次为 积累值、当前值、整个数组 12345let nums = [1, 2, 3];let newNums = nums.reduce(function(preSum, curVal, array) &#123; return preSum + curVal;&#125;, 0);console.log(newNums); // 6 不传默认值会自动以第一个元素为初始值，然后从第二个元素开始依次累计。 3、filter参数 一个函数参数 默认参数：当前元素 返回值 一个布尔类型，决定元素是否保留 12let nums = [1, 2, 3];let oddNums = nums.filter( item =&gt; item % 2); 4、sort参数 一个用于比较的函数 两个默认参数：比较的两个元素 1234567let nums = [2, 3, 1];nums.sort(function(a, b) &#123; if(a &gt; b) return 1; // a在b后面，a下标比b大 else if(a &lt; b) return -1; else if(a == b) return 0;&#125;)// [1, 2, 3] 如果不传函数，则将数字转换为字符串，根据字母 unicode值 进行升序排序 JSON.parse() 与 JSON.stringfy()JSON.parse()将JavaScript对象表示法的JSON字符串转换为对象(字符串转对象) 123var jsonStr = '&#123;"name":"leinov","sex":"famle","address":"beijing"&#125;'var jsonObj = JSON.parse(jsonStr);alert(typeof jsonObj); //Object JSON.stringfy()将 JavaScript json对象转换为JavaScript对象表示法的JSON字符串(对象转为字符串) 1234567var student = new Object();student.name = "leinov";student.sex = "famle";student.address = "chaoyang";var jsonStudent = JSON.stringify(student);alert(typeof jsonStudent); //string]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web前端攻击方式]]></title>
    <url>%2F2019%2F11%2F18%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2Fweb%E5%89%8D%E7%AB%AF%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[CSRF 跨站点伪造请求(cross site request forgery),利用的是网站对用户网页浏览器的信任。攻击者盗用你的身份，以你的名义发送恶意请求，会造成个人隐私泄露以及财产安全。 常见场景：以你名义发送邮件，发消息；盗取你的账号，购买商品，虚拟货币转账等等。 攻击流程 用户登录受信任网站A，并在本地生成保存Cookie 在不登出A的情况下，访问病毒网站B 网站B要求访问A，发出请求 根据网站B的请求，浏览器带着保存的Cookie访问A A不知道上述请求是来自用户还是病毒网站B，由于请求中带上了Cookie，A会根据用户的权限处理请求，达到模拟用户操作的目的 防御1、验证 HTTP Referer 字段HTTP的referer字段保存了http的来源地址，受访网站可以验证这个地址是否合法，如果不合法，则有可能为CSRF攻击，拒绝该请求。但这种方法不是万无一失的，referer的值是由浏览器提供的，我们并不能保证浏览器没有安全漏洞，目前已有一些方法可以篡改referer值，而且有些用户为了保护自己的隐私可以设置浏览器在发送请求时不再提供referer值。 2、在请求地址中添加token并验证CSRF利用cookie来进行攻击，那么我们可以在请求中添加不可伪造的信息并不存在与cookie中，可以在请求中以参数形式随机产生一个token，并在服务器建立一个拦截器验证这个token。 3、在HTTP头中自定义属性并验证解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 4、Cookie Hashing（所有表单都包含同一个伪随机数）5、验证码每次用户提交都需要用户在表单中填写一个图片上的随机字符串 XSS 跨站脚本攻击(corss site scripting),利用的是用户对指定网站的信任。攻击者通过在网页中注入恶意脚本，当用户浏览网页时，恶意脚本执行，控制用户浏览器行为的一种攻击方式。 常见场景：强制弹出广告页面，刷流量，传播跨站脚本蠕虫，网页挂马；窃取用户Cookie，获取用户隐私，盗取用户账号；劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账、强制发表日志、发送电子邮件等。 分类 反射型xss。出现在URL中作为参数提交到服务器，服务器解析并响应，响应结果中包含xss代码，最后浏览器解析执行。 存储型xss。攻击者输入恶意的脚本数据存入数据库，当其他用户读取时，用户浏览器将解析执行这段脚本。 防御1、浏览器自带防御现今主流浏览器（IE，Chrome 和 Safari）带有 HTTP X-XSS-Protection 响应头，当检测到跨站脚本攻击(XSS)时，浏览器将停止加载页面。 X-XSS-Protection 响应头有以下 4 个值： X-XSS-Protection: 0 禁止XSS过滤 X-XSS-Protection: 1 启用XSS过滤（通常浏览器是默认的）。如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。 X-XSS-Protection: 1; mode=block 启用XSS过滤。如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。 X-XSS-Protection: 1; report=&lt;reporting-uri&gt; 启用XSS过滤。如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。 注意 存在兼容性问题 只对反射型 XSS 有一定的防御力，其原理也只是检查 URL 和 DOM 中元素的相关性 2、转义在客户端和服务端，对用户输入的数据进行转义。常见需要转义的特殊字符如 &lt;，&gt;，&amp;，&quot;，&#39;。 123456789function escapeHTML(str) &#123; if (!str) return ''; str = str.replace(/&amp;/g, "&amp;amp;"); str = str..replace(/&lt;/g, "&amp;lt;"); str = str..replace(/&gt;/g, "&amp;gt;"); str = str..replace(/"/g, "&amp;quot;"); str = str..replace(/'/g, "&amp;#39;"); return str;&#125;; 3、过滤常见于富文本内容，因为其需要保留 HTML，所以不能直接使用转义方法，而可以通过使用白名单，来允许特定的 HTML 标签及属性，来抵御 XSS 攻击。 4、内容安全策略（CSP）白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。 通过 HTTP 头信息的 Content-Security-Policy 的字段： 1234Content-Security-Policy: script-src 'self';object-src 'none';style-src cdn.example.org third-party.org;child-src https: 通过网页的 标签 1&lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:"&gt; 上述解释 脚本：只信任当前域名 &lt;object&gt;标签：不信任任何 URL，即不加载任何资源 样式表：只信任 cdn.example.org和third-party.org 页面子内容，如 &lt;frame&gt;、&lt;iframe&gt;：必须使用HTTPS协议加载 其他资源：没有限制 启用后，不符合 CSP 的外部资源就会被阻止加载。 SQL注入什么是SQL注入？攻击者向服务器提交恶意的sql代码，导致源程序执行包含恶意代码的sql。 典型实例为：用户输入的信息带有 delete 、drop等危害性十足的sql，就像用户登录时输入了用户名 ‘ or 1=1 #（mysql是#，oracle是–），那么在我们没有任何防御措施的情况下就会变为“select * from user where username=’’ or 1=1 # passport=md5()”。#后面是注释，所以一定会执行 防止SQL注入 1）在JAVA中使用预编译PreparedStatement； 2）对数据库特殊字符进行转义处理或编码转换； 3）在应用发布前，使用专业的sql 注入检测工具进行检测，及时发现和修补sql注入漏洞； &lt;四&gt;文件上传漏洞-典型实例为：没有对用户上传的文件做校验，恶意用户长时间上传超大文件占用系统资源，上传可执行脚本获取获取服务器信息 -推荐防御措施：对用户上传做限流，每个用户每天最多上传多少内容。对文件类型进行判断，不能通过后缀名判断，而要通过判断魔数（文件起始的几个字节）来判断，很多文件类型的魔数是不变的。 &lt;五&gt;DDOS：分布式拒绝服务攻击-典型实例为：1.攻击者提前控制大量计算机，并在某一时刻指挥大量计算机同时对某一服务器进行访问来达到瘫痪主机的目的。 2.相信大家都知道TCP三次握手的机制，（如不了解请参考文章底部补充）攻击者利用此机制对服务器返回的ACK确认包不回应，这样服务器就会存在大量的等待列表，不断重试，等待队列满了以后不再接受TCP连接，从而阻挡了正常用户的使用 3.攻击者向DNS服务器发送海量的域名解析请求，DNS首先查缓存，如果缓存不存在的话会去递归调用上级服务器查询，直到查询到全球13台根服务器为止，当解析请求过多时正常用户访问就会出现DNS解析超时问题 -推荐防御措施：使用缓存，当缓存中存在时就直接取出，不要频繁的连接数据库。 缩短 SYN Timeout时间，即缩短从接受到SYN报文到确定这个报文无效并丢弃该连接的时间。 限制源ip每秒发起的DNS请求等]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域配置]]></title>
    <url>%2F2019%2F11%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2F%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[跨域是浏览器行为关闭浏览器跨域限制 (不推荐，会有安全问题) 1open -a /Applications/Google\ Chrome.app --args --disable-web-security --user-data-dir 种类 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域（http-proxy-middleware） WebSocket协议跨域 jsonp需要后端单独支持，已经不推荐使用了 123456789101112131415161718192021222324252627282930// JSONPfunction createJsonp() &#123; var script = document.createElement("script"), timeName = new Date().getTime() + Math.round(Math.random() * 1000), callback = "JSONP_" + timeName; window[callback] = function(data) &#123; clearTimeout(timeout_flag); document.body.removeChild(script); success(data); &#125; script.src = url + (url.indexOf("?") &gt; -1 ? "&amp;" : "?") + "callback=" + callback; script.type = "text/javascript"; document.body.appendChild(script); setTime(callback, script);&#125;//设置请求超时function setTime(callback, script) &#123; if (timeOut !== undefined) &#123; timeout_flag = setTimeout(function() &#123; if (dataType === "jsonp") &#123; delete window[callback]; document.body.removeChild(script); &#125; else &#123; timeout_bool = true; xhr &amp;&amp; xhr.abort(); &#125; console.log("timeout"); &#125;, timeOut); &#125;&#125; proxyreact 1）：安装http-proxy-middleware管理包，cnpm http-proxy-middleware –save 123456789101112const proxy = require(‘http-proxy-middleware‘);module.exports = function(app) &#123; app.use(proxy(‘/api‘, &#123; target: ‘http://192.168.1.144:8181‘ , secure: false, changeOrigin: true, pathRewrite: &#123; "^/api": "/" &#125;, // cookieDomainRewrite: "http://localhost:3000" &#125;));&#125;; vue.config.js 1234567891011121314151617181920devServer: &#123; host: '0.0.0.0', port: 8081, https: false, hotOnly: false, disableHostCheck: true, // proxy: &#123; // '/api': &#123; // target: 'https://m.youpin.mi.com', // ws: true, // changeOrigin: true, // pathRewrite: &#123; // '^/api': '/api', // rewrite path // &#125;, // headers: &#123; // Origin: 'https://m.youpin.mi.com', // Referer: 'https://m.youpin.mi.com' // &#125; // &#125;,&#125; nginx终极解决方案， 12345678910111213141516171819202122232425262728server &#123; listen 8092; server_name aa.app.xiaomiyoupin.com; error_log /usr/local/etc/nginx/logs/shop.error.log; access_log /usr/local/etc/nginx/logs/shop.access.log; # 前端页面走本地（vue-cli开的server） location / &#123; proxy_pass http://localhost:8081; &#125; # 后端接口都是/api开头的 location /api &#123; proxy_http_version 1.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # proxy_set_header X-NginX-Proxy true; # proxy_set_header Connection ""; proxy_set_header Host app.xiaomiyoupin.com; # proxy_pass http://st.shop.youpin.srv; proxy_pass https://m.xiaomiyoupin.com; &#125; location ~ ^/app/shopv3/ &#123; proxy_set_header Cookie 'beegosessionID=94c74e9ad2349278b5a67fa17076230e; b_auth=mijiayoupin; serviceToken=cTww0DUseqPODIcT5cvyy9nNT+yBPhcaVfZcWmmlV5N6ajVrta+HoJPzdbhB08jVYVbFX5bNseY2MJitcQED7x1k3CoCAApFfaXeCC7n45Iqn7OSkvIr7spQqX4QGIQXGxwg9Ddn8zW/w4Wjc4qssQ==; cUserId=DKtjN6Lk5SugGBs04CbYODo2nsI; YPToken=4PberWbMNP6-TSzQkMdASH5N5PVDEObS0YFnL-h91PwlqjBU7QO5k5wZ7AKfUE3h'; proxy_set_header Referer 'https://m.xiaomiyoupin.com'; # proxy_set_header Host $host; proxy_pass https://m.xiaomiyoupin.com; &#125;&#125; cors每次都发送两次请求，并发量比较大的时候，对服务器压力比较大 123456789101112app.use('*',function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); //这个表示任意域名都可以访问，这样写不能携带cookie了。// res.header('Access-Control-Allow-Origin', 'http://www.baidu.com'); //这样写，只有www.baidu.com 可以访问。 res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');//设置方法 if (req.method == 'OPTIONS') &#123; res.send(200); // 意思是，在正常的请求之前，会发送一个验证，是否可以请求。 &#125; else &#123; next(); &#125;&#125;); 完整的server例子 12345678910111213141516171819202122232425262728293031323334353637383940414243var express = require('express')var app = express()// var cors = require('cors')// app.use(cors())// var corsOptions = &#123;// origin: 'http://www.baidu.com', //只有百度可以访问// optionsSuccessStatus: 200 // &#125;// app.get('/products/:id', cors(corsOptions), function (req, res, next) &#123;// res.json(&#123;msg: '只有百度可以访问'&#125;)// &#125;)app.use('*',function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); //这个表示任意域名都可以访问，这样写不能携带cookie了。// res.header('Access-Control-Allow-Origin', 'http://www.baidu.com'); //这样写，只有www.baidu.com 可以访问。 res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');//设置方法 if (req.method == 'OPTIONS') &#123; res.send(200); // 意思是，在正常的请求之前，会发送一个验证，是否可以请求。 &#125; else &#123; next(); &#125;&#125;);app.get('/',function(req,res)&#123; res.send('hello')&#125;)app.post('/api2',function(req,res)&#123; // console.log(req) res.json(&#123; "data":1 &#125;) // res.send(&#123;some:'json'&#125;);&#125;)app.get('/api3',function(req,res)&#123; // console.log(req) res.jsonp(&#123; "data":1 &#125;) // res.send(&#123;some:'json'&#125;);&#125;)app.listen(3000, function () &#123; console.log('CORS-enabled web server listening on port 3000')&#125;) 总结 jsonp的实现，需要后端支持，所以实际项目中不建议用这种方法 cors 每次会发送两次请求：第一次为option，无参数无返回，只是询问能否跨域，如果可以再发一次真正的请求，并发量比较大的时候，对服务器压力比较大 prox 可以在vue.config.js 里写proxy代理（小项目应该比较适用） nginx 本地起一个服务器，然后对接口进行转发（终极方案：推荐） 花瓶 和nginx差不多原理，通过劫持系统的端口进行转发返回 WebSocket协议跨域、postMessage跨域等利用本身可跨域的协议进行跨域]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阅后感-Babel]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%E9%98%85%E5%90%8E%E6%84%9F%2FBable%2F</url>
    <content type="text"><![CDATA[BabelBabel的实现：将源码转换 AST(抽象语法树)之后，通过便利AST树，对树做一些修改，然后再将AST转成code，即成源码。可以让我们的代码（es6,es7..语法）在浏览器正常显示。Babel的设计（文章用汽车发动机作比喻，好挺好理解） @babel/core AST转换的核心 @babel/cli 打包工具 @babel/plugin* Babel 插件机制，Babel基础功能不满足的时候,手动添加些 @babel/preset-env 预设了很多语法和API的转换插件，不需要在单独的去安装某个已经列入标准的插件。同时，具备了可以智能的根据browserslist选项,导出项目中使用的语法 @babel/polyfill 把浏览器某些不支持API，兼容性代码全部导入到项目,不管你是不是用到,缺点是代码体积特别大和污染全局变量 @babel/runtime和@babel/plugin-transform-runtime 把你使用到的浏览器某些不支持API，按需导入,代码少，不污染全局变量 其中 presets 加载顺序和一般理解不一样，是倒序的；plugins 正序进行编译；plugins 优先于 presets进行编译 Babel 把 Javascript 语法 分为 syntax （箭头函数，let,const,class, 依赖注入 Decorators,等等这些）和 api（可以通过 函数重新覆盖的语法 ，类似 includes,map,includes,Promise） Babel 只是转换 syntax 层语法,所有需要 @babel/polyfill 来处理API兼容,又因为 polyfill 体积太大，所以通过 preset的 useBuiltIns 来实现按需加载,再接着为了满足 npm 组件开发的需要 出现了 @babel/runtime 来做隔离]]></content>
      <categories>
        <category>技术文章阅后感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阅后感-从 Node 实例推导浏览器的渲染机制]]></title>
    <url>%2F2019%2F11%2F13%2F%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%E9%98%85%E5%90%8E%E6%84%9F%2F%E4%BB%8E%20Node%20%E5%AE%9E%E4%BE%8B%E6%8E%A8%E5%AF%BC%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[从 Node 实例推导浏览器的渲染机制这篇文章通过搭建node实例建起本地服务器，然后实验 静态资源在不同顺序/阻塞环境 浏览器的渲染机制，得出以下结论： 静态资源并不是同时请求的，也不是解析到指定标签的时候才去请求的，浏览器会自行判断； JS 会阻塞页面的解析和渲染，同时浏览器也存在预解析，遇到阻塞可以继续解析下面的元素； CSS`不阻塞dom树的构建解析，只会阻塞其后面元素的渲染，不会阻塞其前面元素的渲染； 图片既不阻塞解析，也不阻塞渲染。 自己也跟着写了以下demo，对于1 2 3点感觉挺新鲜，因为以前一直晓得：当dom树构建时，出现一个js会进行阻塞，要等js加载完毕才能继续；如果js中用到了css，还要等cssom树构建完毕才能继续。原来浏览器存在预解析，遇到阻塞会继续解析下面的元素，也不是到了某个标签才请求，浏览器会自行判断。浏览器的行为可真奇怪呀。]]></content>
      <categories>
        <category>技术文章阅后感</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[v-for key && index && item.id]]></title>
    <url>%2F2019%2F11%2F12%2FVue%2Fv-for%20key%20%26%26%20index%20%26%26%20item.id%2F</url>
    <content type="text"><![CDATA[以前对v-for中key的处理，一直直接：:key=’index’，也没觉得有啥问题。直到小雪指出..原来和虚拟dom有关，首先 index 这个顺序是永远不会变的：0123..，所以当我们修改某个节点，会产生两个相同的key，这样的话vue需要比较两个相同key的dom元素。使用唯一的key值（如item的id）；当某个节点改变，拿到这个key，就能找到节点，只渲染当前节点，提高效率；另外，假如不加key的话，当改变某个节点，全部节点都要重新渲染，因为不知道是哪个变了。 总结：使用v-for渲染元素时，使用元素自身的id属性去指定渲染元素的key值有利于单个元素的重新渲染，若采用其他如v-for提供的index, key等值，在改变渲染出来的DOM结构时，会触发所有元素的重新渲染，当数据过大时，可能会造成性能负担。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[v-model 和 props 双向绑定]]></title>
    <url>%2F2019%2F11%2F12%2FVue%2Fv-model%20%E5%92%8C%20props%20%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[发现了一种数据双向绑定的好写法，子组件 v-model=’item’，子组件用props接收 value。 一种语法糖，做了两个操作 v-bind绑定一个value属性 v-on指令给当前元素绑定input事件 1234567// 在自定义组件中&lt;my-component v-model="inputValue"&gt;&lt;/my-component&gt;// 相当于&lt;my-component v-bind:value="inputValue" v-on:input="inputValue = argument[0]"&gt;&lt;/my-component&gt;// 这个时候，inputValue接受的值就是input事件的回调函数的第一个参数，所以在自定义组件中，要实现数据绑定，还需要$emit去触发input的事件。this.$emit('input', value)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[处理时间函数]]></title>
    <url>%2F2019%2F11%2F08%2FJavaScript%2F%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言记录有关处理时间的函数 时间格式化-秒变日期对象项目中，传过来一串数字：秒。需要把 数字 处理成 日期对象，可使用下面的方法 1234567891011121314151617181920212223242526272829303132333435var a = new Date(1573097217000) // 秒要在后面加3个0，变成毫秒// Thu Nov 07 2019 11:26:57 GMT+0800 (中国标准时间)a.format('yyyy-MM-dd hh:mm')// eslint-disable-next-lineDate.prototype.format = function(format) &#123; const zeros = ['', '0', '00', '000', '0000']; const c = &#123; 'Y+': this.getFullYear(), 'M+': this.getMonth() + 1, 'd+': this.getDate(), 'h+': this.getHours(), 'm+': this.getMinutes(), 's+': this.getSeconds(), 'q+': Math.floor((this.getMonth() + 3) / 3), 'S+': this.getMilliseconds() &#125;; if (/(y+)/.test(format)) &#123; format = format.replace( RegExp.$1, `$&#123;this.getFullYear()&#125;`.substr(4 - RegExp.$1.length) ); &#125; for (const k in c) &#123; if (new RegExp(`($&#123;k&#125;)`).test(format)) &#123; format = format.replace( RegExp.$1, RegExp.$1.length === 1 ? c[k] : (zeros[RegExp.$1.length] + c[k]).substr(`$&#123;c[k]&#125;`.length) ); &#125; &#125; return format;&#125;; ##获取当前日期的30天后 12var now = new Date();return new Date(now.setDate(now.getDate() + 30));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[encodeURIComponent(URIstring)]]></title>
    <url>%2F2019%2F11%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FencodeURIComponent(URIstring)%2F</url>
    <content type="text"><![CDATA[可把字符串作为 URI 组件进行编码。 1encodeURIComponent("http://www.w3school.com.cn") =&gt; http%3A%2F%2Fwww.w3school.com.cn]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[API-Location]]></title>
    <url>%2F2019%2F11%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FAPI-Location%2F</url>
    <content type="text"><![CDATA[前言记录 Location API的属性值 属性 origin 属性 返回URL的协议，主机名和端口号。可读 12假设当前的URL是https://www.jc2182.com:4088/test.htm#part2：结果将是:https://www.jc2182.com:4098 hash 属性 一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分 12假设当前的 URL 是 http://www.runoob.com/test.htm＃PART2：结果将是:#part2]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由懒加载]]></title>
    <url>%2F2019%2F11%2F07%2FVue%2F%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[结合vue异步组件特性和webpack的code spliting特性实现路由懒加载 使用动态import语法（添加syntax-dynamic-import插件）引入组件 在webpack配置文件中的output中添加chunkFilename 因为动态import()打包出来文件的name是按照0,1,2…依次排列，如0.js、1.js等，有的时候我们希望打包出来的文件名是打包前的文件名称 在动态import()代码处添加注释webpackChunkName告诉webpack打包后的chunk的名称，就可以实现：按需引入组件，提高网页性能 12345678const Login = () =&gt; import(/* webpackChunkName: "login" */ '@/container/login');let routes = [ &#123; path: '/login', name: 'login', component: Login &#125;]; 路由写法以前的路由经常在一个文件中书写，使用以下的写法，可以实现：按业务写路由文件，再在index.js，进行拼接 123456789101112131415161718192021// index.js: 拿到当前文件夹中的*/router.js的js文件 然后合并到routes中const routesContext = require.context('./', false, /\.router\.js$/);routes = routesContext.keys().reduce((all, key) =&gt; &#123; return all.concat(routesContext(key).default);&#125;, routes);const router = new Router(&#123; routes &#125;);//子文件 案例// import LogManage from '@/container/log-manage/index';const LogManage = () =&gt;import(/* webpackChunkName: "log-manage" */ '@/container/log-manage/index');export default [ &#123; path: '/log-manage', name: 'LogManage', component: LogManage, meta: &#123; code: '107001' &#125; &#125;];]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单点登录]]></title>
    <url>%2F2019%2F11%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[简称为 SSO，在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux中的删除]]></title>
    <url>%2F2019%2F11%2F07%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FLinux%E4%B8%AD%E7%9A%84%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[-r 就是向下递归，不管有多少级目录，一并删除 -f 就是直接强行删除，不作任何提示的意思 1234567# 删除文件夹实例：$ rm -rf /var/log/httpd/access# 将会删除/var/log/httpd/access目录以及其下所有文件、文件夹# 删除文件使用实例：$ rm -f /var/log/httpd/access.log# 将会强制删除/var/log/httpd/access.log这个文件]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitbook 使用指南]]></title>
    <url>%2F2019%2F11%2F07%2FGit%2FGitbook%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[使用 Gitbook 12345678910$ git clone ...$ gitbook install$ gitbokk serve # 本地预览$ gitbook build # 先 build 再 push，就发布了$ git add . # git status时会有很多历史改动，不要紧张，不太需要管，确实生成$ git commit -m ''$ git pull$ git push# 对于| &amp; # 可以使用code值进行转义，比如&amp;#124; -》 |]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js 精度问题]]></title>
    <url>%2F2019%2F11%2F06%2FJavaScript%2FJs%20%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言Js 浮点数运算会出现意想不到的结果：0.1+0.2=0.30000000000000000004，可以使用一下方法进行精度计算 123456789101112/** * 小数加、减、乘、除 保留精度计算 * @param &#123;Number&#125; value * @param &#123;Number&#125; decimals * for example * precisionRound(0.1 + 0.2, 2) 返回结果0.3 */export const precisionRound = (value, decimals) =&gt; &#123; return Number(`$&#123;Math.round(`$&#123;value&#125;e$&#123;decimals&#125;`)&#125;e-$&#123;decimals&#125;`)&#125;// 用公式precisionRound(0.1+0.2, 2)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则匹配]]></title>
    <url>%2F2019%2F11%2F01%2FJavaScript%2F%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[前言记录正则匹配的相关 参数介绍 /g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。如果不加/g最多只会匹配一个 /i 表示匹配的时候不区分大小写 /m 表示多行匹配，什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$符号 例子1/^(http|https):\/\/(st.)?m\.demo\.com(\/.*)?$/ 匹配 http 或 https 开头的，允许 st 环境下的网址 注意：(/.)?$ 用来匹配.com后面的字符，必须以.com结尾，或者.com/结尾]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[require.context]]></title>
    <url>%2F2019%2F11%2F01%2FJavaScript%2Frequire.context%2F</url>
    <content type="text"><![CDATA[读取文件的路径,是否遍历文件的子目录,匹配文件的正则 遍历文件夹中的指定文件 然后自动导入 不需要每次显式的调用import导入模块 ，比如一个想要导入一个文件夹内的所有文件，可以不用一个个import 1const req = require.context('./floors/youpin-home', true, /\.vue$/im);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Object.keys]]></title>
    <url>%2F2019%2F11%2F01%2FJavaScript%2FObject.keys%2F</url>
    <content type="text"><![CDATA[处理对象，返回可枚举的属性数组 1234567let person = &#123; name:"张三", age:25, address:"深圳", getName:function()&#123;&#125;&#125;Object.keys(person) // ["name", "age", "address","getName"]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-过滤器]]></title>
    <url>%2F2019%2F11%2F01%2FVue%2F%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[自定义过滤器，可被用于一些常见的文本格式化。 过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 ： 12345&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id="rawId | formatId"&gt;&lt;/div&gt; 新建filter.js文件，将所有的全局过滤器放在里面 123// main.js中全局注册import filter from '../filter'Object.keys(filters).forEach(item =&gt; Vue.filter(item, filters[item]));]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Charles(花瓶)]]></title>
    <url>%2F2019%2F11%2F01%2F%E5%BC%80%E5%8F%91%2FCharles(%E8%8A%B1%E7%93%B6)%2F</url>
    <content type="text"><![CDATA[前言之前实习时使用过花瓶进行抓包，现在又使用它进行代理、本地mock，整理一下它的用途。 用途 可以获取 http 的内容，对移动端的网页进行 debugger，将电脑设置成手机的 http 代理，手机 wifi 要设置成电脑的同一个域，结果就是手机的请求都会通过这个电脑，返回数据也会通过这个电脑，所以这个电脑上的Charles 就可以拿到这个手机的请求以及请求的返回； 在工具栏 Tools-&gt;Map Remote（快捷键 option+command+M）,可以设置代理，Map Form(输入啥网址)，Map To(本地地址 localhost 端口号..)，意思是：输入 form 的地址，会代理到本地，把本地的代码拿过来，因为本地的接口的地址是默认取网址的前缀，所以可以跑出来，而直接输入 localhost 会出不来，因为接口地址不对； 可以自定义 mock 接口的内容，在工具栏 Tools-&gt;Map Local（快捷键 option+command+L，或者直接右键接口文件），把接口的内容代理成自己自定义的文件，然后再右键 repeat，即可！ 安装 花瓶破解版 之前因为正版没破解，30分钟就要手动重开一次，非常麻烦。装了破解版后，发现代理成功，但是没有抓包成功 解决： 设置-》wifi-》代理-》配置 网页代理、安全网页代理 127.0.0.1:8888 正版可能默认配置了 遇到的一个小问题：重启了一下电脑，发现不能连上网，但是wifi一切正常 原因：开了花瓶，wifi设置了代理，把网站都转发了，要么开花瓶上网，要么去掉代理~]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac 使用手册]]></title>
    <url>%2F2019%2F10%2F29%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FMac%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[前言记录 Mac 使用的一些快捷手段+开发工具 mac 快捷键 功能 快捷键 最小化当前应用 cmd+m 最小化所有应用 cmd+f3 关掉当前页面 cmd+w 新增页面 cmd+t 复制/粘贴 cmd+c cmd+v cmd+x 开发者工具 cmd+option+i 全屏/退出全屏 cmd+control+f 装系统 iterm2 oh-my-zsh（iterm2主题，高亮等，更美观） vscode vscode 插件 eslint + prettier 定义了变量并且使用了，但是eslint还是报未使用的错，可以在声明变量的当前行加上一条注释 // eslint-disable-line no-unused-vars Ts-node：实现ts自动编译，又没有产生js文件 git nvm node nginx vpn postman switchHosts charles office 下载homebrew，可以使用 brew install iterm2/git/nvm/nginx，其中下载了nvm，默认下载node，npm，nvm版本根据项目规定 配置ssh 修改图片像素可以直接在图片预览中改像素大小 实现code . 打开vscode运行 VS code并打开命令面板（ ⇧⌘P ），然后输入 shell command 找到: Install ‘code’ command in PATH ，点击安装就行了。 在终端中输入命令 1$ code . 即可在 vs code 中打开当前文件夹。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试]]></title>
    <url>%2F2019%2F10%2F29%2F%E5%BC%80%E5%8F%91%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[分享会上介绍了如何使用 jest，进行单元测试。我们在代码中经常有 if else 等条件语句，有时候肉眼无法观察到有什么错误，可能某个不触发的条件没写或者有误，在实际运用中，刚好触发到这个有误的条件，就可能有严重的bug，我们排查也很需要耗费时间；或者公用方法中，使用它的组件有所改动，可以用测试用例查看该改动是否影响其他使用它的组件。 使用 jest 断言，可以查看执行结果，执行方法，异步，mock数据，vue等是否正确。更具体的可以查看 jest 的api进行学习。 也可以使用其他的工具进行单元测试，还有一个很有趣的方法，集成的，可以展示Ui界面，形成视频，模拟自己去操作，查看代码功能是否正确。 不过单元测试确实有点耗时间，一点点功能，就要写很多，可能把精力集中在公用代码进行预防，会比较好。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节流与防抖]]></title>
    <url>%2F2019%2F10%2F21%2FJavaScript%2F%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[防抖触发事件后在 n 秒内函数只能执行一次（并且是最后一次发生的事件），如果 n 秒内又触发了事件，则会重新计算函数执行时间 1234567891011function debounce(fn, delay) &#123; let timer; return function() &#123; let self = this; let args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; fn.apply(self, args); &#125;, delay); &#125;;&#125; 节流连续触发事件，但是在 n 秒内只执行一次函数 1234567891011121314151617181920212223242526272829//方法一：定时器实现function throttle1 = function(fn, delay) &#123; let timer = null; return function() &#123; const self = this; let args = arguments; if(!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(self, args) clearTimeout(timer) timer = null &#125;,delay) &#125; &#125;&#125;//方法二：时间戳function throttle2 = function(fn, delay) &#123; let preTime = Date.now(); return function() &#123; const self = this; let args = arguments; let doTime = Date.now() if(doTime - preTime &lt;= delay) &#123; fn.apply(self, args) preTime = Date.now() &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中序遍历]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132// Way1. 栈结构实现function inOrder(root) &#123; var res = []; var stack = []; var p = root; while (p || stack.length &gt; 0) &#123; while (p) &#123; stack.push(p); p = p.left; &#125; p = stack.pop(); res.push(p.node); p = p.right &#125; return res&#125; // Way2. 递归实现function inOrderCore(root, res) &#123; if (!root) &#123; return &#125; inOrderCore(root.left, res); res.push(root.node); inOrderCore(root.right, res);&#125; function inOrder2(root) &#123; var res = []; inOrderCore(root, res); return res;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二叉树深度]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[12345678910function dfs(root) &#123; if (!root) &#123; return 0 &#125;else &#123; var leftDepth = dfs(root.left); var rightDepth = dfs(root.right); var childDepth = leftDepth &gt; rightDepth ? leftDepth : rightDepth; return childDepth + 1 &#125;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字符串找最长连续数字子序列，输出长度]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%BE%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%8C%E8%BE%93%E5%87%BA%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617function maxLenStr(str) &#123; var n = []; var newStr = str.replace(/\d+/g, function()&#123; return n.push(arguments[0]) &#125;) var i = 0; for(var j = 0;j &lt; n.length;j++) &#123; if(n[j].length &gt;=i) &#123; i = n[j].length; var max = j &#125; &#125; return i; //n[max] 为最长的子序列&#125;maxLenStr(abcd12345ed125ss123456789) //123456789]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个字符串找最大公共子串]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%BE%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718function findSubStr(str1, str2) &#123; if(str1.length &gt; str2.length) &#123; var temp = str1; str1 = str2; str2 = temp; &#125; var len1 = str1.length; for(var j = len1;j &gt; 0;j--) &#123; for(var i = 0;i &lt; len1 - j;i++) &#123; var current = str1.substr(i, j); if(str2.indexOf(current) &gt;=0 ) &#123; return current; &#125; &#125; &#125; return "";&#125;console.log(findSubStr("baa333cc", "aaa333")); //aa333]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2019%2F10%2F11%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[1234567891011121314/* * 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中 * IE8以下不支持数组的indexOf方法 * * */ function uniq(array)&#123; var temp = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++)&#123; if(temp.indexOf(array[i]) == -1)&#123; temp.push(array[i]); &#125; &#125; return temp; &#125; var aa = [1,2,2,4,9,6,7,5,2,3,5,6,5]; console.log(uniq(aa));]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git 重命名分支]]></title>
    <url>%2F2019%2F10%2F11%2FGit%2F%E9%87%8D%E5%91%BD%E5%90%8D%E5%88%86%E6%94%AF%2F</url>
    <content type="text"><![CDATA[1、本地分支重命名1git branch -m oldName newName2、将重命名后的分支推送到远程1git push origin newName3、删除远程的旧分支1git push --delete origin oldName 显示如下，说明删除成功12To http://11.11.11.11/demo/demo.git - [deleted] oleName]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[for in 与 for of]]></title>
    <url>%2F2019%2F10%2F11%2FJavaScript%2Ffor%20in%E4%B8%8Efor%20of%2F</url>
    <content type="text"><![CDATA[for in 循环返回的值是键名（数组的索引），for of返回的是 值for in 还会遍历原型上的值和手动添加的其他键，会以任意顺序遍历，更适合遍历对象for of 不会遍历原型上和手动添加的，可以打破循环 详细：http://www.fly63.com/article/detial/1444]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[data不能使用箭头函数]]></title>
    <url>%2F2019%2F10%2F11%2FVue%2Fdata%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[vue使用严格模式，this指向undefined，data的实现原理是每次创建新实例会判断是否有data函数，如果有会将其赋值给 vm._data ’如果是箭头函数，this 指向 undefined，会赋值给 vm._data，只要不刷新页面会缓存data，不使用箭头函数的话，this指向vm实例，会随着实例更新]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[迭代与递归]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%BF%AD%E4%BB%A3%E4%B8%8E%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[迭代 递归 解释 利用变量的原值推出新值 程序调用自身 优点 代码运行效率好，时间只因循环次数增加而增加，没有额外的空间开销 大问题转化为小问题，可以减少代码量，代码精简，可读性好 缺点 代码不如递归简洁 浪费空间，递归太深容易造成堆栈的溢出]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义指令]]></title>
    <url>%2F2019%2F09%2F26%2FVue%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[注册全局的自定义指令：Vue.directive()，传递两个参数 指令的名字 一个对象 1234567891011Vue.directive('focus', &#123; bind: function (el) &#123; // 注意：每个函数中呢，第一个参数永远是el， 表示被绑定了指令的那个元素，这个el参数，是一个原生的js对象 el.focus() &#125;, // 在元素刚绑定指令的时候，元素还没有放到dom中去，这个时候，调用focus方法没有作用 // 因为一个元素只有插入dom之后，才能获取焦点 inserted: function (el) &#123; el.focus() &#125;,&#125;) 使用时，需要在指令前加一个v-，即v-focus]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css3 绘制三角形]]></title>
    <url>%2F2019%2F09%2F26%2FCss3%2F%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[通过控制元素的border即可实现12345width: 0;height: 0;border-width: 100px;border-style: solid;border-color: #FFCCCC transparernt transparent transparent; //得到一个向下的三角形]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css实现两栏布局]]></title>
    <url>%2F2019%2F09%2F26%2FCss3%2F%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[左侧宽度固定，右侧自适应 1234&lt;div class="box" id="box"&gt; &lt;div class="left"&gt;左侧定宽&lt;/div&gt; &lt;div class="right"&gt;右侧自适应&lt;/div&gt;&lt;/div&gt; Flex 布局123456789101112#box &#123; display: flex; display: -webkit-flex;&#125;.left &#123; width: 100px; background: yellow;&#125;.right &#123; flex: 1; background: red;&#125; Calc 计算12345678.left &#123; width: 100px; background: yellow;&#125;.right &#123; width: calc(100% - 100px); background: red;&#125; Float + Margin123456789.left &#123; float: left; width: 100px; background: yellow;&#125;.right &#123; margin-left: 100px; background: red;&#125; Position123456789101112131415161718#box &#123; position: relative;&#125;.left &#123; position: abosulte; left: 0; top: 0; width: 100px; background: yellow;&#125;.right &#123; position: absolute; left: 100px; top: 0; right: 0; width: 100%; background: red;&#125; Table12345678910111213#box &#123; display: table;&#125;#box&gt;div &#123; display: table-cell;&#125;.left &#123; width: 100px; background: yellow;&#125;.right &#123; background: red;&#125;]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[超大整数相加]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E8%B6%85%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243function sumStrings(a,b) &#123; //通过补零让a和b对齐 //若a比b短，则对a补零 while(a.length &lt; b.length)&#123; a = "0" + a; &#125; //若b比a短，则对b补零 while(b.length &lt; a.length)&#123; b = "0" + b; &#125; //是否有进位 var addOne = 0; //结果数组 var result = []; //从个位开始相加 for(var i=a.length-1;i&gt;=0;i--)&#123; var c1 = a.charAt(i) - 0; var c2 = b.charAt(i) - 0; var sum = c1 + c2 + addOne; //若数字相加大于9，则进位 if(sum &gt; 9)&#123; result.unshift(sum - 10); addOne = 1; &#125; else&#123; result.unshift(sum); addOne = 0; &#125; &#125; //应付下面的情况： //"99" + "11" =&gt; "110" //它最后仍然要进位 if(addOne)&#123; result.unshift(addOne); &#125; //应付如下的情况 //"01" + "01" =&gt; "2" //而不是"02"，所以移除第一位的"0" if(!result[0])&#123; result.splice(0,1); &#125; return result.join(""); &#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[任务管理器]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实现一个任务管理器，这里面执行的函数都是异步函数，然后管理器内部最多只能同时执行两个函数。设置一个 函数数组fnArray，一个参数数组paramsArray，一个计数器count返回一个对象，里面执行run run方法，每次往函数数组，参数数组push对应的内容，执行 异步函数 执行异步函数方法中，判断count和函数数组的长度，每次从头取函数数组，参数数组，count++，执行，执行后count–,循环execute 1234567891011121314151617181920212223242526function taskManager() &#123; let fnArray = []; let paramsArray = []; let count = 0; function run(fn) &#123; let param = Array.from(arguments).slice(1); fnArray.push(fn); paramsArray.push(param); execute() &#125; function execute() &#123; if(count &lt; 2 &amp;&amp; fnArray.length &gt; 0) &#123; let fn = fnArray.shift(); let param = paramsArray.shift(); count++; fn.apply(window, param).then(function() &#123; count--; execute(); &#125;) &#125; &#125; let o = &#123; run: run &#125; return o;&#125;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Keep-alive源码分析]]></title>
    <url>%2F2019%2F09%2F10%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2FKeep-alive%2F</url>
    <content type="text"><![CDATA[前言Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染dom，达到缓存的效果 include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 用法keep-alive 需要配合 router-view 使用 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div id="app"&gt; &lt;!--缓存想要缓存的页面，实现后退不刷新--&gt; &lt;!--加上v-if的判断，可以自定义想要缓存的组件，自定义在router里面--&gt; &lt;keep-alive&gt; &lt;router-view v-if="$route.meta.keepAlive"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if="!$route.meta.keepAlive"&gt;&lt;/router-view&gt; &lt;!--这里是其他的代码--&gt; &lt;/div&gt;&lt;/template&gt;//在 router 文件上加 meta 判断import Vue from 'vue'import Router from 'vue-router' Vue.use(Router)export default new Router(&#123; &#123;//home会被缓存 path:"/home", component:home, meta:&#123;keepAlive: true&#125; &#125; &#123;//hello不会被缓存 path:"/hello", component:hello, meta:&#123;keepAlive: false&#125; &#125;&#125;) 生命周期 activated deactivated 因为 keep-alive 会将组件保存在内存中，并不会销毁以及重新构建，所以不会重新调用组件的 created等 方法，需要用 activated和deactivated 得知当前组件是否处于活动状态 原理created 与 destroyed 钩子created钩子 会创建一个cache对象，用来作为缓存容器，保存vnode节点 1234created () &#123; /* 缓存对象 */ this.cache = Object.create(null)&#125;, destroyed钩子 则在组件被销毁的时候清除cache缓存中的所有组件实例 123456/* destroyed钩子中销毁所有cache中的组件实例 */destroyed () &#123; for (const key in this.cache) &#123; pruneCacheEntry(this.cache[key]) &#125;&#125;, render 通过 getFirstComponentChild 获取第一个子组件， 获取该组件的 name （存在组件名则直接使用组件名，否则会使用tag） 将这个 name 通过 include 与 exclude 属性进行匹配 匹配不成功（说明不需要进行缓存）则不进行任何操作直接返回vnode 1234567891011121314151617181920212223242526272829303132render () &#123; /* 得到slot插槽中的第一个组件 */ const vnode: VNode = getFirstComponentChild(this.$slots.default) const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; // check pattern /* 获取组件名称，优先获取组件的name字段，否则是组件的tag */ const name: ?string = getComponentName(componentOptions) /* name不在inlcude中或者在exlude中则直接返回vnode（没有取缓存） */ if (name &amp;&amp; ( (this.include &amp;&amp; !matches(this.include, name)) || (this.exclude &amp;&amp; matches(this.exclude, name)) )) &#123; return vnode &#125; const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : '') : vnode.key /* 如果已经做过缓存了则直接从缓存中获取组件实例给vnode，还未缓存过则进行缓存 */ if (this.cache[key]) &#123; vnode.componentInstance = this.cache[key].componentInstance &#125; else &#123; this.cache[key] = vnode &#125; /* keepAlive标记位 */ vnode.data.keepAlive = true &#125; return vnode&#125; 检测 include 与 exclude属性匹配的函数很简单，include 与 exclude 属性 支持字符串如”a,b,c”这样组件名以逗号隔开的情况以及正则表达式。matches通过这两种方式分别检测是否匹配当前组件。 123456789101112/* 检测name是否匹配 */function matches (pattern: string | RegExp, name: string): boolean &#123; if (typeof pattern === 'string') &#123; /* 字符串情况，如a,b,c */ return pattern.split(',').indexOf(name) &gt; -1 &#125; else if (isRegExp(pattern)) &#123; /* 正则 */ return pattern.test(name) &#125; /* istanbul ignore next */ return false&#125; 根据 key 在this.cache中查找，如果存在则说明之前已经缓存过了，直接将缓存的vnode的组件实例覆盖到目前的vnode上面 否则将 vnode 存储在 cache 中，再返回 vnode 12345if (this.cache[key]) &#123; vnode.componentInstance = this.cache[key].componentInstance&#125; else &#123; this.cache[key] = vnode&#125; watch 用 watch 来监听 include 与 exclude 这两个属性的改变，在改变的时候修改cache缓存中的缓存数据 123456789watch: &#123; /* 监视include以及exclude，在被修改的时候对cache进行修正 */ include (val: string | RegExp) &#123; pruneCache(this.cache, this._vnode, name =&gt; matches(val, name)) &#125;, exclude (val: string | RegExp) &#123; pruneCache(this.cache, this._vnode, name =&gt; !matches(val, name)) &#125;&#125;, 遍历cache中的所有项，如果不符合filter指定的规则的话，则会执行pruneCacheEntry pruneCacheEntry则会调用组件实例的$destroy方法来将组件销毁 123456789101112131415161718192021222324/* 修正cache */function pruneCache (cache: VNodeCache, current: VNode, filter: Function) &#123; for (const key in cache) &#123; /* 取出cache中的vnode */ const cachedNode: ?VNode = cache[key] if (cachedNode) &#123; const name: ?string = getComponentName(cachedNode.componentOptions) /* name不符合filter条件的，同时不是目前渲染的vnode时，销毁vnode对应的组件实例（Vue实例），并从cache中移除 */ if (name &amp;&amp; !filter(name)) &#123; if (cachedNode !== current) &#123; pruneCacheEntry(cachedNode) &#125; cache[key] = null &#125; &#125; &#125;&#125; /* 销毁vnode对应的组件实例（Vue实例） */function pruneCacheEntry (vnode: ?VNode) &#123; if (vnode) &#123; vnode.componentInstance.$destroy() &#125;&#125; 总结Vue.js内部将DOM节点抽象成了一个个的 VNode节点，keep-alive 组件的缓存也是基于VNode节点的而不是直接存储DOM结构 它将满足条件（include与exclude）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点 从 cache对象中 取出并渲染]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-new实现]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2FJS-new%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言之前我们在 this 指向 这篇文章中，讨论过 构造函数 new 的步骤： 创建一个新对象 把构造函数的 this 指向新对象 新对象的 proto 属性指向构造函数的 prototype 原型 执行构造函数的代码 返回新对象 现在，我们尝试依照这个步骤，用 JS 实现一个 new 实现123456789101112131415161718192021function newFn(fn, ...args) &#123; let newObj = &#123;&#125;; //创建一个新对象 const result = fn.call(newObj, ...args); //把构造函数的 this 指向新对象 newObj._proto_ = fn.prototype; //新对象的 proto 属性指向构造函数的 prototype 原型 if (result &amp;&amp; (typeof result === "object" || typeof result === "function")) &#123; newObj = result; &#125; return newObj; //返回新对象&#125;//测试用例function People(name, age) &#123; this.name = name; this.age = age;&#125;let people = newFn1(People, "Rose", 18); //调用自定义newFn实现newconsole.log(people.name); //Roseconsole.log(people2.age); //18]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-实现继承的五种办法]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2FJS-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言之前一直对原型链不太了解，所以继承也懵懵懂懂，最近终于对原型链有点心得了，抓紧弄懂继承！ 原型链继承核心：将父类的实例作为子类的原型 特点： 实例 是子类的 实例，也是父类的 实例 父类新增原型方法/原型属性，子类都能访问到 缺点： 父类一变，子类也变 无法实现多继承：一个子类只能继承一个父类，不能继承多个父类 子类新增属性/方法，必须在new () 后面执行 创建子类实例时，无法向父类构造函数传参 123456789101112131415161718192021222324252627function Person(name) &#123; this.name = 'wei' || name;&#125;Person.prototype.getName = function() &#123; //对原型进行扩展 return this.name;&#125;function Parent(age) &#123; this.age = age;&#125;Parent.prototype = new Person(); //关键！！！通过构造器函数创建一个新对象，把老对象的东西拿过来//注意，不要在父类构造函数传参，虽然语法上没啥问题，但是实际上并不符合 面向对象 编程规则：对象（实例）才是属性的拥有者//如果创建子类实例时，传参，给属性赋值，就变成类拥有属性，而不是对象拥有属性//例子： Parent.prototype = new Person('老明');//此时，Parent类拥有了 name = '老明'属性，此后，它的实例对象 c1,c2,c3 都只能接受 name 这个属性Parent.prototype.getAge = function() &#123; return this.age;&#125;//Parent.prototype.getName = function() &#123; //可以重写父类继承来的方法，会覆盖// console.log('222') ;//&#125;var result = new Parent(22);console.log(result.getName()); //weiconsole.log(result.getAge()); //22 构造继承核心：在子类构造函数中利用 call/apply 把父类中通过 this 指定的属性/方法 复制到子类创建的实例中 特点： 实例不是父类的实例，只是子类的实例 创建子类实例时，可以向父类传递参数 可以实现多继承（call 多个父类对象） 缺点： 只能继承父类的实例方法/属性，不能继承父类原型上的方法/属性 每个子类都有父类实例对象的副本，影响性能 12345678910111213141516171819202122232425function Person (name) &#123; this.name = name; this.friends = ['小李','小红']; this.getName = function () &#123; return this.name; &#125;&#125;;//Person.prototype.geSex = function () &#123; //对原型进行扩展的方法无法复用// console.log("男");//&#125;;function Parent = (age) &#123; Person.call(this,'老明'); //这一句是核心关键 //这样就会在新parent对象上执行Person构造函数中定义的所有对象初始化代码， // 结果parent的每个实例都会具有自己的friends属性的副本 this.age = age;&#125;;var result = new Parent(23);console.log(result.name); //老明console.log(result.friends); //["小李", "小红"]console.log(result.getName()); //老明console.log(result.age); //23console.log(result.getSex()); //这个会报错，调用不到父原型上面扩展的方法 组合继承（最常用）核心：调用父类构造，继承父类的属性，保留传参的优点；将父类实例作为子类原型，实现父类原型 方法/属性 复用 特点： 结合了 原型链继承 与 构造继承 的优点 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 12345678910111213141516171819202122232425function Person (name) &#123; this.name = name; this.friends = ['小李','小红'];&#125;;Person.prototype.getName = function () &#123; return this.name;&#125;;function Parent (age) &#123; Person.call(this,'老明'); //这一步很关键 this.age = age;&#125;;Parent.prototype = new Person('老明'); //这一步也很关键var result = new Parent(24);console.log(result.name); //老明result.friends.push("小智"); //console.log(result.friends); //['小李','小红','小智']console.log(result.getName()); //老明console.log(result.age); //24var result1 = new Parent(25); //通过借用构造函数都有自己的属性，通过原型享用公共的方法console.log(result1.name); //老明console.log(result1.friends); //['小李','小红'] 寄生组合继承核心：通过寄生方式，砍掉父类的实例属性。那么在调用两次父类的构造时，就不会初始化两次实例方法/熟悉，避免组合继承的缺点 优点： 非常完美 缺点： 实现较复杂 12345678910111213141516171819202122232425function Person(name) &#123; this.name = name; this.friends = ['小李','小红'];&#125;Person.prototype.getName = function () &#123; return this.name;&#125;;function Parent(age) &#123; Person.call(this,"老明"); //关键！！ this.age = age;&#125;(function () &#123; //关键！！ var Super = function () &#123;&#125;; // 创建一个没有实例方法的类 Super.prototype = Person.prototype; //把类的原型指向父类的原型 Parent.prototype = new Super(); //将实例作为子类的原型&#125;)();var result = new Parent(23);console.log(result.name);console.log(result.friends);console.log(result.getName());console.log(result.age); ES6 - class中的super()实现核心：调用super方法：创造父类的实例对象this，然后再用子类的构造函数修改this 1234567891011121314151617181920class Animal &#123; constructor() &#123; this.type = 'animal'; &#125; says(say) &#123; console.log(this.type + ' says ' + say); &#125; &#125; let animal = new Animal(); animal.says('hello'); //animal says hello class Cat extends Animal &#123; constructor() &#123; super(); this.type = 'cat'; &#125; &#125; let cat = new Cat(); cat.says('hello'); //cat says hello]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拷贝数组]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript%2F%E6%8B%B7%E8%B4%9D%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言我们都知道 数组的拷贝，不能直接的使用 = 来拷贝；只是浅拷贝，修改拷贝的值，被拷贝的值也会变。下面总结一下数组的拷贝方法 ES5 方法集合1、slice12345var arr = [1,2,3,4,5]var arr2 = arr.slice(0)arr[2] = 5console.log(arr) //1,2,5,4,5console.log(arr2) //1,2,3,4,5 2、遍历数组（for循环）123456789var arr = [1,2,3,4,5]var arr2 = copyArr(arr)function copyArr(arr) &#123; let res = [] for (let i = 0; i &lt; arr.length; i++) &#123; res.push(arr[i]) &#125; return res&#125; 3、concat()12345var arr = [1,2,3,4,5]var arr2 = arr.concat()arr[2] = 5console.log(arr) //1,2,5,4,5console.log(arr2) //1,2,3,4,5 ES6 方法集合1、展开运算符12345var arr = [1,2,3,4,5]var arr2 = [...arr]arr[2] = 5console.log(arr) //1,2,5,4,5console.log(arr2) //1,2,3,4,5 2、Object.assign()12345let arr = ['sdsd',123,123,123]let arr1 = []Object.assign(arr1,arr)arr[1] = 'aaaa'console.log(arr,arr1) // [ 'sdsd', 'aaaa', 123, 123 ] [ 'sdsd', 123, 123, 123 ] Object.assign() 是浅拷贝还是深拷贝呢？解答：第一级属性深拷贝，第二级属性浅拷贝 12345678910111213141516//示例1 一层深拷贝let obj = &#123;a:1&#125;let newObj = Object.assign(&#123;&#125;,obj);console.log(newObj); //&#123;a: 1&#125;newObj.a=2;console.log(obj); //&#123;a:1&#125;console.log(newObj); //&#123;a: 2&#125; //示例2 二层浅拷贝let obj = &#123;a:1,b:&#123;name:"zhangsan"&#125;&#125;let newObj = Object.assign(&#123;&#125;,obj);console.log(newObj); //&#123;a:1,b:&#123;name:"zhangsan"&#125;&#125;newObj.b.name="lisi";console.log(obj); //&#123;a:1,b:&#123;name:"lisi"&#125;&#125;console.log(newObj); //&#123;a:1,b:&#123;name:"lisi"&#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack与gulp]]></title>
    <url>%2F2019%2F09%2F09%2F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2Fwebpack%E4%B8%8Egulp%2F</url>
    <content type="text"><![CDATA[前言记录 Webpack 与 Gulp 的一些知识点~ gulpgulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 PS：简单说就一个Task Runner 核心原理： 最主要是通过各种 Transform Stream 来实现文件的处理，然后再进行输出。Transform Stream 是 NodeJs Stream 的一种，是可读可写的，它会对传给它的对象做一些转换的操作 文件输入-》Gulp插件处理-》文件输出 webpack 一个前端模块化方案，更侧重模块打包 把开发中的所有资源（图片、js文件、css文件等）都看成模块 通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 入口文件 entry: &#123; app: './src/js/index.js', &#125;, // 输出文件 output: &#123; filename: '[name].bundle.js', path: path.resolve(__dirname, 'dist'), publicPath: '/' //确保文件资源能够在 http://localhost:3000 下正确访问 &#125;, // 开发者工具 source-map devtool: 'inline-source-map', // 创建开发者服务器 devServer: &#123; contentBase: './dist', hot: true // 热更新 &#125;, plugins: [ // 删除dist目录 new CleanWebpackPlugin(['dist']), // 重新穿件html文件 new HtmlWebpackPlugin(&#123; title: 'Output Management' &#125;), // 以便更容易查看要修补(patch)的依赖 new webpack.NamedModulesPlugin(), // 热更新模块 new webpack.HotModuleReplacementPlugin() ], // 环境 mode: "development", // loader配置 module: &#123; rules: [ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125; ] &#125; 1、entry是页面入口文件配置，Webpack 会分析入口文件，解析包含依赖关系的各个文件，当入口文件不止一个时，可以将其配置为数组，output 是输出项配置，如例子中的输出为app.js 2、module为加载器配置，例子中定义了.css文件的加载规则，会生成style标签放在head中。webpack1的时候use中的-loader后缀可以不写，webpack2必须要写 3、plugins为插件配置，例子中定义了一个环境变量，在代码中console.log(process.env.NODE_ENV)将打印production 构建流程是一个串行的过程，从启动到结束依次执行： 初始化参数：从配置文件和 shell 语句中读取与合并参数，得到最终的参数 开始编译：用得到的参数 初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译 确定入口：根据配置中的 entry 找到所有的入口文件 编译模块：从入口出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，递归翻译，直到所有入口依赖的文件都经过了翻译 完成模块翻译：翻译完所有模块后，得到每个模块被翻译后的最终内容以及它们之间的依赖关系 输出资源：根据入口与模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表 输出完成：确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写到文件系统 在以上步骤，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 API 改变 webpack 的运行结果 什么是bundle，什么是chunk，什么是modulebundle：是由webpack打包出来的文件 chunk：是指webpack在进行模块依赖分析的时候，代码分割出来的代码块 module：是开发中的单个模块 什么是loaderloader用于加载某些资源文件。因为webpack本身只能打包common.js规范的js文件，对于其他资源如css，img等，是没有办法加载的，这时就需要对应的loader将资源转化，从而进行加载。 什么是pluginplugin用于扩展webpack的功能。不同于loader，plugin的功能更加丰富，比如压缩打包，优化，不只局限于资源的加载。 1234567891011UglifyJsPlugin: 压缩代码HotModuleReplacementPlugin 自动刷新HtmlWebpackPlugin 依据一个简单的index.html模版，生成一个自动引用你打包后的js文件的新index.htmlExtractTextWebpackPlugin 它会将入口中引用css文件，都打包都独立的css文件中，而不是内嵌在js打包文件中Tree-shaking 指在打包中去除那些引入了，但是在代码中没有被用到的那些死代码在webpack中Tree-shaking是通过uglifySPlugin来Tree-shaking，Css需要使用Purify-CSS 区别： loader 加载资源到webpack，专注转换文件这个领域 plugin 扩展webpack的功能，比如压缩代码，热加载… 有哪些常见的Loader？file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 有哪些常见的Plugin？define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码 8、webpack-dev-server和http服务器如nginx有什么区别? webpack-dev-server使用内存来存储webpack开发环境下的打包文件，并且可以使用模块热更新，比传统的http服务对开发更加简单高效 9、什么 是模块热更新？ 模块热更新是webpack的一个功能，他可以使得代码修改过后不用刷新浏览器就可以更新，是高级版的自动刷新浏览器。 10、如何自动生成webpack配置? webpack-cli、vue-cli 11、什么是tree-shaking? css可以tree－shaking吗？ 指打包中去除那些引入了但在代码中没用到的死代码。在wepack中js treeshaking通过UglifyJsPlugin来进行，css中通过purify-CSS来进行.]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map(parseInt)解析]]></title>
    <url>%2F2019%2F09%2F04%2FJavaScript%2F%5B'1'%2C'2'%2C'3'%5D.map(parseInt)%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言一连两场笔试题都碰到这个问题，连踩两次，这次一定要好好破解它！ parseInt(string, radix)会把 数值字符串 解析成 对应数值，并返回；不是 数值字符串，返回 NaN 参数 描述 string 必需。需要被解析的字符串 radix 可选，默认为10表示要解析的数字的基数，2~36之间（小于或超过 返回NaN）如果为0，按10为基础解析如果为‘0x’ 或 ’0X‘开头，按16为基础解析 1234567parseInt("19"); //返回 19parseInt("19",10); //返回 19 (10+9)parseInt("11",2); //返回 3 (2+1)parseInt("17",8); //返回 15 (8+7)parseInt("1f",16); //返回 31 (16+15)parseInt("010"); //未定：返回 10 或 8parseInt('xyz') //返回：NaN Array.prototype.mapmap 遍历数组中的所有元素，为每个元素调用一次传入的函数。调用完毕将返回的结果存入到一个新数组中 1array.map(callbackfn[, thisArg]) 参数 定义 array 必需。一个数组对象 callbackfn 必需。一个接受最多三个参数的函数。数组内的每个元素都会调用一次如果不是函数，将引发 TypeError 异常function callbackfn(数组元素, 数组元素的索引, 包含该元素的数组) thisArg 可选。在callbackfn函数中引用this关键字的对象。如果省略，this为undefined 1234[1,2,3].map(function(value)&#123; return value + 1&#125;)//返回 [2,3,4] 解析[‘1’,’2’,’3’].map(parseInt) 中 ’1‘，’2‘，’3‘ 依次调用parseInt： 123parseInt('1', 0, ['1','2','3'])parseInt('2', 1, ['1','2','3'])parseInt('3', 2, ['1','2','3']) 因为 parseInt 只接受 两个参数，所以第三个参数数组，我们不用看 12345parseInt('1', 0) // 输出1parseInt('2', 1) // radix小于2，输出NaNparseInt('3', 2) // 3不是基础基数2的一个有效数字，输出NaN所以结果 [1, NaN, NaN]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP的11种状态]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FTCP%E7%9A%8411%E7%A7%8D%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[前言前面文章中有谈到 TCP 的3次握手与4次挥手，其中涉及到一些状态值，因篇幅过长，所以在此篇进行梳理 状态 状态值 表示 CLOSED 初始状态：连接‘关闭’ 或 ‘未打开’ LISTEN 服务端的某个SOCKET处于监听状态，可以接受客户端的连接 SYN_SEND 客户端已发送SYN报文 SYN_RCVD 服务器接收到了来自客户端请求连接的SYN报文 ESTABLISHEND TCP连接成功 FIN_WAIT_1 A想主动关闭连接，A发送FIN报文后进入 CLOSE_WAIT B正在等待关闭。收到A的FIN报文，发送ACK，同意关闭连接。此时已经关闭了 A -&gt; B 连接 FIN_WAIT_2 A收到B的ACK后此时SOCKET为半连接，有一方关闭了连接 LAST_ACK B等待A的ACK报文当收到对方的ACK报文后，就关闭了B -&gt; A的连接 TIME_WAIT A发出ACK报文，与CLOSE_WAIT不同，并未关闭连接 CLOSING 比较罕见的状态（下表）当双方几乎同时CLOSE()一个SOCKET的话，就会出现双方同时发送FIN报文的情况——导致：一方发送FIN报文后，并没有收到对方的ACK报文，反而收到对方的FIN报文]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信方式]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概念 每个进程各自有不同的用户地址空间，进程之间的变量是彼此看不到的 进程之间交换数据必须通过内核，在内核中开辟一块缓冲区 一个进程把自己的数据从用户空间拷贝到内核缓冲区，另一个进程再从内核缓冲区把数据读走 简单的说，就是进程间传播或交换信息 通信目的 数据传输：数据量在一个到几M字节之间 共享数据：多个进程操作共享数据 信息传递：通知某进程发生了某种事件（如进程终止时要通知父进程） 资源共享：多个进程共享同样的资源。为了做到这一点，需要内核提供锁和同步机制 进程管理：有些进程希望完全控制另一个进程的执行（如Debug进程），希望能够拦截另一个进程的所有异常，并能够及时知道它的状态变化 通信方式1、管道管道实质是一个内存缓冲区，需要通信的两个进程在管道两端，进程利用管道传递信息。对于两端的进程而言，管道就是一个文件，但它不属于文件系统，并且只存在与内存中 匿名管道 半双工：数据只能在一个方向流动，不能反方向 只能在有亲缘关系的进程间通信：父子进程、兄弟进程 命名管道 半双工 允许在没有亲缘关系的进程间通信：提供了一个路径名与之关联，以一种特殊设备文件形式存在于文件系统中 2、信号内核可以利用信号来通知进程发生了什么系统事件 信号来源 硬件来源：按下了键盘或其他硬件故障 软件来源：比如kill、raise、alarm、setitimer、sigqueue函数，还包括一些非法运算符操作 进程对信号的响应 忽略信号：但 SIGKLL 和 SIGSTOP 不能忽略 捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数 执行缺省操作 3、消息队列消息的链表，具有特定的格式 存放在内核中，由消息队列标识符（队列ID）标识 允许一个或多个进程向它写入与读取消息 4、共享内存多个进程可以直接读写同一块内存空间：内核专门留出一块内存区，需要访问的进程可以将其映射到自己的私有地址空间，不需要进行数据的拷贝，从而大大提高效率 注意 并未提供同步机制：在一个进程结束对共享内存的写操作之前，没有自动机制阻止另外的进程对它的读取 需要使用其他机制来同步对共享内存的访问 5、信号量标识可用资源数量的计数器 用来控制多个进程对共享资源的访问，不用于交换大批数据，而用于多线程之间的同步 常作为一种锁机制：防止某进程访问资源时其他进程也访问该资源 二进制信号量（二值信号量）：只有 0 和 1 的信号量，可用来标识某个资源是否可用 6、套接字可用于不同机器之间的进程通信 有两种类型的套接字：基于文件的 和 面向网络的 1、基于文件的Unix 套接字，家族名字 AF_UNIX，代表地址家族：UNIX 2、面向网络的家族名字 AF_INET，代表地址家族：INTERNET 不管采用哪个地址家族，都有两种不同的套接字连接：面向连接的 和 无连接的 面向连接的（SOCK_STREAM） 无连接的（SOCK_DGRAM） 进行通信前必须建立一个连接 通信前不需要建立联系成本更加低，因为不需要维护连接的开销 提供序列化的、可靠的、不重复的数据交付，没有记录边界 传输过程中无法保证顺序行、可靠性、重复性 每条信息可以被拆分成多个片段，并且每个片段都能确保到达目的地，在目的地将信息拼接起来 保存了记录边界，意味着消息是以整体发送的，而非首先分成多个片段 主要协议：传输控制协议 TCP 主要协议：用户数据报协议 UDP]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SQL-删除]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL-%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[前言SQL语法中，DROP、DELETE、TRUNCATE都表示删除，下面对其进行区别 语法123DROP TABLE 表名DELETE TABLE 表名 WHERE 列名=值TRUNCATE TABLE 表名 区别 DROP（删除表） DELETE（删除表中的数据） TRUNCATE（删除表中的数据） 把整个表删除：包括被依赖的约束、触发器、索引；依赖于该表的存储过程、函数会保留，但状态变为 invalid 删除表中的行，会把删除操作作为事务记录在日志中保存，以便进行回滚操作 删除内容，保留表的数据结构 作为外键的表，不能TRUNCATE，而应该使用不带 WHERE 的DELETE 数据库定义语言（ddl）操作立即生效原数据不放到 rollback segment 中，不能回滚操作不触发 trigger 数据库操作语言（dml）事务提交之后才生效会放到 rollback segment 中，能回滚操作执行时将触发 trigger 数据库定义语言（ddl）操作立即生效原数据不放到 rollback segment 中，不能回滚操作不触发 trigger 执行速度：DROP &gt; TRUNCATE &gt; DELETE]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树结点个数]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[满二叉树结点个数2^n - 1 满二叉树叶子结点个数2^（n - 1）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系型数据库与非关系型数据库]]></title>
    <url>%2F2019%2F09%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前言经常会涉及到 关系型数据库与非关系型数据库 的笔试题，下面用一张表进行梳理 数据库类型 特性 优点 缺点 关系型数据库MySQL、Oracle、Microsoft Access、Microsoft ServerDB2、PostgreSQL、SQLite、Teradata、MariaDB、SAP 1、采用了关系模型来组织数据，一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织2、最大特性：数据的一致性3、事务必须具备ACID特性 1、容易理解：关系模型相对网状、层次等其他模型更容易理解2、使用方便：使用通用的SQL语言3、易于维护：丰富的完整性（实体、参照、用户定义）大大减低了数据冗余和数据不一致的概率 1、高性能并发需求2、读写性能比较低，性能欠佳：多表的关联查询3、对数据库系统进行升级和扩展时，往往需要停机维护和数据迁移 非关系型数据库Redis、MongoDB、HBase、Amazon DynamoDBMemcached、Microsoft Azure Cosmos DB、Hazelcast 1、使用键值对存储数据2、分布式3、一般不支持ACID特性4、严格上不是一种数据库，而是一种数据结构化存储方法的集合 1、无需多表关联查询，读写性能很高2、基于键值对，数据没有耦合性，容易扩展3、存储格式多样：key,value形式、文档形式、图片形式等等，而关系型数据库则只支持基础类型。 1、不支持sql，学习和使用成本高2、无事务管理3、只适合存储较为简单的数据，不适合久存储海量数据 比较 关系型数据库 非关系数据库 成本 花费大量成本购买使用 √ 数据库简单易部署，基本都是开源软件 查询速度 数据存储在硬盘中 √ 数据存储在缓存中，不需要经过SQL层的解析 存储数据的格式 只支持基础类型 √ 支持基础类型、对象、集合等各种格式 扩展性 扩展很艰难：多表查询机制的限制 √ 基于键值对，数据没有耦合性，容易扩展 持久存储 √ 适合 × 不适合 数据一致性 √ 一般强调的是数据的强一致性 一般强调的是数据最终一致性，有可能读到的是一个处于中间态的数据，不提供事务的处理]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[URL编码]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FURL%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言HTTP协议中，参数的传输按照键值对的形式：’key = value‘ / ? % # &amp; =是 URL 的保留字符，/是地址分隔符，？后面接参数串，#表示书签，&amp;参数间分隔符，=指定参数值 当参数内有/ ? % # &amp; = ，是需要进行转义的，为了不与保留字符产生冲突。下表为特殊字符的转义表 转义表 + URL中的 +号 表空格 %2B 空格 URL中的空格可以用：+号或者编码 %20 / 分割目录、子目录 %2F ？ 分割地址与参数 %3F % 特殊字符 %25 # 书签 %23 &amp; 参数见的分隔符 %26 = 指定参数的值 %3D]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[懒加载与预加载]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2F%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%A2%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载延迟加载，当图片出现在浏览器可视区域时，才加载 优点 页面加载速度快 减轻服务器压力 节约流量，用户体验好 原理 图片Img标签自定义属性data-src来存放真实的地址 当滚动时，检查所有img标签，是否出现在视野范围内与是否已加载，如果出现在视野范围内与未加载，则把src赋值为data-src里面的地址，加载 预加载提前加载图片，当用户需要查看时，可直接从本地缓存中渲染 优点 避免网页加载出来时的空白页面 牺牲服务器前端性能，换取更好的用户体验 原理1、纯 CSS 进行图片预加载 背景图 1234567891011body:after &#123; content: ""; display: block; position: absolute; background: url("../image/manage/help/help_item2_01.png?v=201707241359") no-repeat -10000px -1000px,url("../image/manage/help/help_item2_02.png?v=201707241359") no-repeat -10000px -1000px,url("../image/manage/help/help_item2_03.png?v=201707241359") no-repeat -10000px -1000px....; width: 0; height: 0&#125; 2、纯 JavaScript 进行图片预加载 new Image()；设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存 123456789101112131415161718192021var imgSrcArr = [ 'imgsrc1', 'imgsrc2', 'imgsrc3', 'imgsrc4']; var imgWrap = [];function preloadImg(arr) &#123; for(var i =0; i&lt; arr.length ;i++) &#123; imgWrap[i] = new Image(); imgWrap[i].src = arr[i]; &#125;&#125; preloadImg(imgSrcArr); $(function () &#123; preloadImg(imgSrcArr);&#125;) 3、使用 css+js 进行图片的预加载 添加设置了背景图的类 12345678.preload-img:after&#123; content:"", background: url("../image/manage/help/help_item2_01.png?v=201707241359") no-repeat -10000px -1000px,url("../image/manage/help/help_item2_02.png?v=201707241359") no-repeat -10000px -1000px...&#125; $(function()&#123; $("#target").addClass("preload-img")&#125;) 4、使用 Ajax 的方式进行图片的预加载 123$(function()&#123; $.get('图片的路径');&#125;)]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>懒加载</tag>
        <tag>预加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写出二叉树遍历结果]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E5%86%99%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言在笔试题中，经常会碰到求 遍历 的类型题： 已知 前序遍历、中序遍历 求后序遍历 已知 中序遍历、后序遍历 求前序遍历 已知 前序遍历、后序遍历 求中序遍历 下面做一个总结 已知 前序遍历、中序遍历 求后序遍历中序遍历: GBEDAFCH 前序遍历: ABGDECFH 先找根：前序遍历的第一个元素：A 中序遍历中根据根元素，找到左、右子树：GBED、FCH 看左子树：GBED，因为前序遍历第二个为B，B是右子树的根，那么G就是左子树了 因为前序遍历第四个为D，则D是右子树的根，此时再看中序遍历E在D的前面，说明是D的左子树 上面的步骤，重复，可得到：GEDBFHCA 方法总结 先在前序遍历的第一个元素看：根 根据根在中序遍历中找左右子树 先看左子树，在前序遍历后面的元素看，一般为子树的根 根据子树的根在中序遍历中找子树的左右子树 重复以上 已知 中序遍历、后序遍历 求前序遍历中序遍历：HDMIBJNEAFKCG 后序遍历：HMIDNJEBKFGCA 先找根：后序遍历的最后一个元素：A 中序遍历中根据根元素，找到左、右子树：HDMIBJNE、FKCG 看右子树：FKCG，因为后序遍历倒数第二个为C，则C是右子树的根，那么G就是右子树了 因为后序遍历倒数第四个为F，则F是左子树的根，此时再看中序遍历K在F的后面，说明是F的右子树 上面的步骤，重复，可得到：ABDHIMEJNCFKG 方法总结 先在后序遍历的最后一个元素看：根 根据根在中序遍历中找左右子树 先看右子树，在后序遍历倒数的元素看，一般为子树的根 根据子树的根在中序遍历中找子树的左右子树 重复以上 已知 前序遍历、后序遍历 求中序遍历无法确定唯一的二叉树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[const与define]]></title>
    <url>%2F2019%2F09%2F02%2FC%E8%AF%AD%E8%A8%80%2Fconst%E4%B8%8Edefine%2F</url>
    <content type="text"><![CDATA[前言笔试题碰到了这俩货，查询一番，Oh，久违的C语言~ 区别 const define 编译器处理方式不同 常变量，在编译运行阶段使用 宏定义，常数，在预编译阶段展开 类型和安全检查不同 有具体的类型，在编译阶段时执行类型检查 没有类型，只是简单的字符串替换，不做任何类型检查 存储方式 在内存中分配 不分配内存，有多少地方使用，就展开多少次 可以调试 不能调试，预编译阶段已经替换，调试时没有它了 不能重定义 可以使用undef取消某个定义，再重定义]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链式存储结构与顺序存储结构]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言主要从空间、时间两个维度进行比较 从空间性能角度 链式存储 存储空间动态分配 相邻数据元素可随意存放（逻辑连续 物理统一），但存储空间分两部分：节点值、指针 存储密度小（&lt;1），存储空间利用率低 顺序存储 存储空间静态分配 相邻数据元素存放地址是连续的（逻辑、物理统一 连续），存储空间只有节点值 存储密度大（=1），存储空间利用率高 从时间性能角度查找、读取：顺序表更快 插入、删除：链式结构更快]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[批处理、分时、实时操作系统特点]]></title>
    <url>%2F2019%2F09%2F02%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E6%89%B9%E5%A4%84%E7%90%86%E3%80%81%E5%88%86%E6%97%B6%E3%80%81%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言批处理、分时、实时操作系统是啥呢？ 批处理操作系统工作方式 用户将作业交给系统操作员 系统操作员将许多用户的作业组成一批作业，输入到计算机中，在系统形成一个自动转接的连续的作业流 启动操作系统，系统自动、依次地执行每个作业 最后操作员把作业结果交给用户 特点 脱机：用户提交作业之后直到获得结果之前都几乎不再和计算机打交道 多道：多道程序一起运行 成批处理：操作员把用户提交的作业组织成一批，由操作系统负责每批作业间的自动调度 优点 自动化程度比较高 系统吞吐量大 资源利用率高 系统开销小 缺点 各作业周转时间长 不提供与系统的交互手段 适合大的成熟的作业 分时操作系统工作方式 一个主机连接了若干个终端，每个终端有一个用户在使用 用户交互地向系统提出命令请求，系统接受每个用户的命令，采用时间片轮转方式处理服务请求，并通过交互方式在终端上显示结果 用户根据上步结果发出下道命令 时间片分时操作系统将CPU的时间划分成若干个片段，以时间片为单位，轮流为每个终端用户服务。每个用户轮流使用一个时间片而使每个用户并不感到有别的用户存在 特点 多路性：多用户同时在各自终端使用同一计算机 交互性：联机，用户与系统进行人机对话 独立性：用户彼此独立操作，互不干扰，互不混淆 及时性：用户在短时间内可得到系统的及时回答 应用常见的通用操作系统： 分时系统与批处理系统 的结合 原则：分时优先，批处理在后。“前台”响应需频繁交互的作业，如终端的要求；“后台”处理时间性要求不强的作业 实时操作系统工作方式使计算机能及时响应外部事件的请求，在规定的严格时间内完成该事件的处理，并控制所有实时设备和实时任务协调一致地工作 特点 实时性：系统能及时响应外部事件的请求，并在规定时间内完成对该事件的处理 高可靠性：系统本身要安全可靠，比如航空订票等实时事务系统，不能出现信息处理的延误或丢失 还应该有较强的容错能力 应用对时间敏感的场合：机器人的运动控制、无人驾驶、航天航空等]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Canvas 与 SVG]]></title>
    <url>%2F2019%2F08%2F30%2FCss3%2FCanvas%E4%B8%8ESVG%2F</url>
    <content type="text"><![CDATA[曾在项目中使用过SVG进行流程控制，还挺有趣的；Canvas也试过，使用途径非常广。以下做一些区别。 Canvas SVG 通过 JavaScript 绘制2D图形 通过 XML 绘制2D图形 逐像素进行渲染 每个被绘制的图形均被视为对象，可以为对象增加 事件处理器 依赖分辨率 不依赖分辨率（图像在放大或者改变尺寸的情况下其图形质量不会有所损失） 渲染速度快，适合图像密集型的游戏 复杂度高会减慢渲染速度，不适合做游戏，可以用来做地图（百度地图就是使用 SVG） 一旦绘制完成，就不会继续得到浏览器的关注。（如果其位置发生变化，那么整个场景都需要重新绘制，包括任何或许已被图形覆盖的对象） SVG对象的属性发生变化，浏览器会自动更新]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存泄漏]]></title>
    <url>%2F2019%2F08%2F30%2FJavaScript%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[定义当已经不需要某块内存时这块内存还存在着 引起内存泄露的情况虽然有垃圾回收机制，但是我们编写代码操作不当还是会造成内存泄漏 1、全局变量原因：全局变量，不会被回收 解决： 使用严格模式避免 使用闭包 使用唯一的全局变量进行管理 2、闭包原因：闭包可以维持函数内局部变量，使其得不到释放 解决： 将 事件处理函数 定义在外部，解除闭包 在定义 事件处理函数 的外部函数中，删除对dom的引用 3、没有清理的DOM元素引用原因：虽然别的地方删除了，但是对象中还存在对dom的引用 解决：手动删除 4、被遗忘的定时器或者回调原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom 解决：手动删除定时器和dom 5、子元素存在引用引起的内存泄漏原因：div 间接引用 li，即使 li 被清空，也还是在内存中，并且只要 li 不被删除，他的父元素如 ul 都不会被删除 解决：手动删除清空]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[作用域作用域.assets]]></title>
    <url>%2F2019%2F08%2F30%2FJavaScript%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域每一个变量、函数都有其作用的范围，超出作用不得使用 作用域链 函数被创建或者被定义的时候，函数对象有一个内部属性 [[scope]]，它引用了一条作用域链，也可以理解为对象列表 在函数 a 创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量 当执行 a函数的时候，会创建一个该函数的执行期上下文的内部对象 当这个执行期上下文被创建时，他的作用域链会被初始化为当前执行的函数对象里的[[scope]]属性中所包含的对象 然后解释器创建一个活动对象，这个活动对象包含当前这个执行函数里所有的局部变量（内部var 声明的），命名参数（形参），参数合集（arguments）以及this 然后此活动对象会被推入执行期上下文里作用域链的前端 当函数执行完毕，该执行期上下文就会被销毁 作用域链的作用 用于解析标识符 函数执行上下文被创建好之后，解释器开始自上至下的解释代码了，这时每遇到一个标示符，都会遍历这个执行上下文里的作用域链 首先在最顶层的活动对象里去找，如果没找到，再找下一层，最终找到全局作用域 如果还没找到一般会报语法错误；但是当对未定义的变量执行赋值运算时，解释器会在全局作用域创建该变量并赋值。这一点很重要，编程时要小心，防止污染全局环境，或者造成内存泄露的问题]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP的阻塞处理]]></title>
    <url>%2F2019%2F08%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FTCP%E7%9A%84%E9%98%BB%E5%A1%9E%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言TCP采用基于窗口的方法进行拥塞控制——闭环控制方法 本篇讨论 出现阻塞的情况 与 解决阻塞情况的办法 拥塞窗口发送方让自己的发送窗口等于拥塞窗口，不是一直都等于：网络情况好的时候，窗口会增大，但是接收方的能力有限，窗口也有个限制 真正的发送窗口值 = Min(公告窗口值，拥塞窗口值) 当发送方发送报文段时，发送方没有在时间间隔内收到接收方的确认报文段，就认为发生了拥塞 控制拥塞窗口的原则 只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率 只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞 阻塞的情况 重传定时器超时 因为现在通信线路传输质量一般都很好，因传输出差错而丢弃分组的概率很小。所以只要出现了超时，可以猜想网络可能出现了拥塞 收到三个相同（重复）的ACK（接收确认） 个别报文段 在网络中丢失，预示可能会出现拥塞，需要尽快采取控制措施，避免拥塞 四种算法 算法 描述 慢开始 主机刚开始发送数据的时候，先探测网络状况，如果网络状况良好，即每次发送的报文段都能正确接收到正确的 确认报文段，那么从小到大增加拥塞窗口，这里是指数增加，比如发送1个，接收到后，就增加到2个，又接收到，增加4个… 拥塞避免 让拥塞窗口缓慢增加，一次只加一个，有加法增大的特点 快重传 接收方收到一个失序报文段，立马发送重复确认，比如收到了M1 M2 M4 M5,没有m3，那么会重复确认M2 3次 快恢复 把慢开始门限设置为发送窗口的一半把拥塞窗口设置成之前拥塞窗口的一半执行拥塞避免算法（加法增大），使拥塞窗口缓慢增大有乘法减小的特点 AIMD 算法 加法增大—AI (Additive Increase) 拥塞避免算法：拥塞窗口是按照线性规律增大的 乘法减小—MD(Multiplicative Decrease) 快恢复算法：当出现超时或3个重复的确认时，就要把拥塞窗口设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值 解决阻塞的方法 重传定时器超时 一般采取的措施是慢开始和拥塞避免算法 一开始是慢开始算法，从1以指数增长(也就是1,2,4,8,16……)增长到慢开始门限，转换为拥塞避免算法(也就是逐步加一17,18,19,20,21….) 如果碰到重传计时器溢出的情况，就立刻把阻塞窗口变成一，然后慢开始门槛变成出现阻塞时候的窗口值的一半 重新执行慢开始和阻塞避免算法 收到三个相同（重复）的ACK（接收确认） 采用快重传和快恢复算法 一开始也是慢开始算法和拥塞避免算法 如果碰到收到三个相同（重复）的ACK（接收确认）的情况， 把慢开始门限设置为发送窗口的一半，拥塞窗口设置成之前拥塞窗口的一半，执行拥塞避免算法（加法增大），使拥塞窗口缓慢增大]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手与四次挥手]]></title>
    <url>%2F2019%2F08%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[前言TCP连接与断开都不是普通的一次牵手、分手，为什么呢？又是怎么牵手、分手的呢？下面探个究竟~ 三次握手机制 第一次握手 主机A 向 主机B 发送一个含有同步序列号（SYN）标志位的数据段，请求建立连接。通过这个数据段，主机A 告诉 主机B：我想与你通信；你可以使用哪个序列号作为起始数据段来回应我 第二次握手 主机B 收到 主机A 的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应 主机A，也告诉 主机A：我已收到请求，你可以传输数据了；你要用序列号作为起始数据段来回应我 第三次握手 主机A 收到数据段后，再发送一个带有确认应答的数据段，确认已收到 主机B 的数据段 三次握手成功，主机A 与 主机B 可以传输数据了 握手的特点 没有应用层的数据 SYN这个标志位只有在TCP建产连接时才会被置1 握手完成后SYN标志位被置0 为什么需要三次握手如果一个连接请求在网络中跑得慢，超时了，这时客户端会重新发出请求，但是这个跑得慢的请求最后还是跑到了，服务端就接收了两个连接请求。客户端收到一个确认后，后面发来的确认就不管了，服务器不知道，就会一直维持着资源，造成浪费 三次握手的话，当服务器收不到客户端的 确认应答ACK 时，就会认为这个 SYN 无效，释放；对客户端的数据传输返回 RST 名词解释 ACK TCP报头的控制位之一，对数据进行确认 确认由目的端发出，用它来告诉发送端这个序列号之前的数据段都收到了。比如：确认号为X,则表示前X-1个数据段都收到了 只有当ACK=1时，确认号才有效；当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性 SYN 同步序列号，TCP建立连接时会将这个位 置1 RST 表重置连接、复位连接 四次挥手 第一次挥手 当 主机A 完成数据传输后，将控制位 FIN 置1，提出停止 TCP 连接的请求 第二次挥手 主机B 收到 FIN 后对其作出相应，确认这一方向的 TCP 连接将关闭，将 ACK 置1 第三次挥手 主机B 再提出反方向的关闭请求，将 FIN 置1 第四次挥手 主机A 对 主机B 的请求进行确认，将 ACK 置1，双方向的关闭结束 为什么需要四次分手TCP是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次 名词解释 FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时，提出断开连接的一方将这位置1]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议 与 UDP协议]]></title>
    <url>%2F2019%2F08%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FTCP%E5%8D%8F%E8%AE%AE%E4%B8%8EUDP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[前言TCP、UDP是OSI模型中运输层中的协议。我们经常使用 ping 命令来测试两台主机之间 TCP/IP 通信是否正常，其实 ping 命令的原理就是 向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的 区别 TCP UDP Transmission Control Protocol 传输控制协议 User Data Protocol 用户数据报协议 面向连接的协议，提供可靠的通信传输 面向无连接的协议，不提供差错恢复、数据重传，安全性差 面向字节流（把数据看成一连串无结构的字节流） 面向报文（发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留报文的边界） 首部开销20字节 首部开销8字节 每一条连接只能是点到点 支持一对一、一对多、多对一和多对多的交互通信 有拥塞控制，可以进行丢包的重发、对次序乱掉的分包进行顺序控制 没有拥塞控制，会导致丢包、包的到达顺序错乱，但网络出现拥塞不会使 源主机 的发送速率降低（对实时应用很有用：IP电话，视频会议等） 应用场景对当前网络通讯质量有要求，需要准确且安全地传输1.浏览器使用的：HTTP 2.QQ文件传输 应用场景对当前网络通讯质量要求不高，又要求网络通讯速度尽量快1.QQ语音 2.QQ视频 3.TFTP TCP的包头结构 源端口 16位 目标端口 16位 序列号 32位 回应序号 32位 TCP头长度 4位 reserved 6位 控制代码 6位 窗口大小 16位 偏移量 16位 校验和 16位 选项 32位(可选) UDP的包头结构 源端口 16位 目的端口 16位 长度 16位 校验和 16位]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI模型 与 TCP/IP模型]]></title>
    <url>%2F2019%2F08%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FOSI%E6%A8%A1%E5%9E%8B%E4%B8%8ETCPIP%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言介绍两大模型与它们的区别 两大模型—详情 OSI（Open System Interconnect），即开放式系统互联 每一层实现各自的功能和协议，并完成与相邻层的接口通信 通信特点：对等通信 为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信。在每一层通信过程中，使用本层自己协议进行通信。 作用 OSI七层模型 TCP/IP四层模型 协议 为用户的应用程序提供 网络服务 应用层 应用层 网络服务协议：HTTP，HTTPS，FTP，POP3、SMTP等 把数据转换为 与 接收者 的 系统格式兼容并适合传输 的 格式 表示层 Telnet, Rlogin, SNMP, Gopher 在数据传输中 设置和维护 两台计算机之间的通信连接 会话层 SMTP, DNS 将下层接收到的数据进行分段和传输，到达目的地址后再进行重组（这一层数据叫做段）使用 TCP 或 UDP 等，为上层协议提供端对端的 可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题（端 指的是 端口号） 传输层 传输层 TCP, UDP IP协议层：通过IP寻址建立两个节点之间的连接，为分组选择合适的路由和交换节点，正确的传送至目的处 网络层 网络层 IP, ICMP, ARP（将IP地址解析成对应的MAC地址）, RARP, AKP, UUCP路由器 将比特组合成字节,再将字节组合成帧决定访问介质的方式差错检测，确保数据的可靠传输 数据链路层 数据链路层 FDDI, Ethernet, Arpanet, PDN, SLIP, PPP交换机 通过物理介质（集线器、中继器、双绞线、同轴电缆等）传输比特流（数模转换与模数转换，由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0） 物理层 IEEE 802.1A, IEEE 802.2到IEEE 802.11 两大模型—关系 OSI先有模型，后有协议。有了标准，再进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型 OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[连接 与 轮询]]></title>
    <url>%2F2019%2F08%2F28%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%BD%AE%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[长连接 与 短连接 长连接 只需要建立一次 Tcp 连接，以后 Http 请求重复使用同一个 Tcp 连接 短连接 每次 Http 请求都会建立一个 Tcp 连接 长连接 与 短连接 长轮询 服务器收到请求后如果有数据, 立刻响应请求 如果没有数据就会 hold 一段时间, 这段时间内如果有数据立刻响应请求 如果时间到了还没有数据, 则响应 http 请求；浏览器受到 Http 响应后会再发送一个同样 Http 请求查询是否有数据 短轮询 服务器收到请求不管是否有数据都直接响应 Http 请求 浏览器受到 Http 响应隔一段时间在发送同样的 Http 请求查询是否有数据 相同点长轮询 和 短轮询都会 hold 一段时间 不同点hold 在服务端还是浏览器端 长轮询在服务端会 hold 一段时间 短轮询在浏览器端 hold 一段时间 应用 长轮询 电商平台的库存更新 朋友圈的im 短轮询 一般用在实时性要求不高的地方, 比如 新浪微薄的未读条数查询就是浏览器端每隔一段时间查询的.]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS-类数组]]></title>
    <url>%2F2019%2F08%2F27%2FJavaScript%2FJS-%E7%B1%BB%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[定义当我们使用document.querySelectorAll(‘p’) （选择指定的css选择器），返回的就是一个类数组 它是一个含使用从0开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象 1234567var array = ['zhangsan', 'lisi', 'zhaoliu'];var arrayLike = &#123; 0: 'zhangsan', 1: 'lisi', 2: 'zhaoliu', length: 3&#125; 与数组的相同之处在数值和长度的读取，自身遍历等方法的用法和数组 相似 与数组的不同之处不存在数组上的操作方法，比如push // arrayLike.push is not a function 如何使用数组的方法通过Function.call Funciton.apply 方法改变this指向 1234567891011var arrayLike = &#123; 0: 'name', 1: 'age', 2: 'sex', length: 3&#125;Array.prototype.join.call(arrayLike, ':'); // name:age:sexArray.prototype.map.call(arrayLike, function(item)&#123; return `$&#123;item&#125;-map`;&#125;);// ["name-map", "age-map", "sex-map"] 怎么 转换成数组slice1Array.prototype.slice.call(arrayLike); // ["name", "age", "sex"] splice1Array.prototype.splice.call(arrayLike, 0); // ["name", "age", "sex"] concat1Array.prototype.concat.apply([], arrayLike) ES6 Array.from1Array.from(arrayLike); // ["name", "age", "sex"] ES6 …运算符作为函数参数的时候可以把arguments转换成数组 123function translateArray(...arguments) &#123; // ...&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS-等于]]></title>
    <url>%2F2019%2F08%2F27%2FJavaScript%2FJS-%E7%AD%89%E4%BA%8E%2F</url>
    <content type="text"><![CDATA[== 和 === 使用 “==”会先把两端的变量试图转换成相同类型，然后再比较值 如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较 “===”会直接去比较类型是否相同，如果类型相同则继续比较值是否相同。 为什么前端开发过程最好严格的控制变量的数据类型 频繁的进行数据类型的转化损耗性能 数据类型影响了可以使用的内置方法，严格控制可以避免使用时 出现方法不存在的情况 对数据类型把控体现了编码人对 业务和业务意义的理解，同时也容易保持前后端变量的数据类型一致。如果使用==，就无法感知到 数据类型和预期有出入]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS-变量声明和函数声明]]></title>
    <url>%2F2019%2F08%2F27%2FJavaScript%2FJS-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[变量声明提前var 声明一个变量，这个变量会被提前到整个函数的顶部，但没有被赋值 123456789101112(function()&#123; console.log(a);//undefined var a ="小钻风"; console.log(a);//小钻风&#125;())(function()&#123; var a; console.log(a);//声明了但未赋值，所以输出undefined； a ="小钻风"; console.log(a);//上一步赋值了，所以输出小钻风&#125;()) 函数声明提前只有函数声明格式的函数才会存在函数声明提前，而函数表达式、构造函数不存在 函数创建的三种写法 函数声明：function fun( a ) { console.log(a) }; (存在函数声明提前) 函数表达式：var fun = function( a ) { console.log(a) }; 构造函数：var fun = new Function( “a”, console.log(a) ); 1234567891011121314151617181920212223242526272829303132333435num()//1console.log(num)//函数本身function num()&#123; console.log(1);&#125;num();//1console.log(num)//函数本身//实际上function num()&#123; console.log(1);&#125;num()//1console.log(num)//函数本身num();//1console.log(num)//函数本身--- 函数表达式的情况 ---num()//报错console.log(num)//undefinedvar num = function ()&#123; console.log(1);&#125;num();//1console.log(num)//函数本身//实际上var num;num()//报错，这时候没有函数声明console.log(num)//undefined，因为已经声明了numnum = function ()&#123; console.log(1);&#125;num();//1，有函数了，可以调用了console.log(num)//函数本身，有函数了 变量声明提前 函数声明提前顺序函数声明比变量声明更提前 1234567891011console.log(a);var a = "孙悟空";function a()&#123; console.log("小钻风"); &#125;//实际上function a()&#123; console.log("小钻风");&#125;var a;//由于上面函数已声明a,相同的变量名声明会被直接忽略console.log(a);//输出函数本体a = "孙悟空";]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[专业名词进行算法分析时，总是从下面三个名词入手 时间复杂度是一个函数，它定性描述了该算法的运行时间 空间复杂度执行这个算法所需要的内存空间 算法的稳定性排序前2个相等的数在序列中的前后位置顺序与排序后它们两个的前后位置顺序相同 不稳定：快速排序，选择排序，堆排序，希尔排序（快选堆希） 稳定：插入排序，冒泡排序，归并排序，基数排序（插冒归基） 总结表格 算法 描述 时间复杂度(最好) 最坏 平均 空间复杂度 稳定性 冒泡排序 在一组数据中，相邻元素依次比较大小， 最大的放后面，最小的冒上来 O(n) O(n2) O(n2) O(1) √ 快速排序 把最左边的数设置为基准，然后把序列中所有比基准数大的数放在它的右边，比基准小的数放在左边 + 算法描述 O(nlog2n) O(n2) O(nlog2n) O(nlog2n) × 选择排序 每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置（和已排序列的最后一个数交换），直到全部待排序的数据元素排完 O(n2) O(n2) O(n2) O(1) × 插入排序 把待排序的记录按其值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 O(n) O(n2) O(n2) O(1) √ 希尔排序 将记录按下标的一定增量分组，对每组使用 直接插入排序算法 排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 O(n) O(n2) O(n1.3) O(1) × 归并排序 利用递归与分治的方法将数据序列划分为越来越小的子区间直到子区间长度为1，再对子区间排序，用递归方法将子区间合并成越来越大的有序序列 nlog2(n) nlog2(n) nlog2(n) O(n) √ 堆排序 利用完全二叉树的结构来维护的一维数组，将 待排序 序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，如此反复执行，便能得到一个有序序列 O(nlog2n) O(nlog2n) O(nlog2n) O(1) × 冒泡排序（Bubble Sort）在一组数据中，相邻元素依次比较大小， 最大的放后面，最小的冒上来 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 时间复杂度 最好的情况：O(n)；如果数据是正序的，只需要走一趟即可完成排序。关键字比较次数 C 和记录移动次数 M 均达到最小值： 1C = n - 1，M = 0 最坏的情况：O(n2)；如果数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1 ≤ i ≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。关键字比较次数 C 和记录移动次数 M 均达到最大值： 12C = n(n-1)/2 = O(n2)M = 3n(n-1)/2 = O(n2) 平均：O(n2) 空间复杂度因为需要一个临时变量用来交换数据位置，所以空间复杂度为O(1) 稳定性稳定。因为如果两个元素相等，并不会交换位置；就算相等的两个元素不相邻，即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变 快速排序（Quick Sort）经典排序：不需要借助其他数组首先把最左边的数设置为基准，然后把序列中所有比基准数大的数放在它的右边，比基准小的数放在左边 算法描述： 从初始序列两端开始探测，用两个变量 哨兵i 哨兵j 分别指向序列的最左和最右 首先哨兵j开始出动，往左移动（j–）直到找到小于基准的数停下来 哨兵i往右移动（i++）直到找到大于基准的数停下来 交换i 和j对应的数，交换成功后，i j继续移动，直到相遇，则探测完毕，将基准数和当前ij所对应的数交换。 此时以旧基准为分界点拆分了两个序列，左边比旧基准小，右边比旧基准大，然后递归左边和右边的序列，即可 12345678910111213141516171819202122232425262728function quicksort(a,left,right)&#123; if(left&gt;right)&#123; //一定要有这个判断，因为有递归left和i-1，若没有这个判断条件，该函数会进入无限死错位递归 return; &#125; var i=left, j=right, jizhun=a[left]; //基准总是取序列开头的元素 while(i!=j)&#123; //该while的功能为每一趟进行的多次比较和交换最终找到位置k。当i==j时意味着找到k位置了 while(a[j]&gt;=jizhun&amp;&amp;i&lt;j)&#123;j--&#125; //只要大于等于基准数，j指针向左移动直到小于基准数才不进入该while。i&lt;j的限制条件也是很重要，不然一直在i!=j这个循环里，j也会越界 while(a[i]&lt;=jizhun&amp;&amp;i&lt;j)&#123;i++&#125; //只要小于等于基准数，i指针向右移动直到大于基准数才不进入该while。等于条件也是必要的，举例[4,7,6,4,3]验证一下是两个4交换 if(i&lt;j)&#123; //如果i==j跳出外层while t=a[i]; a[i]=a[j]; a[j]=t &#125; &#125; a[left]=a[i];//交换基准数和k位置上的数 a[i]=jizhun; quicksort(a,left,i-1); quicksort(a,i+1,right);&#125;var array=[4,7,2,8,3,9,12];quicksort(array,0,array.length-1);//排完序后再看array是[2, 3, 4, 7, 8, 9, 12] 构建左右两个新数组 找基准：以中间项为基准，并把基准从原数组删除 遍历数组，小于基准的放在左数组，大于基准的放在右数组 左右数组递归 12345678910111213141516171819202122function quickSort(arr)&#123; //如果数组&lt;=1,则直接返回 if(arr.length&lt;=1)&#123;return arr;&#125; var pivotIndex=Math.floor(arr.length/2); //找基准，并把基准从原数组删除 var pivot=arr.splice(pivotIndex,1)[0]; //定义左右数组 var left=[]; var right=[]; //比基准小的放在left，比基准大的放在right for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;=pivot)&#123; left.push(arr[i]); &#125; else&#123; right.push(arr[i]); &#125; &#125; //递归 return quickSort(left).concat([pivot],quickSort(right));&#125; 时间复杂度 最好的情况：O(nlog2n)；每一次取到的元素都刚好平分整个数组，也就是说经过log2n趟划分，便可得到长度为1的子表 最坏的情况：O(n2)；每一次取到的元素就是数组中最小/最大的，退化成 冒泡排序 平均：O(nlog2n) 空间复杂度O(nlog2n)：最好的情况下，即每一趟排序都将元素序列均匀地分割成长度相近的两个子表，所需栈的最大深度为log2(n+1)；最坏的情况下，栈的最大深度为n。 稳定性不稳定：比如（5，3A，6，3B），排序后（3B，3A，5，6） 选择排序（Selection Sort）每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置（和已排序列的最后一个数交换），直到全部待排序的数据元素排完 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 时间复杂度 最好/坏/平均：O(n2)；关键字比较次数 永远都是 n(n-1)/2 次，记录移动最少0次，最多3n(n-1)/2次 空间复杂度因为需要一个临时变量用来交换数据位置，所以空间复杂度为O(1) 稳定性不稳定：比如：8 5 8 7 9，第二次外循环8和8的相对顺序就发生了改变,违反了稳定性的定义,故不稳定 插入排序（Insertion Sort）把待排序的记录按其值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 算法描述 从第一个元素开始，该元素可以认为被排序 将下一个元素存到临时变量temp中，然后temp在有序序列中从后往前扫描，如果前面的元素大于temp，则将前一位往后移，直到找到比temp更小的数，把它插进去 1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125; 时间复杂度 最好的情况（已经有序）：O(n) 最坏的情况（每次插入都遍历一遍已经排好序的数组） 外层循环n-1次，内层循环1+2+3+…+(n-2)=(n-2)(n-1)/2次所以最坏情况是O(n^2) 平均： O(n) 空间复杂度因为只有一个辅助变量，所以空间复杂度为O(1) 稳定性稳定，相同元素在排序后不会交换顺序 希尔排序（Shell Sort）将记录按下标的一定增量分组，对每组使用 直接插入排序算法 排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 选择增量gap=length/2，缩小增量继续以gap = gap/2的方式 123456789101112131415function shellSort(arr) &#123; var len = arr.length; for (var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) &#123; for (var i = gap; i &lt; len; i++) &#123; var j = i; var current = arr[i]; while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) &#123; arr[j] = arr[j - gap]; j = j - gap; &#125; arr[j] = current; &#125; &#125; return arr;&#125; 时间复杂度 最好的情况：O(n) 最坏的情况：使用希尔增量 时，O(n2) 平均：使用 Hibbard 增量时，O(n1.3) 这个现在还不确定，取决去选择什么增量 空间复杂度因为只有一个辅助变量，所以空间复杂度为O(1) 稳定性不稳定：两个相同的元素会分到不同的组，进行直接插入排序 归并排序（Merge Sort）利用递归与分治的方法将数据序列划分为越来越小的子区间直到子区间长度为1，再对子区间排序，用递归方法将子区间合并成越来越大的有序序列。 排序采用了一个新的数组，通过比较两个不同的区间的值，按序放入新数组，然后返回新数组 123456789101112131415161718192021222324252627282930function mergeSort(arr) &#123; var len = arr.length; if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125; function merge(left, right) &#123; var result = []; while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125;else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 时间复杂度最好最坏平均：nlog2(n)；原数组长度为n，则细分得最大深度为log2(n)，每一层需要排序的元素为n。不管元素在什么情况下都要做这些步骤，所以最好最坏平均花销的时间是不变的 空间复杂度O(n)：需要一个与原数组相同长度的数组做辅助 稳定性稳定：交换元素时，可以在相等情况下做出不移动的限制 堆排序利用完全二叉树的结构来维护的一维数组，将 待排序 序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，如此反复执行，便能得到一个有序序列 完全二叉树：除了最后一层之外，其他的每一层都被填满，并且所有节点都保持左对齐 堆的特点 左子节点位置 = 当前父节点的两倍 + 1，右子节点位置 = 当前父节点的两倍 + 2 大顶堆（升序）：每个结点的值都大于或等于其左右孩子结点的值 arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] 小顶堆（降序）：每个结点的值都小于或等于其左右孩子结点的值 arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] 具体图解：https://www.cnblogs.com/lanhaicode/p/10546257.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;void Swap(int *heap, int len); /* 交换根节点和数组末尾元素的值 */void BuildMaxHeap(int *heap, int len);/* 构建大顶堆 */int main()&#123; int a[6] = &#123;7, 3, 8, 5, 1, 2&#125;; int len = 6; /* 数组长度 */ int i; for (i = len; i &gt; 0; i--) &#123; BuildMaxHeap(a, i); Swap(a, i); &#125; for (i = 0; i &lt; len; i++) &#123; printf("%d ", a[i]); &#125; return 0;&#125;/* Function: 构建大顶堆 */void BuildMaxHeap(int *heap, int len)&#123; int i; int temp; for (i = len/2-1; i &gt;= 0; i--) &#123; if ((2*i+1) &lt; len &amp;&amp; heap[i] &lt; heap[2*i+1]) /* 根节点大于左子树 */ &#123; temp = heap[i]; heap[i] = heap[2*i+1]; heap[2*i+1] = temp; /* 检查交换后的左子树是否满足大顶堆性质 如果不满足 则重新调整子树结构 */ if ((2*(2*i+1)+1 &lt; len &amp;&amp; heap[2*i+1] &lt; heap[2*(2*i+1)+1]) || (2*(2*i+1)+2 &lt; len &amp;&amp; heap[2*i+1] &lt; heap[2*(2*i+1)+2])) &#123; BuildMaxHeap(heap, len); &#125; &#125; if ((2*i+2) &lt; len &amp;&amp; heap[i] &lt; heap[2*i+2]) /* 根节点大于右子树 */ &#123; temp = heap[i]; heap[i] = heap[2*i+2]; heap[2*i+2] = temp; /* 检查交换后的右子树是否满足大顶堆性质 如果不满足 则重新调整子树结构 */ if ((2*(2*i+2)+1 &lt; len &amp;&amp; heap[2*i+2] &lt; heap[2*(2*i+2)+1]) || (2*(2*i+2)+2 &lt; len &amp;&amp; heap[2*i+2] &lt; heap[2*(2*i+2)+2])) &#123; BuildMaxHeap(heap, len); &#125; &#125; &#125;&#125;/* Function: 交换交换根节点和数组末尾元素的值*/void Swap(int *heap, int len)&#123; int temp; temp = heap[0]; heap[0] = heap[len-1]; heap[len-1] = temp;&#125; 时间复杂度最好最坏平均：O(nlog2n)；共进行n-1次交换，所需操作数为n-1，并且需要对新的根节点进行下沉操作，所需操作数为3(n-1)log2n。综上，该过程所需操作数为n-1 + 3(n-1)log2n = (n-1)(3log2n + 1) 空间复杂度O(1)：借助一个辅助空间来交换元素 稳定性不稳定：因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Next7.x升级及相关配置]]></title>
    <url>%2F2019%2F08%2F24%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2FNext7.x%E5%8D%87%E7%BA%A7%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言本想只给博客开个 评论 功能，查询了一些教程文章后发现，现在已经是Hexo v3.9、Next v7.x了，对应的，可能现在比较流行的插件并不兼容之前的旧版本，便索性升级博客，嵌入评价、浏览数、运行时间等插件，也根据自己的风格调整了页面样式 主题升级去 Next 代码仓库中，下载最新包，千万别覆盖了之前的包。除了需要在 站点配置文件 修改主题名字，还需要修改语言类型： language: zh-CN 其他的可对照着之前包的 主题配置文件 进行修改，注意有一些插件是不用了或者升级了，要做相应的更改 样式更改 字体更改，可在 \source\css_variables\base.styl 查询 font 相关进行更改 最简单的方法是，在 开发者模式 下调整样式，然后在代码中查找对应 类名 ，进行修改 开启站点内容搜索 安装 hexo-generator-searchdb 插件 1npm install hexo-generator-searchdb --save 在 站点配置文件 添加 12345search: path: search.xml field: post format: html limit: 10000 将 主题配置文件 的 local_search enable设置为true 开启评论因为其他评论系统已经下线或者是外国网站，选择了简单的valine 打开 主题配置文件，将 valine enable设置为true 前往 leancloud 注册账号，注册应用，名字随意 进入应用设置，复制 appid、appkey，粘贴到 主题配置文件 valine 的对应文字 如需邮件通知功能，把 valine 的 notify 设置成 true 默认的样式有点丑，可以在 \source\css_variables\base.styl 里覆盖样式，需要 !important 置顶文章 安装 hexo-generator-index-pin-top 插件 12npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save 在需要置顶的文章，添加 top: true/数字 1234567title: XXXtags: - XXXcategories: - XXXdate: XXXtop: 100 可添加自定义置顶样式， 在 /layout/_macro/post.swig 下方添加 123456789&#123;% if post.top %&#125; &lt;span class="post-meta-item"&gt; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-thumb-tack"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="post-meta-item-text" style="font-weight: bold;"&gt;置顶&lt;/span&gt; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt; &lt;/span&gt; &#123;% endif %&#125; 显示页脚访客统计 打开 主题配置文件 ，讲 busuanzi_count entable设置为 true 在 /layout/_partials/analytics/busuanzi-counter.swig 增加以下文本标记 123456789101112131415161718192021222324252627&#123;% if theme.busuanzi_count.enable %&#125;&lt;div class="busuanzi-count"&gt;&lt;script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&#123;% if theme.busuanzi_count.total_visitors %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt; &amp;nbsp;本站访客数&amp;nbsp;&lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.busuanzi_count.total_visitors and theme.busuanzi_count.total_views %&#125; &lt;span class="post-meta-divider"&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.busuanzi_count.total_views %&#125; &lt;span class="post-meta-item-icon"&gt; &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt; &amp;nbsp;本站总访问量&amp;nbsp;&lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt; &lt;/span&gt;&#123;% endif %&#125;&lt;/div&gt;&#123;% endif %&#125; 显示字数统计、阅读时长 安装 hexo-symbols-count-time 插件 12npm install hexo-symbols-count-time --savenpm install eslint --save 在 站点配置文件 添加 123456symbols_count_time: symbols: true # 文章字数统计 time: true # 文章阅读时长 total_symbols: true # 站点总字数统计 total_time: true # 站点总阅读时长 exclude_codeblock: false # 排除代码字数统计 默认是没有 中文提示 的，如需增加，前往 \themes\next\layout_partials\footer.swig 修改 显示页脚运行时间 在 \themes\next\layout_partials\footer.swig 增加 123456789101112131415161718192021222324252627282930313233343536373839404142&#123;%- if config.symbols_count_time.total_time %&#125;--- 增加 ---&lt;div id="sitetime"&gt;&lt;/div&gt;&lt;script language=javascript&gt; function siteTime()&#123; window.setTimeout("siteTime()", 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2017,08,12,15,15,47); //建站时间 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒"; &#125; siteTime();&lt;/script&gt;--- 增加 ---&#123;%- if theme.footer.powered.enable %&#125; 阅读全文 在文章加 修改 主题配置文件 -&gt; auto_excerpt -&gt; length 404页面原来小小的举动也可以为公益事业献出自己的一份爱心，何乐而不为呢？ -新建 404.html 页面，放到主题的 source 目录下 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码高亮之前一直好奇为啥代码区域没有高亮，原来是忘了设置语言类型 手动设置 代码设置 1​```js 去掉文章目录标题 修改 主题配置文件 -&gt; toc -&gt; number: false 控制页面文章数目 修改 站点配置文件 -&gt; index_generator -&gt; per_page]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-BY与HAVING]]></title>
    <url>%2F2019%2F08%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL-BY%E4%B8%8EHAVING%2F</url>
    <content type="text"><![CDATA[前言虽然都是BY，都是表条件（HAVING WHERE），它们有什么不同呢？？ ORDER BY / GROUP BY 区别ORDER BY 行的排序（ASC正序，DESC倒序） 非常通俗易懂，ORDER BY 列名，就会返回列的顺/倒序排列 GROUP BY 分组 不是行的排序！不是行的排序！不是行的排序！ 必须与聚合函数一起用（sum()、count()、avg()等） 探究为啥必须与聚合函数一起用？1234567891011121314SELECT customer FROM Orders ORDER BY customer返回customer列，不包括重复行SELECT customer，priceFROM Orders ORDER BY customer报错：把customer相同的元素聚合在一起，那么price就没有意义了SELECT customer，SUM(price)FROM Orders ORDER BY customer此时把customer相同的元素聚合在一起，SUM(price)为聚合元素的总数 聚合函数必须搭配GROUP BY吗？1SELECT Customer,SUM(OrderPrice) FROM Orders 注意ORDER BY 要写在 GROUP BY 后面，对分组后的数据进行排序 Customer SUM(OrderPrice) Bush 5700 Carter 5700 Bush 5700 Bush 5700 Adams 5700 Carter 5700 因为指定了两列，分别返回了结果，Customer返回表中的所有行，SUM(OrderPrice)返回一个值，不能得到正确的答案。所以咱们必须后面加个GROUP BY，分组计算。 HAVINGWHERE后面不能接聚合函数，以下写法会报错： 1234SELECT product,sum(price) FROM orders WHERE sum(price)&gt;100GROUP BY product 原因：聚合函数是针对结果集进行处理，而WHERE子句执行时结果集还没出来 解决： 对聚合函数限制条件时，需要写在 HAVING 后面；且 HAVING 只能在 GROUP BY 后面，对分组后的结果进行筛选 综合使用如果一个查询语句同时出现 WHERE、GROUP BY、HAVING、ORDER BY时，编写和执行顺序： 用 WHERE 进行初步筛选，返回第 1 个结果集 第 1 个结果集使用 GROUP BY 分组，返回第 2 个结果集 第 2 个结果集使用 HAVING 进行筛选，返回第 3 个结果集 第 3 个结果集使用 ORDER BY 排序 123456SELECT product,sum(price) FORM orders WHERE product='Bush'GROUP BY product HAVING sum(price)&gt;100 ORDER BY sum(price)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-函数]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[前言整理函数表，方便查询~ 函数表 函数名 语法 描述 AVG(列名) SELECT AVG(column_name) FROM table_name 平均值 COUNT(列名) SELECT COUNT(*) FROM table_nameSELECT COUNT(column_name) FROM table_nameSELECT COUNT(DISTINCT column_name) FROM table_name 匹配条件的行数 FIRST(列名) SELECT FIRST(column_name) FROM table_name 第一条记录 LAST(列名) SELECT LAST(column_name) FROM table_name 最后一条记录 MAX(列名) SELECT MAX(column_name) FROM table_name 最大值 MIN(列名) SELECT MIN(column_name) FROM table_name 最小值 SUM(列名) SELECT SUM(column_name) FROM table_name 总数 UCASE(列名) SELECT UCASE(column_name) FROM table_name 大写 LCASE(列名) SELECT LCASE(column_name) FROM table_name 小写 MID(列名，开始位置，返回字符数) SELECT MID(column_name,start[,length]) FROM table_name 从文本字段中提取字符 LEN(列名) SELECT LEN(column_name) FROM table_name 文本字段中值的长度 ROUND(列名，指定小数位数) SELECT ROUND(column_name,decimals) FROM table_name 返回指定小树位数的数值 NOW()GETDATE() SELECT NOW() FROM table_name //MySqlSELECT GETDATE() FROM table_name //Sql Server 当前日期和时间 FORMAT(列名) NULL 函数如果某列是可选时，为空的数据值为NULL。但是NULL不等于0，我们并不好处理。所以可以使用NULL函数，转换成数字，再来处理。不同的数据库中NULL函数的表示不同，但用法相同 12SELECT ProductName,UnitPrice*(UnitsInStock+ISNULL(UnitsOnOrder,0))FROM Products SQL Server / MS Access —— ISNULL() Oracle —— NVL() MySQL —— IFNULL()， COALESCE() Date 函数注意以下查询是得不到结果的 OrderId ProductName OrderDate 1 computer 2008-12-26 16:23:55 1SELECT * FROM Orders WHERE OrderDate='2008-12-26' 因为查询中不含有时间部分的日期]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-进阶语法知识]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前言此篇为一些子句 / 字段等进阶知识拓展 TOP 子句(规定返回数据的数目)12SELECT TOP number|percent 列名称 FROM 表名称 Alias 别名1234567表的别名SELECT 别名.列名FROM 表名 AS 别名列的别名SELECT 列名 AS 别名FROM 表名 JOIN 连接 连接两个或多个表中列之间的关系 区别 INNER JOIN ===JOIN LEFT JOIN RIGHT JOIN FULL JOIN 描述 内连接；返回表中所有匹配条件的行 返回左表的全部行和右表匹配条件的行，如果左表的行并不匹配条件，则这一行的右表对应数据用NULL代替 返回右表的全部行和左表匹配条件的行，如果右表的行并不匹配条件，则这一行的左表对应数据用NULL代替 返回左表和右表所有的行，如果其中一个表的数据行在另一个表中没有匹配的行，那么对应的数据用NULL代替 语法 SELECT * FROM Table AINNER JOIN Table BON Table A.id = Table B.id SELECT * FROM Table ALEFT JOIN Table BON Table A.id = Table B.id SELECT * FROM Table ARIGHT JOIN Table BON Table A.id = Table B.id SELECT * FROM Table AFULL JOIN Table BON Table A.id = Table B.id UNION 与 UNION ALL 合并 用于合并两个或多个 SELECT语句 的结果集 UNION 会选取不同的值（没有重复） UNION ALL 会选取全部的值（有重复） 123456789SELECT column_name(s) FROM table_name1UNIONSELECT column_name(s) FROM table_name2SELECT column_name(s) FROM table_name1UNION ALLSELECT column_name(s) FROM table_name2// UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 SELECT INTO 备份 / 记录存档表的备份123SELECT * INTO 新表名 [IN 数据库名]FROM 旧表名 对记录进行存档123SELECT 列名INTO 新表名 [IN 数据库名]FROM 旧表名 NULL 字段 未知的或不适用的值的占位符 NULL 不等于 0 我们在选择数据的时候，可以使用 IS NULL 或者 IS NOT NULL 选择为空或不为空的数据 AUTO INCREMENT 字段 每次插入新纪录，自动地创建主键字段的值 默认地，开始值为1，每条新纪录递增1；可以自定义开始值 MySQL 语法12345678CREATE TABLE Persons(P_Id int NOT NULL AUTO_INCREMENT,PRIMARY KEY (P_Id))自定义起始值ALTER TABLE Persons AUTO_INCREMENT=100 SQL Server 语法1234CREATE TABLE Persons(P_Id int PRIMARY KEY IDENTITY) Constraints 约束 限制加入表的数据的类型 可以在创建表时加(CREATE TABLE)，也可以创建后加约束(ALTER TABLE) NOT NULL 强制 列 不接受 NULL 值 12345CREATE TABLE Persons(id int NOT NULL,city varchar(255)) UNIQUE / PRIMARY KEY / FOREIGN KEY它们在语法上其实差不多，又都有数据库之间的区别，所以并在一起，方便记忆与对比 UNIQUE 唯一标识数据库表中的每条记录 与 PRIMARY KEY 约为列或列集合提供了唯一性的保证 每个表可以有多个 UNIQUE 约束，只能有一个 PRIMARY KEY 约束 PRIMARY KEY 拥有自动定义的 UNIQUE 约束 主键必须包含唯一的值 主键列不能包含NULL值 每个表必须有且只能有一个主键 FOREIGN KEY 外键 一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY 作用 预防破坏表之间连接的动作 防止非法数据插入外键列 MySQL 语法 SQL / Oracle / MS Access 创建（不同） CREATE TABLE Persons(Id_P int NOT NULL,UNIQUE (Id_P) // 标识PRIMARY KEY (id_P) // 主键PRIMARY KEY (Id_O), // 外键FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)) CREATE TABLE Persons(Id_P int NOT NULL UNIQUE // 标识Id_P int NOT NULL PRIMARY KEY // 主键Id_O int NOT NULL PRIMARY KEY, // 外键Id_P int NOT NULL FOREIGN KEY REFERENCES Persons(Id_P)) 修改 ALTER TABLE PersonsADD UNIQUE (Id_P) // 标识ADD PRIMARY KEY (Id_P) // 主键ADD FOREIGN KEY (Id_P) // 外键REFERENCES Persons(Id_P) 撤销 ALTER TABLE OrdersDROP INDEX uc_PersonID // 标识DROP PRIMARY KEY //主键DROP FOREIGN KEY fk_PerOrders // 外键 创建：多个列的约束，并命名 CREATE TABLE Persons(Id_P int NOT NULL,LastName varchar(255) NOT NULL,CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName) // 标识CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,LastName) // 主键PRIMARY KEY (Id_O), // 外键CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)REFERENCES Persons(Id_P)) 修改：多个列的约束，并命名 ALTER TABLE PersonsADD CONSTRAINT uc_PersonID UNIQUE (Id_P,lastName) // 标识ADD CONSTRAINT pk_PersonID PRIMARY KEY (Id_P,lastName) // 主键ADD CONSTRAINT fk_PerOrders // 外键FOREIGN KEY (Id_P)REFERENCES Persons(Id_P) 撤销：多个列的约束，并命名 ALTER TABLE OrdersDROP CONSTRAINT uc_PersonID // 标识DROP CONSTRAINT PRIMARY KEY //主键DROP CONSTRAINT fk_PerOrders // 外键 CHECK 限制列中的值的范围 MySQL SQL / Oracle / MS Access 创建 CREATE TABLE Persons(Id_P int NOT NULL,CHECK (Id_P&gt;0))CREATE TABLE Persons(Id_P int NOT NULL,City varchar(255),CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=’Sandnes’)) CREATE TABLE Persons(Id_P int NOT NULL CHECK (Id_P&gt;0),)CREATE TABLE Persons(Id_P int NOT NULL,City varchar(255),CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=’Sandnes’)) 修改 ALTER TABLE PersonsADD CHECK (Id_P&gt;0)ALTER TABLE PersonsADD CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=’Sandnes’) 撤销 ALTER TABLE PersonsDROP CHECK chk_Person ALTER TABLE PersonsDROP CONSTRAINT chk_Person DEFAULT 默认值 插入默认值 MySQL SQL / Oracle / MS Access 创建 CREATE TABLE Persons(Id_P int NOT NULL,City varchar(255) DEFAULT ‘Sandnes’) 修改 ALTER TABLE PersonsALTER City SET DEFAULT ‘SANDNES’ ALTER TABLE PersonsALTER COLUMN City SET DEFAULT ‘SANDNES’ 撤销 ALTER TABLE PersonsALTER City DROP DEFAULT ALTER TABLE PersonsALTER COLUMN City DROP DEFAULT 服务器 DBMS - 数据库管理系统（Database Management System） RDBMS - 关系数据库管理系统（Relational Database Management System） 区别 DBMS RDBMS 将数据存储为文件，容易出现数据冗余 将数据存储在表中，每个表中有一个主键作为唯一标识符 数据以导航或分层形式存储，每个数据单元通常具有父节点和一个或多个子节点。对于大量复杂的数据，访问数据速度较慢 数据之间的关系以表格形式存储，所以数据更容易地访问，存储在系统中的数据在逻辑上和物理上也是独立的。 不支持 支持数据完整性、高级查询能力、数据库安全性和结构独立性 是DBMS的增强版本；RDBMS 是 SQL 的基础，现代的 SQL 服务器构建在 RDBMS 之上]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-简单操作语法]]></title>
    <url>%2F2019%2F08%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL-%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言希望有一个简单明了，忘记即查即记起的sql笔记，因为sql基础知识其实挺细挺多的，为了不混淆，分3部分进行梳理。 又引申了一个思考：虽然很多知识网上确实总结了许多，还很不一样，但是要变成自己的知识，当然不能简单的复制粘贴，而且也不一定某个人的总结就是对的，需要多次查阅，进行比较。用自己的语言进行复述，梳理，往后直接查阅笔记就省了很多猜疑与困惑的点。 介绍 SQL —— Structured Query Language（结构化查询语句） 数据库上执行的大部分工作都由SQL语句完成 SQL对大小写不敏感 SQL由DDL( 数据定义语言 )与DML( 数据操作语言 )组成 DDL —— 数据定义语言 创建数据库 / 表 / 索引（搜索键）/ 视图 CREATE DATABASE / TABLE / INDEX / VIEW 修改数据库 / 表 ALTER DATABASE / TABLE 删除数据库 / 表 / 索引（搜索键）/ 视图 DROP DATABASE / TABLE / INDEX / VIEW CREATE TABLE 创建表1234567CREATE TABLE 表名称(列名称1 数据类型,列名称2 数据类型,列名称3 数据类型,....) 数据类型 数据类型 描述 int(size) 整型 decimal(size, d) numeric(size, d) 小数 char(size) 字符串 varchar(size) 可变字符串 date(yyyymmdd) 日期 CREATE INDEX 创建索引 用户看不到索引，索引只能加快搜索 / 查询 在不读取整个表的情况下，使用索引可以更快地查找数据 更新一个包含索引的表 比 更新没有索引的表更多时间，因为索引也要更新；所以最好在需要常常被搜索的列或表上创建索引 1234567允许使用重复的值CREATE INDEX 索引名ON 表名 (列名 [ASC, DESC]) 不能重复，唯一索引CREATE UNIQUE INDEX 索引名ON 表名 (列名 [ASC, DESC]) CREATE VIEW 创建视图 把结果集定义成另一个表，可以更精确地处理我们想要的数据 1234CREATE VIEW 视图名 ASSELECT 列名FROM 表格名WHERE condition ALTER 修改添加列12ALTER TABLE 表名ADD 列名 数据类型 删除列12ALTER TABLE 表名DROP COLUMN 列名 修改列的数据类型12ALTER TABLE 表名ALTER COLUMN 列名 数据类型 DROP 撤销删除索引12ALTER TABLE 表名 DROP INDEX 索引名 删除表 / 数据库123DROP TABLE 表名DROP DATABASE 数据库名 不删除表，只清空数据1TRUNCATE TABLE 表名 DML —— 数据操作语言 SELECT 选取 UPDATE 更新 DELETE 删除 INSERT INTO 插入 SELECT 语句(选取)123456789SELECT 列名称 FROM 表名称SELECT * FROM 表名称关键词 DISTINCT 返回不重复行的列数据SELECT DISTINCT 列名称 FROM 表名称 WHERE 子句(条件)123SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 操作符 操作符 描述 = 等于 &lt;&gt; 或 != 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN… AND 在某个范围内，可以是数值、文本或日期；如果在范围外，只需要在BETWEEN前加NOT操作符 LIKE 搜索某种模式(使用通配符) AND &amp; OR 基于一个以上的条件对记录进行过滤 IN 规定多个值: WHERE 列名称 IN (值1, 值2…) 通配符 SQL通配符可以替代一个或多个字符，必须与LIKE运算符一起使用 通配符 描述 % 替代一个或多个字符 _ 仅替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist]或[!charlist] 不在字符列中的任何单一字符 ORDER BY 子句(排序) 对结果集进行排序 ASC 升序 默认 DESC 降序 注意 如果第一列中有相同值的行或者值为null，后面会以升序排列（如规定了倒序就是倒序） 123SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC Company OrderNumber W3School 2356 W3School 6953 IBM 3532 Apple 4698 UPDATE 语句(修改)123UPDATE 表名称 SET 列名称 = 新值, 新列名称 = 新值WHERE 列名称 = 某值 DELETE 语句(删除)1234567删除表中的行DELETE FROM 表名称 WHERE 列名称 = 值删除所有行DELECT FROM 表名称DELECT * FROM 表名称 INSERT INTO 语句(插入)12345INSERT INTO 表名称 VALUES (值1, 值2,....)INSERT INTO 表名称 (列1, 列2,...) VALUES (值1, 值2,....)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蘑菇街实习感悟]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F%E8%98%91%E8%8F%87%E8%A1%97%E5%AE%9E%E4%B9%A0%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[前言从5.23 ~ 8.13(中间回去考试10天)历时2个多月的杭州实习，对从没有在外省生活那么长时间的自己确实是一次不可思议的有趣经历。为了不让远离家乡、暂无定居的自己感到太大的孤单，为自己安排了很多事情，趁着最近刚好进行实习后期总结，也记录下这次的‘夏日探险’。 吃住行虽然没有完全经济独立，但是绝大部分的生活还是靠自己的实习工资支撑。为了能挤出钱来做自己想做的事情，选择了火车🚆和住青旅。火车也试过好几次硬座，还是硬卧比较舒服，摇摇晃晃，一首 火车驶向云外，梦安魂与九霄 很是应景。 青旅在杭州也不算便宜，但却是最省事的：不用关注水电、租金、卫生；房客也是和我一样的长住生。唯二不太喜欢的就是公用厕所和白天不开空调(炒鸡闷热)。By the way，都是能够忍受的~ 自律不得不说，这次实习最大的收获应该就是 自律。不是简单地两点一线，而是更严格地要求自己。 每天早起一小时，就可以有多一个小时的时间对实习工作进行总结、深入学习；白天的学习可比晚上的要有效率多了，不得不说白天的工作还是蛮耗精力滴，下班后只想让自己放松紧张的头脑和紧绷的肌肉。 晚上进行1个半小时左右的健身和拉伸，一周保底5次。虽然是青旅，但是房间空间还蛮大的，运动也不会很大幅度，主要是b站的塑性运动，拉伸完后整个人神清气爽，仿佛得到了升华，这大概就是平凡中的小幸福了吧。 周末如果有学习任务，会选择泡馆，杭州图书馆蛮大蛮舒服，大家都齐刷刷地沉浸在自己的学习世界里，成为里面的一份子也会收获到小快乐；或者出去旅游，背上书包：在市内探索、在武汉探索、在东极岛探索、在上海探索、在苏州探索…旅游途中的风景不同于以往生活所固在的地方，很新奇很新鲜，探索的乐趣实在太迷人了，不管是和盆友们还是自己，都想永远在路上。 工作这两个多月的工作主要围绕： 线上Bug：诸如容错、控制台报错、打点、优化… 独立页面的开发：h5评价页面、头条小程序收藏页面 虽说每个需求看起来还挺小的，但是在实际开发中，因项目中使用的是公司自己的轮子、自己的组件，有自己的一套发布系统。每个项目run的流程，发布的流程不一样，所以每次接到一个小需求就得重新熟悉对应的（h5、pc、各种小程序…）开发流程、发布流程。不过经过项目的积累，以及自己总结，后面也逐渐掌握技巧，可以更快的投入需求开发中。 另外，在开发需求前还需要进行业务上的沟通：要了解业务是怎样的、站在自己的角度上思考需求是否合理、代码上能否方便实现、排期…当然这个沟通对象不只是和产品，还可能是后端、设计等参与到业务开发的小伙伴们。所以也有一部分时间花在这上面，但是这种时间是必须花费的，好的沟通能够大幅度提高开发的效率以及避免不必要的后续埋坑。 在开发中，因为很多时候都在别人的代码基础上进行填坑、优化，所以开发前需要整理代码的功能框架：知道整个项目框架是如何的、哪个页面对应哪个Html、自己需要在哪个地方进行开发…有一个清晰的思路，并且做好项目文档，沉淀，方便后续能够更快地投入开发。 在前辈代码上开发，有利有弊，弊是得从头梳理代码，假如对方的代码很复杂或者个人风格十分强烈，对自己的阅读及开发是会造成很大阻拦的。利是可以学习到好的代码规范、简单的代码写法，如遇到自己从未试过的写法const {MWP} = M; 需要去了解里面的原理，而不是只知道可以这么写，而是要知道为什么可以这么写。 自我评价 业务能力不错，可以较快的完成业务，保质保量，且进行风险评估减低线上bug出现的可能性。 自律。提前一小时到公司，进行对之前自己遇到的一些问题解惑以及对学到的东西总结。晚上健身拉伸，做手账（主要是工作上或学习上的点，好看的手账在以后的翻阅中比日报看起来舒服多了，也很有成就感~） 小笔记：当天遇到啥任务或者学习了啥都会写在小本本上，这是之前就养成的习惯（因为有时事情多了，心情不好了，老忘事；也方便查阅）小笔记也在现在的日报中发挥了重要作用~ 好问。经常会有不懂的地方，比如模板管理平台，git rebase/merge区别，dns裁剪等等项目中遇到的问题，虽然以前略有所闻，但是实际开发中一使用就想不通了，当然是查阅了资料带着疑惑问问题，也超级感谢各种学长学姐耐心为我答疑，收获很多~ 喜欢思考。最近看到克瑞的fan组件，觉得还蛮厉害的，在重复工作中，总结整理出一套可以减轻自己重复工作提高效率的组件，也方便大家的工作，这样对团队工作做出贡献的工作者实在太棒了，希望自己以后也能在工作中可以有所贡献，或技术或内容。 成长与收获 技术 React、Vue 微信/头条/百度小程序 Linux命令 Es6 Git（多人合作） 项目 编码规范 按照公司规定的编码规范书写，改正自己之前不良的编码规范，好的编码风格可以很方便后续伙伴们的交接；自己也总结出一套比较优雅的编码规范，但实际开发中，如果是在前人代码上改或者与他人合作，还是需要统一编码规范的。 合理排期 留出buffer，因为实际开发过程中会有很多其他的事情：比如线上紧急bugger需要处理，其他活动要求等，打碎自己的开发时间。在排期时，需要充分留出缓冲的时间。想起老大说，排期也是一种能力，尽管你最终可以完成业务需求，但是延期了，就是能力不足的表现。 注意兜底/容错 发现很多线上问题，都是之前没有考虑到容错。比如传过来是空数组或者undefined，没有做一个容错，就很可能页面崩了。 风险评估 及时向项目负责人抛出风险，降低后续开发时踩坑的可能性。 好习惯 开发前熟悉业务、代码、开发流程 提高效率 开发时，整理并总结出项目文档，技术难题 沉淀 不足与改进 表达需要更清晰 业务沟通需更加重视 前端工作不能只是负责好自己那块就好了，要时时跟进，主动跟进，比如后端接口，产品对接…都需要自己一步步跟进，落实。（ps:大家都挺忙的，一不留神就有可能把自己给忘了…要鼓起勇气跟进！） 要更关注底层原理 开发时偶尔遇到一些问题，查了很久才发现原来只是一个技术底层的问题，需要了解它背后的原理，做好记录，提高开发的效率。 未来期望 业务拓展，主动接触团队中的其他业务 如果有需求就可以尽快投入开发当中啦。 主动了解所使用的组件原理（不做无脑伸手党） 在使用过程中遇到问题时，思考是组件本身的问题，还是自己代码的问题，不要一碰到问题就去问组件开发维护者。 对团队工作有所贡献（组件、优秀代码…） 不局限前端（感受技术的乐趣）]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>蘑菇街</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现图片懒加载]]></title>
    <url>%2F2019%2F08%2F09%2FJavaScript%2F%E5%8E%9F%E7%94%9FJS%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前言在项目中有一个图片懒加载的需求，因为轮子无法满足老版本的react，所以手动写了一个，顺便对比几种方法 实现原理无论哪种方法，原理都是 图片Img标签自定义属性data-src来存放真实的地址 当滚动时，检查所有img标签，是否出现在视野范围内与是否已加载，如果出现在视野范围内与未加载，则加载图片。 方法1：offsetTop-scroolTop&lt;clientHeight element.offsetTop //获取元素相对于文档顶部的高度 element.scrollTop //滚动条滚动的距离 element.clientHeight //获取屏幕可视区域的高度 offsetTop-scroolTop&lt;clientHeight，则图片进入了可视区内 方法2：getBoundingClientRect()通过getBoundingClientRect()方法来获取元素的大小以及位置，它会返回一个名为ClientRect的DOMRect对象，包含了top、right、botton、left、width、height这些值。 bound.top(获取图片到可视区顶部的距离) &lt;= clientHeight(可视区高度) ，则图片进入了可视区内 方法3：IntersectionObserver新的API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持 注意IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。 规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。 12345678基本用法：var io = new IntersectionObserver(callback, option);// 开始观察io.observe(document.getElementById('example'));// 停止观察io.unobserve(element);// 关闭观察器io.disconnect(); 详细用法，参见阮一峰大大：http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html 我们需要用到callback的intersectionRatio属性(目标元素的可见比例)来判断是否在可视区域内，当intersectionRatio &gt; 0 &amp;&amp; intersectionRatio &lt;= 1,则图片进入了可视区内 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687window.addEventListener('scroll', this.throttle(this.checkScroll));throttle(fn, mustRun = 300)&#123; const timer = null; let previous = null; return function() &#123; const now = new Date(); const context = this; const args = arguments; if (!previous)&#123; previous = now; &#125; const remaining = now - previous; if (mustRun &amp;&amp; remaining &gt;= mustRun) &#123; fn.apply(context, args); previous = now; &#125; &#125;&#125;,//检查图片是否在可视区内，如果不在，则加载checkScroll()&#123; let scrollImages = document.querySelectorAll('img'); let self = this; Array.from(scrollImages).forEach(function(el)&#123; if(self.isIn(el) &amp;&amp; !self.isLoaded(el))&#123; self.loadImg(el); &#125; &#125;)&#125;,//方法1：offsetTop-scroolTop&lt;clientHeight，表示图片已进入可视区isIn(el)&#123; var H = document.documentElement.clientHeight;//获取可视区域高度 var S = document.documentElement.scrollTop || document.body.scrollTop; return H + S &gt; getTop(el);&#125;//offsetTop是元素与offsetParent的距离，循环获取直到页面顶部getTop(el)&#123; var T = e.offsetTop; while(e = e.offsetParent) &#123; T += e.offsetTop; &#125; return T;&#125; //方法2：用来判断bound.top&lt;=clientHeight的函数，返回一个bool值isIn(el)&#123; var bound = el.getBoundingClientRect(); var clientHeight = window.innerHeight; return bound.top &lt;= clientHeight;&#125;, //方法3：IntersectionObserverisIn(el)&#123; const io = new IntersectionObserver(ioes =&gt; &#123; let self = this; ioes.forEach(ioe =&gt; &#123; const el = ioe.target; const intersectionRatio = ioe.intersectionRatio; if (intersectionRatio &gt; 0 &amp;&amp; intersectionRatio &lt;= 1) &#123; self.loadImg(el); &#125; el.onload = el.onerror = () =&gt; io.unobserve(el); &#125;); &#125;) io.observe(el);&#125;,//判断是否被加载过isLoaded(el)&#123; // console.log(el) if(el.getAttribute('data-src')) &#123; return el.getAttribute('src')===el.getAttribute('data-src'); &#125; else &#123; return true; &#125;&#125;,loadImg(el)&#123; if(!el.src)&#123; var source = el.dataset.src; el.src = source; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git-rebase]]></title>
    <url>%2F2019%2F08%2F02%2FGit%2FGit-rebase%2F</url>
    <content type="text"><![CDATA[前言闻rebase色变，最近刚好在项目中用到了rebase合并分支与commit号，特此记录（非常艰难的探索） 合并分支问题最开始同事和我约定，在自己的分支中，先git pull rebase origin master，再切到master分支，merge 自己的分支，最后push master分支。往后继续在自己的分支上开发，如有修改再重复上面的步骤。 我一看rebase（确实对它有点恐慌），又想之前咱们合并功能分支不是直接在master分支上merge？怎么突然又rebase 又merge，跳来跳去的呢？ 和同事讨论了一会，为啥在自己的分支上要rebase而不是merge？当时两个人都觉得merge是ok的。包括后来我自己在测试分支上尝试，也没看出个所以然。 实践最后两个人对着电脑又使用测试分支尝试了一波 主分支merge功能分支我们平时经常是 主分支 merge 功能分支 ，这样做的结果是，功能分支的commit号按时间顺序插到主分支的commit号里面，最后有一个merge commit 号。假如咱们还想继续在功能分支开发，就需要和主分支保持联系，从与自己的远程分支联系变成和主分支联系，这显示是不科学的，成本很高。每次都要从主分支pull代码，解决冲突，主分支又再merge，主分支上的log将惨不忍睹，何况不止一个功能分支 主分支Merge功能分支，适用于之后不再在功能分支上开发的情况。 功能分支merge 主分支rebase/merge如果我们想后面可以继续在功能分支上开发，显然需要避免需要多次解决冲突的情况 先在功能分支 merge 主分支，主分支的commit号按时间顺序插到功能分支上，最后形成merge commit号。随后在主分支rebase的话，最后是需要强制push的，肯定不能再主分支上强制push （主分支rebase不合理）；如果是merge的话…..那就没啥必要功能分支再merge了，和上面情况一致 （主分支merge不合理） 功能分支rebase 主分支rebase/merge在 功能分支 上 rebase 主分支，会以主分支为主，如果功能分支有与主分支不同的commit号，会一次次合并，不管有没有冲突，产生的都是新的commit 号。（注意，如果有冲突，解决完需要 git add .再git rebase –continue，最后需要强制push -f），这个时候功能分支就能与主分支保持最新的代码 （功能分支rebase合理）；、 之后主分支如果rebase功能分支，就需要再次一个个commit号合并 （主分支rebase 不合理），使用merge，就只需要解决一次冲突，产生一个merge commit号 (主分支merge合理) 总结折腾了半天，根据上面各种情况的推算，最后还是维持之前的约定，往后开发 合并功能分支 步骤如下： 功能分支 git pull –rebase origin master git add . git rebase –continue git push -f 主分支 git merge 功能分支 git push 合并commit号问题在项目发开中思考了一个问题，因为改版模块，其实改动不大，都是一个个小的功能，我习惯于把一个功能写好，就push到分支上。最后会发现很多commit，其中有可能针对同一个功能，前后改动很多次，log就很难看了。 实践恰好看到了rebase，自测了一下，可以使用git rebase -i 版本号（或 HEAD~回退的版本数）合并commit。输入命令后，会调出vim编辑器，显示想要操作的commit，按照提示（一般第一个p,后面几个s表合并前面的commit），可以对commit进行保留，删除等等。最后需要强制push -f，覆盖掉远端仓库的版本，不然又来回来了。 注意，可能几次提交的版本都对某个地方进行修改，需要手动合并（这个代价还挺大的，所以rebase还是得看情况使用）。而且最后需要强制提交，1是我们可能还需要在项目中设置分支保护 取消，2是其实不太安全。]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git区、状态、修改]]></title>
    <url>%2F2019%2F07%2F31%2FGit%2Fgit%E5%8C%BA%E3%80%81%E7%8A%B6%E6%80%81%E3%80%81%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[四个工作区工作区我们平时存放项目代码的地方，但是是指受Git控制的，被Git跟踪记录的文件 暂存区类似缓存区域，临时保存文件 本地仓库连接本地代码和远程代码的枢纽，不能联网时本地代码可以先提到本地仓库；或叫版本（.git），HEAD指向最新放入仓库的版本 远程仓库托管代码的服务器 状态未跟踪未跟踪的文件改动不受到Git的版本控制 在工作区新加入一个文件时，是处于未跟踪状态的，需要add 将其加入跟踪，并同时放在暂存区 初次克隆某个仓库时，工作区中的所有文件都是已跟踪且未修改的状态 已跟踪被纳入版本控制的文件，又分 未修改（unmodified） 已修改（modified） 已暂存（staged） 已提交(Committed) 已推送(Pushed) 代码提交和同步流程 文件增删改，变为 已修改状态 git add，变为 已暂存状态 git add . 暂存所有更改的文件 git add [指定的文件] git commit，变为 已提交状态 git commit -m ‘[描述]’ git commit -m ` [描述]\n[描述]\n[描述]` git commit -am 不需要写add,会直接把已跟踪的文件一起推到暂存区（注意：不适用于未被git跟踪的） git push，变为已推送状态 git push -u origin 本地分支 远程分支 第一次要关联上 git push 之后直接push git branch 查看本地仓库分支 git branch -a 查看本地仓库和本地远程仓库(远程仓库的本地镜像)的所有分支 五种状态间的撤销更改 已修改，但未暂存（未git add）123456git diff 列出所有修改git diff [指定文件的修改]git checkout . 撤销工作区的所有修改git checkout [撤销工作区指定文件的修改]git clean -f 撤销新增的未跟踪文件git clean -df 撤销新增的未跟踪文件和文件夹 已暂存，未提交（git add了，未git commit）123git diff --cached 查看暂存区和本地仓库的差异git reset (--soft) 回退到已修改状态，内容还在工作区git reset --hard 回退到未修改状态，清空所有的修改 已提交，未推送（git commit了，未git push）commit后，仓库中会生成版本号(hash值)，标志这次的提交。之后可以按照版本会进行控制 123456git diff [分支1] [分支2] 查看两个分支的差异git diff 本地仓库分支名 origin/远程仓库分支名 查看本地仓库和本地远程仓库的差异git reset (--soft) 回退到已修改状态，修改还在工作区git reset --hard HEAD^ 回退到本地仓库上一个版本（可以说是修改全没了）git reset --hard [hash值] 回退到任意版本git reset --hard origin/远程仓库分支名 回退到与本地远程仓库一致 已推送到远程12git push -f origin 远程仓库分支名（慎用） 强制覆盖远程分支git push -f 如果关联过，可以忽略分支名（慎用） 其他删除123rm 物理上的删除，版本库还未删除git rm 工作区和版本库都删除了git rm --cached 工作区还在，版本库删除了。适用于不想被版本控制的文件 移动123456git mv test.txt TEST 把test.txt移到test实际上执行mv test.txt TESTgit rm test.txt git add TEST 查看版本号1234git log 查看提交过的版本信息，会有很多信息：作者，时间等。可以加--pretty=oneline，只会显示版本号和commit的内容git reflog 查看所有的提交记录，包括已经删掉的和reset的操作例如执行 git reset --hard HEAD~1，退回到上一个版本，用git log则是看不出来被删除的commitid，用git reflog则可以看到被删除的commitid，我们就可以买后悔药，恢复到被删除的那个版本 恢复版本我们恢复版本一般用reset和revert reset作用：改变HEAD的位置，可以改成之前存在的某个版本。适用于，想恢复到某个版本，那之后的版本不要了的场景。 revert作用：反做。适用于，想撤销某次版本的提交，但不影响后面的版本（revert后会新建一个版本）。比如功能分支合并到主分支，功能分支发现有问题，又不能影响主分支后面的代码，就可以把它revert掉。 1git revert -n 版本号 易混淆 git reset 可以作用在暂存区（git add了），可以回退到工作区；也可以作用在本地仓库（git commit了），可以回退/前进到任意版本 git checkout 可以撤销工作区的修改]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库-MVCC]]></title>
    <url>%2F2019%2F07%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93-MVCC%2F</url>
    <content type="text"><![CDATA[MVCC介绍1、定义MVCC（Multi-Version Concurrency Control）：多版本并发控制机制 2、与 传统的基于锁的并发控制 的区别读不上锁：这种特性对于读多写少的场景，大大提高了系统的并发性。大部分关系型数据库都实现了MVCC 3、MVCC的优点大多数的MYSQL事务型存储引擎，如InnoDB等都不使用一种简单的行锁机制，会和MVCC一起使用。因为锁机制系统开销较大，MVCC在大多数情况下能够代替行锁，大大降低系统开销 4、实现MVCC是通过保存数据在某个时间点的快照实现的 MVCC没有正式的规范，各个数据库和存储引擎的实现都不尽相同 InnoDB的MVCC实现1、原理通过在每行记录后面保存两个隐藏的列来实现，这两个列，分别保存了行的创建时间和行的删除时间 注意：存储的不是具体的时间，而是系统版本号（可以理解为事务的ID），每开始一个新的事务，系统版本号就会自动递增。事务开始时刻的系统版本号就会作为事务的ID 2、INSRT新插入的每一行的创建时间：当前系统版本号 3、DELETE删除的每一行的删除时间：当前系统版本号 4、SELECT 只会查找创建时间小于或等于当前版本号的行数 被删除行的删除时间需要未定义或大于当前版本号的行数 以上两种条件都必须满足 5、UPDATE实际上是新插入了一行记录，创建时间为当前系统版本号；同是把要UPDATE的行的删除时间更改为当前系统版本号]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库-事务]]></title>
    <url>%2F2019%2F07%2F29%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[什么是数据库事务 构成单一逻辑工作单元的操作集合 一个典型的数据库事务如下 123BEGIN TRANSACTION //事务开始SQL1...比如取款操作COMMIT/ROLLBACK //事务提交或回滚 事务四大特性 ACID不是所有操作都是事务，事务要有一下四个特性 原子性(Atomicity) 事务作为一个整体被执行，包括对数据库的操作，要么全部被执行， 要么都不执行 一致性(Consistency) 事务应确保数据库的状态从一个一致状态转变成另一个一致状态。一致状态是数据库中的数据应满足完整性约束 隔离性(Isolation) 多个事务并发执行时，一个事务的执行不应该影响其他事务的执行 永久性(Durability) 已被提交的事务对数据库的修改应该永久保存在数据库中 常见并发异常1、脏读一个事务读取到另一个事务未提交的数据 事务A 事务B - 开始事务 开始事务 - 查询账户余额为2000元 - 取款1000元，余额被更改为1000元 查询账户余额为1000元（产生脏读） - - 取款操作发生未知错误，事务回滚，余额变更为2000元 转入2000元，余额被更改为3000元（脏读的1000+2000） - 提交事务 - 按照正确逻辑，此时账户余额应该为4000元 - 2、不可重复读前后多次读取，数据内容不一致 事务A 事务B 开始事务 - 第一次查询，小明的年龄为20岁 - - 开始事务 其他操作 - - 更改小明的年龄为30岁 - 提交事务 第二次查询，小明的年龄为30岁 - 按照正确逻辑，事务A前后两次读取到的数据应该一致 - 3、幻读前后多次读取，数据总量不一致 事务A 事务B 开始事务 - 第一次查询，数据总量为100条 - - 开始事务 其他操作 - - 新增100条数据 - 提交事务 第二次查询，数据总量为200条 - 按照正确逻辑，事务A前后两次读取到的数据应该一致 - 不可重复读和幻读 区别1、不可重复读读取了其他事务更改的数据，针对insert和update操作 解决：使用行级锁，锁定该行，事务A多次读取操作完毕后才释放，这时候才允许其他事务更改刚才的数据 2、幻读读取了其他事务新增的数据，针对insert和delete操作 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放，这时候才允许其他事务新增数据 四大隔离级别1、读未提交 READ UNCOMMITTED123456781）用户B：BEGIN TRANUPDATE test SET age=25 WHERE name = ‘AA’2）用户A：SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED（此句不写即默认为READ COMMITTED模式）SELECT * FROM test（此时将查到AA的age值为25）3）用户B：ROLLBACK（此时撤消了步骤1的UPDATE操作，则用户A读到的错误数据被称为脏读） 2、读已提交 READ COMMITTEDSQL Server和Oracle的默认隔离级别 1234561）用户B：BEGIN TRANUPDATE test SET age=25 WHERE name = ‘AA’2）用户A：SET TRANSACTION ISOLATION LEVEL READ COMMITTEDSELECT * FROM test （上句设置了提交读模式，则此时将会查不到数据，显示查询等待中，直到用户B进行了ROLLBACK或者COMMIT操作后，此语句才会生效） 3、可重复读 REPEATABLE READMySql的默认隔离级别 1234在用户A的事务运行之前，先设定SQL的隔离等级为REPEATABLE READSQL语句为SET TRANSACTION ISOLATION LEVEL REPEATABLE READ用户A查询完之后，用户B将无法更新用户A所查询到的数据集中的任何数据（但是可以更新、插入和删除用户A查询到的数据集之外的数据），直到用户A事务结束才可以进行更新，这样就有效的防止了用户在同一个事务中读取到不一致的数据。 4、串行化 SERIALIZABLE1234在用户A的事务运行之前，先设定SQL的隔离等级为SERIALIZABLE语句为SET TRANSACTION ISOLATION LEVEL SERIALIZABLE这样在用户A的事务执行过程中，别的用户都将无法对任何数据进行更新、插入和删除的操作，直到用户A的事务回滚或者提交为止。 这是四个隔离级别中限制最大的级别：一个一个排队执行，执行效率奇差，性能开销也最大，所以应只在必要时才使用该选项。 总结 - 脏读 不可重复读 幻读 读未提交 可能 可能 可能 读已提交 可能 可能 可重复读 可能 读已提交]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Js异步任务macrotask和microtask]]></title>
    <url>%2F2019%2F07%2F25%2FJavaScript%2FJs%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1macrotask%E5%92%8Cmicrotask%2F</url>
    <content type="text"><![CDATA[前言在阅读 Vue-nextTick源码时，看到有通过MutationObserver去实现nextTick（使用textnode模拟DOM变化，MO监听到后触发回调函数），百思不得其解：为什么可以使用MO这个API，为什么MO要优选与setTimeout？ Js运行机制（刷新三观）众所周知，JS是单线程的，主线程拥有一个执行栈和一个任务队列 主线程依次执行同步代码 当异步任务有结果时，把事件放入任务队列 当主线程的同步代码执行完毕了，又会依次地从任务队列取事件，执行异步任务的回调——event loop（事件循环） 但是重点来了 任务队列分成tasks 和 microtasks，在每次事件循环中，tasks只会取一个执行，执行完成会检查microtasks队列，并把里面所有的任务都执行完毕。 APImacrotasks(tasks) setTimeout setInterval setImmediate I/O requestAnimationFrame UI rendering microtasks process.nextTick, Promise MutationObserver Object.observe 12345678910console.log(1);setTimeout(function()&#123; console.log(2);&#125;, 0);Promise.resolve().then(function()&#123; console.log(3);&#125;).then(function()&#123; console.log(4);&#125;);结果：1 3 4 2 (promise比setTimeout优先级高) 注意根据HTML Standrad，在每个task运行完以后，UI都会重新渲染，那么在microtask完成数据更新，当前task结束后就能得到新的UI；反之新建一个task来做数据更新，UI就会渲染两次 总结现在我们就可以回答前言提到的两个问题啦： 为什么可以使用MO这个API 它属于一个异步任务，到数据发生变化(Js主线程执行了赋值操作)，就会调用起microtasks任务队列的任务MO(MO做了啥请移动到 Vue-nextTick) 为什么MO要优选与setTimeout 因为MO是一个microtask，setTimeout是一个task，task做数据更新，UI会渲染两次，耗费性能 补充12345678910111213141516// CVTE笔试题2019.09.05process.nextTick(function()&#123; console.log(1); process.nextTick(function()&#123; console.log(2); &#125;)&#125;)setTimeout(function()&#123; console.log(4);&#125;, 0);process.nextTick(function()&#123; console.log(3);&#125;)console.log(5);// 5 1 2 3 4//如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前"执行栈"执行]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>运行机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-nextTick源码浅析]]></title>
    <url>%2F2019%2F07%2F24%2F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2FVue%2FnextTick%2F</url>
    <content type="text"><![CDATA[前言nextTick 的作用： 让回调函数在DOM更新完成后被调用。 12345678910111213141516171819202122232425举个栗子：new Vue(&#123; el: '#app', data: &#123; list: [] &#125;, mounted: function () &#123; this.get() &#125;, methods: &#123; get: function () &#123; this.$http.get('/api/article').then(function (res) &#123; this.list = res.data.data.list // ref list 引用了ul元素，我想把第一个li颜色变为红色 this.$refs.list.getElementsByTagName('li')[0].style.color = 'red' &#125;) &#125;, &#125;&#125;)结果报错，因为此时此刻dom上的list还没有数据，也就是说赋值操作没有引起视图的更新；需要改成：this.list = res.data.data.listthis.$nextTick(function () &#123; this.$refs.list.getElementsByTagName('li')[0].style.color = 'red'&#125;) 原理Vue的特点：响应式。但是数据更新时，DOM不会立即更新。因为Vue在更新DOM时是异步执行的，只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watch被多次触发，只会被推入到队列中一次(去除重复数据，避免不必要的计算和DOM操作)。当刷新(执行)队列时，DOM会在下一个事件循环‘tick’中更新。 使用123456789import Vue from 'vue'Vue.nextTick(function () &#123; console.log(this.$refs.msg.innerHTML) // 已更新&#125;)//下面的方法不需要使用全局Vue，而且this将自动绑定到当前的Vue实例上this.$nextTick(function () &#123; console.log(this.$refs.msg.innerHTML) // 已更新&#125;) 应用场景 created()钩子函数进行的DOM操作一定要放在nextTick()的回调函数中 因为created() 时DOM还没有渲染，写在nextTick()中相当于mounted()函数，DOM的挂载和渲染已完成 如果某个操作，需要使用随数据改变的DOM结构时，需要放在nextTick()的回调函数中 源码浅析源代码在@vue/src/core/util/next-tick.js定义变量： 123var callbacks = []; // 存储回调函数的数组var pending = false; // 是否正在执行回调函数var timerFunc; // 触发执行回调函数 $nextTick内实际调用的函数：(不直接操作callbacks，是为了防止后续有新的回调函数操作传入) 1234567891011function flushCallbacks () &#123; pending = false // 拷贝出回调函数数组副本 const copies = callbacks.slice(0) // 把函数数组清空 callbacks.length = 0 // 依次执行函数 for (let i = 0; i &lt; copies.length; i++) &#123;​ copies[i]() &#125;&#125; 接下来，分了4种情况来延迟调用flushCallbacks()(依次优雅降序) 1、Promise.then 延迟调用12345678if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; Promise.then为microtasks的一种异步任务，当主线程(数据赋值)完成后，才会调用Promise.then，从而做到延迟(详情看microtask和task的文章) 2、MutationObserver 监听变化12345678910111213141516if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; MutationObserve是HTML5的一个新API，功能是：监听dom节点变化，在所有dom变动完成后，执行回调函数。 MO也是一个microtasks，在这里是创建一个文本节点，当主线程(数据赋值)完成后，会改变文本节点的内容来触发MutationObserve，执行回调，从而达到延迟的作用。 3、setImmediate 延迟器12345if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; 4、setTimeout 延迟器1234&#123; timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125; setImmediate和setTimeout都是task中的异步任务类型，它们会等待主线程(数据赋值)完成后，再起新的一个task执行回调函数，也起到了延迟的作用。setImmediate比setTimeout优先级更高。 闭包函数12345678910111213141516171819202122232425export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) // 如果没有函数队列在执行才执行 if (!pending) &#123; pending = true timerFunc() &#125; // promise化 if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 每一次添加函数，都会向callbacks这个函数数组入栈。然后监听当前是否正在执行，如果没有，执行函数。 123456this.$nextTick(function () &#123;&#125;)// promise化this.$nextTick().then(function () &#123;&#125;.bind(this))]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux与Shell]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2FLinux%E4%B8%8EShell%2F</url>
    <content type="text"><![CDATA[前言公司实习期间，使用的是分配的mac,之前使用包括自己的电脑都是window，所以现在有机会可以放开胸怀使用Linux命令啦！ 首先需要安装iTerm2，可以打造舒适的终端体验。有了颜色和背景色，敲起代码来倍爽！ 掌握一些常用的命令： 查看目录 ls ls -l (ll) 可以看到文件的具体信息：大小、创建时间、可读可写可执行等 ls -a 查看所有文件（包括不能看的） 跳转目录 ~/ 主目录 ./ 当前目录 ../上一级目录 cd 具体路径 可安装autojump工具，只需要打 j cd过的文件名 即可直接跳到想去的地方 清屏 clear 退出命令 ctrl+c 创建目录 mkdir 创建文件 touch vi(进入vi编辑器) i 进入编辑 按ESC退出编辑 :q 不保存，退出 :q! 不保存，强制退出 :wq 保存，退出 :wq! 保存，强制退出 有时安装包后，会要求给~/.zshrc文件中加路径才能生效，需要（可以用上面的vim方法） open ~/.zshrc 在文件中加完后，保存 source ~/.zshrc 本地跑项目，发现端口被占用 lsof -i :端口号 （查看谁在占用） kill 9 端口号 （杀杀杀） 查看当前文件的绝对路劲 pwd 删除 rm 文件名 rm -rf 文件夹名 shell命令突然意识到linux命令和shell命令原来不能统称一体，linux和windows都为操作系统，其中shell是一个脚本，我们可以通过使用它操作系统，但在不同的系统中，使用的shell不同，比如linux默认都是GUNbash shell，而windows默认是cmd。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS解析过程与记录类型]]></title>
    <url>%2F2019%2F07%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FDNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概念网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以在通讯过程中只能识别Ip地址，而不是域名。DNS的工作是把域名解析成Ip地址，从而我们可以访问到对应的网页。DNS是应用层协议。 解析过程用户通过浏览器访问某域名时 浏览器缓存 浏览器首先在缓存中查找是否有该域名对应的ip地址 系统缓存 自动检查用户计算机系统Hosts文件DNS缓存是否有对应的ip地址 路由器缓存 路由器缓存中检查，以上三步均为客服端的DNS缓存 ISP（互联网服务提供商）DNS缓存 比如用的电信的网络，则进入电信的DNS缓存服务器中查找 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询 根域名服务器（不是转发模式） 全球仅有13台根域名服务器：1个主根域名服务器，另12台为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器 顶级域名服务器 顶级域名收到请求后会查看区域文件记录，若无则将其管辖范围内主域名（如.com）服务器IP告诉本地DNS服务器 主域名服务器 主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确记录 （转发模式）此DNS服务器会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把请求转给上上级，以此循环。（从客服端到本地DNS服务器是属于递归查询，DNS服务器之间的交互查询是迭代查询） 保存结果至缓存 结果返回给本地DNS服务器，本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端向该IP地址定位的HTTP服务器发起TCP连接 记录类型1.A记录又称IP指向，用来指定主机名（或域名）对应的IP地址记录，同时也可以设置域名的二级域名 2.CNAME记录又称别名记录，允许将多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。 比如有一台计算机，‘host.blog.com’（A记录），同时提供WWW和MAIL服务，可以设置两个CNAME记录，别名的全称就 http://www.blog.com/和“mail.blog.com”。实际上他们都指向 “host.blog.com”。 A记录优先于CNAME记录。即如果一个主机地址同时存在A记录和CNAME记录，则CNAME记录不生效。 3.MX记录邮件交换记录，用于将以该域名为结尾的电子邮件指向对应的邮件服务器以进行处理。 4.NS记录解析服务器记录，用来表明由哪台服务器对该域名进行解析。 NS记录优先于A记录。即，如果一个主机地址同时存在NS记录和A记录，则A记录不生效。这里的NS记录只对子域名生效。 5.TTL生存时间，即DNS记录在DNS服务器上的缓存时间。 6.TXT记录为某个主机名或域名设置的说明 1admin IN TXT "jack, mobile:13800138000"； 7.AAAA记录指向IPv6地址的记录。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React填坑笔记]]></title>
    <url>%2F2019%2F07%2F10%2FReact%2FReact%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数组循环时缺少unique “key” prop 1warning:Each child in an array or iterator should have a unipue "key" prop.check the render method. 注意render里的map，需要加key videoJs报错1VIDEOJS:ERROR:The "flash" tech is undefined.skipped browser support check for that tech. 删除掉playerOptions的配置属性techOrder即可 videoJs与ReactJs冲突报错当使用ReactJs和videoJs时，将有两个相同data-reactid属性的元素，但ReactJs只允许唯一data-reactid 1Uncaught Error:Invaeriant Violation:ReactMount Tow valid but unequal nodes with the same 'data-reactid' 在video.js包的js文件中，修改： 为了避免之后npm i后覆盖已更改的包，重新发布一个自定义的包@meili/videoJs，拷贝原npm包，把package.json的内容改成npm包仓库内的package.json内容，并把script的内容清空，最后更改包名字，npm login npm publish 1234567if(attr === 'class') &#123; el.className = attrs[attr];&#125;else if(attr === 'data-reactid') &#123; el.setAttribute(attr, attrs[attr] + '_foo');&#125;else &#123; el.setAttribute(attr, attrs[attr]);&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>填坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js编码规范（注释与空格篇）]]></title>
    <url>%2F2019%2F07%2F08%2F%E5%BC%80%E5%8F%91%2Fjs%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88%E6%B3%A8%E9%87%8A%E4%B8%8E%E7%A9%BA%E6%A0%BC%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注释多行注释使用 /* … /12345678910/*** @param &#123;Grid&#125; grid 需要合并的Grid* @param &#123;Array&#125; cols 需要合并列的Index(序号)数组；从0开始计数，序号也包含。* @param &#123;Boolean&#125; isAllSome 是否2个tr的cols必须完成一样才能进行合并。true：完成一样；false(默认)：不完全一样* @return void* @author 单志永 2018/11/8*/function mergeCells(grid, cols, isAllSome) &#123; // Do Something&#125; 单行注释使用 //注释为一行，且内容前面需要有空格 12// is current tabconst active = true; 空格使用 2 个空格作为缩进，在大括号前放置 1 个空格123function test() &#123; console.log('test');&#125; 在控制语句（if、else、while 等）的小括号前放一个空格1234// goodif (isJedi) &#123; fight();&#125; 使用空格把运算符隔开12// goodconst x = y + 5; 不要在圆括号内加空格1234// goodfunction bar(foo) &#123; return foo;&#125; 不要在中括号内添加空格123// goodconst foo = [1, 2, 3];console.log(foo[0]); 在大括号内添加空格12// goodconst foo = &#123; clark: 'kent' &#125;;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端输入框唤起问题]]></title>
    <url>%2F2019%2F07%2F05%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BE%93%E5%85%A5%E6%A1%86%E5%94%A4%E8%B5%B7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言移动端输入框在输入的时候，我们希望输入框能在键盘的上面展示。这样的需求会很多，但是可能不同机型下输入框会存在无法唤起的问题，以下是一个常见的解决方法。scrollIntoview可以把元素滚动到可视区域内 12345678语法：element.scrollIntoView(); // 等同于element.scrollIntoView(true) element.scrollIntoView(alignToTop); // Boolean型参数 element.scrollIntoView(scrollIntoViewOptions); // Object型参数参数(alignToTop)：true: 元素的顶端将和其所在滚动区的可视区域的顶端对齐false: 元素的底端将和其所在滚动区的可视区域的底端对齐 注意还存在浏览器兼容性问题，所以在开发的时候，需要看看是否能达到自己的效果。 如果页面定位为fixed，scrollIntoview是不生效的，因为整个页面都是可视区域了，可以当点击输入时，修改页面的定位方式(最简单)]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git填坑笔记]]></title>
    <url>%2F2019%2F07%2F03%2FGit%2FGit%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用 Git 的时候，总能遇到各种奇奇怪怪的报错，记录记录 &gt;-&lt; 1. 缺少权限1git push ![remote rejected] 分支名-&gt;分支名 (pre-receive hook declined) 2. 强制Push失败，提示分支被保护1you are not allowed to push code to protected branches on this project 需要工程的创建人在 git 上把用户添加到被保护的分支的 Developer 中去。 在工程页面，选择设置，下拉选择 Protected Branches -&gt; Developer 3. 装oh-my-zsh时总是报错12localhost% sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out 解决：配置git账号 123git config --global user.name 'xx'git config --global user.email 'xx@xxx.com'git config -l 4. 直接copy库，import后，报错 Cannot assign to read only property ‘exports’ of object ‘#‘ 原因： 在webpack打包的时候，可以在js文件中混用require和export。但是不能混用import 以及module.exports。因为webpack 2中不允许混用import和module.exports 解决： 把库的index.js module.exports 改成 export default function… 5. 在html文件中怎么引入库呢？直接在script引入地址会报错 Uncaught SyntaxError: Cannot use import statement outside a module 解决： 123456&lt;script type="module"&gt; import a from './库/index.js'&lt;/script&gt;// 或者 &lt;script src='./库/index.js' type="module"&gt;&lt;/script&gt; 6. Broken pipe12345$ git pull # packet_write_wait: Connection to 10.108.238.163 port 22: Broken pipe# fatal: 无法读取远程仓库。# 请确认您有正确的访问权限并且仓库存在。 解决：突然无法 pull ，原因是 gitlab 升级，过一会就好了….]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>填坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-检测对象、数组变化]]></title>
    <url>%2F2019%2F06%2F17%2FVue%2FVue-%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言使用Vue开发的过程中，有的时候操作变量的时候老是无法触发更新，比如以下几种情况 无法做到 对象属性 的添加/删除 无法做到 数组 的一些变化 利用索引值直接设置元素：this.arr[0] = ‘y’//不是响应的 修改数组长度 this.arr.length = 5 //不是响应的这是为什么呢？？ 为什么无法做到对象属性的添加与删除Vue使用Object.defineProperty，在初始化实例时对属性执行getter/setter转化，进行监测，属性必须在data对象上存在才能让Vue将它转换成响应式。 解决方案1234567this.someObject.b = 2改成：Vue.set(this.someObject, 'b', 2)this.$set(this.someObject, 'b', 2)为已有对象赋值多个新属性this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 为什么不能监听数组的一些变化如果监测的值是 值 类型，当值变化就会触发set；如果监测的值是 引用 类型，虽然值变了，但是引用没有变，所以不会触发set 解决方案12345Vue.set(vm.items, indexOfItem, newValue)vm.$set(vm.items, indexOfItem, newValue)Vue重写了一些方法，我们可以灵活使用：push, pop, shift, unshift,splice, sort, reversevm.items.splice(indexOfItem, 1, newValue)vm.items.splice(newLength)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue-进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[严格模式(use strict)]]></title>
    <url>%2F2019%2F06%2F12%2FJavaScript%2F%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F(use%20strict)%2F</url>
    <content type="text"><![CDATA[支持的浏览器 IE10+ Firfox4+ Chrome13+ Safari5+ Opera12+ 声明在脚本或者函数的头部加’use strict’好处 消除js语法不合理、不严谨的地方，减少怪异行为 保证代码运行的安全 提高编译器效率，增加运行速度 为未来版本的js做铺垫 限制 不允许使用未声明的变量 不允许删除变量、函数、不允许删除的属性 不允许变量重名 不允许函数参数重名 不允许使用八进制 不允许使用转义字符 不允许对只读属性赋值 不允许对一个使用getter方法读取的属性赋值 不能使用’eval’字符串 var eval = 3.14; // 报错 在作用域 eval() 创建的变量不能被调用： eval (“var x = 2”); alert (x); // 报错 不能使用’arguments’字符串 var arguments = 3.14; // 报错 不允许使用with语句 增加了保留字（比如protected、static和interface） 注意：1、在非严格模式中,修改命名参数的值也会反应到arguments对象中,而严格模式坐下,这两个值是完全独立的 123456789// 修改命名参数的值// 非严格模式:修改会反应到arguments中// 严格模式中不会反应到arguments中function sum(num,num2)&#123; 'use strict'num=3 console.log(arguments[0],num2)// 严格模式下输出为1,2 非严格模式下输出为3,2&#125;sum(1,2) 2、禁止this指向全局对象 12345function f()&#123; "use strict"; return !this;&#125; // 返回true，因为严格模式下，this的值为undefined，所以"!this"为true 使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。 12345function f()&#123; "use strict"; this.a = 1;&#125;;f();// 报错，this未定义 3、在严格模式中,可以在eval()中声明变量和函数,但这些边行或者函数只能在被求值的特殊作用域中有效,随后就将被销毁,下面这段代码执行就是没问题的 123'use strict'var result=eval('x=1,y=13;x+y')alert(result) 在这里,eval中声明了变量x和y,然后将他们加在一起,反悔了他们的和,于是result变量的值就是21,即x+y的结果,在调用alert时,尽管x和y已经不存在了,result变量的值还是有效的]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6-解构赋值]]></title>
    <url>%2F2019%2F06%2F11%2FEs6%2FES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[前言看到大家有这样的写法，很方便，但是为什么可以这样写呢？ 12import &#123;常量1,常量2,...&#125; from 路径 const &#123;MWP&#125; = M; 什么是解构赋值Es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值——解构 123456比如之前必须：let a = 1;let b = 2;现在可以let [a, b] = [1, 2]; 数组的解构赋值-注意点1、左右两边格式需要对等，数量可以不对等；不对等将赋值undefined12let [b, a] = [1];//b=1 a=undefined 2、左右两边为其他类型会报错；字符串例外123456789let [a] = 1;let [a] = false;let [a] = NaN;let [a] = undefined;let [a] = null;let [a] = &#123;&#125;;以上都会报错let [a] = '121321' a = '1' //取字符串第一个下标的值 3、Set结构也可以解构赋值1let [x,y,z] = new Set([1,2,3]) //x = 1, y = 2, z = 3 4、允许指定默认值1let [a = 3] = [] // a:3 5、undefined 与 null如果需要默认值生效，则应对等的值为undefined的时候才会采用默认值，否则还是使用赋值 12let [a = 3] = [undefined] // a:3let [a = 3] = [null] // a:null 对象的解构赋值-注意点非常注意：数组的解构赋值需要等号两边位置一致才能正确赋值；而对象的解构赋值需要等号两边的变量和属性同名一致即能正确赋值，否则undefined 12let &#123;a,b&#125; = &#123;a:'3',c:'d'&#125;//a: 3 b: undefined 1、可以将现有对象的方法赋值给一个新变量1let &#123;sin,cos&#125; = Math 2、注意左边的变量名不能与右边的对象属性名保持一致的情况必须这样写 let {a:b} = {a: ‘sss’} // b: ‘sss’ 3、允许嵌套赋值12345678910111213141516171819202122232425第一种：let obj = &#123; p:[ 'Hello', &#123;y:'world'&#125; ]&#125;let &#123;p:[x,&#123;y&#125;]&#125; = obj // x: Hello, y: world这边的p只是属性不是变量，如果p想赋值可以写成：let &#123;p,:[x,&#123;y&#125;]&#125; = obj第二种：const a = &#123; loc: &#123; t :1, b :&#123; c:1, d:2 &#125; &#125;&#125;let &#123;loc:&#123;t,b:&#123;c,d&#125;&#125;&#125; = a或者let &#123;loc,loc:&#123;t,b,b:&#123;c,d&#125;&#125;&#125; = a 如果子对象所在的父属性不存在，则会报错，如下：1let &#123;foo:&#123;bar&#125;&#125; = &#123;baz:'baz'&#125; //报错 4、允许指定默认值12let &#123;x = 3&#125; = &#123;&#125; //x:3注意：不能将已声明的变量用于解构赋值，因为已经是一个代码块 字符串的解构赋值-注意点如果赋值的对象是数组，字符串将被分割为数组的格式一一对应赋值 12let [a,b] = 'ha' // a = h , b = alet &#123;length:len&#125; = '12121' // len = 5 数值和布尔值的解构赋值-注意点如果等号右边是 数值和布尔值，会把他们转化成对象（没有赋值），如果是undefined和null会报错(无法转成对象) 1234let &#123;a: b&#125; = 123; b === Number.prototype.a;let &#123;a: b&#125; = true; b === Boolean.prototype.a;let &#123;a: b&#125;=undefined; //报错let &#123;a: b&#125;=null; //报错 函数参数的解构赋值-注意点123456789101112131415161718192021222324注意以下两种写法(区别：左边传值，右边赋值；传值会覆盖赋值)function m(&#123;x=3, y=4&#125; = &#123;&#125;)&#123; return [x,y]&#125;m(&#123;x:33,y:8&#125;) // [33,8]m(&#123;x:32&#125;) // [32,4]m(&#123;&#125;) // [3,4]m() // [3,4]function m(&#123;x,y&#125; = &#123;x=0,y=0&#125;)&#123; return [x,y]&#125;m(&#123;x:33,y:8&#125;) // [33,8] //代替右边的 x:0, y:0 所以是传值 33 8m(&#123;x:32&#125;) // [32,undefined]//因为传值替代右边的赋值，但是只有x没有y//所以y是取左边y的默认值，因为你没有赋值 为undefinedm(&#123;&#125;) // [undefined,undefined] // 取左边x,y的默认值，因为没有赋值 为undefinedm() // [0,0]// 没有传值，使用本身的赋值 都是0 圆括号问题1、声明语句不能使用1var [(a)]=[1]; 2、函数参数不能使用1function f([(z)]) = &#123; return z; &#125; 3、不能讲整个模式或嵌套模式中的一层放在圆括号中12(&#123;p: a&#125;)=&#123;p: 42&#125;([a]) = [5] 正确：把圆括号放在非模式部分12[(b)] = [3];(&#123;p: (d)&#125; = &#123;&#125;) 常用情景1、变换变量的值1[x,y]=[y,x] 2、从函数中返回多个值1234567891011121314// 返回一个数组function f()&#123; return [1,2,3];&#125;var [a,b,c] = f(); // 返回一个对象function f1()&#123; ruturn &#123; foo: 1, bar: 2 &#125;&#125;var &#123;foo, bar&#125; = f1(); 3、函数参数的定义12345function f([x,y,z])&#123;...&#125;f(&#123;1,2,3&#125;)function f([x,y,z])&#123;...&#125;f(&#123;x:1,z:3,y:2&#125;) 4、提取JSON数据123456var jsonData= &#123; id: 42, status: 'ok',&#125;let &#123;id,status: isok&#125; = jsonData;consoloe.log(id, isok); // 42 "OK" 5、函数参数的默认值1function f(a=1, b=2) &#123;&#125; 6、遍历Map解构1234567891011var map = new Map() ;map.set('first', 'hello');map.set('sec', 'world');for(let [key, value] of map)&#123; // 从循环的数值中依次赋值key和value console.log(key + "is" + value) // first is hello // sec is world &#125; 7、输入模块的制定方法1const &#123; SourceMapConsumer, SourceNode&#125; = require("source-map")]]></content>
      <categories>
        <category>Es6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2019%2F06%2F10%2F%E7%AE%97%E6%B3%95%E9%A2%98%2F%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 12345678910var twoSum = function(nums, target) &#123; pairs = new Map() for (var i=0; i&lt;nums.length; i++) &#123; if (!pairs.has(nums[i])) &#123; pairs.set(target-nums[i], i) &#125; else &#123; return [pairs.get(nums[i]), i] &#125; &#125;&#125;;]]></content>
      <categories>
        <category>算法题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack4.x填坑笔记]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2FWebpack%2Fwebpack4.x%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言今天继续迁移一个老的react项目，因为新的脚手架起的是webpack v4.x 版本，而老项目是v1.x 版本，所以配置上有蛮多的改变…在一堆报错中冲出杀路… es2015报错2017年Babel 的官网上在9月宣布 ES2015 / ES2016/ ES2017 等等 ES20xx 时代的 presets 通通被废弃（deprecated），取而代之的是 babel-preset-env，并且承诺它将成为“未来不会过时的（future-proof）”解决方案。 也就是说： babel preset将基于你的实际浏览器及运行环境，自动的确定babel插件及polyfills，转译ES2015及此版本以上的语言。 解决方案： 1234567npm uninstall --save-dev babel-preset-es2015npm install --save-dev babel-preset-env@next将es2015修改成env&#123; "presets": [ "env" ], ...&#125; react报错1Error: Cannot find module 'babel-preset-react' from '/Users/me/Desktop/reflask' - If you want to resolve "react", use "module:react" - Did you mean "@babel/react"? at Function.module.exports [as sync] 1234567891011webpack.config.js &#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: "babel-loader", options: &#123; presets: ['react'] &#125; &#125;&#125;, 解决方案： 123456789把options: &#123; presets: ['react']&#125;but改成options: &#123; presets: ['@babel/preset-react']&#125; 插件不支持extract-text-webpack-plugin插件主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象。但是只支持webpack3 mini-css-extract-plugin插件也是用来提取css到单独的文件的，该插件有个前提条件，只能用于webpack 4及以上的版本，所以如果使用的webpack版本低于4，,那还是用回extract-text-webpack-plugin插件。 添加依赖 1npm install --save-dev mini-css-extract-plugin webpack配置 1234567891011121314151617181920const MiniCssExtractPlugin = require("mini-css-extract-plugin");module.exports = &#123; plugins: [ new MiniCssExtractPlugin(&#123; filename: "[name].css", chunkFilename: "[id].css" &#125;) ], module: &#123; rules: [ &#123; test: /\.css$/, use: [ MiniCssExtractPlugin.loader, "css-loader" ] &#125; ] &#125;&#125; 运行webpack要加参数从4.0开始:运行webpack一定要加参数 – mode development 或者 –mode production， 分别对应开发环境和生产环境,否则会报警告: 1234"scripts": &#123; "build": "webpack --optimize-minimize --mode production", "dev": "webpack-dev-server --config webpack.dev.config.js --mode development" &#125;, babel报错现在改用babel-loader，但是换成babel-loader后也是老报错：Error: Cannot find module ‘@babel/core’ 原因：官方默认babel-loader | babel 对应的版本需要一致: 即babel-loader需要搭配最新版本babel 1234567两种解决方案:回退低版本npm install -D babel-loader@7 babel-core babel-preset-env更新到最高版本:npm install -D babel-loader @babel/core @babel/preset-env webpack]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>填坑</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hosts文件]]></title>
    <url>%2F2019%2F05%2F30%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHosts%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言前面我们在DNS解析中，有谈到域名解析过程中，可能会到hosts文件中查看域名缓存，从而拿到ip地址。在实际开发中，我们经常会在几个环境中切换：线上、预发、线上。为了咱们方便记忆，不用去记各种ip地址，只需要在hosts里面做好域名-ip映射即可。 什么是Hosts文件Hosts文件是一个没有扩展名的系统文件，主要的作用是定义域名和ip地址的映射关系。 Hosts文件作用1.加快域名解析当我们输入域名时，浏览器若在缓存中找不到，则会在hosts文件中查找映射关系，这样就能迅速找到ip地址，而不需要请求网络上的DNS服务器 2.方便局域网用户比如咱们在开发项目时，会有很多环境：线上、预发、线下，不可能都去记服务器的ip地址，这时候给它们取个名字，在Hosts里面建立映射关系，就非常方便啦。 3.屏蔽网站有一些网站会经常给自己安插件，可以把这些网站的域名映射到安全的Ip或者自己的Ip地址上，就不用访问了。 1127.0.0.1 http://www.baidu.com#屏蔽的网站 怎么改host1sudo vi /etc/hosts ip在前，域名在后（可多个域名映射一个ip）]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS模块化区别：CommonJs、AMD、CMD、UMD、Es6Module]]></title>
    <url>%2F2019%2F05%2F29%2FJavaScript%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8C%BA%E5%88%AB%EF%BC%9ACommonJs%E3%80%81AMD%E3%80%81CMD%E3%80%81UMD%E3%80%81Es6Module%2F</url>
    <content type="text"><![CDATA[前言之前在探索Es6 中import()和import…form的区别时，就在想Es6之前是咋引用模块的呀？？咱今天就来一探究竟！ JS-模块化进程Js在模块化上有经历一个越来越好的过程，目的是更好的封装模块，引用模块 原始的开发方式 -&gt; CommonJs -&gt; AMD -&gt; CMD -&gt; UMD -&gt; Es6Module 原始的开发方式例子最开始的时候，Js自身是没有模块机制的。项目中有多个js文件，在html加载的时候，需要一个个文件引用 1&lt;script src="a.js"&gt;&lt;/script&gt; 问题 命名问题：所有的文件都是挂在 global 上，咱就不能重名了，否则污染全局环境。 依赖问题：scrpit是顺序加载，如果各文件之间有依赖，比如某个a文件里面的代码依赖jquery，那jquery就必须放在a文件前面引用。我们需要时刻考虑js文件的书写顺序。 网络问题：文件太多了，请求次数就会多，加载时间自然而然多！ 突然想起最开始自己写的代码，都是原生js，或者使用jq，当时就经常会遇到重名、顺序，还有万恶的堵塞问题，嘤嘤嘤，模块化快出现！ CommonJs使用场景、加载方式主要运行于服务器端（Node.js实现） 同步加载模块，因为加载的文件资源大多数在本地服务器，所以执行速度和时间都很棒 例子该规范指出，一个单独的文件就是一个模块。 主要两个命令 引用其他模块 输出 require module.exports/exports 注意：输出的是一个值得拷贝，输出后不能改变，会缓存起来 12345678910111213141516171819// moduleA.jsvar name = 'weiqinl'function foo() &#123;&#125;module.exports = exports = &#123;name,foo&#125;// moduleB.jsvar ma = require('./moduleA') // 可以省略后缀.jsexports.bar = function() &#123;ma.name === 'weiqinl' // truema.foo() // 执行foo方法&#125;// moduleC.jsvar mb = require('./moduleB')mb.bar() AMD使用场景、加载方式主要运行于浏览器端（Require.js实现） 异步加载，不会影响后面语句的执行 例子一个单独的文件就是一个模块，模块与模块的依赖可以异步加载 主要有4个命令 引用其他模块 定义 输出接口 对象 require define:全局函数，define(id?, dependencies?, factory) return define.amd 属性是一个对象，表明函数遵循AMD规范 12345678910111213141516171819// moduleA.jsdefine(['jQuery','lodash'], function($, _) &#123; var name = 'weiqinl', function foo() &#123;&#125; return &#123; name, foo &#125;&#125;)// index.jsrequire(['moduleA'], function(a) &#123; a.name === 'weiqinl' // true a.foo() // 执行A模块中的foo函数 // do sth...&#125;)// index.html&lt;script src="js/require.js" data-main="js/index"&gt;&lt;/script&gt; CMD使用场景、加载方式主要在浏览器运行，也可以在node.js运行（主要是Sea.js推广中形成的） 依赖就近，延迟执行。当程序执行到，才会自动加载 例子主要有4个命令 引用其他模块 定义 输出接口 使用 require define:全局函数，定义模块 exports seajs.use() 123456789101112131415161718192021222324// moduleA.js// 定义模块define(function(require, exports, module) &#123; var func = function() &#123; var a = require('./a') // 到此才会加载a模块 a.func() if(false) &#123; var b = require('./b') // 到此才会加载b模块 b.func() &#125; &#125; // do sth... exports.func = func;&#125;)// index.js// 加载使用模块seajs.use('moduleA.js', function(ma) &#123; var ma = math.func()&#125;)// HTML，需要在页面中引入sea.js文件。&lt;script src="./js/sea.js"&gt;&lt;/script&gt;&lt;script src="./js/index.js"&gt;&lt;/script&gt; UMD使用场景通用模块定义 模式，主要用来解决CommonJs和AMD代码不能通用的问题，并同时还支持老式的全局变量规范 一般用于webpack打包，output.libraryTarget 将模块以哪种规范的文件输出 例子123456789101112131415161718// 使用Node, AMD 或 browser globals 模式创建模块(function (root, factory) &#123;if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD模式. 注册为一个匿名函数 define(['b'], factory);&#125; else if (typeof module === 'object' &amp;&amp; module.exports) &#123; // Node等类CommonJS的环境 module.exports = factory(require('b'));&#125; else &#123; // 浏览器全局变量 (root is window) root.returnExports = factory(root.b);&#125;&#125;(typeof self !== 'undefined' ? self : this,function (b) &#123; // 以某种方式使用 b //返回一个值来定义模块导出。(即可以返回对象，也可以返回函数) return &#123;&#125;;&#125;)); 解析 1、判断 define 是否为函数，并是否存在 define.amd =&gt; AMD规范 2、判断 module 是否为一个对象，并是否存在 module.exports =&gt; CommonJs规范 3、如果以上两种都没有，设定为原始的代码规范 Es6Module注意的几个点1、同时兼容node环境，可以和CommonJs混合使用。 2、因为可以和CommonJs混合使用，有两点区别 CommonJs Es6 运行时加载确定输出接口 编译时确定输出接口 输出的是一个值的拷贝，输出后不能修改，会被缓存 输出的是一个值的引用，加载的时候会做静态优化（即模块内发生变化，import出的接口也会相应发生变化） 3、对于加载外部模块 模块之中，import命令加载其他模块，.js后缀不可省略 模块之中，顶层的this返回undefined，而不是window 同一个模块加载多次，讲只执行一次 主要有两个命令 引用其他模块 输出 import export/export default 加载方式浏览器加载1、外链js文件 2、内嵌到内页 1234&lt;script type="module"&gt; import utils from './utils.js'; // other code&lt;/script&gt; 名词区别加载方式 区别 名词 同步加载 异步加载 依赖就近，延迟执行 解释 需要等到依赖模块加载完成才编译执行(CommonJs) 哪一个模块小，就先执行哪一个(AMD) 当需要某个模块的时候再去再去异步加载（CMD） 不足 阻塞加载，当依赖的模块太大，浏览器会处于假死的状态 提前加载，依赖前置（要用到的模块，一开始就要写好） 1234567891011121314151617// AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;)// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) import、require、import()区别 require import import() CommonJs(moudule.exports/exports)、AMD(return)、CMD(exports)都用这个命令加载 es6加载(export/export.default) 同前 运行时调用，可以随处引入 编译时调用，必须放到文件开头，需要babel把es6转成es5 运行时调用，可以随处引入，异步加载 引入基础数据类型时，属于复制；引用复杂数据类型时，属于浅拷贝（值的拷贝） 值的引用，会跟随引入的模块一起变化 同前 运行时加载、编译时加载区别运行时加载默认export的是一个对象，输入时必须查找对象属性。 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致 完全没办法在编译时做“静态优化” 编译时加载ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 1import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高 总结 - CommonJs AMD CMD ES6 使用场景 服务器端:Nodejs 浏览器端:Require.js 服务器浏览器皆可:Sea.js 服务器浏览器皆可,还可以和CommonJs混用 定义 define define 暴露接口 moudlue.exports/exports return exports export/exportdefalut 引用 require require require import…form/import() 引用语句加载方式 运行时加载（那会才知道依赖的关系） 运行时加载 运行时加载 编译时加载(进行值的引用，可以静态优化，会跟随引入的模块一起变化；前面几种进行的是值的拷贝，输出后不能改变，得到的是缓存的结果)，静态加载，只能放在代码的最前面；但是import()为运行时加载，异步加载 依赖加载方式 同步加载 异步加载(提前加载，依赖前置)载 依赖就近，延迟执行 注意 es6-es5的转译，需要有babel，使用import()还需要额外的babel配置]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-import…form、import()区别]]></title>
    <url>%2F2019%2F05%2F28%2FEs6%2FES6-import%E2%80%A6form%E3%80%81import()%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言在咱们项目中，发现import会有两种形式写法 1234567import Vue form 'vue'routes: [ &#123; path: '/home', component: () =&gt; import('./sre/home.vue') &#125;] import…form、import()之间有啥区别呢？让我们揭开它们的面纱，let’s go 区别这两个都是Es6新增的特性，表示引用加载模块 import…form import() 静态加载：先于模块内的其他语句执行。所以import…form命令只能在模块的顶层，不能在代码块之中 动态加载：运行时执行，异步加载 Es6-Es5转译方面，只要有babel就行（webapce 配置 babel-loader） Es6-Es5转译方面，需要额外的babel配置 注意1、import() 函数加载模块成功后，这个模块会作为一个对象，当做then方法的参数(简单地说，就是会返回一个Promise对象)。因此，可以使用 对象解构赋值 的语法，获取输出接口 123import('./test.js').then( (&#123;export1, export2&#125;) =&gt; &#123; //...&#125;) 2、import() 函数可以用在async函数中 1234567891011async function main() &#123; const myModule = await import('./myModule.js'); const &#123;export1, export2&#125; = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);&#125;main();]]></content>
      <categories>
        <category>Es6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6-export、export default区别]]></title>
    <url>%2F2019%2F05%2F28%2FEs6%2FES6-export%E3%80%81export%20default%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言在项目中发现有的引用是这样的 12import &#123; test1 &#125; form 'foo1.js'import test2 form 'foo2.js' 怎么有的有花括号，有的没有呢？？？ 观察 foo1.js 和 foo2.js，会发现它们方法、变量的导出方式是不一样的 1234567foo1.jsexport const str = 'hello'foo2.jsexport default function isTest(str) &#123; return str&#125; 看来是因为，export和export default的原因 区别在es6中，export 和 export default均可以导出常量、函数、文件、模块等，我们可以在其他的文件或模块中使用 import 导入 在一个文件或模块中，export、import可以有多个，export default仅有一个 通过export方式导出，在导入时要加{}，export default不用 export可以直接导出变量表达式，export default不行]]></content>
      <categories>
        <category>Es6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6-Class探秘]]></title>
    <url>%2F2019%2F05%2F27%2FEs6%2FES6-Class%E6%8E%A2%E7%A7%98%2F</url>
    <content type="text"><![CDATA[前言总所周知，咱们传统的生成实例对象的方法是通过构造函数： 123456789101112function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = funciton() &#123; return `( $&#123;this.x&#125;, $&#123;this.y&#125; )`&#125;var p = new Point(1, 2);p.toString();//( 1,2 ) 现在 ES6 提供Class（类）的概念，一个语法糖，作为对象的模板。自从有了Class，咱们生成实例对象的写法就更加清晰，更像面对对象的语法。 123456789101112class Point &#123; constructor (x, y) &#123; this.x = x; this.y = y; &#125; toString () &#123; return `( $&#123;this.x&#125;, $&#123;this.y&#125; )` &#125;&#125;var p = new Point(1, 2);p.toString(); 解析：类里面有个constructor方法——构造方法，this指向实例对象；咱们ES5的构造函数Point就相当于ES6的Point类的constructor方法 定义方法，也只需要直接写在类里面就好了。构造函数的prototype属性，在类上依然存在。（类上的所有方法都定义在类的prototype属性上） 严格模式（注意）ES6里面默认是严格模式，只要代码写在类或模块里面，就只有严格模式可用哦。 深入Class的老窝constructor方法类的默认方法，new生成实例对象时，自动调用。如果没有自定义，会默认加上空的constructor（所以是类里必须的方法） 默认返回实例对象（this），也可以指定返回另一个对象 123456class Person &#123; constructoe () &#123; return Object.creat(null); &#125;&#125;new Person() instanceof Preson //false 判断实例是否为构造函数的实例 实例对象生成的方式仍然是new命令。注意：实例的属性除非是定义在this对象（显示定义在本身，constructor方法），否则都是定义在原型(类）上 12345678910111213141516class Point &#123; constructor (x, y) &#123; this.x = x; this.y = y; &#125; toString () &#123; return `( $&#123;this.x&#125;, $&#123;this.y&#125; )` &#125;&#125;var p = new Point(1, 2);Point.hasOwnProperty('x') //truePoint.hasOwnProperty('y') //truePoint.hasOwnProperty('toString') //falsePoint.__proto__.hasOwnProperty('toString') //true 表达式类可以用表达式的形式定义 12345const MyClass = class Me &#123; getClassName () &#123; return Me.name; &#125;&#125; 注意：这个类的名字叫MyClass而不是Me，Me只有在Class内部有定义 123let inst = new MyClass();inst.getClassName(); //MeMe.name //ReferenceError :Me is not defined 如果类的内部没有用到，可以省略Me 12345const MyClass = class &#123; getClassName () &#123; return ; &#125;&#125; 也可以写出立即执行Class 1234567891011let person = new class &#123; constructor (name) &#123; this.name = name; &#125; sayName () &#123; console.log(this.name); &#125;&#125;('zhangwei');person.sayName(); //zhangwei 不存在变量提升即类使用在在，定义在后会报错的。原因和继承相关，必须保证子类在父类之后定义。 this的指向如果类里面的某个方法有this，默认指向类的实例，但是如果把这个方法单独使用，会指向该方法运行时的环境，一般会指到window 123456789101112131415161718class Test &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const test = new Test();1、错误const &#123; printName &#125; = test;printName(); // TypeError: Cannot read property 'print' of undefined2、正确test.printName(); //Hello there getter和setter可以在类内部使用get和set，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 1234567891011121314class MyClass &#123; get prop() &#123; return 'getter'; &#125; set prop(value) &#123; console.log('setter: '+value); &#125;&#125;let inst = new MyClass();inst.prop = 123; // setter: 123inst.prop // 'getter' 静态方法、静态属性、实例属性（重中之重）类相当于实例的原型，所有类有的东西，都会被实例继承 1、静态方法 类自己的方法，不会被实例继承 使用方法：方法前面加 static关键字（此方法可以被类调用） 12345678910class Foo &#123; static classMethod () &#123; return 'hello'; &#125;&#125;Foo.classMethod(); //hellovar foo = new Foo();foo.classMethod(); // TypeError: foo.classMethod is not a function 注意1：静态方法的this指向类，而不是实例 12345678910111213class Foo &#123; static bar () &#123; this.baz(); //this指的是Foo类，baz()为静态方法 &#125; static baz () &#123; //静态方法可以与非静态方法重名 console.log('hello'); &#125; baz () &#123; console.log('world'); &#125;&#125;Foo.bar() // hello 注意2：父类的静态方法可以被子类继承；也可以从super对象上调用 2、静态属性和实例属性静态属性： 类自己的属性，不会被实例继承 因为ES6明确规定，class内没有静态属性，所以只有下面形式可行 123class Foo &#123;&#125;Foo.prop = 1;Foo.prop //1 但是ES7有一个提案：对静态属性和实例属性规定了新的写法。目前Babel转码器支持。 静态属性在属性前面加static关键字 123class Foo &#123; static prop = 1;&#125; 实例属性之前的实例属性只能写在类的construtor方法里 12345678class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; &#125; 现在写法更清晰 12345class ReactCounter extends React.Component &#123; state = &#123; count: 0 &#125;; &#125; 并且在constructor里面定义的实例属性，还可以直接列出 123456789class ReactCounter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; state;&#125;]]></content>
      <categories>
        <category>Es6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Npm填坑笔记]]></title>
    <url>%2F2019%2F05%2F24%2FNpm%2FNpm%E5%A1%AB%E5%9D%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.node版本不对 问题描述 npm i时，发现报错primordials is not defined. 原因 node 12版本太高，须降到稳定版10 解决 卸载node，安装nvm brew install nvm mkdir ~/.nvm; open ~/.zshrc 复制export NVM_DIR=”$HOME/.nvm” . “/usr/local/opt/nvm/nvm.sh” 到文件中， source ~/.zshrc nvm install 10.15.3 达到降版本的作用，以及npm也回来啦~2.安装Node、Mysql报错 123456问题1Error:Directory not empty @ dir_s_rmdir - /usr/local/opt/openssl解决sudo rm -rf /usr/local/opt/opensslbrew install openssl 123456问题2dyld:Library not loaded:/usr/local/opt/openssl/lib/libssl.1.0.0.dylib解决brew remove opensslbrew install openssl 12345678问题3If you need to have mysql@5.1 first in your PATH num:echo "export PATH='/USR/LOCAL/OPT...'" &gt;&gt; ~/.zshrc解决open ~/.zshrc复制路径到最后source ~/.zshrc]]></content>
      <categories>
        <category>Npm</category>
      </categories>
      <tags>
        <tag>填坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Npm、Cnpm、Nrm、Nvm]]></title>
    <url>%2F2019%2F05%2F24%2FNpm%2FNpm%E3%80%81Cnpm%E3%80%81Nrm%E3%80%81Nvm%2F</url>
    <content type="text"><![CDATA[前言项目中基本一定会使用到npm，以前的项目里还经常使用到cnpm（现在实习公司有自己的源，所以没有用cnpm了），又接触了nrm，今天就来揭开它的面纱！ npmnodejs的包管理器，用于node包管理（比如安装、卸载、管理依赖等，我们最常就是npm install） cnpmnpm安装包是从国外服务器下载，受网络影响大，所以经常咱实行npm install时，又有很多包，就会很慢很慢，还可能出现异常。淘宝团队整了一个npmjs.org镜像，同步频率10分钟一次，保证与官方服务同步，所以咱们使用cnpm速度更快！（界面：下载速度条 我也觉得更好看） nrm管理npm源的工具，比如npm源，cnpm源…通过这个工具，我们可以很方便的切换源，方便自己项目使用 查看源 nrm ls npm —- https://registry.npmjs.org/ cnpm — http://r.cnpmjs.org/ 使用指定源 nrm use [name] 跳转到源的官网 nrm home [name] nvm容易和nrm混淆，nvm是管理node版本的工具。之前项目里npm i失败，提示版本太高，为了降版本使用到的工具。 在安装它的时候，需要把node给卸载了 安装nvm brew install nvm mkdir ~/.nvm; open ~/.zshrc 复制export NVM_DIR=”$HOME/.nvm” . “/usr/local/opt/nvm/nvm.sh” 到文件中， source ~/.zshrc 下载想要的node版本 nvm install [版本号] 下载最新的node版本和与之对应的npm版本 nvm install latest 使用指定版本号的node nvm use [版本号] 查看有多少个版本号的node nvm list 卸载 nvm uninstall [版本号]]]></content>
      <categories>
        <category>Npm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开发小手册]]></title>
    <url>%2F2019%2F05%2F23%2F%E5%BC%80%E5%8F%91%2F%E5%BC%80%E5%8F%91%E5%B0%8F%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Html1&lt;a href='//hongbao.mogu.com/h5/list'&gt;&lt;/a&gt; 可以自适应 http、https 兜底开发中，时刻注意兜底，比如展示一个图片，要考虑到后台没有返回数据时的兜底；展示数据时，要做兼容处理 this.arr = result || [],不然会有很多报错，因为变量Undefined，页面无法渲染 GitFork在刚开始实习时，为了谨慎起见，学姐要求fork项目来进行开发，开发完毕，再到gitlab提mr，学姐查看完毕再合到正式的分支上，过程如下 先在项目中fork到自己的远程仓库 打开命令行，进入文件夹 git status 查看是否更改 git pull 更新远程仓库 git remote -v 查看关联的远程仓库的详细信息 一个别名仓库下会有两个地址 fetch 用于从远程仓库拉代码 push 用于向远程仓库提交代码 git remote add 别名 [fork的仓库地址] git push 别名 [远程仓库分支名] 在gitlab 进行和并提交 删除仓库信息 git remote remove 别名 建立并切换远程分支一种办法是直接在gitlab-Commits-Branches创建分支 一种是命令行建 clone代码后，新建且切换分支 git checkout -b feature/reason 提交时 git push -u origin feature/reason feature/reason commit123git commit -am === git commit -a -m == git add . git commit -mgit commit --amand 可以重写commit内容 查看Log树1git log --oneline --graph stash当自己在develop分支开发时，远端develop有新的更改，只需要把本地的修改stash，pull拉取远端的develop新代码后再pop出存起来的本地修改，会自动合并，有冲突会提示 微信小程序控制台诸多报错/卡掉/突然无数据返回重启微信开发者工具，重新导入项目，一次不行试两次，基本都是玄学问题 简单写法总结12this.$couponlist.setData(&#123;tabType&#125;) == this.$couponlist.setData(&#123;tabType:tabType&#125;)// 因为小程序赋值还挺麻烦的，需要setData,使用这种方法还是省力不少 当触发 点击事件 的按钮为遍历出来时1does not have a method 'logger' to handle event 'tap' 需要在绑定点击事件时：bindtap=”$.logger” vscode断点直接在代码中写一句debugger，断点完毕~ 开启 emmet语法1234567"emmet.triggerExpansionOnTab": true,"emmet.showAbbreviationSuggestions": true,"emmet.showExpandedAbbreviation": "always","emmet.includeLanguages": &#123; "vue-html": "html", "vue": "html"&#125; 开项目终端切到目录，直接code . CSS渐变线有时候标题两边会有渐变线，可以用css解决，linear-gradient默认是从上到下的顺序渐变，可以在第一个参数设置方向，然后是 颜色 从哪个地方开始变（很有用~） 1background-image: linear-gradient(-90deg, #FFFFFF 0%, #D8D8D8 100%); Reactconstructor及super constructor 表示父类的构造方法，用来新建父类的this对象，该方法是类中必须有的，如果没有显示定义，则会默认添加空的constructor( )方法。 super( )子类 必须 在 constructor( )调用 super( )方法，否则新建实例时会报错，因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法；子类就得不到this对象。 super()和super(props)的区别 就是你是否需要在构造函数内使用this.props，如果需要那么你就必须要写props，如果不需要，那么写不写效果是一样的 jsx不能实现常规的换行操作1234const html = reason.replace(/\&amp;/g,'&lt;br/&gt;')return ( &lt;div dangerouslySetInnerHTML=&#123;&#123;_html:html&#125;&#125;&gt;&lt;/div&gt;) JS简单写法总结123!isMoreloading &amp;&amp; this.setData(&#123;.&#125;) 相当于if(!isMoreloading) &#123;this.setData(&#123;.&#125;)&#125;reset(tabType='',isResetList=false) 可以设置默认参数 forEach不能break跳出循环，需要换成for循环1会报错 VM192:3 Uncaught SyntaxError: Illegal break statement 从数组中随机取指定数目的元素1234567891011121314function getRandomArrayElements(arr, count) &#123; var shuffled = arr.slice(0), i = arr.length, min = i - count, temp, index; while (i-- &gt; min) &#123; index = Math.floor((i + 1) * Math.random()); temp = shuffled[index]; shuffled[index] = shuffled[i]; shuffled[i] = temp; &#125; return shuffled.slice(min);&#125;var items = ['1','2','4','5','6','7','8','9','10'];console.log( getRandomArrayElements(items, 4) ); 过滤数组内不想要的元素在项目中比较常用到哦！比如把已经选择的元素从数组中剔除 1arr = arr.filter( item =&gt; item.emotionName != tab.emotionName) 操作系统端口占用12lsof -i :端口号kill 9 端口号 Npmnpm link当我们本地开发一个模块时，可以在模块里 1npm link 模块会被链接到全局，然后再到引用这个模块的项目里 1npm link 模块文件名 即可实现模块到项目的映射 头条小程序 不支持引入json文件，需要把数据放到js文件中，export default，然后在所需要的文件中import即可 不支持css嵌套书写，但支持element, element选择器，所以不必头疼命名啦 移动端输入框上下跳动有试过类似滑动卡片效果的项目，里面有输入框，当移动端书写的时候，输入法上有 上/下 跳动的按钮，如果用户点击 上/下，会相应跳到 上/下 的输入框，因为是滑动卡片，所以也会相应跳到上/下一个卡片，体验非常不好。 解决：需要把输入框的上下跳转禁掉；把输入框全部置为disabled，点击的当前输入框移除disabled属性即可。]]></content>
      <categories>
        <category>开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2019%2F04%2F23%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[定义一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到该资源，这种现象称为进程死锁，这一组进程就称为死锁进程 产生死锁的原因 竞争资源 进程推进顺序非法 产生死锁的必要条件 互斥条件：涉及的资源是非共享的。 不剥夺条件：不能强行剥夺进程拥有的资源。 部分分配条件：进程在等待一新资源时继续占有已分配的资源。 环路条件：存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中的下一个进程所请求。 理解解决死锁的方法 预防：破坏四个必要条件中的１个或ｎ个，包括资源的一次性分配、新申请资源得不到剥夺之前的资源和资源的有序分配等。 避免：防止系统进入不安全状态（银行家算法） 检测：资源分配图（死锁定理） 解除：剥夺资源、撤销]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BOM&DOM]]></title>
    <url>%2F2019%2F04%2F17%2FJavaScript%2FBOM%26DOM%2F</url>
    <content type="text"><![CDATA[BOM &amp; DOMBOM 浏览器对象模型有window、location、history、screen等对象window常用的方法：open() 打开一个新的资源。moveTo() 将窗口左上角的屏幕位置移动到指定的 x 和 y 位置。 moveBy() 相对于当前的窗口移动指定的 x 和 y 偏移值(左上角)。 setInterval() 每隔指定的毫秒数指定指定的代码。 setTimeout（） 经过指定毫秒数指定一次指定的代码。 DOM 文档对象模型 当一个html页面加载到浏览器的时候,那么浏览器会为每个标签都创建一个对应的对象描述该标签的所有信息，那么我们看到的网页信息实际上就是看到了这些标签对象的信息、 如果我们需要操作页面的数据，那么我们就可以通过这些标签对象进行操作。 Global对象 &amp; window对象Global对象 单体内置对象，即不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了，就是一切全局里存在的变量和函数都是它的属性和方法。也就是那些在宿主环境（常见的宿主环境：浏览器和nodejs）里所有的内建或自定义的变量和函数全局都是Global这个的全局对象和方法。它更像是一个抽象概念，而要指明它是什么，取决于程序在什么环境中运行。（例如：js不仅可以书写页面，在书写页面中，global相对于浏览器这个环境而言就是window，但是其他环境就不一定了） window对象 是相对于Web浏览器而言的，它并不是ECMAScript规定的内置对象，它是浏览器的Web API,是存在于浏览器之中的，也就是离开浏览器这个宿主环境的话就不存在此对象了。 《JavaScript高级程序设计第3版》：在所有代码执行之前，作用域中就存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象，不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Globla对象的属性。 结论JavaScript中的window对象扮演ECMAScript中的Global对象，所以Global对象包含着window对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2019%2F04%2F09%2FGit%2Fgit%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[fetch和merge和pull的区别 pull相当于git fetch 和 git merge，即更新远程仓库的代码到本地仓库，然后将内容合并到当前分支。 git fetch：相当于是从远程获取最新版本到本地，不会自动merge git merge : 将内容合并到当前分支 git pull：相当于是从远程获取最新版本并merge到本地 git merge和git rebase的区别都是从一个分支获取并且合并到当前分支。 比如在一个feature分支进行新特性的开发，与此同时，master 分支的也有新的提交。 此时在feature上git 自动会产生一个新的commit(merge commit) marge 特点：自动创建一个新的commit 如果合并的时候遇到冲突，仅需要修改后重新commit 优点：记录了真实的commit情况，包括每个分支的详情 缺点：因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。 rebase 本质是变基 rebase 特点：会合并之前的commit历史 优点：得到更简洁的项目历史，去掉了merge commit 缺点：如果合并出现代码问题不容易定位，因为re-write了history 合并时如果出现冲突需要按照如下步骤解决 修改冲突部分 git add git rebase –continue （如果第三步无效可以执行 git rebase –skip） git commit 撤销git add . //添加所有文件 git commit -m “本功能全部完成” 执行完commit后，想撤回commit，怎么办？ 这样凉拌： git reset –soft HEAD^ HEAD^的意思是上一个版本，也可以写成HEAD~1 如果你进行了2次commit，想都撤回，可以使用HEAD~2 –mixed 意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作 这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 –soft 不删除工作空间改动代码，撤销commit，不撤销git add . –hard 删除工作空间改动代码，撤销commit，撤销git add . 注意完成这个操作后，就恢复到了上一次的commit状态。 顺便说一下，如果commit注释写错了，只是想改一下注释，只需要： git commit –amend 此时会进入默认vim编辑器，修改注释完毕后保存就好了。 reset revert reset 回退到目标版本后，之前的版本没有了，head指向目标版本。需要强制push -f revert 会反做一个和目标版本内容一致的版本，head指向新的版本 revert -n 版本号 可能要处理冲突 为啥要有暂存区方便将需要添加的文件才添加，如果没有暂存区，就是全部提交，如果一些文件的修改不需要提交，就得一个个修改后，再提交。 放弃本地更改git checkout .]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[undefined&null&NaN]]></title>
    <url>%2F2019%2F04%2F09%2FJavaScript%2FUndefined_Nul_NAN%2F</url>
    <content type="text"><![CDATA[数据类型的区别undefined和null是两个基本类型 存在场景不同undefined是未初始化变量的值 null通常用来标识一个空对象 typeof(undefined) ==undefined typeof(null) ==object 判断undefined方法typeof() 判断null方法typeof(x) !=’undefined’ &amp;&amp; !x &amp;&amp; x!=0 (x为false有3种情况：0 undefined null 空字符串’’等于0) 其他10 + null = 10 10 + undefined = NaN undefined == true //false undefined == false //false null == true //false null == false //false]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js和jq语句]]></title>
    <url>%2F2019%2F04%2F02%2FJavaScript%2FjQuery%2Fjs%26jq%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[JQ JS 获取 $(#h1)$(.h1)$(‘.classTag1’)[0].tagName; document.getElementById()document.getElementsByClassName()document.getElementsByTagName() 创建 var h1 = $(‘‘) var h1 = document.createElement(‘‘) 添加 before() insertBefore() 插入前面append() appendTo() 插入尾部prepend() prependTo() 插入父元素的最前面after() insertAfter() 插入后面 document.insertBefore(h1) 头部添加document.appendChild(h1) 尾部添加 移除 remove()html()empty() document.removeChild(h1) 删除子元素h1.remove() 删除本身 复制 clone() var h = h1.cloneNode() 查找 find() 查找子级 children()查找子级们siblings()查找同级 contents()查找文本节点prev()查找上一级节点 prevAll()查找上一级节点们next()查找下一级节点 nextAll()查找下一级节点们first()第一个节点 last()最后一个节点伪类查找$(‘xxx’):first 查找第一个节点 $(‘xxx’):last 查找最后一个节点$(‘xxx’):eq(‘下标’)查找指定节点$(‘xxx’):not(‘.xxx’)查找不含有同级节点 $(‘xxx’):has(‘.xxx’)查找含有该节点的元素$(‘xxx’):gt(‘下标’)查找大于指定下标节点 $(‘xxx’):lt(‘下标’)查找小于指定下标节点$(‘xxx’):odd查找奇数倍节点 $(‘xxx’):even 查找偶数倍节点 childNodes 元素节点和文本节点children 元素节点 firstChild 获取第一个节点（文本节点也算）firstElementChild 文本节点不算，推荐 lastChild lastElementChild获取最后一个节点previousSibling previousElementChild 获取上一个节点nextSibling nextElementSibling 获取下一个节点siblings 获取同级节点]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单页面应用与多页面应用]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2F%E5%8D%95%26%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言单页面应用，多页面应用是什么？ 单页面应用（SinglePage Web Application，SPA）只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站 如图: 单页面应用结构视图 多页面应用（MultiPage Application，MPA）多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等 如图： 多页面应用结构视图]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深浅拷贝浅拷贝和深拷贝的区别数据都是存储在内存当中，而我们调用数据的时候都是通过地址（指针）来调用数据。 对于浅拷贝来说，比如一个数组（数组是一种对象），只要我们修改了一个拷贝数组，那么原数组也会改变！ 因为他们引用的是同一个地址的数据！拷贝的时候并没有给b数组创造独立的内存，只是把a数组指向数据的 指针 拷贝给了b！ 而深拷贝就与其相反，将会给b数组创造独立的内存，并且将a数组的内容一一拷贝进来，两者互不影响。 浅拷贝和深拷贝的原理浅拷贝和深拷贝一般是对于引用类型值（如对象）来讲的，而基本类型值（如undefined、null、number、string、boolean以及es6新增的Symbol），只要是复制，就一定是另开辟以存储空间！ ①基本数据类型存储：名值都存在栈内存中 如let a = 1; 当let b = a时，b复制了a，栈内存会新开辟一个内存 所以两者互不影响，修改谁都没问题！ ②引用数据类型：名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值 b复制了a后，b是引用了a的值的存储地址，而不是把a的值复制了下来！ 所以改了b，a也会受到影响。 实现浅拷贝：也就是只复制了第一层属性，复制对象是基本类型 在复制基本类型时，直接使用等号完成，在复制引用类型时，循环遍历对象，对每个属性或值使用等号完成。 12345678var color1 = ['red','green']; var color2 = []; //复制for(var i = 0;i &lt; color1.length;i++)&#123; color2[i] = color1[i]; &#125; console.log(color2); //[red,green] color1.push('black'); console.log(color2); //[red,green] 深拷贝：对属性中所有引用类型的值，遍历到是基本类型的值为止，利用递归来实现深拷贝。 1234567891011121314function cloneObject (obj) &#123; var newObj = &#123;&#125; //如果不是引用类型，直接返回 if (typeof (obj) !== 'object') &#123; return obj &#125; //如果是引用类型，遍历属性 else&#123; for (var attr in obj) &#123; //如果某个属性还是引用类型，递归调用 newObj[attr] = cloneObject(obj[attr]) &#125; &#125; return newObj &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构是计算机存储、组织数据的方式。 数组 栈 队列 链表 树 图 字典 树（这是一种高效的树形结构，但值得单独说明） 散列表（哈希表） 数组和链表的区别不同： 1、链表是链式的存储结构；数组是顺序的存储结构。 2、链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。 3、链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难； 4、数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。 相同：两种结构均可实现数据的顺序存储，构造出来的模型呈线性结构。 链表与队列的区别1、链表可以说是一种存储方式，保存的数据在内存中不连续的，用指针对数据进行访问。 2、队列是一种数据结构，特点是先进先出，后进后出，队列的存储方式可以用线性表或链表存储 判断链表是否有环设置两个指针，开始都指向链表头，然后一个指针每次向前走一步，另一个指针每次向前走两步，如果快的遇到了NULL，证明无环。如果两个指针相等，相遇了，说明存在环 bool HasCircle(ListNode * pHead) { ListNode * pFast = pHead; // 快指针每次前进两步 ListNode * pSlow = pHead; // 慢指针每次前进一步 while(pFast != NULL &amp;&amp; pFast-&gt;next != NULL) { pFast = pFast-&gt;next-&gt;next; pSlow = pSlow-&gt;next; if(pSlow == pFast) // 相遇，存在环 return true; } return false; } 栈和队列LIFO后进先出 入栈:push 出栈:pop方法 FIFO先进先出 队列:ushift和pop方法 ①堆（数据结构）：堆可以被看成是一棵树，如：堆排序。 ②栈（数据结构）：一种先进后出的数据结构。 堆、栈、队列之间的区别是？①堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 ②栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来。（后进先出） ③队列只能在队头做删除操作,在队尾做插入操作.而栈只能在栈顶做插入和删除操作。（先进先出） JS数据结构栈和堆栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。 基本类型：String，Number，Boolean，Null，Undefined 堆(heap):动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。 引用类型：Function，Array，Object 区别栈：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。 优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享； 缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 堆：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(参数传递)。创建对象是为了反复利用，这个对象将被保存到运行时数据区。 深度遍历和广度遍历二叉树有深度遍历和广度遍历， 深度遍历有前序、 中序和后序三种遍历方法。二叉树的前序遍历可以用来显示目录结构等；中序遍历可以实现表达式树，在编译器底层很有用；后序遍历可以用来实现计算目录内的文件及其信息等。 前序遍历：访问根–&gt;遍历左子树–&gt;遍历右子树; 中序遍历：遍历左子树–&gt;访问根–&gt;遍历右子树; 后序遍历：遍历左子树–&gt;遍历右子树–&gt;访问根; 广度遍历：按照层次一层层遍历;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型链]]></title>
    <url>%2F2019%2F03%2F20%2FJavaScript%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型对象 每个函数都有 prototype属性，指向它的原型对象；原型对象有一个constructor属性，指向函数 用构造方法创建一个新对象后，这个对象默认有个 _pro_属性，指向构造方法的原型对象 原型链当试图访问一个对象的属性时，如果没有在该对象上找到，他还会搜索该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾 新建对象用 new Object 或者 {} 建的对象是普通对象，它没有prototype属性，只有 proto 属性，它指向Object.prototype 1tsrot -&gt; Person.prototype -&gt; Object.prototype -&gt; null 如果没有定义Person.prototype这一环，则直接跳到下一环 ObjectObject 是一个函数对象，Object 的原型就是一个 Object对象。里面存在着一些对象的方法和属性，例如最常见的 toString 方法 1o -&gt; Object.prototype -&gt; null ArrayArray 也是一个函数对象，它的原型就是 Array.prototype。里面存在着一些数组的方法和属性，例如常见的 push，pop 等方法。 1arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null FunctionFunction 也是一个函数对象，但它有点特殊，它的原型就是一个 function 空函数。 1fun -&gt; Function.prototype -&gt; Object.prototype -&gt; null 自定义函数它的原型就是给它指定的那个东西。如果不指定，那它的原型就是一个Object.prototype。 如何确定原型与实现机制的关系？isPrototypeOf()作用：检测一个对象是否存在于另一个对象的原型链上 12345678910111213var p = &#123;x:1&#125;;//定义一个原型对象var o = Object.create(p);//使用这个原型创建一个对象// 通过 Object.create() 创建的对象使用第一个参数作为原型p.isPrototypeOf(o);//=&gt;true：o继承p// 对象使用 Object.prototype 作为原型Object.prototype.isPrototypeOf(p);//=&gt; true p继承自Object.prototypefunction Animal()&#123; this.species = "动物"; &#125;;var eh = new Animal();// 通过new创建的对象使用 构造函数的prototype 属性作为原型Animal.prototype.isPrototypeOf(eh)//=&gt;true instanceof作用：检测原型链的对象是否存在于指定对象实例中 123var d = new Date();d instanceof Date;//=&gt;true d是Date的实例d instanceof Object;//=&gt;true 所有对象都是Object的实例 区别 A.isPrototypeOf(B) 判断的是A对象是否存在于B对象的原型链之中 A instanceof B 判断的是 B.prototype 是否存在于A的原型链之中，可以检测 一个对象是否是另一个对象的实例 A.isPrototypeOf(B) 为true，则 B instanceof A 一定返回true 怎么遍历一个对象上不是原型上的所有属性呢hasOwnPropertyNames]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[slice 与 splice 区别]]></title>
    <url>%2F2019%2F03%2F19%2FJavaScript%2Fslice%E4%B8%8Esplice%2F</url>
    <content type="text"><![CDATA[前言经常会弄混它俩，最后做一次区别 区别表 slice splice 作用 选取元素，返回一个从start，到end（不包含该元素）的数组，不会改变原数组 删除或添加元素，返回被删除的数组，会改变原数组 语法 slice(star, end) splice(index, howmany, item1,…itemX) start参数：必须，规定从何处开始选取，如果为负数，规定从数组尾部算起的位置，-1是指最后一个元素。 end参数：可选（如果该参数没有指定，那么切分的数组包含从start倒数组结束的所有元素，如果这个参数为负数，那么规定是从数组尾部开始算起的元素）。 index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。 howmany参数：必须，要删除的数量，如果为0，则不删除项目。 tem1,…itemX参数：可选，向数组添加的新项目。 var arr = [1,2,3,4,5]; console.log(arr.slice(1));// [2,3,4,5] 选择序列号从1到最后的所有元素组成的新数组。 console.log(arr.slice(1, 3));// [2,3] 不包含end，序列号为3的元素console.log(arr.slice(0, -1));// [1,2,3,4] 从开始到结束，不包含最后一个 var arr = [1,2,3,4,5]; console.log(arr.splice(2,1,”hello”));//[3] 返回的新数组 console.log(arr);//[1, 2, “hello”, 4, 5] 改变了原数组]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-双向绑定]]></title>
    <url>%2F2019%2F03%2F18%2FVue%2FVue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前言Vue 是采用 数据劫持 结合 发布者-订阅者模式的方法，通过 Object.definedProperty() 来劫持各个属性的 setter、getter，在数据变化时发布消息给订阅者，触发相应的监听回调 具体步骤第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher 订阅者 是 Observer 和 Compile 之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 update() 方法 3、待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile中绑定的回调 第四步：MVVM **作为数据绑定的入口，整合 Observer、Compile 和 Watcher三者**，通过 Observer 来监听自己的model数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue-生命周期]]></title>
    <url>%2F2019%2F03%2F18%2FVue%2FVue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期 beforeCreate（创建前） created（创建后） beforeMount(载入前) mounted（载入后） beforeUpdate（更新前） updated（更新后） activated （keep-alive 激活用） deactivated（keep-alive 移除用） beforeDestroy（销毁前） destroyed（销毁后） keep-aliveVue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染dom include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 父子组件的生命周期顺序加载渲染过程1父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 子组件更新过程1父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 父组件更新过程1父beforeUpdate-&gt;父updated 销毁过程1父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[什么是浏览器缓存把已经请求过的资源拷贝一份副本存储在浏览器中，当下次请求相同的 URL 时，就会根据缓存机制，判断是否读取缓存还是再向服务器发出请求 浏览器缓存机制核心：根据响应的 header内容 决定 是强缓存（本地缓存）还是 协商缓存 浏览器在请求某一资源时，会先获取该资源缓存的 header 信息，根据 cache-control和expires信息，判断是否命中强缓存。如果命中，则直接在本地缓存中获取资源信息，包括缓存的 header 信息，这次请求不会与服务器进行通信 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的 header 信息（Last-Modified/If-Modified-Since 或 Etag/If-None-Match），由服务器比对结果是否命中协商缓存。如果命中，则服务器更新缓存中对应的 header信息，返回304 Not Modified，但并不返回资源内容；如果没有命中，则返回最新的资源内容 强缓存相关的header字段 expires：一个绝对时间的 GMT格式 的时间字符串 cache-control：max-age=number 利用该字段的 max-age 值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行 cache-control，优先级比 expires 大 两者一起使用时，Cache-Control/Expires 的优先级要高于 Last-Modified/ETag 协商缓存相关的header字段这两组搭档都是成对出现的：第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match）；若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。 一般情况下，使用 Cache-Control/Expires 会配合 *Last-Modified/ETag 一起使用，因为即使服务器设置缓存时间, *当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销 Last-Modified/If-Modified-Since 服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和 资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容 当服务器返回304 Not Modified的响应时，响应 header 中不会再添加 Last-Modified 的header：因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回304时的 响应 header 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified 的 Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值 Etag/If-None-Match 这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，响应 header 会更新 Etag Last-Modified 与 ETag 区别HTTP1.1中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。 怎么知道资源已被修改，更新核心：比对If-Modified-Since 或 If-None-Match 和资源在服务器上的最后修改时间 服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容 CDN缓存策略主要作用：加速网络访问，本质仍然是一个缓存 在浏览器和服务器，加上一层CDN： 浏览器先检查是否有本地缓存、是否过期，如果过期，则向 CDN边缘节点 发起请求，CDN边缘节点 会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求，来拉取最新的数据 CDN网络是在用户和服务器之间增加缓存层，将用户的访问请求引导到最优的缓存节点而不是服务器源站点，从而加速访问速度。（负载均衡和缓存，距离一次http最起码三次握手四次挥手。7个来回的链接，距离的时延是指数增长的）]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[html新特性]]></title>
    <url>%2F2019%2F03%2F15%2FHtml%2Fhtml5%2F</url>
    <content type="text"><![CDATA[语义标签html语义化是使用一些语义化的标签来定义html的结构。 标签 描述 定义了文档的头部区域 定义了文档的尾部区域 定义文档的导航 定义文档中的节（section、区段） 定义页面独立的内容区域 定义页面的侧边栏内容 用于描述文档或文档某个部分的细节 标签包含 details 元素的标题 定义对话框，比如提示框 代码结构: 使页面没有css的情况下，也能够呈现出很好的内容结构 有利于SEO: 爬虫依赖标签来确定关键字的权重，因此可以和搜索引擎建立良好的沟通，帮助爬虫抓取更多的有效信息 提升用户体验： 例如title、alt可以用于解释名称或者解释图片信息，以及label标签的灵活运用。 便于团队开发和维护: 语义化使得代码更具有可读性，让其他开发人员更加理解你的html结构，减少差异化。 方便其他设备解析: 如屏幕阅读器、盲人阅读器、移动设备等，以有意义的方式来渲染网页。 增强型表单HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证。 输入类型 描述 color 主要用于选取颜色 date 从一个日期选择器选择一个日期 datetime 选择一个日期（UTC 时间） datetime-local 选择一个日期和时间 (无时区) email 包含 e-mail 地址的输入域 month 选择一个月份 number 数值的输入域 range 一定范围内数字值的输入域 search 用于搜索域 tel 定义输入电话号码字段 time 选择一个时间 url URL 地址的输入域 week 选择周和年 HTML5 也新增以下表单元素 表单元素 描述 &lt;datalist&gt; 元素规定输入域的选项列表使用 &lt;input&gt; 元素的 list 属性与 &lt;datalist&gt; 元素的 id 绑定 &lt;keygen&gt; 提供一种验证用户的可靠方法标签规定用于表单的密钥对生成器字段。 &lt;output&gt; 用于不同类型的输出比如计算或脚本输出 HTML5 新增的表单属性 placehoder 属性，简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。 required 属性，是一个 boolean 属性。要求填写的输入域不能为空 pattern 属性，描述了一个正则表达式用于验证&lt;input&gt; 元素的值。 min 和 max 属性，设置元素最小值与最大值。 step 属性，为输入域规定合法的数字间隔。 height 和 width 属性，用于 image 类型的 &lt;input&gt; 标签的图像高度和宽度。 autofocus 属性，是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。 multiple 属性 ，是一个 boolean 属性。规定&lt;input&gt; 元素中可选择多个值。 视频和音频 HTML5 提供了播放音频文件的标准，即使用 &lt;audio&gt; 元素&lt;audio controls\&gt; &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;\&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;\&gt; 您的浏览器不支持 audio 元素。 &lt;/audio\&gt; control 属性供添加播放、暂停和音量控件。 在&lt;audio&gt; 与 &lt;/audio&gt; 之间你需要插入浏览器不支持的&lt;audio&gt;元素的提示文本 。 元素允许使用多个 元素. 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件 目前, &lt;audio&gt;元素支持三种音频格式文件: MP3, Wav, 和 Ogg HTML5 规定了一种通过 video 元素来包含视频的标准方法。 &lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;您的浏览器不支持Video标签。&lt;/video&gt; control 提供了 播放、暂停和音量控件来控制视频。也可以使用dom操作来控制视频的播放暂停，如 play() 和 pause() 方法。 同时 video 元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。 与 标签之间插入的内容是提供给不支持 video 元素的浏览器显示的。 video 元素支持多个source 元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式（ MP4, WebM, 和 Ogg） Canvas绘图 标签只是图形容器，必须使用脚本来绘制图形。 Canvas - 图形 创建一个画布，一个画布在网页中是一个矩形框，通过 &lt;canvas&gt; 元素来绘制。默认情况下 元素没有边框和内容。 标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小，使用 style 属性来添加边框。你可以在HTML页面中使用多个 元素 使用Javascript来绘制图像，canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成 &lt;script&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.fillStyle=&quot;#FF0000&quot;; ctx.fillRect(0,0,150,75); &lt;/script&gt; getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 设置 fillStyle 属性可以是CSS颜色，渐变，或图案。fillStyle默认设置是#000000（黑色）。fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)。 Canvas - 路径 moveTo(x,y) 定义线条开始坐标 lineTo(x,y) 定义线条结束坐标 绘制线条我们必须使用到 “ink” 的方法，就像stroke()。 &lt;script&gt; var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); ctx.moveTo(0,0); ctx.lineTo(200,100); ctx.stroke(); &lt;/script&gt; 定义开始坐标(0,0), 和结束坐标 (200,100). 然后使用 stroke() 方法来绘制线条 Canvas - 文本 使用 canvas 绘制文本，重要的属性和方法如下： font - 定义字体 fillText(text,x,y) - 在 canvas 上绘制实心的文本 strokeText(text,x,y) - 在 canvas 上绘制空心的文本 使用 fillText(): var c=document.getElementById(&quot;myCanvas&quot;);var ctx=c.getContext(&quot;2d&quot;);ctx.font=&quot;30px Arial&quot;;ctx.fillText(&quot;Hello World&quot;,10,50) 使用 “Arial” 字体在画布上绘制一个高 30px 的文字（实心） Canvas - 渐变 渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。 以下有两种不同的方式来设置Canvas渐变： createLinearGradient(x,y,x1,y1) - 创建线条渐变 createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变 当我们使用渐变对象，必须使用两种或两种以上的停止颜色。 addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1. 使用渐变，设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条线。 var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); // Create gradientvar grd=ctx.createLinearGradient(0,0,200,0); grd.addColorStop(0,&quot;red&quot;);grd.addColorStop(1,&quot;white&quot;); // Fill with gradientctx.fillStyle=grd;ctx.fillRect(10,10,150,80); 创建了一个线性渐变，使用渐变填充矩形 Canvas - 图像 把一幅图像放置到画布上, 使用 drawImage(image,x,y) 方法 var c=document.getElementById(&quot;myCanvas&quot;); var ctx=c.getContext(&quot;2d&quot;); var img=document.getElementById(&quot;scream&quot;); ctx.drawImage(img,10,10); 把一幅图像放置到了画布上 (5)SVG绘图 SVG是指可伸缩的矢量图形 SVG 与 Canvas两者间的区别 SVG 是一种使用 XML 描述 2D 图形的语言。 Canvas 通过 JavaScript 来绘制 2D 图形。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 地理定位HTML5 Geolocation（地理定位）用于定位用户的位置。 window.navigator.geolocation { getCurrentPosition: fn 用于获取当前的位置数据 watchPosition: fn 监视用户位置的改变 clearWatch: fn 清除定位监视 } 获取用户定位信息： navigator.geolocation.getCurrentPosition( function(pos){ console.log(‘用户定位数据获取成功’) //console.log(arguments); console.log(‘定位时间：’,pos.timestamp) console.log(‘经度：’,pos.coords.longitude) console.log(‘纬度：’,pos.coords.latitude) console.log(‘海拔：’,pos.coords.altitude) console.log(‘速度：’,pos.coords.speed) }, //定位成功的回调 function(err){ console.log(‘用户定位数据获取失败’) //console.log(arguments); }//定位失败的回调 ) 拖放API拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。 拖放的过程分为源对象和目标对象。源对象是指你即将拖动元素，而目标对象则是指拖动之后要放置的目标位置。 拖放的源对象(可能发生移动的)可以触发的事件——3个 dragstart：拖动开始 drag：拖动中 dragend：拖动结束 整个拖动过程的组成： dragstart1 + dragn + dragend*1 拖放的目标对象(不会发生移动)可以触发的事件——4个 dragenter：拖动着进入 dragover：拖动着悬停 dragleave：拖动着离开 drop：释放 整个拖动过程的组成1： dragenter1 + dragovern + dragleave*1 整个拖动过程的组成2： dragenter1 + dragovern + drop*1 dataTransfer：用于数据传递的“拖拉机”对象 在拖动源对象事件中使用e.dataTransfer属性保存数据： e.dataTransfer.setData( k, v )在拖动目标对象事件中使用e.dataTransfer属性读取数据： var value = e.dataTransfer.getData( k )(8)Web Worker 当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。 web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 首先检测浏览器是否支持 Web Worker if(typeof(Worker)!==&quot;undefined&quot;){ // 是的! Web worker 支持! // 一些代码..... }else{ // //抱歉! Web Worker 不支持 }下面的代码检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码 if(typeof(w)==&quot;undefined&quot;) { w=new Worker(&quot;demo_workers.js&quot;); }然后我们就可以从 web worker 发送和接收消息了。向 web worker 添加一个 “onmessage” 事件监听器： w.onmessage=function(event){ document.getElementById(&quot;result&quot;).innerHTML=event.data; }; 当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。 如需终止 web worker，并释放浏览器/计算机资源，使用 terminate() 方法。 Web Storage使用HTML5可以在本地存储用户的浏览数据。早些时候,本地存储使用的是cookies。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能。数据以 键/值 对存在, web网页的数据只允许该网页访问使用。 客户端存储数据的两个对象为： localStorage - 没有时间限制的数据存储 sessionStorage - 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。 在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage if(typeof(Storage)!==&quot;undefined&quot;) { // 是的! 支持 localStorage sessionStorage 对象! // 一些代码..... } else { // 抱歉! 不支持 web 存储。 } 不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）： 保存数据：localStorage.setItem(key,value); 读取数据：localStorage.getItem(key); 删除单个数据：localStorage.removeItem(key); 删除所有数据：localStorage.clear(); 得到某个索引的key：localStorage.key(index); WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。]]></content>
      <categories>
        <category>Html</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打印和编程]]></title>
    <url>%2F2019%2F03%2F15%2F%E4%BB%A3%E7%A0%81%E9%A2%98%2F%E6%89%93%E5%8D%B0%26%E4%BB%A3%E7%A0%81%E9%A2%98%2F</url>
    <content type="text"><![CDATA[打印 promise123456789101112131415161718192021console.log('a')setTimeout(() =&gt;&#123; console.log('b')&#125;,0)new Promise((resolve)=&gt;&#123; console.log('c') resolve()&#125;).then(()=&gt;&#123; console.log('d')&#125;)new Promise((resolve)=&gt;&#123; console.log('e') resolve()&#125;).then(()=&gt;&#123; console.log('f')&#125;)setTimeout(() =&gt;&#123; console.log('g')&#125;,0)console.log('h')//acehdfbg this12345678910var obj = &#123; func: function()&#123; console.log(this) &#125;&#125;var func1 = obj.funcobj.func()func1()//&#123;func: ƒ&#125;func: ƒ ()arguments: nullcaller: nulllength: 0name: "func"prototype: &#123;constructor: ƒ&#125;__proto__: ƒ ()[[FunctionLocation]]: VM2010:2[[Scopes]]: Scopes[1]__proto__: Object//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125; 代码题匹配qq号1String regex = "[1-9][0-9]&#123;4,14&#125;"; // 第一位1-9之间的数字，第二位0-9之间的数字，数字范围4-14个之间 在一段英文中找出出现频率最高的单词12345678910111213141516function counts(article)&#123; article = article.trim().toUpperCase(); var array = article.match(/[A-z]+/g); article = " "+array.join(" ")+" "; var max = 0,word,num = 0,maxword=""; for(var i = 0; i &lt; array.length; i++) &#123; word = new RegExp(" "+array[i]+" ",'g'); num = article.match(word).length; if(num&gt;max)&#123; max=num; maxword = array[i]; &#125; &#125; console.log(maxword+" "+max); &#125; counts("Age has reached the end of the beginning of a word. May be guilty in his seems to passing a lot of different life became the appearance of the same day;"); 数组去重12345678910111213141516// 最简单数组去重法 /* * 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中 * IE8以下不支持数组的indexOf方法 * * */ function uniq(array)&#123; var temp = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++)&#123; if(temp.indexOf(array[i]) == -1)&#123; temp.push(array[i]); &#125; &#125; return temp; &#125; var aa = [1,2,2,4,9,6,7,5,2,3,5,6,5]; console.log(uniq(aa)); 千位符分割1(1234567.8).toLocaleString() "1,234,567.8" 字符串反转1string.split('').reverse().join('') 字符串变数组1split('') 数组变字符串1join('')]]></content>
      <categories>
        <category>代码题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ElementUI]]></title>
    <url>%2F2019%2F03%2F15%2FVue%2FElement%2FelementUi%2F</url>
    <content type="text"><![CDATA[表格组件怎么使用？它有哪些属性？答：用一个&lt; /el-table&gt;这个是最外面的上面，里面用。属性：一、el-table组件的data是用来获取数据；二、每一行el-table-row的数据通过prop属性。 计数器组件怎么使用？答：首先引入ui框架，然后放的vue里面写 表单组件怎么使用？它有哪些属性？答：先写el-form组件，里面写el-form-item用来放输入框，例如用户名和密码那些。 属性：一、el-from属性有ref、rules、绑定:model二、el-form-item属性有prop用来定义一个该输入框对应的验证规则 表单验证怎么实现？答：表单验证 *一、在一开始el-form中绑定:model=”a”，遵守一个规则:rules=”规则名b”，然后:ref跟之前的a一样值，要遵守规则的数据名。二、在data中定义a，里面放表单的所有数据。三、在data属性中定义rules规则，例如：必须填写就是required:true，最小最大就是min和max。四、里面放el-form-item，上面定义prop取一个名字等于什么，rules中用这个prop里面定义的名字作为规则属性。五、若要自定义规则，首先在rules的规则中定义validata属性，它的值就是自定义规则的名称，然后在data里写 var 自定义规则名称 = (rule,value,callback)=&gt; 如果校验正确就返回callback()，校验错误就返回callback(ne Error(‘有误！’))]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-新特性]]></title>
    <url>%2F2019%2F03%2F14%2FEs6%2FES6-%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1、let const引入块级作用域的概念；ES6前，Js 没有块级作用域 {} 的概念 let 与 var 与 const 区别 let、const 都是 ES6 新提出的命令 都是块级作用域，只在命令所在的代码块内有效 不会变量提升 var 不是块级作用域 会变量提升：在函数中央声明变量，实际上整个函数域都会有效，会造成 变量的混淆等情况 const 用来定义常量，使用时必须赋值 基本类型不能修改，引用类型可以修改：赋值的是一个指针，一个地址；改变的时候地址并没有变 2、import、exportimport导入模块、export导出模块 3、箭头函数 arrow functions1234let func = （num) =&gt; num;let func = () =&gt; num;let sum = (num1,num2) =&gt; num1 + num2;[1,2,3].map(x =&gt; x * x); 本身没有this，不能用call()、apply()、bind()这些方法去改变this的指向 this是继承 父执行上下文 中的this，在定义函数的时候绑定，而不是在执行函数的时候绑定 不能作为构造函数，不能使用 new，不然会报错（箭头函数没有实例） 没有 arguments，需要用 rest参数 接收 123456789let B = (b)=&gt;&#123; console.log(arguments);&#125;B(2,92,32,32); // Uncaught ReferenceError: arguments is not definedlet C = (...c) =&gt; &#123; console.log(c);&#125;C(3,82,32,11323); // [3, 82, 32, 11323] 没有原型属性 123456789var a = ()=&gt;&#123; return 1;&#125;function b()&#123; return 2;&#125;console.log(a.prototype); // undefinedconsole.log(b.prototype); // &#123;constructor: ƒ&#125; 返回对象时，要加一个小括号 12var func = () =&gt; (&#123; foo: 1 &#125;); //正确var func = () =&gt; &#123; foo: 1 &#125;; //错误 4、模板字符串 template string 取变量 1234//` $&#123;&#125;` 反引号 + $ + 中括号变量var name = "liyang";console.log(`I am $&#123;name&#125;`) 多行字符串拼接 es5 var msg = “Hi \ man!”; es6 const template = &lt;div&gt; &lt;span&gt;hello world&lt;/span&gt; &lt;/div&gt;; 5、函数默认参数 default12345678910// ES5 给函数定义参数默认值 function foo(num) &#123; ​ num = num || 200; ​ return num; &#125; // ES6 在 函数参数列表中，赋值，作默认值function foo(num = 200) &#123; ​ return num; &#125; 6、rest参数获取函数的多余参数，放在数组里 1234function foo(x, y, ...rest) &#123; return ((x + y) * rest.length); &#125; foo(1, 2, 'hello', true, 7); // 9 7、展开运算符 Spread Operator 组装数组 123let color = ['red', 'yellow']; let colorful = [...color, 'green', 'blue']; console.log(colorful); // ["red", "yellow", "green", "blue"] 获取数组除了某几项的其他项 123let num = [1, 3, 5, 7, 9]; let [first, second, ...rest] = num; console.log(rest); // [5, 7, 9] ​ 8、class、extends、super提供 Class（类） 的概念，一个语法糖，作为对象的模块。使得生成实例 更像面向对象的语法 每个类里面都有一个 construtor方法（构造方法，即使没写，也会默认生成一个），this 指向实例对象 1234567891011121314151617181920class Animal &#123; constructor() &#123; this.type = 'animal'; &#125; says(say) &#123; console.log(this.type + ' says ' + say); &#125; &#125; let animal = new Animal(); animal.says('hello'); //animal says hello class Cat extends Animal &#123; constructor() &#123; super(); this.type = 'cat'; &#125; &#125; let cat = new Cat(); cat.says('hello'); //cat says hello ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this 9、Promise 表示一个异步操作的最终状态（成功或失败），以及其返回的值 Promise 是一个构造函数，自己身上有all、reject、resolve等方法，原型上有then、catch等方法 我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数 1234567891011function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('执行完成'); resolve('随便什么数据'); &#125;, 2000); &#125;); return p; &#125; runAsync() 解析： 构造函数传入两个参数：resolve，reject，分别表示 异步操作执行成功后的回调函数 和 异步操作执行失败后的回调函数 resolve **将 Promise 的状态置为fullfiled，reject** 将 Promise 的状态置为rejected（pending 初始状态，既不是成功，也不是失败状态) 在runAsync() 的返回上直接调用 then 方法，then 接收两个回掉函数作为参数 promise 对象的状态变为 resolved 时调用 promise 对象的状态变为 reject 时调用 （可选） 还可以调用 catch方法，用来指定 reject 的回调 原生js实现promise 怎么调用一个函数，让它实现promise方法123456789101112131415161718192021function myRequest() &#123; //内容 &#125; myRequest(&#123;url:'11',data:&#123;'a':'1'&#125;,method:'get'&#125;).then().catch() function myRequest(obj) &#123; return new Promise((resolve,reject)=&gt;&#123; $.ajax(&#123; url: obj.url, type: obj.type, data: obj.data || '', dataType: 'json', success: function(data)&#123; resolve(data) &#125;, error:function(error)&#123; reject(error) &#125; &#125;) &#125;) &#125; all方法 提供了并行执行异步操作的能力，并且在所有异步操作 执行完后 才执行回调 all 会把所有异步操作的结果放进一个数组中传给 then race方法 当参数的某个方法执行完了，就把异步操作的结果传给 then，不影响其他异步操作的执行 async/await es7提出的语法糖，Await和Async其实就是promise的封装 async 的用法 作为一个关键字放到函数前面，用于表示函数是一个异步函数，因此该函数的执行不会阻塞后面代码的执行 async 函数内部的实现原理 如果async 函数中有返回一个值 ,当调用该函数时，内部会调用 Promise.resolve() 方法把它转化成一个promise 对象作为返回，可以使用 then方法 获取到promise 返回值 如果函数内部抛出错误，就会调用 Promise.reject() 返回一个 promise 对象，可以使用 catch 方法 获取到promise 返回值 await 的用法 await 关键字只能放到 async 函数里面；await 后面是一个 promise 对象，如果不是的话，也会被转换成一个 立即 resolve 的 Promise 当代码执行到 await 的时候，不再往下执行，执行完 await 才执行下面的，这样写异步代码就像写同步代码一样了。（再也没有回调地狱了。为了实现某些逻辑经常会写出层层嵌套回调函数，如果嵌套过多，会极大影响代码可读性和逻辑，这种情况也被成为回调地狱） 123456789101112131415161718192021async function f() &#123; return await 1&#125;;f().then( (v) =&gt; console.log(v)) // 1function fetchUser() &#123; return new Promise((resolve, reject) =&gt; &#123; fetch('https://api.github.com/users/superman66') .then((data) =&gt; &#123; resolve(data.json()); &#125;, (error) =&gt; &#123; reject(error); &#125;) &#125;);&#125;async function getUserByAsync()&#123; let user = await fetchUser(); return user; &#125;getUserByAsync().then(v =&gt; console.log(v));]]></content>
      <categories>
        <category>Es6</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染]]></title>
    <url>%2F2019%2F03%2F13%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[从浏览器中输入URL到页面加载发生了什么 域名解析：把域名解析为对应的ip地址 发起 TCP 的3次握手 建立 TCP 连接后发起 HTTP请求 服务器响应 HTTP 请求，浏览器得到 HTML 代码 浏览器解析 HTML 代码，并请求 HTML 代码中的资源（如js、css、图片等） 浏览器对页面进行渲染呈现给用户 浏览器渲染流程 解析 HTML 生成 DOM树 解析 CSS 生成 CSSOM规则树（每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象） 将 DOM树 与 CSSOM规则树 合并在一起生成 渲染树 遍历 渲染树 开始布局，计算每个节点的位置大小信息——重排 将渲染树每个节点绘制到屏幕——重绘 渲染阻塞当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM 每次去执行 JavaScript脚本 都会严重地阻塞DOM树的构建，如果 JavaScript脚本 还操作了CSSOM，而正好这个CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建 重排遍历 渲染树，计算每个节点的位置大小信息，并把它们放置在界面的正确位置 因为浏览器渲染界面是基于流式布局模型，某一个节点信息变化，就需要对 DOM 结构进行重新计算，重新布局，再次引发重排 会引起重排的操作有 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或删除可见的DOM元素 激活CSS伪类（例如：:hover） 设置 style 属性 查询某些属性或调用某些方法 常见引起 重排 的属性和方法 width height margin padding display border position overflow clientWidth clientHeight clientTop clientLeft offsetWidth offsetHeight offsetTop offsetLeft scrollWidth scrollHeight scrollTop scrollLeft scrollIntoView() scrollTo() getComputedStyle() getBoundingClientRect() scrollIntoViewIfNeeded() 重绘当样式的改变不影响它在文档流中的位置时 常见引起 重绘 的属性 color border-style visibility background text-decoration background-image background-position background-repeat outline-color outline outline-style border-radius outline-width box-shadow background-size]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器机制]]></title>
    <url>%2F2019%2F03%2F12%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言浏览器机制：DOM事件流，如今采用的是 DOM2级事件模型，下面我们依次讨论中间涉及的一些名词以及之前的事件模型 事件代理（事件委托）利用事件的冒泡原理来实现，在父元素上添加可以处理 子元素事件 的 事件处理函数 123456789101112131415161718//不用事件委托的话，首先要找到 ul,然后遍历 li，然后点击 li 的时候，又要找 li 的位置，最后执行操作window.onload = function()&#123; var oUl = document.getElementById('ull') var aLi = oUl.getElementsByTagName('li') for(var i = 0;i &lt; aLi.length;i++) &#123; aLi[i].onclick = function()&#123; alert(123) &#125; &#125;&#125;//使用事件委托,当点击 li 的时候，由于冒泡原理，事件会冒泡到 ul 上，ul 有点击事件，所以触发window.onload = function()&#123; var oUl = document.getElementById('ull') oUl.onClick = function()&#123; alert(123) &#125;&#125; Target 与 Currenttarget target：触发事件的最具体的元素 currenttarget：绑定事件的元素(在函数中一般等于this) 事件流从页面接收到事件的顺序 事件模型DOM0 级事件模型、IE 事件模型、DOM2 级事件模型 DOM0 级事件模型 又称原始事件模型 没有事件流，方法较为简单，但是将逻辑和界面耦合在了一起，对之后的维护不是很友好 但这种方式兼容所有浏览器 12345678910// 方式一// 将事件直接通过属性绑定在元素上&lt;button onclick="clickBtn()"&gt;&lt;/button&gt;// 方式二// 获取到页面元素后，通过 onclick 等事件，将触发的方法指定为元素的事件// 取消该事件可直接设置为 nullvar btn = document.getElementById('btn')btn.onclick = function () &#123;...&#125;btn.onclick = null IE 事件模型 IE 事件模型仅在 IE 浏览器中有效，不兼容其他浏览器 一共有两个阶段： 事件处理阶段：事件在达到目标元素时，触发监听事件 事件冒泡阶段：事件从目标元素冒泡到 document，并且依次检查各个节点是否绑定了监听函数，如果有则执行 1234567// 绑定事件el.attachEvent(eventType, handler)// 移除事件el.detachEvent(eventType, handler)eventType 是如onclick一样的带有”on“的事件；绑定事件时，handler可以是具名函数，也可以是匿名函数，但是匿名函数无法移除 DOM2 级事件模型 IE8及之前版本不支持 好处 一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次执行各个事件函数 当新增子对象时，无需再对其进行事件绑定，对于动态内容部分非常适合 减少耦合 一共有三个阶段： 事件捕获阶段：事件从 document 向下传播到目标元素，依次检查所有节点是否绑定了监听事件，如果有则执行 事件处理阶段：事件在达到目标元素时，触发监听事件 事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行 123addEventListener('事件名称', '事件回调', '捕获/冒泡') true捕获 false冒泡（默认）removeEventListener('事件名称', '事件回调', '捕获/冒泡') true捕获 false冒泡（默认） 阻止事件冒泡1234567891011方式一：event.stopPropagation(); //只阻止事件往上冒泡，不阻止事件本身 $("#div1").mousedown(function(event)&#123; event.stopPropagation(); &#125;);方式二：return false; //不仅阻止了事件往上冒泡，而且阻止了事件本身$("#div1").mousedown(function(event)&#123; return false; &#125;);]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Http]]></title>
    <url>%2F2019%2F03%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHttps%2F</url>
    <content type="text"><![CDATA[前言介绍 Https 与其和 Http 的区别 与 Http 的区别 Http 的 URL 以 http:// 开头，而 Https 的 URL 以 https:// 开头 Http 默认80端口，Https 默认443端口 Http 处在应用层，Https 处在传输层 Http 明文传输，Https 通过ssl加密和身份认证 Http无需认证证书，Https 需要认证证书 ![img](https://img.youpin.mi-img.com/jianyu/44586988305322c3cc46247c0dfc17b9.jpeg?w=1592&amp;h=856 style=”zoom:50%;” ) Https 定义超文本传输安全协议，Http 的安全版：Http + SSL加密处理（一般是SSL安全通信线路）+ 认证 + 完整性保护 SSL 过程SSL是一种公认的加密协议，在网络传输层上提供一种基于 非对称密钥和对称密钥 技术用于浏览器和服务器安全连接的技术 服务端把自己的公钥a发给证书颁发机构，向证书颁发机构申请证书 证书颁发机构有一对公钥私钥，机构用私钥加密a，并且通过服务端网址等信息生成一个证书签名，证书签名也用私钥加密，证书制作完成，机构把证书发给服务端 客户端向服务端请求通信时，服务端把证书发给客户端 因为各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥，客户端知道证书的颁发机构，就可以从本地拿出对应的公钥进行解密 客户端按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，则证书有效 然后客户端用公钥解密a 客户端生成自己的对称加密密钥b，用a加密b，发给服务端 服务端用自己的私钥解开加密，得到b，然后，客户端和服务端就可以用b进行对称加密的通信 对称加密与非对称加密对称加密(公开密钥加密) 加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。 常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。 非对称加密(共享密钥加密) 使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。 常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http]]></title>
    <url>%2F2019%2F03%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FHttp%2F</url>
    <content type="text"><![CDATA[状态码 206：在客户端表明自己只需要目标url上的部分资源 301：永久性重定向，表示请求的资源已经永久的搬到了其他位置 302：临时重定向，表示请求的资源临时搬到了其他位置 304：缓存 400：请求无效（出现这个请求无效报错说明请求没有进入到后台服务里） 前端提交数据的字段名称或者是字段类型和后台的实体类不一致，导致无法封装 前端提交的到后台的数据应该是json字符串类型，而前端没有将对象转化为字符串类型 403：请求的对应资源禁止被访问 404：服务器无法找到对应资源 500：服务器内部错误 503：服务器正忙 504：网关超时 301 与 302相同 表示重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址， 区别 301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址 跳转场景 301 更换域名 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。 空间服务器不稳定，换空间的时候。 302 尽量使用301跳转！不然会有网址规范化和网址劫持 Http 定义 超文本传输协议，默认端口号为80； 构建与TCP/IP协议上，处于应用层 无连接无状态的 采用的是请求/响应的工作方式 通过报文的方式来交换数据，分为请求报文和响应报文 请求报文由请求行（包含请求方法、URI、HTTP版本信息），请求头，请求体组成； 响应报文包括状态行（包含HTTP版本、状态码、状态码的原因短语），响应头和响应体组成 什么叫无连接无状态 无连接是指限制每次连接只处理一个请求：服务器处理完客户的请求，并收到客户的应答后，即断开连接。这种方式可以节省传输时间 无状态是指协议对于事务处理没有记忆能力，服务器处理完请求后，不会记录任何信息，每个请求都是独立的 Http 头1234567891011Host:rss.sina.com.cn //请求资源所在的服务器User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14 //浏览器自己的信息Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5 //可处理的媒体类型Accept-Language：zh-cn,zh;q=0.5 //可接收的的语言Accept-Encoding：gzip,deflate //可接收的的编码方式Accept-Charset：gb2312,utf-8;q=0.7,*;q=0.7 //可接收的字符集Keep-Alive：300 //保持多久Connection：keep-alive //连接的状态Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &lt;-- CookieIf-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT //缓存Cache-Control：max-age=0 8种请求方式 方式 作用 Http1.0 GET 获取资源，请求参数在请求行中 HEAD 类似 GET 请求，但返回的响应没有具体内容，用于获取报头 POST 提交资源，请求参数在请求体中 Http1.1 PUT 更新资源 DELETE 删除指定资源 OPTIONS 查询服务器性能、服务器支持的 Http 请求方法 TRACE 请求服务器回送的请求信息，主要用于测试或诊断（一般禁用，防止被恶意攻击或盗取信息） CONNECT 能够将连接改为管道方式的代理服务器（把服务器作为跳板，去访问其他页面，然后再把数据返回回来，连接成功后，就可以正常的 GET 或 POST…） Get 和 Post请求方式 的区别 安全性不同：Get请求的安全性较差，因为数据参数是直接拼接在URL后面的，可见。Post请求的数据参数是封装在 Http 的请求体中，浏览器中没有缓存。 参数长度不同：Get请求可提交的数据量收到URL长度的限制，不同浏览器对长度的限制不同，IE为2048个字符（最小）。Post请求是没有长度的限制的。 Get请求适用于数据量较小，并且数据不敏感的情况。Post正好相反 Get请求的数据类型只允许Ascll字符，Post可以是任何类型 POST、PUT、PACTH 区别幂等相同的操作重复执行多次，效果都是一样的 POST PUT PATCH 用来在服务器上创建一个子资源 更新 对 PUT 方法的补充，局部更新 不幂等：多次执行，将导致多条相同的条目被创建 幂等：存在则替换，不存在则创建 幂等 需要把完整的对象传给后端，进行更新 只需要把要更新的字段传给后端，完成更新 文件上传到后端发生了什么 前端通过浏览器获取到文件地址，然后用Post协议，将文件切片逐步上传，直到传输完成 后端通过 post协议，逐步获取到文件数据片，在服务器磁盘缓存区中将片逐步组装，完成后将文件保存到指定位置并返回前端传输成功，关闭连接 Http1.1 与 Http1.0 区别 缓存处理，引入更多的缓存头：1.0主要使用 Expires、If-Modified-Since来作为缓存判断的标准，1.1有了 E-tag、If-Match、If-None-Match等 带宽优化：1.0中，虽然我们只是需要某个对象的一部分，服务器也会把整个对象传过来，并且不支持 断点续传 功能；1.1在请求头引入了 range头域，允许只请求资源的某个部分，返回码是206 新增24个错误状态码：如 410，表示服务器上的某个资源永久地被删除 Host头处理：1.1请求和响应都需要支持 Host头域，传递主机名，因为现在一个 ip 可能会有很多个主机，如果没有 Host头域 ，会报 400 长连接：1.1请求头中默认开启 Connection: Keep-Alive，在一个 TCP 连接上可以传送多个 HTTP请求和响应 Http2 与 Http1 区别 采用二进制格式而非文本格式 多路复用：连接共享。1.1 虽然采用了长连接，一个 TCP连接上可以传输多个 HTTP 请求和响应，但是多个请求串行化单线程处理，后面的请求需要等待前面的请求返回才能执行，一旦某请求超时，后续请求会被阻塞；2 就可以让多个请求在一个连接上并行执行。即使某请求超时，也不影响其他连接的正常执行 使用报头压缩，降低开销：通讯双方各自 cache 一份 header fields 表，避免重复传输 header，减少需要传输的大小 服务器推送：能把客户端需要的资源伴随 index.html 一起发送过来，省去了客户端重复请求的步骤，极大地提升了速度 关于 TCP tcp可以分段传输信息，有个机制，不会丢包或者乱序 http1.1的时候，一个域名下只能有6个tcp连接，不过一个tcp连接可以有多个http请求]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器存储]]></title>
    <url>%2F2019%2F03%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2FlocalStorage%E3%80%81cookie%E3%80%81session%2Btoken%2F</url>
    <content type="text"><![CDATA[Cookie、sessionStorage、localStorage 区别 Cookie SessionStorage LocalStorage 存放数据大小 4KB 一般为 5 MB 一般为 5 MB 数据有效期 可以设置过期时间 仅在同源窗口有效，关闭窗口就无效了 长期有效 与服务端通信 每次都会携带在 HTTP 头中，如果保存过多数据会带来性能问题 仅仅在本地存储，不会和服务端通信 同 SessionStorage 用途 一般由服务器端生成，用于标识用户身份 用于浏览器端缓存数据 同 SessionStorage 需要程序员手动封装 有现成的API 有现成的API a.html 与 b.html 通信 cookie 如果在同域下，可以访问 原理：默认情况下，只有与创建了cookie的页面在同一个目录或子目录下的网页才可以访问cookie 如果同域不同目录下的解决：把cookie设置到一个更高级别的目录下 1document.cookie = "key=value;path=/" 如果不同域 解决：设置domin 1document.cookie = 'key = value;path=/;domain=csdn.cn' www.csdn.cn/blog/a.html 创建了cookie www.csdn.cn/blog/b.html 就可以访问这个cookie页(同一目录) www.csdn.cn/blog/xyz/c.html 也可以访问这个cookie页(字目录) www.csdn.cn/xx/d.html 就不可以访问 webStorage 不同浏览器无法共享 loacalStorage 和 sessionStorage 的信息 相同浏览器的不同页面可以共享 localStorage（注意页面需要同域） 不同页面或标签页面无法共享 sessionStorage，如果页面中包含多个 iframe标签且属于同源页面，那么他们之间是可以共享 seesionStorage的 Cookie 与 Session 的区别 Cookie 与 Session 出现的原因是：HTTP 是无状态的，没办法知道请求的是谁 Cookie 保存在客户端，也就是浏览器端。每次往服务器发请求，都会在请求头里带着cookie，缺点显而易见，浪费流量、降低效率 Session 将用户信息保存在服务端，只需要往客户端的 Cookie 中保存一个 Session id 值就可以了。这样每次往服务器发请求，Cookie 的 size 很小，在服务端只需要根据 Cookie 传过来的 Session id 进行匹配session，从Session 中获取用户信息就可以了 Token 作用防止表单重复提交 当客户端请求页面时，服务器会生成一个随机数 Token，并且将 Token 放置到 Session 当中 然后将 Token 发给客户端（一般通过构造 hidden 表单） 下次客户端提交请求时，Token 会随着表单一起提交到服务器端 （如果应用于“anti csrf攻击”，则）服务器端会对Token值进行验证，判断是否和 Session 中的 Token 值相等 若相等，则可以证明请求有效，不是伪造的 身份验证 服务器端第一次验证通过后，会将 Session 中的 Token 值更新下 若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的 Token 没变，但服务器端 Session 中 Token 已经改变了 Localstorage太长怎么办 设置的时候，在 key 加标识 一些表状态的，不要删；一些常用的缓存超出了一定大小，就清除 同样在 key 加自己业务的标识，清除其他业务，前提是无交互的缓存 划分域名：各域名下的存储空间由各业务组统一规范使用 跨页面传值：考虑单页应用，优先采用url传数据 LocalStorage(webStorage)使用时需要注意的问题 兼容性 ie8.0及以上才有 LocalStorage的值为string类型 在使用的时候要进行类型转换 在浏览器隐私模式下不可读取 不同浏览器无法共享 LocalStorage 不能被爬虫获取 存储过多数据会导致页面变卡 LocalStorage 的本质是对字符串的读取 Cookie 参数 参数 描述 name 必需。规定 cookie 的名称。 value 必需。规定 cookie 的值。 expire 可选。规定 cookie 的有效期。0为永远有效 path 可选。规定 cookie 的服务器路径。 domain 可选。规定 cookie 的域名。 secure 可选。规定是否通过安全的 HTTPS 连接来传输 cookie。如果值为1，则cookie只能在https连接上有效，默认值为0。 Cookie 读写设置 以键值对的形式保存的，即 key = value 的格式 各个cookie之间一般是以“;”分隔 12345678910document.cookie = "name = "+ username; // 设置过期时间function setCookie(name,value) &#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days*24*60*60*1000); document.cookie = name + "="+ escape (value) + "; expires=" + exp.toGMTString(); &#125; 读取 document.cookie.split 123假设 Cookie为 name=jack;password=123var username = document.cookie.split(";")[0].split("=")[1]; 删除 设置过期时间小于当前时间，那么就会删除该 Cookie 还可以在谷歌开发工具 application -&gt; cookies 修改 123456789function delCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval=getCookie(name); if(cval!=null) document.cookie= name + "="+cval+"; expires="+exp.toGMTString(); &#125; //使用示例 setCookie("name","hayden"); alert(getCookie("name"));]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2019%2F03%2F07%2FCss3%2FBFC%2F</url>
    <content type="text"><![CDATA[定义 块级格式化上下文 一个独立的布局环境，其中的元素布局不受外界影响 在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列 布局规则 内部的 Box 会在垂直方向，一个接一个地放置 Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 BFC 的区域不会与 float box 重叠 BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算 BFC 的高度时，浮动元素也参与计算 创建BFC，满足下列的任意一个或多个条件即可 float 的值不是 none position 的值不是 static 或者 relative overflow 的值不是 visible display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Post方法]]></title>
    <url>%2F2019%2F03%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FPost%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[如何设置传输的数据的格式在 Post 方法中，设定 http的头（header)，在里面声明不同的 content-type 传输的数据格式 application/x-www-form-urlencoded 最常见的方式；浏览器的 原生表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded方式提交数据 multipart/form-data 使用表单上传文件时 application/json text/xml 前端向后端传输数据的方法有哪些 Ajax 传给后台的数据通过 Json 封装起来，再用 Ajax 将 Json 传到后台，需要添加 Jquery 库 通过 form 表单的 action 传值 Vue 的 Axios 通过 Url 字符串拼接传值 直接在 Ajax 中 Url 拼接数据 通过 window.location.href 指定路径提交数据 通过 a 标签的 href 属性提交数据 表单是怎么传输数据的当前端，把前端层面的表单提交时候，会把表单数据，写到 html header里面，然后传送给服务器 服务器从 Request.Form中，拿到数据 -&gt; 数据通过 url解码为表单元素数据 -&gt; 构成一个对象后，再进行处理]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Post</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F03%2F07%2FVue%2Fvue%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[vue原理Vue.js是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。 虚拟DOMdom是树状结构，其节点为vnode，vnode和浏览器DOM中的Node一一对应，通过vnode的elm属性可以访问到对应的Node。 vdom因为是纯粹的JS对象，所以操作它会很高效，但是vdom的变更最终会转换成DOM操作，为了实现高效的DOM操作，一套高效的虚拟DOM diff算法显得很有必要。 用JS对象记录一个dom节点的副本，当dom发生更改时候，先用虚拟dom进行diff，算出最小差异，然后再修改真实dom。 diff算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。 diff 的实现主要通过两个方法，patchVnode 与 updateChildren 。 patchVnode 有两个参数，分别是老节点 oldVnode, 新节点 vnode 。主要分五种情况： if (oldVnode === vnode)，他们的引用一致，可以认为没有变化。 if(oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text)，文本节点的比较，需要修改，则会调用Node.textContent = vnode.text。 if( oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch ), 两个节点都有子节点，而且它们不一样，这样我们会调用 updateChildren 函数比较子节点，这是diff的核心，后边会讲到。 if (ch)，只有新的节点有子节点，调用createEle(vnode)，vnode.el已经引用了老的dom节点，createEle函数会在老dom节点上添加子节点。 if (oldCh)，新节点没有子节点，老节点有子节点，直接删除老节点。 updateChildren 是关键，这个过程可以概括如下： oldCh 和 newCh 各有两个头尾的变量 StartIdx 和 EndIdx ，它们的2个变量相互比较，一共有4种比较方式。如果 4 种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。 为什么用vue1.操作dom元素需要把html结构销毁之后,然后再进行重新生成,十分消耗性能 2.虚拟dom,通过diff算法,减少性能的消耗 vue通过建立一个虚拟DOM树对真实DOM发生的变化保持追踪。 一棵真实DOM树的渲染需要先解析CSS样式和DOM树，然后将其整合成一棵渲染树，再通过布局算法去计算每个节点在浏览器中的位置，最终输出到显示器上， 而虚拟DOM则可以理解为保存了一棵DOM树被渲染之前所包含的所有信息，而这些信息可以通过对象的形式一直保存在内存中，并通过JavaScript的操作进行维护。 用传统jquery操作dom的思想，可以先删除,然后再插入新的标签（更新） 虚拟dom会如何处理上述问题呢？第一步：通过树的形式保存旧的dom信息，这些信息可能在页面第一次加载的时候被渲染到浏览器中，但仍是通过虚拟dom的方式创建的 第二步：检测到数据更新，需要更新dom，先在JavaScript中将需要修改的节点全部修改完成（这个步骤可以进行算法上的优化，会在后面的原理中详细说明） 第三步：将最终生成的虚拟DOM更新到视图中去。 需要付出的代价付出的只是在你的内存中需要保存一份可供维护的数据信息 vue特点轻量级的框架、组件化、数据双向绑定 VUE 响应式原理 data如何实现第一步当然是通过 observer 进行数据劫持，然后在需要订阅的地方（如：模版编译），添加观察者（watcher），并立刻通过取值操作触发指定属性的 getter 方法，从而将观察者添加进 Dep （利用了闭包的特性，进行依赖收集），然后在 Setter 触发的时候，进行 notify，通知给所有观察者并进行相应的 update。 Object.defineProperty()缺点1、不能监听数组的变化 比如push pop shift等，不会触发setter，vue内部做了hack处理 2、必须遍历对象的每个属性 使用Object.defineProperty()多数要配合object.keys()和遍历，多了一层嵌套 3、必须深层遍历嵌套的对象 proxyvue3.0的一个新特性 1、针对整个对象，而不是对象的某个属性，不用对keys进行便利（Reflect.get 和 Reflect.set 可以理解为类继承里的 super，即调用原来的方法） 2、支持数组 3、嵌套支持，在get里面递归调用proxy并返回 4、提供13种拦截的方法 vue3.0 特性1、虚拟dom重写，更多的编译时提示减少运行时开销。 2、优化slots的生成，目前在 Vue 中，当父组件重新渲染时，其子组件也必须重新渲染。使用Vue 3，可以单独重新渲染父级和子级。 3、静态树提升 Vue 3 的编译器将能够检测到什么是静态组件，然后将其提升，从而降低了渲染成本 4、静态属性提升 5、基于 Proxy 的 Observation 6、vue更小 7、更具有维护性，支持typescript，将内容更加模块化 8、新加observer模块 Vue computed 实现从两个问题出发： 建立与其他属性（如：data、 Store）的联系； 属性改变后，通知计算属性重新计算。 实现时，主要如下： 初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。 Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集。 computed里面用箭头函数的this是啥undefined 因为继承上下文，不是vue实例 computed &amp; watchcomputed,设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。 在页面中使用大量或是复杂的表达式去处理数据，对页面的维护会有很大的影响。这个时候就需要用到computed 计算属性来处理复杂的逻辑运算。 computed 计算属性只有在相关的数据发生变化时才会改变要计算的属性，当相关数据没有变化是，它会读取缓存。 watch，当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 watch模式没有computed模式简单，但watch比较适合做异步的操作。 computed VS methods不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。 methods方式是每次进入页面都要执行该方法，但是在利用实时信息时，比如显示当前进入页面的时间，必须用methods方式。 computed是在HTML DOM加载后马上执行的，如赋值； methods则必须要有一定的触发条件才能执行，如点击事件； 为什么data要是一个function，不是一个普通的对象因为组件是需要复用的，每次复用组件就会复制data，如果是普通的对象，那么每次复制的都是同一个地址的数据，那么更改了，都会更改。所以需要return一个新的对象，开辟一个新的空间，那么每个组件的data就是隔离的。 组件化 模块化 组件化：将实现页面某一部分功能的结构、样式和逻辑封装成一个整体，让它高内聚、低耦合，达到分治和复用的目的。 比如页头、页尾，表单就是一个组件 模块化：是一种处理复杂系统分解成更好的可管理模块的方式。各模块通常都用一个标准的接口来进行通信。任何一个库实际上都是一个模块，比如node,log4js。任何语言都有模块化的思想，比如es6的import/export vue-router的实现机制大致是什么样，怎么去掉url里默认的#vue-router通过hash和history两种方法实现前端路由，更新视图但不重新请求页面。 vue实现单页面应用，实际上是每一个页面都是一个单独的 vue实例，切换页面时，通过删除或不展示当前的实例，替换为新的实例来展示，实现浏览器不更新页面，在完成页面展示后修改地址栏，完成了不触发浏览器刷新，就替换了页面内容。 hash方法：利用url的#，通过改变#后面hash值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。 history方法:14年后，因为HTML5标准发布。多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 popstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。 将mode改成history。默认是hash mvvmMVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。在MVVM的框架下视图和模型是不能直接通信的。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。MVVM流程图如下： mvcMVC是Model-View- Controller的简写。即模型-视图-控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。‘MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。MVC和MVVM的区别并不是VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的重用。 视图（View）：用户界面。（传送指令到 Controller） 控制器（Controller）：业务逻辑（完成业务逻辑后，要求 Model 改变状态） 模型（Model）：数据保存（将新的数据发送到 View，用户得到反） MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。 提交一次反馈一次，通信一次相互制约。 vue几种常用的指令答：v-for 、 v-if 、v-bind、v-on、v-show、v-else 相同点：v-if与v-show都可以动态控制dom元素显示隐藏 不同点：v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加css–display:none，dom元素还在。 1.手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐； 2.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； 3.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留； 4.性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； 5.使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。 聊聊你对Vue.js的template编译的理解？答：简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点） 详情步骤： 首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。 然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue-进阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组与对象]]></title>
    <url>%2F2019%2F03%2F07%2FJavaScript%2F%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[判断数组与对象因为typeof({}) typeof([]) 都是object 1、instanceof操作符 这个操作符是检测对象的原型链是否指向构造函数的prototype对象的。 var arr = [1,2,3,1]; alert(arr instanceof Array); // true2、对象的constructor属性 除了instanceof，每个对象还有constructor的属性，利用它似乎也能进行Array的判断。 var arr = [1,2,3,1]; alert(arr.constructor === Array); // true 第2种和第3种方法貌似无懈可击，但是实际上还是有些漏洞的，当你在多个frame中来回穿梭的时候，这两种方法就亚历山大了。由于每个iframe都有一套自己的执行环境，跨frame实例化的对象彼此是不共享原型链的，因此导致上述检测代码失效 3、Array.isArray()方法 Array.isArray([1, 2, 3]); // true Array.isArray({foo: 123}); // false 4、Object.prototype.toString Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)。利用这 个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。 function isArrayFn (o) { return Object.prototype.toString.call(o) === &apos;[object Array]&apos;; [object object] } var arr = [1,2,3,1]; alert(isArrayFn(arr));// true typeof 有哪些类型6种，function (函数)、string(字符串)、boolean(布尔)、object(对象)、number(数值)、undefined(未定义) 怎么遍历一个对象上不是原型上的所有属性呢hasOwnPropertyNames 判断一个对象是否为空*1、将json对象转化为json字符串，再判断该字符串是否为”{}” * var data = {}; var b = (JSON.stringify(data) == &quot;{}&quot;); alert(b);//true2、for in 循环判断 var obj = {}; var b = function() { for(var key in obj) { return false; } return true; } alert(b());//true3、jquery的isEmptyObject方法 此方法是jquery将2方法(for in)进行封装，使用时需要依赖jquery var data = {}; var b = $.isEmptyObject(data); alert(b);//true4、Object.getOwnPropertyNames()方法 此方法是使用Object对象的getOwnPropertyNames方法，获取到对象中的属性名，存到一个数组中，返回数组对象，我们可以通过判断数组的length来判断此对象是否为空 注意：此方法不兼容ie8，其余浏览器没有测试 var data = {}; var arr = Object.getOwnPropertyNames(data); alert(arr.length == 0);//true5、使用ES6的Object.keys()方法 与4方法类似，是ES6的新方法, 返回值也是对象中属性名组成的数组 var data = {}; var arr = Object.keys(data); alert(arr.length == 0);//true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[观察者模式&单例模式]]></title>
    <url>%2F2019%2F03%2F07%2FJavaScript%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者同时监听一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者vue里面的watch，当监听到的对象发生变化，是可以观察到的，并做出反应。 单例模式router-view 是个单例，当构造了一个组件或实例时，再次打开仍然是上次的实例，需要销毁后，才能建立新的实例。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2F2019%2F03%2F07%2FCss3%2Fcss%2F</url>
    <content type="text"><![CDATA[CSS选择器id选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child） CSS优先级算法如何计算？!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 *优先级就近原则，同权重情况下样式定义最近者为准; *载入样式以最后载入的定位为准; 优先级 同权重:内联样式表（标签内部）&gt;嵌入样式表（当前文件中）&gt;外部样式表（外部文件中）。 !important &gt; id &gt; class &gt; tag important比内联优先级高 CSS优化、提高性能的方法有哪些？关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； CSS盒子模型了解吗，IE盒子模型会在IE的什么版本出现呢IE5.5及更早的版本使用的是IE盒模型。IE6及其以上的版本在标准兼容模式下使用的是W3C的盒模型标准。 w3c盒子模型的范围包括margin、border、padding、content,并且content部分不包含其他部分。 当设置background颜色时候，会覆盖padding+width，当border为dashed虚线时，背景色会嵌进去 IE盒子模型的范围包括margin、border、padding、content,和w3c盒子模型不同的是，IE盒子模型的content部分包含了padding和border. box-sizing: content-box(w3c) border-box(ie) CSS3 新特性1.CSS3的选择器 1）E:last-child 匹配父元素的最后一个子元素E。 2）E:nth-child(n)匹配父元素的第n个子元素E。 3）E:nth-last-child(n) CSS3 匹配父元素的倒数第n个子元素E。 2. @Font-face 特性 3. 圆角 4.阴影（Shadow） 5.CSS3 的渐变效果 background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E)); 6. CSS3制作特效 1) Transition 对象变换时的过渡效果 2) Transforms 2D转换效果 主要包括 translate（水平移动）、rotate（旋转）、scale（伸缩）、skew（倾斜） 3) Animation动画特效 @keyframes CSS继承属性有哪些 1、字体系列属性 font-family：字体系列 font-weight：字体的粗细 font-size：字体的大小 font-style：字体的风格 2、文本系列属性 text-indent：文本缩进 text-align：文本水平对齐 line-height：行高 word-spacing：单词之间的间距 letter-spacing：中文或者字母之间的间距 text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个） color：文本颜色 3、元素可见性： visibility：控制元素显示隐藏 4、列表布局属性： list-style：列表风格，包括list-style-type、list-style-image等 5、光标属性： cursor：光标显示为何种形态 块级元素、行内元素块级元素：块级大多为结构性标记 &lt;address&gt;...&lt;/address&gt; &lt;center&gt;...&lt;/center&gt; 地址文字 &lt;h1&gt;...&lt;/h1&gt; 标题一级 &lt;h2&gt;...&lt;/h2&gt; 标题二级 &lt;h3&gt;...&lt;/h3&gt; 标题三级 &lt;h4&gt;...&lt;/h4&gt; 标题四级 &lt;h5&gt;...&lt;/h5&gt; 标题五级 &lt;h6&gt;...&lt;/h6&gt; 标题六级 &lt;hr&gt; 水平分割线 &lt;p&gt;...&lt;/p&gt; 段落 &lt;pre&gt;...&lt;/pre&gt; 预格式化 &lt;blockquote&gt;...&lt;/blockquote&gt; 段落缩进 前后5个字符 &lt;marquee&gt;...&lt;/marquee&gt; 滚动文本 &lt;ul&gt;...&lt;/ul&gt; 无序列表 &lt;ol&gt;...&lt;/ol&gt; 有序列表 &lt;dl&gt;...&lt;/dl&gt; 定义列表 &lt;table&gt;...&lt;/table&gt; 表格 &lt;form&gt;...&lt;/form&gt; 表单 &lt;div&gt;...&lt;/div&gt;行内元素：行内大多为描述性标记 &lt;span&gt;. &lt;a&gt;...&lt;/a&gt; 链接 &lt;br&gt; 换行 &lt;b&gt;...&lt;/b&gt; 加粗 &lt;strong&gt;...&lt;/strong&gt; 加粗 &lt;img &gt; 图片 &lt;sup&gt;...&lt;/sup&gt; 上标 &lt;sub&gt;...&lt;/sub&gt; 下标 &lt;i&gt;...&lt;/i&gt; 斜体 &lt;em&gt;...&lt;/em&gt; 斜体 &lt;del&gt;...&lt;/del&gt; 删除线 &lt;u&gt;...&lt;/u&gt; 下划线 &lt;input&gt;...&lt;/input&gt; 文本框 &lt;textarea&gt;...&lt;/textarea&gt; 多行文本 &lt;select&gt;...&lt;/select&gt; 下拉列表区别 块级元素 1.总是从新的一行开始 2.高度、宽度都是可控的 3.宽度没有设置时，默认为100% 4.块级元素中可以包含块级元素和行内元素 行内元素 1.和其他元素都在一行 2.高度、宽度以及内边距都是不可控的 3.宽高就是内容的高度，不可以改变 4.行内元素只能行内元素，不能包含块级元素 一个div,position设置为absolute,再用JS设置div.style.position=””，问这时div的表现？怎么去判断？被js覆盖，因为js会把样式写在style的属性，是行内元素，覆盖掉了。 CSS 水平居中方式行内元素text-align:center 块级元素 定宽margin:0 auto； 不定宽： 父级元素设置 text-align:center; 子元素设置为内嵌块元素 display:inline-block; 父级：relative 子级： position：absolute; left:50%; magin-left: -自己宽度的一半； translate()CSS 垂直居中方式父级：relative 子级： position：absolute; top:50%; magin-top: -自己宽度的一半； flex align-items:center translate()说说floatfloat虽然已经脱离了文档流，但是他还会占据文档的位置。 CSS实现一个旋转的动画如何实现，animation和transition有什么区别transition主要是过渡作用，比如鼠标移入移出的动画，animation是强化版的动画。 transition 不能自行触发，通过hover等动作，或者结合js进行触发。animation可以自行运行 transition可控性相对较弱，只能够指定起始和结束的状态，而animation可以定义多个关键帧 听说过逐帧动画吗，如果让你实现，你会如何实现animation @keyframes 前端如何实现直播的功能你了解吗，让你设计弹幕效果如何实现后台返回一个流式媒体，前端通过video接收 知道canvas吗，canvas怎么实现一个旋转的矩形rotate() inline-block知道吗，应用场景都有哪些呢结合inline和block两种属性的特性，保持行内排列的特性，也可以设置宽高。 可以应用于一切需要行内排列且要设置大小的需求，比如网页的导航栏和把a标签做按钮时。 浏览器最小的字体？怎么更小？12px。使用transform-origin transform-scale css3和js动画哪个好如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css动画是优选方案。然而如果你在设计很复杂的富客户端界面或者在开发一个有着复杂UI状态的 APP。那么你应该使用js动画，这样你的动画可以保持高效，并且你的工作流也更可控。所以，在实现一些小的交互动效的时候，就多考虑考虑CSS动画。对于一些复杂控制的动画，使用javascript比较可靠。 JS动画缺点：(1)JavaScript在浏览器的主线程中运行，而主线程中还有其它需要运行的JavaScript脚本、样式计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。 ​ (2)代码的复杂度高于CSS动画 优点：(1)JavaScript动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。 ​ (2)动画效果比css3动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有JavaScript动画才能完成 ​ (3)CSS3有兼容性问题，而JS大多时候没有兼容性问题 CSS动画缺点： (1)运行过程控制较弱,无法附加事件绑定回调函数。CSS动画只能暂停,不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件,无进度报告 (2)代码冗长。想用 CSS 实现稍微复杂一点动画,最后CSS代码都会变得非常笨重。 优点： (1)浏览器可以对动画进行优化。 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame比起setTimeout，setInterval设置动画的优势主要是:1)requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率,一般来说,这个频率为每秒60帧。2)在隐藏或不可见的元素中requestAnimationFrame不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。 强制使用硬件加速 （通过 GPU 来提高动画性能） 总结： 1、css用于简单的动画，比如过渡；js用于复杂的动画，比如需要对动画进行开始，暂停，回放灯，css不能暂停。 2、css有兼容性问题，但是他可以gpu加速，提高性能 同样的动画，js能实现，css也能实现，选择哪个呢 1、如果有兼容性，选择Js 2、但是js会损耗浏览器性能，单线程的，处理动画一个接一个，会卡顿 显示/隐藏display:block/none visibility:visible/hidden 区别： none 隐藏内容，会脱离文本流，不占据页面空间 引发重绘 回流 hidden 隐藏内容，不会脱离文本流，会继续占据页面空间 引发重绘 @mediaall screen print(用于打印机和打印预览) speech(用于屏幕阅读器等发声设备) px rem em1、px 像素，是一个固定大小的单元 2、rem css3新增，相对长度单位，相对于html元素 3、em 相对长度单位，不是固定的，它相对于当前对象内文本的字体尺寸，会继承父级元素，如果没设置，相对于浏览器的默认字体尺寸16px 网页上那个小图标是通过什么设置的&lt;link rel=&quot;SHORTCUT ICON&quot; href=&quot;ico图标文件地址&quot;&gt;meta里有哪些属性两个属性：name http-equiv 1、name name属性主要用于描述网页，比如网页的关键词，叙述等。对应的content，是对name的具体描述，便于搜索引擎抓取 &lt;meta name=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;参数 &lt;meta name=&quot;keywords&quot; content=&quot;Lxxyx,博客，文科生，前端&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;文科生，热爱前端与编程。目前大二，这是我的前端博客&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; //移动端的窗口 &lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;Lxxyx,841380530@qq.com&quot;&gt; &lt;meta name=&quot;generator&quot; content=&quot;Sublime Text3&quot;&gt; &lt;meta name=&quot;copyright&quot; content=&quot;Lxxyx&quot;&gt; //代表该网站为Lxxyx个人版权所有。 &lt;meta name=&quot;revisit-after&quot; content=&quot;7 days&quot; &gt; //搜索引擎爬虫重访时间 &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; //默认webkit内核 &lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式 &lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式2、http-equiv &lt;meta http-equiv=&quot;参数&quot; content=&quot;具体的描述&quot;&gt;参数 &lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; //旧的HTML，不推荐 //设定网页字符集 &lt;meta charset=&quot;utf-8&quot;&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; //指定IE和Chrome使用最新版本渲染当前页面 &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;Sunday 26 October 2016 01:00 GMT&quot; /&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;2；URL=http://www.lxxyx.win/&quot;&gt; //意思是2秒后跳转向我的博客 &lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;name, date&quot;&gt; //格式 &lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT&quot;&gt; //具体范例]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2F2019%2F03%2F07%2FJavaScript%2FAjax%2F</url>
    <content type="text"><![CDATA[前言Ajax = 异步 JavaScript + XML 技术核心： XMLHttpRequest 对象 请求过程：创建XMLHttpRequest、连接服务器、发送请求、服务器做出相应、接收数据 原生 Ajax 的工作流程 创建XMLHttp对象 1234var xmlhttp = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP")标准浏览器：使用XMLHttpRequest对象IE浏览器：用ActiveXObject对象 调用对象的 open方法 来规定请求的类型、URL 以及是否异步处理请求 12345open(method, url, async)method：请求的类型 GET/POSTurl：文件在服务器上的位置async：true（异步） / false（同步） 如果为异步请求，使用 onreadystatechange事件 来监听请求的状态，当 readyState 属性为 4 时，就会调用 执行函数 123456readyState0：请求未初始化1：服务器连接已建立2：请求已接收3：请求处理中4：请求已完成，且相应已就绪 最后调用 send() 将请求发给服务器 123456789101112131415161718// 1、创建XMLHttpRequest对象var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");// 2、设置请求参数xhr.open(请求方式,请求地址,异步或同步);// 3、设置回调函数xhr.onreadystatechange = function()&#123; if(xhr.reasyState===4)&#123; if(xhr.status === 200) &#123; //5、接受响应 console.log(xhr.responseText); &#125; &#125;&#125;// 4、发送请求xhr.send(); 自定义header的字段发送之前用 setRequestHeader(header, value) 向请求添加http头 跨域携带cookie跨域请求时，由于浏览器安全 策略，不会自动携带cookie到服务器 原生 Ajax 开启我们可以设置 XMLHttpRequest.withCredentials ， xmlhttp.setRequestHeader(‘Cookie’, document.cookie) 是不安全的做法 12XMLHttpRequest.withCredentials=true;xmlhttp.setRequestHeader('Cookie', document.cookie) // error Jq -&gt; Ajax开启1234567891011 $.ajax(&#123; type: "POST", url: "http://xxx.com/api/test", dataType: 'jsonp', xhrFields: &#123;withCredentials: true&#125;, crossDomain: true,&#125;)服务器端设置：header("Access-Control-Allow-Credentials: true");header("Access-Control-Allow-Origin: http://www.xxx.com") 用途 / 好处 实现客户端服务器的异步通信效果，带来更好的用户体验 实现页面的局部刷新，按需获取数据，节约带宽资源 缺点 不支持浏览器back按钮 安全问题，暴露了与服务器交互的细节 对搜索引擎的支持比较弱：如果使用不当，会增大网络数据的流量，从而降低整个系统的性能]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包&变量污染&垃圾机制]]></title>
    <url>%2F2019%2F03%2F06%2FJavaScript%2F%E9%97%AD%E5%8C%85%2B%E5%8F%98%E9%87%8F%E6%B1%A1%E6%9F%93%2B%E5%9E%83%E5%9C%BE%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[闭包闭包是JS总一个主要的设计理念，闭包简单来说，是 函数+函数里的变量 称作闭包。 12345678function test() &#123; var i = 0; return function() &#123; console.log(++i) &#125; &#125; var doAdd = test(); doAdd(); 好处 闭包里的变量，是安全的，并且是对于全局是隐藏的，在不对外暴露操作的方法时候，外界无法直接改变闭包中变量的值 通过闭包的思维，来管理对象的属性变更的操作，可以增加代码的可读性，也易于管理 缺点1、闭包会使函数中的变量保存在内存中，内存消耗很大，所以不能滥用闭包，解决办法是，退出函数之前，将不使用的局部变量删除。 2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 应用场景1、小范围代替全局变量 全局变量有变量污染和变量安全问题，可以使用闭包（匿名函数），外部无法访问变量 2、采用函数引用方式的setimeout调用 原生的setTimeout有一个缺陷，你传递的第一个函数不能带参数 所以可以调用另一个函数来返回一个内部函数的调用，将这个内部函数对象的引用传递给settimeout函数。内部函数执行时需要的参数，在调用外部函数时传递给它。 function callLater(paramA, paramB, paramC) { /*使用函数表达式创建并放回一个匿名内部函数的引用*/ return (function () { /* 这个内部函数将被setTimeout函数执行； 并且当它被执行时， 它能够访问并操作外部函数传递过来的参数 */ paramA[paramB] = paramC; }); } /* 调用这个函数将在它的执行上下文中创建，并最终返回内部函数对象的引用 传递过来的参数，内部函数在最终被执行时，将使用外部函数的参数 返回的引用被赋予了一个变量 */ var funcRef = callLater(elStyle, &quot;display&quot;, &quot;none&quot;); /*调用setTimeout函数，传递内部函数的引用作为第一个参数*/ hideMenu = setTimeout(funcRef, 500); 3、回调（return) 4、访问私有函数和私有变量的公有函数 一个函数内部的私有变量，外部想要访问，可以通过其内部的方法，能通过作用链访问到变量 作用域每一个变量、函数都有其作用的范围，超出作用不得使用，这个叫做作用域 全局变量、局部变量 作用域链函数被创建或者被定义的时候，函数对象有一个内部属性[[scope]]，它引用了一条作用域链，也可以理解为对象列表。 在函数func创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，当执行函数的时候，会创建一个该函数的执行期上下文的内部对象，当这个执行期上下文被创建时，他的作用域链会被初始化为当前执行的函数对象里的[[scope]]属性中所包含的对象，然后解释器创建一个活动对象，这个活动对象包含当前这个执行函数里所有的局部变量（内部var 声明的），命名参数（形参），参数合集（arguments）以及this。然后此对象会被推入执行期上下文里作用域链的前端。 当函数执行完毕，该执行期上下文就会被销毁。 作用域链的作用是用于解析标识符，函数执行上下文被创建好之后，解释器开始自上至下的解释代码了，这时每遇到一个标示符，都会遍历这个执行上下文里的作用域链：首先在最顶层的活动对象里去找，如果没找到，再找下一层，最终找到全局作用域，如果还没找到一般会报语法错误，但是当对未定义的变量执行赋值运算时，解释器会在全局作用域创建该变量并赋值。这一点很重要，编程时要小心，防止污染全局环境，或者造成内存泄露的问题。 减少全局变量污染全局变量的三种定义方式： 在任何函数外部var声明一个变量； 在window对象中声明一个变量； 在函数内部不先var声明变量后直接使用变量（隐式全局变量） 1、使用唯一全局变量 这个方法是在全局声明一个对象字面量，作为我们的全局变量容器，这样全局就只出现一个全局变量： var myApp = {};此时，变量myApp就成了我们的变量容器了，所有的全局变量都可以保存在这里： myApp.students = { name:&quot;小明&quot;， age:18 }; 2、使用闭包 3、0全局变量 用let声明 垃圾回收机制为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。 JS垃圾回收方式 标记清除、引用计数 标记清除工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 再被加上标记的会被视为准备删除的变量。 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 引用计数工作原理：跟踪记录每个值被引用的次数。 工作流程： 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1. 当引用次数变成0时，说明没办法访问这个值了。 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 但是循环引用的时候就会释放不掉内存。循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。 因为IE中的BOM、DOM的实现使用了COM，而COM对象使用的垃圾收集机制是引用计数策略。所以会存在循环引用的问题。 解决：手工断开js对象和DOM之间的链接。赋值为null。IE9把DOM和BOM转换成真正的JS对象了，所以避免了这个问题。 什么情况会引起内存泄漏？虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。 1. 意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。 解决：使用严格模式避免。 2. 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。 解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。 3. 没有清理的DOM元素引用 原因：虽然别的地方删除了，但是对象中还存在对dom的引用 解决：手动删除。 4. 被遗忘的定时器或者回调 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。 解决：手动删除定时器和dom。 5. 子元素存在引用引起的内存泄漏 原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。 解决：手动删除清空。 什么放在内存中？什么不放在内存中？基本类型是：Undefined/Null/Boolean/Number/String 基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。 引用类型：object 引用类型的值是对象，保存在堆内存中。 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。 js不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 栈和堆的区别 一、堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 二、堆栈缓存方式区别： 1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放； 2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 三、堆栈数据结构区别： 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2019%2F03%2F06%2FJavaScript%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[为什么要跨域？跨域问题是浏览器同源策略限制，当前域名的js只能读取同域下的窗口属性。 不同的协议名、子域名、主域名、端口号不同都会导致跨域问题。 为什么会有同源策略因为同源策略的限制，我们不能通过ajax请求不同域的数据，不能通过脚本操作不同域下的DOM 如果没有同源策略，不同源的数据和资源，比如cokkie，dom等能被随意访问。比如我们访问了一个恶意网站，没有同源策略，网站能通过js访问document.cookie得到用户的cookie信息，比如sessionId，然后就会有csrf攻击 比如恶意网站写了一个iframe加载淘宝的登录页面，当用户进入网站，弹出登录页面，当用户输入密码后，因为没有同源策略，可以通过dom操作获取到用户输入的值，从而控制账号 jsonp因为浏览器的script、img、iframe标签是不受同源策略限制的 ，所以引用一个script标签，将他的src设置为接口地址并在其后添加一个callback=a的参数，这里的a是回调函数名称。因为是script标签，所以自动调用a函数，传到后台，用于包裹数据。当数据返回给前端后，就是a(result)的形式，戴上了参数，有了这个参数，执行我们的回调函数，处理数据 优点：兼容性好，在很古老的浏览器中也可以用，简单易用，支持浏览器与服务器双向通信。 缺点：只支持GET请求，且只支持跨域HTTP请求这种情况 CORS “跨域资源共享”（Cross-origin resource sharing，简称CORS）在服务器端通过检查请求头部的origin，从而决定请求应该成功还是失败。具体的方法是在服务端设置Response Header响应头中的Access-Control-Allow-Origin为对应的域名 与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 请求。 CORS 一般用XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。 1、简单请求 2、复杂请求 一个简单的请求大致如下： HTTP方法是下列之一 HEAD GET POST HTTP头信息不超出以下几种字段 Accept Accept-Language Content-Language Last-Event-ID Content-Type，但仅能是下列之一 application/x-www-form-urlencoded multipart/form-data text/plain 任何一个不满足上述要求的请求，即被认为是复杂请求。 简单请求需要包含一个域的信息。该域包含协议名、地址以及一个可选的端口。不过这一项实际上由浏览器代为发送，并不是开发者代码可以触及到的。 复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种”预请求”，此时作为服务端，也需要返回”预回应”作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。 预请求以OPTIONS形式发送，当中同样包含域，并且还包含了两项CORS特有的内容：Access-Control-Request-Method Access-Control-Request-Headers HTML5 中的window.postMessage方法可以使用它来向其它的window对象发送消息。在a页面中利用windowObj.postMessage(message, targetOrigin)向目标页面发送信息，而在b页面中通过监听message事件获取信息。不能和服务端交换数据，只能在两个窗口（iframe）之间交换数据。对于IE6、IE7等老版本浏览器无法使用。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css选择器及优先级]]></title>
    <url>%2F2019%2F03%2F05%2FCss3%2FCss%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[前言本篇讨论 css 的选择器、优先级算法以及选择器的优先级顺序 基本选择器 id选择器（#myid） 类选择器（.myclassname） 标签选择器(（div, h1, p） 相邻选择器（h1 + p）、子选择器（ul &gt; li）、后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=”external”]） 伪类选择器（a:hover/link/visited/active、li:nth-child） 优先级算法每个规则对应一个初始四位数：0、0、0、0 若为 内联选择器，加 1、0、0、0 若为 ID选择器，加 0、1、0、0 若为 类、伪类、属性选择器，加 0、0、1、0 若为 元素、伪元素选择器，加 0、0、0、1 通配选择器、子选择器、相邻选择器 都为 0、0、0、0 算法：将选择器对应的四位数相加，从左到右比较，大的优先级高 优先级注意： !important 的优先级是最高的，但出现冲突时还是需要比较四位数 优先级相同，则采用就近原则，选择最后出现的样式 继承的属性，优先级最低 !important &gt; 内联样式&gt;ID选择器 &gt; 类|伪类|属性选择器 &gt; 元素|伪元素选择器 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 内联样式 &gt; 内嵌样式 &gt; 外联/导入样式 伪类 与 伪元素伪类某个类的状态 链接伪类 【:link】 【:visited】 动态伪类 【:focus】 【:hover】 【:active】 静态伪类 【:first-child】选择元素的第一个子元素。 伪元素DOM 不存在的元素，只在 CSS 中用来渲染，添加一些特殊效果 首字母和首行 【:first-letter】 【:first-line】 之前和之后 【:before】 【:after】 经常见到::after和:after，为什么会出现单冒号和双冒号？单冒号 =&gt; CSS3 伪类，双冒号 =&gt; CSS3 伪元素 在 CSS3 中引入伪元素不再允许使用单冒号的写法，因此以后在某元素前后插入内容，要用双引号。]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[引入CSS样式的四种方式]]></title>
    <url>%2F2019%2F03%2F04%2FCss3%2F%E5%BC%95%E5%85%A5CSS%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言引入 CSS 样式表的方法，不外乎四种：内联、内嵌、外联、导入。接下来详细讨论其用法及优缺点 内联将 style属性 直接写在标签内 1&lt;标签 style='属性1: 值1;属性2: 值2;'&gt;&lt;/标签&gt; 优点 可灵活应用于各标签内 缺点 容易产生重复代码，增大文档体积 会让 html 代码冗余，不利于维护 内嵌写在 &lt;style&gt; 标签内，放在 html 文档的 头部 12345 &lt;style type="text/css"&gt; &lt;!-- 样式规则表 --&gt;&lt;/style&gt; 优点 适合单页面应用 结构与样式 分离 缺点 代码复用不方便 外联新建一个 css 样式表，通过 link 来引入样式 1&lt;linK rel='stylesheet' type='text/css' href=''&gt; 优点 利于后期维护 可以重复使用 结构与样式 分离 缺点 代码高度集中，代码量可能过大 维护不当的话容易出现混乱 会增加服务器连接请求，访问量较大时，需要在维护性和性能上进行权衡 导入新建一个 css 样式表，在 style 标签内，使用 @import url() 导入 12345&lt;style type="text/css"&gt;&lt;!--@import url(引入的样式表的位址、路径与档名);--&gt;&lt;/style&gt; 与 link 实现效果一样，不同： link @import 页面加载时同时引入样式 页面加载完成后再引入 是 xhtml 中的标签，兼容所有浏览器 CSS2.1 提出，低版本浏览器不会兼容 可以通过Js改变样式 不可以通过Js改变样式 可以引入除了 CSS 以外的其他文件 只能引入 CSS 文件]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Display 属性]]></title>
    <url>%2F2019%2F03%2F04%2FCss3%2FDisplay%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言display 属性值有： inherit、none、inline、block、inline-block、list-item(作为列表显示)、run-in(根据上下文作为块级元素或内联元素显示)、table及其相关的一系列值。下面我们讨论前面几个最常见的属性值 none 隐藏，元素不会显示 相较与 visibility: hidden 它会脱离文本流；把元素空间也隐藏掉；引发重绘，回流 而 hidden 不会脱离文本流；会保留元素空间；引发重绘 inline 默认值，内联元素（行内元素） 与其他元素在一行上 高度、宽度、内边距不可控；宽高就是内容的宽高 只能包含行内元素，不能包含块级元素 123456789101112131415&lt;span&gt;&lt;/span&gt;&lt;br&gt; 换行&lt;a&gt;&lt;/a&gt; 链接&lt;b&gt;&lt;/b&gt; 加粗&lt;strong&gt;&lt;/strong&gt; 加粗&lt;sup&gt;&lt;/sup&gt; 上标&lt;sub&gt;&lt;/sub&gt; 下标&lt;i&gt;&lt;/i&gt; 斜体&lt;em&gt;&lt;/em&gt; 斜体&lt;del&gt;&lt;/del&gt; 删除线&lt;u&gt;&lt;/u&gt; 下划线&lt;input&gt; 文本框&lt;textarea&gt;&lt;/textarea&gt; 多行文本&lt;select&gt;&lt;/select&gt; 下拉列表&lt;img&gt; 图片 block 块级元素 元素独占一行 宽高可控；宽度没有设置时，为100% 可以包含块级与行内元素 1234567891011121314&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; 段落&lt;h1&gt;&lt;/h1&gt; 标题等 &lt;ul&gt;&lt;/ul&gt; 无序列表&lt;ol&gt;&lt;/ol&gt; 有序列表&lt;dl&gt;&lt;/dl&gt; 定义列表&lt;li&gt;&lt;/li&gt;&lt;hr&gt; 水平分割线&lt;table&gt;&lt;/table&gt; 表格&lt;form&gt;&lt;/form&gt; 表单&lt;pre&gt;&lt;/pre&gt; 预格式化&lt;blockquote&gt;&lt;/blockquote&gt; 段落缩进，前后5个字符&lt;address&gt;&lt;/address&gt; 地址&lt;center&gt;&lt;/center&gt; inline-block 行内块元素 融合了 inline 和 block 特性，即是内联元素，又可以设置宽高]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Display</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Position 属性]]></title>
    <url>%2F2019%2F03%2F04%2FCss3%2FPosition%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言还记得刚开始入门前端的时候，总是被 position 弄得脑袋一团乱，现在打码多了，总算有点思路了。还是需要再理论巩固一下！ inherit 继承父元素的 position 属性 IE8及之前的版本不支持该属性 static 默认值，没有定位 元素处于正常的文档流中，忽略 left、right、top、bottom 和 z-index 属性 relative 相对定位，相对原本位置的定位 元素不脱离文档流，原本的位置会保留，其他元素位置不受影响 absolute 绝对定位 相对于 static 定位以外的第一个父元素定位；如果没有，则相对于 body 定位 元素脱离文档流，原本的位置会被后面的元素填充 fixed 绝对定位，可以说是特殊的 absolute 相对于 浏览器窗口 定位，不随滚动条改变位置 sticky 粘性定位，CSS3 新发布的一个属性，兼容性不好，只支持 FixFox 和 Safari 屏幕范围内不受定位影响，元素将要移出偏移范围，定位会变成 fixed ，根据设置的 left、top 等属性偏移 拓展z-index只在有定位的元素生效（relative、aboslute、fixed..）]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Position</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向]]></title>
    <url>%2F2019%2F03%2F01%2FJavaScript%2Fthis%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[普通的this指向this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象 如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window 如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象 如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象 构造函数的this指向1234567function Foo(name,age)&#123; this.name=name; this.age=age;&#125;var foo=new Foo("Tom",14);foo.name;//Tomfoo.age;//14 构造函数的 this 指向实例的，因为 new 的步骤 创建一个新对象 把构造函数的作用域赋给新对象，因此 this 指向新对象 新对象的 proto 属性指向构造函数的prototype原型 执行构造函数的代码 返回新对象 当this碰到return1234567function Foo(name,age)&#123; this.name=name; this.age=age; return &#123;name:"Jeff"&#125;&#125;var foo=new Foo("Tom",14);foo.name;//Jeff 如果返回值是一个对象({},[],RegExp, Date, Function)，那么this指向的就是那个返回的对象，如果返回值不是一个对象(基本类型)那么this还是指向函数的实例 箭头函数的this指向 箭头函数本身没有this，不能用call()、apply()、bind()这些方法去改变this的指向 箭头函数中的this是继承 父执行上下文 中的this，在定义函数的时候绑定，而不是在执行函数的时候绑定 123456789var x=11;var obj=&#123; x:22, say:()=&gt;&#123; console.log(this.x); &#125;&#125;obj.say();//输出的值为11 比如这里的箭头函数中的this.x，箭头函数本身与say平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而obj的父执行上下文就是window，因此这里的this.x实际上表示的是window.x，因此输出的是11 call,apply,bind方法的总结用途call 、apply 、bind 三者都是用来改变函数的this对象的指向的 call、apply 区别 call 接收的是参数列表 apply 接收的是参数数组 参数是传给调用的对象的 1234567891011121314151617var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125; &#125; var b = a.fn; b.call(a,1,2) // 3var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125; &#125; var b = a.fn; b.apply(a,[1,2]) // 3 call、apply 与 bind 区别call 和 apply 都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用 123456789101112131415var a =&#123; name : "Cherry", fn : function (a,b) &#123; console.log( a + b) &#125; &#125;var b = a.fn;b.bind(a,1,2)() // 3--- 或 ---var c = b.bind(a,1,2)c //注意，返回的是一个函数//ƒ (a,b) &#123;// console.log( a + b)//&#125;c() // 3 多次绑定 bind 只有第一次是有效的1234567891011var one = function()&#123; console.log(this.x);&#125;var two = &#123; x: 1&#125;var three = &#123; x: 2&#125;var fn = one.bind(two).bind(three);fn(); //1 因为 bind() 的实现，相当于使用函数在内部包了一个 call/apply，第二次 bind() 相当于再包住第一次 bind()，所以后面的 bind 都是无效的 12345var fn = function() &#123; return function() &#123; one.apply(two); &#125;.apply(three);&#125; 利用 call() 和 apply() 方法实现 bind() 方法12345678910if( !function()&#123;&#125;.bind ) &#123; Function.prototype.bind = function(obj) &#123; var self = this; //this 是调用函数的对象 var args = Array.prototype.slice.call(arguments); //将 arguments 类数组转换成数组 return function() &#123; return self.apply(obj, args.slice(1)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置next主题]]></title>
    <url>%2F2019%2F01%2F24%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F%E9%85%8D%E7%BD%AEnext%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装Next 下载主题在博客根目录 1git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题修改站点配置文件_config.yml 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 验证主题启用主题后，先清除缓存 1hexo clean 启用Hexo本地站点，验证主题 1hexo s --debug 主题设定选择皮肤 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 可以在主题配置文件进行切换，把注释#去除即可 123#scheme: Muse#scheme: Mistscheme: Pisces 设置语言在站点配置文件，设置language 1language: zh-Hans 设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。 主题配置文件 设定菜单内容 1234567menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 若你的站点运行在子目录中，请将链接前缀的 / 去掉 NexT 默认的菜单项有（标注 ！的项表示需要手动创建这个页面）： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页！ tags tags: /tags 标签页！ about about: /about 关于页面！ commonweal commonweal: /404.html 公益 404！ 设置菜单项的显示文本 在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： 123456789menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 something: 有料 设定菜单项的图标 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置头像编辑 主题配置文件，修改字段 avatar 12放置在 source/images/ 目录下 配置为：avatar: /images/avatar.png 设置作者昵称编辑 站点配置文件，设置 author 为你的昵称。 站点描述编辑 站点配置文件，设置 description 字段为你的站点描述。站点描述可以是你喜欢的一句签名:) 百度统计 登录百度统计，添加网站后，到代码获取页面 复制hm.js后面那串统计脚本id 编辑 主题配置文件， 修改字段 baidu_analytics 字段，值设置成你的百度统计脚本 id。 创建 分类生成分类页1$ hexo new page categories 成功后进入文件，打开后默认 1234---title: 文章分类date: 2017-05-27 13:47:40--- 添加type 12345---title: 文章分类date: 2017-05-27 13:47:40type: "categories"--- 保存 关闭 创建 标签生成标签页1$ hexo new page tags 成功后进入文件，打开后默认 1234---title: 标签date: 2017-05-27 13:47:40--- 添加type 12345---title: 分类date: 2017-05-27 13:47:40type: "tags"--- 保存 关闭 创建 新文章1hexo new '文章名' 打开 scaffolds/post.md 12345678910---title: jQuery对表单的操作及更多应用date: 2017-05-26 12:12:57categories: - web前端tags:- jQuery- 表格- 表单验证--- 注意categories只有一个，tags允许多个 侧边栏社交链接主题配置文件 123456789101112131415social: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name # 等等 # Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 注意要去掉social,social icons的注释！！以及enable要设置为true 腾讯公益404页面使用方法，新建 404.html 页面，放到主题的 source 目录下，内容如下： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 站点建立时间这个时间将在站点的底部显示，例如 © 2017 - 2019。 编辑 主题配置文件，字段 since。 12footer: since: 2013 设置「背景动画」NexT 自带两种背景动画效果 编辑 主题配置文件， 搜索 canvas_nest 或 three_waves，根据您的需求设置值为 true 或者 false 即可： 注意： three_waves 在版本 5.1.1 中引入。只能同时开启一种背景动画效果。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pixi]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%8A%A8%E7%94%BB%2Fpixi%2F</url>
    <content type="text"><![CDATA[介绍Pixi是一个超快的2D渲染引擎。 安装需要在你项目的根目录运行一个web服务器 安装http-server1npm install http-server -g 使用http-server打开 安装 PixiPixi的主要发布页面中获取最新版本。 创建一个基础的HTML页面，用一个标签去加载你刚刚下载的pixi.min.js文件。 测试用123456789101112131415161718&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt; &lt;script src="pixi/pixi.min.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;script type="text/javascript"&gt; let type = "WebGL" if(!PIXI.utils.isWebGLSupported())&#123; type = "canvas" &#125; PIXI.utils.sayHello(type) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果Pixi连接成功，一些这样的东西会在你的浏览器控制台里显示： 1PixiJS 4.4.5 - * canvas * http://www.pixijs.com/ ♥♥♥ 创建Pixi应用和 舞台12345//Create a Pixi Applicationlet app = new PIXI.Application(&#123;width: 256, height: 256&#125;);//Add the canvas that Pixi automatically created for you to the HTML documentdocument.body.appendChild(app.view); 第一步就是去创建一个可以显示图片的矩形显示区。Pixi拥有一个Pixi应用对象来帮助你创建它。它会自动创建一个HTML标签并且计算出怎么去让你的图片在这个标签中显示。你现在需要创建一个特殊的Pixi容器对象，他被称作舞台。正如你所见，这个舞台对象将会被当作根容器而使用，它将包裹所有你想用Pixi显示的东西。 PIXI.Application算出了应该使用Canvas还是WebGL去渲染图象，它取决于你正在使用的浏览器支持哪一个。 12345678let app = new PIXI.Application(&#123; width: 256, // default: 800 height: 256, // default: 600 antialias: true, // default: false 圆滑边界，使得字体的边界和几何图形更加圆滑 transparent: false, // default: false 透明度 resolution: 1 // default: 1 分辨率 &#125;); Pixi的画布对象将会默认选择WebGL引擎渲染模式，但是如果你需要强制使用Canvas引擎绘制而抛弃WebGLforceCanvas: true, 1234567891011app.renderer.backgroundColor = 0x061639; //改变背景颜色app.renderer.autoResize = true; //确认宽高的格式正确app.renderer.resize(512, 512); //改变大小//让canvas占据整个窗口app.renderer.view.style.position = "absolute";app.renderer.view.style.display = "block";app.renderer.autoResize = true;app.renderer.resize(window.innerWidth, window.innerHeight);&lt;style&gt;* &#123;padding: 0; margin: 0&#125;&lt;/style&gt; Pixi 精灵Pixi拥有一个精灵类来创建游戏精灵。有三种主要的方法来创建它： 用一个单图像文件创建。 用一个 雪碧图 来创建。雪碧图是一个放入了你游戏所需的所有图像的大图。 从一个纹理贴图集中创建。（纹理贴图集就是用JSON定义了图像大小和位置的雪碧图） 将图片加载到纹理缓存中因为Pixi用WebGL和GPU去渲染图像，所以图像需要转化成GPU可以处理的版本。可以被GPU处理的图像被称作 纹理 。在你让精灵显示图片之前，需要将普通的图片转化成WebGL纹理。 Pixi强大的loader对象可以加载任何你需要种类的图像资源。 1234567PIXI.loader .add([ "images/imageOne.png", "images/imageTwo.png", "images/imageThree.png"]) .load(setup); 显示精灵1234567891011121314151617181920212223242526272829app.stage.addChild(cat);//Create a Pixi Applicationlet app = new PIXI.Application(&#123; width: 256, height: 256, antialias: true, transparent: false, resolution: 1&#125; );//Add the canvas that Pixi automatically created for you to the HTML documentdocument.body.appendChild(app.view);//load an image and run the `setup` function when it's donePIXI.loader .add("images/cat.png") .load(setup);//This `setup` function will run when the image has loadedfunction setup() &#123; //Create the cat sprite let cat = new PIXI.Sprite(PIXI.loader.resources["images/cat.png"].texture); //Add the cat to the stage app.stage.addChild(cat);&#125; 如果你想把一个精灵从舞台上挪走，可以把精灵的visible属性设置成false来让精灵简单的隐藏。anySprite.visible = false; 使用别名来看看怎么将所有的Pixi对象和方法改成别名之后，来重写加载和显示图像的代码。 123456789101112131415161718192021222324252627282930313233//Aliaseslet Application = PIXI.Application, loader = PIXI.loader, resources = PIXI.loader.resources, Sprite = PIXI.Sprite;//Create a Pixi Applicationlet app = new Application(&#123; width: 256, height: 256, antialias: true, transparent: false, resolution: 1&#125; );//Add the canvas that Pixi automatically created for you to the HTML documentdocument.body.appendChild(app.view);//load an image and run the `setup` function when it's doneloader .add("images/cat.png") .load(setup);//This `setup` function will run when the image has loadedfunction setup() &#123; //Create the cat sprite let cat = new Sprite(resources["images/cat.png"].texture); //Add the cat to the stage app.stage.addChild(cat);&#125; 一些关于加载的其他知识 使用普通的javaScript Img对象或canvas创建一个精灵如果因为某些原因你需要从JavaScript的Image对象之中创建，你可以使用Pixi的BaseTexture和Texture类： 123let base = new PIXI.BaseTexture(anyImageObject), texture = new PIXI.Texture(base), sprite = new PIXI.Sprite(texture); 你可以使用BaseTexture.fromCanvas从任何已经存在canvas标签中创建纹理： 1let base = new PIXI.BaseTexture.fromCanvas(anyCanvasElement), 如果你想改变已经显示的精灵的纹理，使用texture属性，可以设置任何Texture对象，像下面这样： 1anySprite.texture = PIXI.utils.TextureCache["anyTexture.png"]; 你可以使用这个技巧在游戏发生一些重大变化时交互式的改变精灵的纹理。 监视加载进程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556PIXI.loader.on("progress", loadProgressHandler);PIXI.loader .add([ "images/one.png", "images/two.png", "images/three.png"]) .on("progress", loadProgressHandler) .load(setup);function loadProgressHandler() &#123; console.log("loading");&#125;function setup() &#123; console.log("setup");&#125;loadingloadingloadingsetupPIXI.loader .add([ "images/one.png", "images/two.png", "images/three.png"]) .on("progress", loadProgressHandler) .load(setup);function loadProgressHandler(loader, resource) &#123; //Display the file `url` currently being loaded console.log("loading: " + resource.url); //Display the percentage of files currently loaded console.log("progress: " + loader.progress + "%"); //If you gave your files names as the first argument //of the `add` method, you can access them like this //console.log("loading: " + resource.name);&#125;function setup() &#123; console.log("All files loaded");&#125;loading: images/one.pngprogress: 33.333333333333336% loading: images/two.pngprogress: 66.66666666666667% loading: images/three.pngprogress: 100% All files loaded //resource.error会告诉你有哪些加载时候的错误 add 方法有四个基础参数: 1add(name, url, optionObject, callbackFunction) 这里有文档里面对这些参数的描述： name (string): 加载源文件的别名,如果没设置，url就会被放在这. url (string): 源文件的地址，是加载器 baseUrl的相对地址. options (object literal): 加载设置. options.crossOrigin (Boolean): 源文件请求跨域不？默认是自动设定的。 options.loadType: 源文件是怎么加载进来的？默认是Resource.LOAD_TYPE.XHR。 options.xhrType: 用XHR的时候该怎么处理数据？ 默认是Resource.XHR_RESPONSE_TYPE.DEFAULT。 callbackFunction: 当这个特定的函数加载完，这个特定的函数将会被执行。 只有url必填（你总得加载个文件吧。） 第一个就是文档里所谓的“正常语法”： 123.add('key', 'http://...', function () &#123;&#125;).add('http://...', function () &#123;&#125;).add('http://...') 第二个就是所谓“对象语法”啦： 1234567891011121314151617181920.add(&#123; name: 'key2', url: 'http://...'&#125;, function () &#123;&#125;).add(&#123; url: 'http://...'&#125;, function () &#123;&#125;).add(&#123; name: 'key3', url: 'http://...' onComplete: function () &#123;&#125;&#125;).add(&#123; url: 'https://...', onComplete: function () &#123;&#125;, crossOrigin: true&#125;) 第三个可以给add方法传一个对象的数组，或者既使用对象数组，又使用链式加载： 12345.add([ &#123;name: 'key4', url: 'http://...', onComplete: function () &#123;&#125; &#125;, &#123;url: 'http://...', onComplete: function () &#123;&#125; &#125;, 'http://...']); （注意：如果你需要重新加载一批文件，调用加载器的reset方法：PIXI.loader.reset();） 精灵位置1234cat.x = 96;cat.y = 96;sprite.position.set(x, y) 大小和比例123456cat.width = 80;cat.height = 120;cat.scale.x = 0.5;cat.scale.y = 0.5;cat.scale.set(0.5, 0.5); 旋转12345cat.rotation = 0.5;// 旋转是相对于锚点的，有两种方法设置锚点cat.anchor.x = 0.5;cat.anchor.y = 0.5;cat.anchor.set(x, y) 原点1cat.pivot.set(32, 32) 假设精灵图是64x64像素，它将绕着它的中心点旋转。但是记住：你如果改变了精灵的pivot属性，你也就改变了它的原点位置。 anchor改变了精灵纹理的图像原点，用0到1的数据来填充。pivot则改变了精灵的原点，用像素的值来填充。 从精灵图（雪碧图）中创建精灵 1234567891011121314151617181920212223242526272829loader .add("images/tileset.png") .load(setup);function setup() &#123; //Create the `tileset` sprite from the texture let texture = TextureCache["images/tileset.png"]; //Create a rectangle object that defines the position and //size of the sub-image you want to extract from the texture //(`Rectangle` is an alias for `PIXI.Rectangle`) let rectangle = new Rectangle(192, 128, 64, 64); //Pixi内置了一个通用的Rectangle对象 (PIXI.Rectangle)，他是一个用于定义矩形形状的通用对象。他需要一些参数，前两个参数定义了x 和y轴坐标位置，后两个参数定义了矩形的width 和 height //Tell the texture to use that rectangular section texture.frame = rectangle; //Pixi的纹理中有一个叫做frame的很有用的属性，它可以被设置成任何的Rectangle对象。frame将纹理映射到Rectangle的维度。 //Create the sprite from the texture let rocket = new Sprite(texture); //Position the rocket sprite on the canvas rocket.x = 32; rocket.y = 32; //Add the rocket to the stage app.stage.addChild(rocket); //Render the stage renderer.render(stage);&#125; 使用一个纹理贴图集一个纹理贴图集就是一个JSON数据文件，它包含了匹配的PNG雪碧图的子图像的大小和位置。如果你使用了纹理贴图集，那么想要显示一个子图像只需要知道它的名字就行了。你可以任意的排序你的排版，JSON文件会保持他们的大小和位置不变。这非常方便，因为这意味着图片的位置和大小不必写在你的代码里。如果你想要改变纹理贴图集的排版，类似增加图片，修改图片大小和删除图片这些操作，只需要修改那个JSON数据文件就行了，你的游戏会自动给程序内的所有数据应用新的纹理贴图集。你没必要在所有用到它代码的地方修改它。 Pixi兼容著名软件Texture Packer输出的标准纹理贴图集格式。 如果你正在用免费版的Texture Packer，把 Algorithm 选项设为Basic，把 Trim mode 选项设为None，把 Extrude 选项设为0，把 Size constraints 选项设为 Any size ，把 PNG Opt Level 中所有的东西都滑到左边的 0位置。这就可以使得Texture Packer正常的输出你的纹理贴图集。如果你做完了，点击 Publish 按钮。选择输出文件名和存储地址，把生成文件保存起来。你将会获得两个文件：一个叫做treasureHunter.json，另外一个就是treasureHunter.png。为了让目录干净些，我们把他俩都放到一个叫做images的文件夹里面去。（你可以认为那个json文件是图片文件的延伸，所以把他们放进一个文件夹是很有意义的。）那个JSON文件里面写清楚了每一个子图像的名字，大小和位置。下面描述了“泡泡怪”这个怪物的子图像的信息。 123456789"blob.png":&#123; "frame": &#123;"x":55,"y":2,"w":32,"h":24&#125;, "rotated": false, "trimmed": false, "spriteSourceSize": &#123;"x":0,"y":0,"w":32,"h":24&#125;, "sourceSize": &#123;"w":32,"h":24&#125;, "pivot": &#123;"x":0.5,"y":0.5&#125;&#125;, 这些子图像每一个都被叫做 帧 ,有了这些数据你就不用去记每一个图片的大小和位置了，你唯一要做的就只是确定精灵的 帧ID 即可。帧ID就是那些图片的原始名称，类似"blob.png"或者 "explorer.png"这样。 加载纹理贴图集建议给纹理贴图集的textures对象创建一个叫做id的别名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455let id = PIXI.loader.resources["images/treasureHunter.json"].textures;let id = PIXI.loader.resources["images/treasureHunter.json"].textures;//Define variables that might be used in more//than one functionlet treasure, id;function setup() &#123; //Create an optional alias called `id` for all the texture atlas //frame id textures. id = PIXI.loader.resources["images/treasureHunter.json"].textures; //Make the treasure box using the alias treasure = new Sprite(id["treasure.png"]); app.stage.addChild(treasure); //Position the treasure next to the right edge of the canvas treasure.x = app.stage.width - treasure.width - 48; treasure.y = app.stage.height / 2 - treasure.height / 2; app.stage.addChild(treasure);&#125;let numberOfBlobs = 6, spacing = 48, xOffset = 150;//Make as many blobs as there are `numberOfBlobs`for (let i = 0; i &lt; numberOfBlobs; i++) &#123; //Make a blob let blob = new Sprite(id["blob.png"]); //Space each blob horizontally according to the `spacing` value. //`xOffset` determines the point from the left of the screen //at which the first blob should be added. let x = spacing * i + xOffset; //Give the blob a random y position //(`randomInt` is a custom function - see below) let y = randomInt(0, app.stage.height - blob.height); //Set the blob's position blob.x = x; blob.y = y; //Add the blob sprite to the stage app.stage.addChild(blob);&#125;&#125;//The `randomInt` helper functionfunction randomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1)) + min;&#125; randomInt是一个很好的用来做游戏的工具函数 移动精灵使用Pixi的ticker。这被称为 游戏循环 。任何在游戏循环里的代码都会1秒更新60次。 游戏状态123456789101112131415161718//Set the game statestate = play;//Start the game loopapp.ticker.add(delta =&gt; gameLoop(delta));function gameLoop(delta)&#123; //Update the current game state: state(delta);&#125;function play(delta) &#123; //Move the cat 1 pixel to the right each frame cat.vx = 1 cat.x += cat.vx;&#125; delta的值代表帧的部分的延迟。你可以把它添加到cat的位置，让cat的速度和帧率无关。下面是代码:cat.x += 1 + delta;是否加进去这个delta的值其实是一种审美的选择。它往往只在你的动画没法跟上60帧的速率时候出现（比如你的游戏运行在很老旧的机器上）。 速度属性 ：vx和 vy去控制精灵的运动速度。 键盘移动123456789101112131415161718192021222324252627282930313233343536function keyboard(keyCode) &#123; let key = &#123;&#125;; key.code = keyCode; key.isDown = false; key.isUp = true; key.press = undefined; key.release = undefined; //The `downHandler` key.downHandler = event =&gt; &#123; if (event.keyCode === key.code) &#123; if (key.isUp &amp;&amp; key.press) key.press(); key.isDown = true; key.isUp = false; &#125; event.preventDefault(); &#125;; //The `upHandler` key.upHandler = event =&gt; &#123; if (event.keyCode === key.code) &#123; if (key.isDown &amp;&amp; key.release) key.release(); key.isDown = false; key.isUp = true; &#125; event.preventDefault(); &#125;; //Attach event listeners window.addEventListener( "keydown", key.downHandler.bind(key), false ); window.addEventListener( "keyup", key.upHandler.bind(key), false ); return key;&#125; 用的方法： 1234567let keyObject = keyboard(asciiKeyCodeNumber);keyObject.press = () =&gt; &#123; //key object pressed&#125;;keyObject.release = () =&gt; &#123; //key object released&#125;; 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//Define any variables that are used in more than one functionlet cat, state;function setup() &#123; //Create the `cat` sprite cat = new Sprite(resources["images/cat.png"].texture); cat.y = 96; cat.vx = 0; cat.vy = 0; app.stage.addChild(cat); //Capture the keyboard arrow keys let left = keyboard(37), up = keyboard(38), right = keyboard(39), down = keyboard(40); //Left arrow key `press` method left.press = () =&gt; &#123; //Change the cat's velocity when the key is pressed cat.vx = -5; cat.vy = 0; &#125;; //Left arrow key `release` method left.release = () =&gt; &#123; //If the left arrow has been released, and the right arrow isn't down, //and the cat isn't moving vertically: //Stop the cat if (!right.isDown &amp;&amp; cat.vy === 0) &#123; cat.vx = 0; &#125; &#125;; //Up up.press = () =&gt; &#123; cat.vy = -5; cat.vx = 0; &#125;; up.release = () =&gt; &#123; if (!down.isDown &amp;&amp; cat.vx === 0) &#123; cat.vy = 0; &#125; &#125;; //Right right.press = () =&gt; &#123; cat.vx = 5; cat.vy = 0; &#125;; right.release = () =&gt; &#123; if (!left.isDown &amp;&amp; cat.vy === 0) &#123; cat.vx = 0; &#125; &#125;; //Down down.press = () =&gt; &#123; cat.vy = 5; cat.vx = 0; &#125;; down.release = () =&gt; &#123; if (!up.isDown &amp;&amp; cat.vx === 0) &#123; cat.vy = 0; &#125; &#125;; //Set the game state state = play; //Start the game loop app.ticker.add(delta =&gt; gameLoop(delta));&#125;function gameLoop(delta)&#123; //Update the current game state: state(delta);&#125;function play(delta) &#123; //Use the cat's velocity to make it move cat.x += cat.vx; cat.y += cat.vy&#125;]]></content>
      <categories>
        <category>动画</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019.01]]></title>
    <url>%2F2019%2F01%2F02%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F2019.01%2F</url>
    <content type="text"><![CDATA[2019.01.021.git 不提交某个文件 1git update-index --assume-unchanged src/partner/dc/config/dbs.js 2.测试IE IETester 3.IE报错 IE11浏览器出现”TypeError:对象不支持”starsWith”属性或方法” 1cnpm install babel-polyfill --save 在入口文件第一行加上 1import &quot;babel-polyfill&quot; 判断IE和Edge，世界之窗12345678910111213141516171819202122232425var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1;var isEdge = userAgent.indexOf(&quot;Edge&quot;)&gt;-1&amp;&amp;!isIE;var isWorld = userAgent.match(&quot;TheWorld&quot;);var isIE11 = userAgent.indexOf(&apos;Trident&apos;)&gt;-1&amp;&amp;userAgent.indexOf(&apos;rv:11.0&apos;)&gt;-1;if (isIE) &#123; var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;); reIE.test(userAgent); var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]); if (fIEVersion == 7) &#123; return 7; &#125; else if (fIEVersion == 8) &#123; return 8; &#125; else if (fIEVersion == 9) &#123; return 9; &#125; else if (fIEVersion == 10) &#123; return 10; &#125; else if (isEdge) &#123; return &quot;edge&quot;; &#125; else if (isIE11) &#123; return 11; &#125; else &#123; return -1; &#125; 2019.01.03slice &amp;&amp; splice slice不改变原数组，切割 splice会改变原数组，删除 2019.01.04单例模式 如果有同样的函数或组件出现，会销毁前一个 router-view 是个单例 例子：项目中，父子组件都用到了播放器组件，因为vue，不会销毁，两个点击后都会出现，设计单例模式 因为vue的destoryed销毁后dom还在，还需要进行一系列操作。而v-if可以实现组件销毁，因此通过v-if设计。 2019.01.14pixi教程 2019.01.15调试Node,下载nodemon,然后nodemon 文件，不然每次改完都需要run 2019.01.161.引用模块module.exports = getSql;才能用getSql引用模块 import 方法，不能嵌套用，比如cp_game.js在其他地方require，就不能import，只能require 2.console.log &amp;&amp; log4jsconsole是控制台对象，console.log是到了运行端的控制台，所以express部分是打印到了后端控制台而不是浏览器；界面的是打印到了浏览器标准的服务器log，其实是变成了文本文件。log4js标准是后端很稳定可靠的日志设计，log4js是node版本，本质也会产生log文件，会到一个文本文件里。 2019.01.171.return不成功 12345678910如果一个方法里有异步，return会不成功，采用以下方法a:function(sql,callback) &#123; if(callback) &#123; callback(a) &#125; return a;&#125;a(sql,function(result)&#123;&#125; 2.log4js不会自动创建文件夹 3.命名 命名使用业务术语，而非计算机术语，即更多表现业务逻辑。 1list =&gt; flaggedCells 尽量不要缩写 不同的程序员命名相同的业务术语一致 驼峰命名 如何缩短命名，避免范围内重复 12比如：person下的 personName personId 4.工具不是简单地把通用的代码抽离出来，而是实现用户在页面中输入少量且简单地代码，工具收到参数后即可进行功能作用——通用、简化 2018.01.22vue不要直接赋值 this.skillform.intentionTable = result.data 容易赋值不成功，比如result.data 没有id的属性，之后操作this.skillform.intentionTable.id是不能成功的 2018.01.23try,catch,throw123456try &#123; //在这里运行代码&#125;catch(err) &#123; //在这里处理错误&#125; throw 创建自定义错误 可以直接用 123if(x&gt;10) &#123; throw &apos;too high&apos;&#125; 与try catch连用 123456try &#123; if(x&gt;10) throw &apos;too high&apos;&#125;catch(err) &#123; let a = &apos;Error:&apos; + err&#125; export,export default,import || export,module.exports,requiremodule exports 和 require因为Node应用由模块组成，采用CommonJs模块规范。根据这个规范，每个文件就是一个模块，有自己的作用域。在这些文件里面定义的变量、函数、类，都是私有的，对外不可见。因此规避了作用域污染。根据CommonJS规定，每个模块内部，module变量代表当前模块，这个变量是一个对象，它的exports属性是对外的接口，加载某个模块，其实就是加载该模块的exports属性 1234567891011MyModule.jsconst config = &#123; case: function()&#123; &#125;&#125;module.exports = config引入 var config = require(&apos;./MyModule&apos;) exports 与 module.exports1node中，exports = module.exports 但 12exports = config (x)exports.config = config (√) export和importES6中，导出export，导入import 补充 export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。CommonJS输出的值是缓存，不存在动态更新。 export和import命令不能在块级作用域，要在模块顶层。 import命令具有提升效果，会提升到整个模块的头部，首先执行。 检查父子组件！！一个诡异的问题： 页面有添加和修改功能，修改后表格会相应更新，但添加不会。它们都是通过点击打开弹窗（子组件），保存后调用表格（父组件）的初始化功能。后发现，添加是在另一个组件，其父组件不是表格而是表格的父组件（页面），所以需要调用表格的方法打开父组件。 2018.01.251.git push失败 因为做博客，换了账号提交，还提交了很多次，结果push失败。 首先用现在的账号回到第一次提交git abort 然后git add …. 换账号，git log,git reset… 提交 2.operation not permitted 权限不够，给文件夹加上权限。如有加不上的，一直报无权限的，试试注销电脑 3.不提交log文件 .gitgnore中，加上 *.log ，git add .gitgnore 2019.01.28算一个字符串在数组中出现多少次 1const countOccurrences = (arr,value) =&gt; arr.reduce( (a,v) =&gt; (v===value?a+1:a+0),0 )]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>百田</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.12]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F2018.12%2F</url>
    <content type="text"><![CDATA[2018.12.04ant组件 Bug 123表格数据更改后，前端不会实时更新A.B = [] 不生效 -&gt; B=[] A.B=[] 2018.12.05localstorage 没有数组结构 1localstroage.getItem(&apos;visited&apos;).split(&apos;,&apos;) 2018.12.06当播放组件不适应： 12341.组件inline-block2.中间波宽度 width:calc( 90%-3.6rem ) 3.文字两端对齐calc:动态计算宽度，左右两边需要加空格 2018.12.071.linux命令 12345:q 退出:q! 强制退出，不保存修改的内容:wq 保存编辑操作退出:wq! 保存编辑强制退出 2. 12Duplicate keys detected:&apos;京东&apos;,This may cause an update error.=&gt; :key=index 2018.12.101.设置下拉框的变量，用数字代替 1winner=[&apos;1&apos;,&apos;2&apos;] 取代 winner=[&apos;角色1&apos;,&apos;角色2&apos;] 2.变量尽量完整 3.功能调整实现后，建议先检查一遍这几个功能方法，然后有可能简单整理重构第一次 4.方法可传多个参数，就是一个方法用作多个地方，比如上传和修改 5.想分开哪行传入哪个upload 123456789101112&lt;el-upload :http-request:&apos;test&apos;&gt; &lt;div&gt;上传&lt;/div&gt; &lt;div&gt;上传&lt;/div&gt;&lt;/el-upload&gt;1.：action=&apos;scope.$index&apos;2.:data=&apos;scope.$index&apos;test(file)&#123; console.log(file.action/data)&#125; 2018.12.111.添加文本，输入字总是莫名其妙消失 12因为@change=test(row,false)test()方法有两个提交事件，异步慢 -&gt; 用@blur 2.解决两个页面共同调试 1一个页面开匿名模式（无痕） 3.改host名 1231.win+R -&gt; drivers2.etc -&gt; hosts3.加 ip 名字（127.0.0.1 zw.ais.bt） 2018.12.121.按多个字符切割 1data.split(/[\t\n]/) 2.eval() 括号内是可执行代码，风险比较大 eval(‘fd.’ + key + ‘=”‘ +char + ‘“‘) 还差 react dns 批量处理 分页 2018.12.13eval() 123a=&quot;[&#123; questionId: 1,index: 1,type: 0,option:&apos;第一个：艺术家，&apos;,url: null,optionFlag: &apos;艺术家&apos;,correct: true&#125;,&#123;questionId: 1,index: 2,type: 0,option: &apos;第二个：水晶饺&apos;,url: null,optionFlag: &apos;水晶饺&apos;,correct: false&#125;]&quot;eval(&apos;b=(&apos;+a+&apos;)&apos;) 2018.12.17纯前端分页 创建一个计算变量 为 curry_corpus. 创建总页码(total)，当前页(page)，每页页数(limit) 这三个变量 创建一个 map,关联curpus ID和原本全量curpus的Index 然后 curry_corpus 的逻辑是 ，截取 (page-1)*limit 到 page * limit 切换页面直接修改 page。 后台有接口的话，直接传limit offset，没有的话，用slice() 2018.12.281.css 1:class=&quot;&#123;red:corpusIdsText===&apos;缺音频&apos;&#125;&quot; 2.ant 123456789101112131415161718192021222324&lt;a-table :dataSource=&apos;corpusArr&apos;...&gt; &lt;span slot=&apos;time&apos; slot-scope=&apos;record&apos;&gt; &lt;audio ref=&quot;&apos;audioTime_&apos;+record.id&quot; :durationchange=&quot;getFileTime($event.target.duration,corpusMap.get(record.id))&quot; :src=&quot;record.url&quot;&gt;&lt;/audio&gt; &lt;/span&gt;&lt;/a-table&gt;computed: &#123; corpusArr() &#123; if (this.corpusMap.size !== this.voiceOptions.length) &#123; this.voiceOptions.forEach((item, index) =&gt; &#123; this.corpusMap.set(item.id, index); &#125;); &#125; return [].concat(...this.voiceOptions); &#125;,&#125;,methods:&#123; getFileTime(time, index) &#123; this.voiceOptions[index].time = this.formatTime(time); this.$set(this.voiceOptions, index, this.voiceOptions[index]); &#125;,&#125; 3.写样式 尽量以视觉划分 尽量用通用class，加一个]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>百田</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL必知必会]]></title>
    <url>%2F2018%2F11%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FSQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[12graph LRA--&gt;B1.1 数据库基础数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。表（table）某种特定类型数据的结构化清单。模式关于数据库和表的布局及特性的信息。 列（column）表中的一个字段。所有表都是由一个或多个列组成的。 行（row）表中的一个记录。 主键（primary key）一列（或一组列），其值能够唯一标识表中每一行。 1.2SQLSQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库沟通的语言。 第 2 章 MySQL简介2.1 什么是MySQLMySQL是一种DBMS（数据库管理系统） 2.1.1 客户机—服务器软件DBMS可分为两类：一类为基于共享文件系统的DBMS，另一类为基于客户机—服务器的DBMS。(MySQL) 服务器部分是负责所有数据访问和处理的一个软件。这个软件运行在称为数据库服务器的计算机上。关于数据、数据添加、删除和数据更新的所有请求都由服务器软件完成。这些请求或更改来自运行客户机软件的计算机。客户机是与用户打交道的软件。 2.2 MySQL工具为了使用MySQL，需要有一个客户机，即你需要用来与MySQL打交道（给MySQL提供要执行的命令）的一个应用。 2.2.1 mysql命令行实用程序 在操作系统命令提示符下输入mysql会出现welcome to the mysql monitor 第３章 使用MySQL3.1 连接为了连接到MySQL，需要以下信息： 主机名（计算机名）——如果连接到本地MySQL服务器，为localhost； 端口（如果使用默认端口3306之外的端口）; 一个合法的用户名； 用户口令（如果需要）。 3.2 选择数据库输入 use crashcourse;输出 Database changed分析 USE语句并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。例如，这里显示出的Database changed消息是mysql命令行实用程序在数据库选择成功后显示的。（use为一个关键字） 3.3 了解数据库和表1.SHOW DATABASES;返回可用数据库的一个列表。包含在这个列表中的可能是MySQL内部使用的数据库（如例子中的mysql和information_schema）。当然，你自己的数据库列表可能看上去与这里的不一样。 2.SHOW TABLES;返回当前选择的数据库内可用表的列表。SHOW也可以用来显示表列： 3.SHOW COLUMNS 要求给出一个表名（这个例子中的 FROM customers），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment）。(DESCRIBE customers == SHOW COLUMNS FROM customers;) 4.SHOW STATUS，用于显示广泛的服务器状态信息； 5.SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； 6.SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限； 7.SHOW ERRORS和SHOW WARNINGS，用来显示服务器错误或警告消息。 第 4 章 检 索 数 据 4.1 SELECT语句为了使用SELECT检索表数据，必须至少给出两条信息——想选择什么，以及从什么地方选择。 4.2 检索单个列SELECT prod_nameFROM products; 上述语句利用SELECT语句从products表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。 4.3 检索多个列SELECT prod_name,prod_idFROM products; 4.4 检索所有列SELECT *FROM products; 4.5 检索不同的行SELECT vend_idFROM products; 会返回所有匹配的行，但是不想每个值每次都出现。比如上述命令，返回了14个行，因为有14个产品，但是只有4个经销商 SELECT DISTINCT vend_idFROM products; (不能部分使用DISTINCT DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price，除非指定的两个列都不同，否则所有行都将被检索出来。) 4.6 限制结果SELECT prod_nameFROM productsLIMIT 5;返回不多于5行 SELECT prod_nameFROM productsLIMIT 5,5;从第5行开始的5行，两个参数时，第一个为开始的位置，第二个为要检索的行数。 注释：1.返回的数据没有顺序可言。2.多条SQL语句必须以分号（；）分隔，不需要在单条SQL语句后加分号。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。3.SQL语句不区分大小写，建议对所有SQL关键字使用大写，而对所有列和表名使用小写。4.在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。分开来比较易于读 第５章 排序检索数据 5.1 排序数据 SELECT prod_nameFROM productsORDER BY prod_name; (子句（clause）一个子句通常由一个关键字和所提供的数据组成。子句的例子有SELECT语句的FROM子句。) 5.2 按多个列排序 SELECT prod_name,prod_priceFROM productsORDER BY prod_name,prod_price; 5.3 指定排序方向 SELECT pord_id,prod_name,prod_priceFROM productsORDER BY prod_name DESC,prod_price; DESC关键字只应用到直接位于其前面的列名.降序 第６章 过 滤 数 据 6.1 使用WHERE子句 SELECT prod_name,prod_priceFROM productsWHERE prod_price = 2.50; 从products表中检索两个列，但不返回所有行，只返回prod_price值为2.50的行 (在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误) 6.2 WHERE子句操作符 6.2.1 检查单个值SELECT prod_name,prod_priceFROM productsWHERE prod_name = ‘wei’; MySQL在执行匹配时默认不区分大小写，所以wei与WEI匹配。 6.2.2 不匹配检查 6.2.3 范围值检查 SELECT prod_name,prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10; 在使用BETWEEN时，必须指定两个值——所需范围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。 6.2.4 空值检查 (NULL 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。) SELECT prod_name,prod_priceFROM productsWHERE prod_price IS NULL; 第 7 章 数 据 过 滤 7.1 组合WHERE子句 (操作符（operator） 用来联结或改变WHERE子句中的子句的关键字。也称为逻辑操作符（logical operator）。) 7.1.1 AND操作符 SELECT pord_id,prod_name,prod_priceFROM productsWHERE vend_id = 1003 AND prod_price &lt;= 10; 7.1.2 OR操作符 SELECT prod_name,prod_priceFROM productsWHERE vend_id = 1002 OR vend_id = 1003; 7.1.3 计算次序 WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂和高级的过滤。AND的优先度大于OR，所以一定要用圆括号 任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确地分组操作符。 SELECT prod_name,prod_priceFROM productsWHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 13; 7.2 IN操作符 SELECT prod_name,prod_priceFROM productsWHERE vend_id IN (1002，1003); IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当。用IN，更好 7.3 NOT操作符 否定它之后所跟的任何条件。 SELECT prod_name,prod_priceFROM productsWHERE vend_id NOT IN (1002，1003); 第 8 章 用通配符进行过滤 8.1 LIKE操作符 怎样搜索产品名中包含文本anvil的所有产品？用简单的比较操作符肯定不行，必须使用通配符。利用通配符可创建比较特定数据的搜索模式。在这个例子中，如果你想找出名称包含anvil的所有产品，可构造一个通配符搜索模式，找出产品名中任何位置出现anvil的产品。 通配符（wildcard） 用来匹配值的一部分的特殊字符。搜索模式（search pattern）① 由字面值、通配符或两者组合构成的搜索条件。 8.1.1 百分号（%）通配符 在搜索串中，%表示任何字符出现任意次数。 SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE ‘jet%’; 此例子使用了搜索模式’jet%’。在执行这条子句时，将检索任意以jet起头的词。%告诉MySQL接受jet之后的任意字符，不管它有多少字符。 也可以放到开头，%jet% (注意尾空格 :在保存词anvil 时，如果它后面有一个或多个空格，则子句WHEREprod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l后有多余的字符。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数（第11章将会介绍）去掉首尾空格。) (注意NULL 虽然似乎%通配符可以匹配任何东西，但有一个例外，即NULL。不匹配NULL) 8.1.2 下划线（_）通配符 下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符。 SELECT prod_id,prod_nameFROM productsWHERE prod_name LIKE ‘_ ton anvil’; 只能匹配 1 ton anvil,不能.5 ton anvil 8.2 使用通配符的技巧 不要过度使用通配符。 第9章 用正则表达式进行搜索 9.2.1 基本字符匹配 LIKE与REGEXP 在LIKE和REGEXP之间有一个重要的差别。请看以下两条语句： SELECT prod_nameFROM productsWHERE prod_name LIKE ‘1000’; SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1000’; 如果执行上述两条语句，会发现第一条语句不返回数据，而第二条语句返回一行。为什么？正如第8章所述，LIKE匹配整个列。如果被匹配的文本在列值中出现，LIKE将不会找到它，相应的行也不被返回（除非使用通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回。这是一个非常重要的差别。那么，REGEXP能不能用来匹配整个列值（从而起与LIKE相同输入输出分析的作用）？答案是肯定的，使用^和$定位符（anchor）即可，本章后面介绍。 SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘.1000’; .是正则表达式语言中一个特殊的字符。它表示匹配任意一个字符， (匹配不区分大小写 MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXPBINARY ‘JetPack .000’。) 9.2.2 进行OR匹配 SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘1000|2000’; 9.2.3 匹配几个字符之一 SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘[123] ton’; [123] = [1|2|3] [^123]匹配除这些字符外的任何东西。 9.2.4 匹配范围 集合可用来定义要匹配的一个或多个字符。[1-3] [1-9] [a-z] 9.2.5 匹配特殊字符 为了匹配特殊字符，必须用\为前导。\-表示查找-，\.表示查找.。这种处理就是所谓的转义. \f 换页\n 换行\r 回车\t 制表\v 纵向制表 9.2.6 匹配字符类 存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类 类 说明[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）[:alpha:] 任意字符（同[a-zA-Z]）[:blank:] 空格和制表（同[\t]）[:cntrl:] ASCII控制字符（ASCII 0到31和127）[:digit:] 任意数字（同[0-9]）[:graph:] 与[:print:]相同，但不包括空格[:lower:] 任意小写字母（同[a-z]）[:print:] 任意可打印字符[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符[:space:] 包括空格在内的任意空白字符（同[\f\n\r\t\v]）[:upper:] 任意大写字母（同[A-Z]）[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 9.2.7 匹配多个实例 重复元字符 元字符 说 明 0个或多个匹配 1个或多个匹配（等于{1,}）? 0个或1个匹配（等于{0,1}）{n} 指定数目的匹配{n,} 不少于指定数目的匹配{n,m} 匹配数目的范围（m不超过255） SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘\([0-9] sticks?\)’ORDER BY prod_name; 正则表达式\([0-9] sticks?\)需要解说一下。\(匹配)，[0-9]匹配任意数字（这个例子中为1和5），sticks?匹配stick和sticks（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出现），\)匹配)。没有?，匹配stick和sticks会非常困难。 SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘[[:digit:]]{4}’ORDER BY prod_name; ，[:digit:]匹配任意数字，因而它为数字的一个集合。{4}确切地要求它前面的字符（任意数字）出现4次，所以[[:digit:]]{4}匹配连在一起的任意4位数字。 9.2.8 定位符 定位元字符元字符 说 明^ 文本的开始$ 文本的结尾[[:&lt;:]] 词的开始[[:&gt;:]] 词的结尾 SELECT prod_nameFROM productsWHERE prod_name REGEXP ‘^[0-9\.]’ORDER BY prod_name; ^匹配串的开始。因此，^[0-9\.]只在.或任意数字为串中第一个字符时才匹配它们。没有^，则还要多检索出4个别的行（那些中间有数字的行）。 (^的双重用途 ^有两种用法。在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。) 第 10 章 创建计算字段 10.1 计算字段 计算字段发挥作用:存储在表中的数据都不是应用程序所需要的。我们需要直接从数据库中检索出转换、计算或格式化过的数据；而不是检索出数据，然后再在客户机应用程序或报告程序中重新格式化。计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的。 (字段（field） 基本上与列（column）的意思相同，经常互换使用) 10.2 拼接字段 拼接（concatenate） 将值联结到一起构成单个值。 SELECT Concat(vend_name,’(‘,vend_country,’)’)FROM vendorsORDER BY vend_name; Concat()拼接串，即把多个串连接起来形成一个较长的串。Concat()需要一个或多个指定的串，各个串之间用逗号分隔。 SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’)FROM vendorsORDER BY vend_name; RTrim()函数去掉值右边的所有空格.LTrim() Trim() 使用别名 SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’) AS vend_titleFROM vendorsORDER BY vend_name; 10.3 执行算术计算 SELECT prod_id,quantity,item_priceFROM orderitemsWHERE order_num = 2005; 计算字段的另一常见用途是对检索出的数据进行算术计算。举一个例子，orders表包含收到的所有订单，orderitems表包含每个订单中的各项物品。 SELECT prod_id,quantity,item_price,quantity*item_price AS expanded_priceFROM orderitemsWHERE order_num = 2005; 第 11 章 使用数据处理函数 11.2.1 文本处理函数 常用的文本处理函数 函 数 说 明Left() 返回串左边的字符Length() 返回串的长度Locate() 找出串的一个子串Lower() 将串转换为小写LTrim() 去掉串左边的空格Right() 返回串右边的字符RTrim() 去掉串右边的空格Soundex() 返回串的SOUNDEX值SubString() 返回子串的字符Upper() 将串转换为大写 SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。 SELECT cust_name,cust_contactFROM customersWHERE Soundex(cust_contact) = Soundex(‘Y Lie’); WHERE子句使用Soundex()函数来转换cust_contact列值和搜索串为它们的SOUNDEX值。因为Y.Lee和Y.Lie发音相似，所以它们的SOUNDEX值匹配 11.2.2 日期和时间处理函数 常用日期和时间处理函数 函 数 说 明AddDate() 增加一个日期（天、周等）AddTime() 增加一个时间（时、分等）CurDate() 返回当前日期CurTime() 返回当前时间Date() 返回日期时间的日期部分DateDiff() 计算两个日期之差Date_Add() 高度灵活的日期运算函数Date_Format() 返回一个格式化的日期或时间串Day() 返回一个日期的天数部分DayOfWeek() 对于一个日期，返回对应的星期几Hour() 返回一个时间的小时部分Minute() 返回一个时间的分钟部分Month() 返回一个日期的月份部分Now() 返回当前日期和时间Second() 返回一个时间的秒部分Time() 返回一个日期时间的时间部分Year() 返回一个日期的年份部分 首先需要注意的是MySQL使用的日期格式。无论你什么时候指定一93图灵社区会员 臭豆腐(StinkBC@gmail.com) 专享 尊重版权72 第 11 章 使用数据处理函数个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。因此，2005年9月1日，给出为2005-09-01。 SELECT cust_id,order_numFROM ordersWHERE Date(order_date) = ‘2015-09-01’; SELECT cust_id,order_numFROM ordersWHERE Year(order_date) = 2015 AND Month(order_date)= 9; 11.2.3 数值处理函数 常用数值处理函数 函 数 说 明Abs() 返回一个数的绝对值Cos() 返回一个角度的余弦Exp() 返回一个数的指数值Mod() 返回除操作的余数Pi() 返回圆周率Rand() 返回一个随机数Sin() 返回一个角度的正弦Sqrt() 返回一个数的平方根Tan() 返回一个角度的正切 第 12 章 汇 总 数 据 SQL聚集函数 函 数 说 明AVG() 返回某列的平均值COUNT() 返回某列的行数MAX() 返回某列的最大值MIN() 返回某列的最小值SUM() 返回某列值之和 SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avgFROM products; 1.为了获得多个列的平均值，必须使用多个AVG()函数。AVG()函数忽略列值为NULL的行。2.如果指定列名，则指定列的值为空的行被COUNT()函数忽略，但如果COUNT()函数中用的是星号（），则不忽略。3.以上5个聚集函数都可以如下使用： 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）； 只包含不同的值，指定DISTINCT参数。如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT()，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。 SELECT AVG(DISTINCT prod_price) AS price_avgFROM productsWHERE vend_id = 1003; 4.取别名 第 13 章 分 组 数 据13.1 数据分组13.2 创建分组分组是在SELECT语句的GROUP BY子句中建立的。 SELECT vend_id,COUNT(*) AS num_prodsFROM productsGROUP BY vend_id; vend_id num_prods1001 31002 21003 71005 2 上面的SELECT语句指定了两个列，vend_id包含产品供应商的ID，num_prods为计算字段（用COUNT(*)函数建立）。GROUP BY子句指示MySQL按vend_id排序并分组数据。这导致对每个vend_id而不是整个表计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。 重要的规定1.GROUP BY子句可以包含任意数目的列2.在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。3.如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。4.除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。5.如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。6.GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 使用ROLLUP 使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值，如下所示： SELECT vend_id,COUNT(*) AS num_prodsFROM productsGROUP BY vend_id WITH ROLLUP; 13.3 过滤分组目前为止所学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是WHERE过滤行，而HAVING过滤分组。 SELECT vend_id,COUNT() AS num_prodsFROM productsGROUP BY vend_idHAVING COUNT() &gt;= 2; 最后一行增加了HAVING子句，它过滤COUNT(*) &gt;=2（两个以上的订单）的那些分组。 HAVING 和 WHERE 结合的例子 SELECT vend_id,COUNT() AS num_prodsFROM productsWHERE prod_price &gt;= 10GROUP BY vend_idHAVING COUNT() &gt;= 2; 13.4 分组和排序ORDER BY与GROUP BYORDER BY GROUP BY排序产生的输出 分组行。但输出可能不是分组的顺序任意列都可以使用（甚至非选择的列也可以使用）只可能使用选择列或表达式列，而且必须使用每个选择列表达式不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。 SELECT order_num,SUM(quantityitem_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantityitem_price) &gt;= 50ORDER BY ordertotal; 13.5 SELECT子句顺序子 句 说 明 是否必须使用SELECT 要返回的列或表达式 是FROM 从中检索数据的表 仅在从表选择数据时使用WHERE 行级过滤 否GROUP BY 分组说明 仅在按组计算聚集时使用HAVING 组级过滤 否ORDER BY 输出排序顺序 否LIMIT 要检索的行数 否 第 14 章 使用子查询 子查询最常见的使用是在WHERE子句的IN操作符中，以及用来填充计算列 14.2 利用子查询进行过滤 SELECT cust_idFROM ordersWHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = ‘TBT2’) 在SELECT语句中，子查询总是从内向外处理。在处理上面的SELECT语句时，MySQL实际上执行了两个操作。首先，它执行下面的查询：SELECT order_num FROM orderitems WHERE prod_id = ‘TBT2’ 此查询返回两个订单号：20005和20007。然后，这两个值以IN操作符要求的逗号分隔的格式传递给外部查询的WHERE子句。外部查询变成： SELECT cust_idFROM ordersWHERE order_num IN (20005,20007) 14.3 作为计算字段使用子查询 假如需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。为了执行这个操作，遵循下面的步骤。(1) 从customers表中检索客户列表。(2) 对于检索出的每个客户，统计其在orders表中的订单数目。 SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS ordersFROM customersORDER BY cust_name; HERE orders.cust_id = customers.cust_id) AS orders用了完全限定列名 相关子查询（correlated subquery） 涉及外部查询的子查询。 第 15 章 联 结 表 15.1.1 关系表 假如有由同一供应商生产的多种物品，那么在何处存储供应商信息（如，供应商名、地址、联系方法等）呢？ 在这个例子中，可建立两个表，一个存储供应商信息，另一个存储产品信息。vendors表包含所有供应商信息，每个供应商占一行，每个供应商具有唯一的标识。此标识称为主键（primary key）（在第1章中首次提到），可以是供应商ID或任何其他唯一值。products表只存储产品信息，它除了存储供应商ID（vendors表的主键）外不存储其他供应商信息。vendors表的主键又叫作products的外键，它将vendors表与products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。 外键（foreign key） 外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 15.2 创建联结 联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。 SELECT vend_name,prod_name,prod_priceFROM vendors,productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name,prod_name; 1.必须WHERE2.完全限定列名 笛卡儿积（cartesian product） 由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 SELECT vend_name,prod_name,prod_priceFROM vendors,productsORDER BY vend_name,prod_name; 从上面的输出中可以看到，相应的笛卡儿积不是我们所想要的。这里返回的数据用每个供应商匹配了每个产品，它包括了供应商不正确的产品。实际上有的供应商根本就没有产品。 15.2.2 内部联结 目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。 SELECT vend_name,prod_name,prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id; 15.2.3 联结多个表 以14章的例子 SELECT cust_name,cust_contactFROM customers,orders,orderitemsWHERE customers.cust_id = orders.cust_idAND orderitems.order_num = orders.order_numAND prod_id = ‘TNT2’; 第 16 章 创建高级联结 16.1 使用表别名 SELECT cust_name,cust_contactFROM customers AS c,orders AS O,orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = ‘TNT2’; 16.2 使用不同类型的联结 现在来看3种其他联结，它们分别是自联结、自然联结和外部联结。 16.2.1 自联结 假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。 SELECT prod_id,prod_nameFROM productsWHERE vend_id = (SELECT vend_id FROM products WHERE prod_id = ‘DTNTR’); SELECT p1.prod_id,p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_idAND p2.prod_id = ‘DTNTR’; 用自联结而不用子查询 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性能更好 16.2.2 自然联结 无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。这一般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子集来完成的。 SELECT c.*,o.order_num,o.order_date,oi.prod_id,oi.quantity,oi.item_priceFROM customers AS c,orders AS o,orderitems AS oiWHERE c.cust_id = o.cust_idAND oi.order_num = o.order_numAND prod_id = ‘FB’; 事实上，迄今为止我们建立的每个内部联结都是自然联结，很可能我们永远都不会用到不是自然联结的内部联结 16.2.3 外部联结 联结包含了那些在相关表中没有关联行的行。这种类型的联结称为外部联结。 为了检索所有客户，包括那些没有订单的客户，可如下进行 SELECT customers.cust_id,orders.order_numFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; 这条SELECT语句使用了关键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句的左边表（customers表）中选择所有行。 16.3 使用带聚集函数的联结 如果要检索所有客户及每个客户所下的订单数 SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ordFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id; 此SELECT语句使用INNER JOIN将customers和orders表互相关联。GROUP BY 子句按客户分组数据，因此，函数调用 COUNT(orders.order_num)对每个客户的订单计数，将它作为num_ord返回。 第 17 章 组 合 查 询 17.1 组合查询 也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。有两种基本情况，其中需要使用组合查询： 在单个查询中从不同的表返回类似结构的数据； 对单个表执行多个查询，按单个查询返回数据。 组合查询和多个WHERE条件 多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出 17.2 创建组合查询17.2.1 使用UNION假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品（不考虑价格） SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id,prod_id,prod_priceFROM productsWHERE cend_id IN (1001,1002); 由前面的两条SELECT语句组成，语句中用UNION关键字分隔。UNION指示MySQL执行两条SELECT语句，并把输出组合成单个查询结果集。作为参考，这里给出使用多条WHERE子句而不是使用UNION的相同查询： SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5 OR vend_id IN (1001,1002); 17.2.2 UNION规则  UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。 17.2.3 包含或取消重复的行 UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样）。这是UNION的默认行为，但是如果需要，可以改变它。事实上，如果想返回所有匹配行，可使用UNION ALL而不是UNION。 17.2.4 对组合查询结果排序 在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。 SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id,prod_id,prod_priceFROM productsWHERE cend_id IN (1001,1002)ORDER BY vend_id,prod_price; 第 18 章 全文本搜索 18.1 理解全文本搜索 并非所有引擎都支持全文本搜索:两个最常使用的引擎为MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。 18.2.1 启用全文本搜索支持 一般在创建表时启用全文本搜索。 CREATE TABLE productnotes( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_text text NULL, PRIMARY KEY(node_id), FULLTEXT(node_text)) ENGING=MyISAM; 这条CREATE TABLE语句定义表productnotes并列出它所包含的列,这些列中有一个名为note_text的列，为了进行全文本搜索，MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。这里的FULLTEXT索引单个列，如果需要也可以指定多个列。 在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。 不要在导入数据时使用FULLTEXT 18.2.2 进行全文本搜索 在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。 SELECT node_textFROM productnotesWHERE Match(note_text) Aginst(‘rabbit’); 1.使用完整的 Match() 说 明 传递给 Match() 的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。2.搜索不区分大小写 18.2.3 使用查询扩展 查询扩展用来设法放宽所返回的全文本搜索结果的范围。例如：你想找出所有提到anvils的注释。只有一个注释包含词anvils，但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。 在使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行； 其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简要地解释MySQL如何断定什么有用，什么无用）。 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。 SELECT node_textFROM productnotesWHERE Match(note_text) Aginst(‘anvils’ WITH QUERY EXPANSION); 18.2.4 布尔文本搜索 MySQL支持全文本搜索的另外一种形式，称为布尔方式（booleanmode）。 即使没有FULLTEXT索引也可以使用,但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。 SELECT node_textFROM productnotesWHERE Match(note_text) Aginst(‘heavy’ IN BOOLEAN MOOE); SELECT node_textFROM productnotesWHERE Match(note_text) Aginst(‘heavy -rope*’ IN BOOLEAN MOOE); 匹配包含heavy但不包含任意以rope开始的词的行. 全文本布尔操作符布尔操作符 说 明 包含，词必须存在 排除，词必须不出现 包含，而且增加等级值&lt; 包含，且减少等级值() 把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）~ 取消一个词的排序值 词尾的通配符“” 定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） 在布尔方式中，不按等级值降序排序返回的行。 18.2.5 全文本搜索的使用说明  在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参阅MySQL文档以了解如何完成此工作）。 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEANMODE。 如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。 忽略词中的单引号。例如，don’t索引为dont。 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。 第 19 章 插 入 数 据 19.1 数据插入 INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用： 插入完整的行； 插入行的一部分； 插入多行； 插入某些查询的结果 19.2 插入完整的行 INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES(‘Pep E. LaPew’, ‘100 Main Street’, ‘Los Angeles’, ‘CA’, ‘90046’, ‘USA’, NULL, NULL); 省略列 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。 该列定义为允许NULL值（无值或空值）。 在表定义中给出默认值。这表示如果不给出值，将使用默认值。 19.3 插入多个行 INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES(‘Pep E. LaPew’, ‘100 Main Street’, ‘Los Angeles’, ‘CA’, ‘90046’, ‘USA’), (‘Pep E. LaPew’, ‘100 Main Street’, ‘Los Angeles’, ‘CA’, ‘90046’, ‘USA’ ); 其中单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔。 19.4 插入检索出的数据 想从另一表中合并客户列表到你的customers表,应该首先创建和填充custnew表。custnew表的结构与附录B中描述的customers表的相同。在填充custnew时，不应该使用已经在customers中使用过的cust_id值（如果主键值重复，后续的INSERT操作将会失败）或仅省略这列值让MySQL在导入数据的过程中产生新值。 INSERT INTO customers(cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM custnew; 第 20 章 更新和删除数据 20.1 更新数据 为了更新（修改）表中的数据，可使用UPDATE语句。  更新表中特定行； 更新表中所有行。 基本的UPDATE语句由3部分组成，分别是： 要更新的表； 列名和它们的新值； 确定要更新行的过滤条件。 客户10005现在有了电子邮件地址: UPDATE customersSET cust_email = ‘elmer@fudd.com’WHERE cust_id = 10005; 更新多个列时，只需要使用单个SET命令，每个“列=值”对之间用逗号分隔（最后一列之后不用逗号）。 UPDATE customersSET cust_name = ‘The Fudds’, cust_email = ‘elmer@fudd.com’WHERE cust_id = 10005; 为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）。 UPDATE customersSET cust_email = NULLWHERE cust_id = 10005; 20.2 删除数据 为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方式使用DELETE： 从表中删除特定的行； 从表中删除所有行。 DELECT FROM customersWHERE cust_id = 10006; DELETE FROM要求指定从中删除数据的表名。WHERE子句过滤要删除的行。在这个例子中，只删除客户10006。如果省略WHERE子句，它将删除表中每个客户。DELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了删除指定的列，请使用UPDATE语句。 删除表的内容而不是表 DELETE语句从表中删除行，甚至是删除表中所有行。但是，DELETE不删除表本身。 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句 20.3 更新和删除的指导原则  除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。 保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。 在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 使用强制实施引用完整性的数据库（关于这个内容，请参阅第15章），这样MySQL将不允许删除具有与其他表相关联的数据的行。 第 21 章 创建和操纵表 21.1 创建表 一般有两种创建表的方法： 使用具有交互式创建和管理表的工具（如第2章讨论的工具）； 表也可以直接用MySQL语句操纵。 值得注意的是，在使用交互式工具时，实际上使用的是MySQL语句。 21.1.1 表创建基础 为利用CREATE TABLE创建表，必须给出下列信息： 新表的名字，在关键字CREATE TABLE之后给出； 表列的名字和定义，用逗号分隔。 CREATE TABLE customers( cust_id int NOT NULL AUTO_INCREMENT, cust_name char(50) NOT NULL, cust_address char(50) NULL, cust_city char(50) NULL, PRIMARY KEY (cust_id)) ENGINE = InnoDB; (处理现有的表 在创建新表时，指定的表名必须不存在，否则将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删除该表（请参阅后面的小节），然后再重建它，而不是简单地用创建表语句覆盖它。) 21.1.2 使用NULL值 在插入或更新行时，该列必须有值。NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。NULL值是没有值，它不是空串。 21.1.3 主键再介绍 主键值必须唯一。即，表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。 CREATE TABLE orderitems( order_num int NOT NULL, order_item int NOT NULL, prod_id char(10) NOT NULL, quantity int NOT NULL, item_price decimal(8,2) NOT NULL, PRIMARY KEY (order_num,order_item)) ENGINE=InnoDB; orderitems表包含orders表中每个订单的细节。每个订单有多项物品，但每个订单任何时候都只有1个第一项物品，1个第二项物品，如此等等。因此，订单号（order_num列）和订单物品（order_item列）的组合是唯一的，从而适合作为主键 21.1.4 使用AUTO_INCREMENT AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。每次执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字AUTO_INCREMENT），给该列赋予下一个可用的值。这样给每个行分配一个唯一的cust_id，从而可以用作主键值。每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。 21.1.5 指定默认值 如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定。 CREATE TABLE orderitems( order_num int NOT NULL, order_item int NOT NULL, prod_id char(10) NOT NULL, quantity int NOT NULL DEFAULT 1, item_price decimal(8,2) NOT NULL, PRIMARY KEY (order_num,order_item)) ENGINE=InnoDB; (与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。) 21.1.6 引擎类型 如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。 以下是几个需要知道的引擎： InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索； MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）； MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。 21.2 更新表 为了使用ALTER TABLE更改表结构，必须给出下面的信息： 在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）； 所做更改的列表。 ALTER TABLE vendorsADD vend_phone CHAR(20); 这条语句给vendors表增加一个名为vend_phone的列，必须明确其数据类型。 21.3 删除表 删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语句即可： DROP TABLE customers2; 这条语句删除customers 2表（假设它存在）。删除表没有确认，也不能撤销，执行这条语句将永久删除该表。 21.4 重命名表 RENAME TABLE customers2 TO customers; 第 22 章 使 用 视 图 22.1 视图 视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种MySQL的SELECT语句层次的封装，可用来简化数据处理以及重新格式化基础数据或保护基础数据。 22.2 使用视图  视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname;。 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE ORREPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；如果要更新的视图存在，则第2条更新语句会替换原有视图。 22.2.1 利用视图简化复杂的联结 视图的最常见的应用之一是隐藏复杂的SQL CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_idFROM customers,orders,orderitemsWHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num; 这条语句创建一个名为productcustomers的视图，它联结三个表，以返回已订购了任意产品的所有客户的列表。如果执行SELECT * FROM productcustomers，将列出订购了任意产品的客户。 为检索订购了产品TNT2的客户， SELECT cust_name,cust_contactFROM productcustomersWHERE prod_id = ‘TNT2’; 22.2.2 用视图重新格式化检索出的数据 CREATE VIEW vendorlocations ASSELECT Concat(RTrim(cend_name),’(‘,RTrim(vend_country),’)’) AS vend_titleFROM vendorsORDER BY vend_name; SELECT * FROM vendorlocations; 22.2.3 用视图过滤不想要的数据 CREATE VIEW customeremaillist ASSELECT cust_id,cust_name,cust_emailFROM customersWHERE cust_email IS NOT NULL; SELECT *FROM customeremaillist; 22.2.4 使用视图与计算字段 视图对于简化计算字段的使用特别有用。 CREATE VIEW orderitemsexpanded ASSELECT order_num, prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM orderitems; SELECT *FROM orderitemsexpandedWHERE order_num = 20005; 22.2.5 更新视图 通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。 但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新： 分组（使用GROUP BY和HAVING）； 联结； 子查询； 并； 聚集函数（Min()、Count()、Sum()等）； DISTINCT； 导出（计算）列 第 23 章 使用存储过程 23.1 存储过程 存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。 23.3 使用存储过程 23.3.1 执行存储过程 MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数。 CALL productpricing(@pricelow, @pricehigh, @priceaverage); 执行名为productpricing的存储过程，它计算并返回产品的最低、最高和平均价格。 23.3.2 创建存储过程 一个返回产品平均价格的存储过程. CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; 此存储过程名为productpricing，用CREATE PROCEDURE productpricing()语句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没有参数，但后跟的()仍然需要。BEGIN和END语句用来限定存储过程体，过程体本身仅是一个简单的SELECT语句 CALL productpricing(); CALL productpricing();执行刚创建的存储过程并显示返回的结果。因为存储过程实际上是一种函数，所以存储过程名后需要有()符号（即使不传递参数也需要）。 23.3.3 删除存储过程 DROP PROCEDURE productpricing; 23.3.4 使用参数 一般，存储过程并不显示结果，而是把结果返回给你指定的变量。 CREATE PROCEDURE productpricing( OUT pl DECIMAL(8,2), OUT ph DECIMAL(8,2), OUT pa DECIMAL(8,2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; 关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键字）。 CALL productpricing(@pricelow,@pricehigh,@priceaverage); 所以，这条CALL语句给出3个参数。它们是存储过程将保存结果的3个变量的名字。在调用时，这条语句并不显示任何数据。它返回以后可以显示（或在其他处理中使用）的变量。 为了显示检索出的产品平均价格:SELECT @priceaverage; 使用IN和OUT参数的例子 CREATE PROCEDURE ordertotal(IN onnumber INT,OUT ototal DECIMAL(8,2))BEGIN SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END; onumber定义为IN，因为订单号被传入存储过程。ototal定义为OUT，因为要从存储过程返回合计。SELECT语句使用这两个参数，WHERE子句使用onumber选择正确的行，INTO使用ototal存储计算出来的合计。 CALL ordertotal(20005,@total); 23.3.6 检查存储过程 SHOW CREATE PROCEDURE ordertotal;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.11]]></title>
    <url>%2F2018%2F11%2F02%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F2018.11%2F</url>
    <content type="text"><![CDATA[2018.11.021.JS获取上一访问页面URL地址 document.referrer 2.获取后跳转到指定页面，也可获取当前页面地址 document.location.href 2018.11.07ant的输入框返回一个value，而不是整个值，比如输入123，返回的是1，2，3 处理：函数在失焦后执行,blur() 2018.11.091.router的history模式 1history没有# 2.打包工具可视化 12cnpm i -g @vue/clivue ui 3.vue ssr 服务器渲染，之前是浏览器渲染，服务器更快 2018.11.121.小技巧 1微信聊天：新建一个文件夹，写上时间、名称，专门用于开发 2.process.browser 12345判断是否在浏览器环境中，在的话，可以调用window（因为vue ssr没有window）if(process.browser) &#123; console.log(localstorage)&#125; 3.服务器端的路由是全部注册好的，不用做区别，因为之前浏览器是为了加载速度 2018.11.141.写css 1需要有一个大的id，包裹，减少环境污染 2.一个debug产生的想法 1发现steps组件无数据-&gt;找steps组件，发现无数据传入-&gt;往上查找，发现父组件未传数据（因为不符合条件） 2018.11.161.git 坑1 1234git commit -a -&gt; 去到奇怪的地方 -&gt; 退出 -&gt; git add . 报错：Unable to create &apos;D:/cms-open/.git/index.lock&apos;:File exists. -&gt; 解决：rm -f ./.git/index.lockgit commit -a -m “massage”:其他功能如-m参数，加的-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，注意，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。建议一般不要使用-a参数，正常的提交还是使用git add先将要改动的文件添加到暂存区，再用git commit 提交到本地版本库。 2.git 坑2 123git commit 不成功 导致pull有冲突 -&gt; git rebase --abort 回滚到pull之前 -&gt; git pull 解决 每次解决冲突后，git status 看看 2018.11.19当要断其他点：比如 serer.js 或 router -&gt; Debug(visual) -&gt; Start bugging 2018.11.20 computed watch 当变量少，逻辑简单，使用推荐；如果变量多，逻辑复杂不推荐，因缓存 迫不得已才用 &gt; computed&gt;watch post put patch 创建一个新资源，不幂等 更新，要完整的资源对象，幂等（局部更新） 不幂等（局部更新） 幂等：在计算机范畴内表示一个操作执行任意次对系统的影响跟一次是相同的 2018.11.26 git reset –soft git reset –hard 回退到某个版本，只回退到commit 的信息，且之前修改的代码还在；如果还要提交，直接commit 即可 彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit 中新包含的更改被冲掉 2018.11.301.React 一、新特性(ES6)let 与var的区别 let声明的变量只在其声明的块或子块中可用，var声明的变量的作用域是整个封闭区域。 let不能变量提升，var可以 1234console.log(bar) undefinedconsole.log(foo) foo is not undefinedvar bar = 1;let foo = 2; 二、React是什么一个采用声明式，高效且灵活的用来构建用户界面的框架 123456789class ShoppingList extends React.Component &#123; render()&#123; return ( &lt;div class = &apos;test&apos;&gt; &lt;h1&gt;&#123;this.props.name&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; ShoppingList 是一种React组件类。一个组件会接受名为props的参数，并通过名为render的方法返回一个嵌套结构的视图。React会根据你的描述讲对应的内容在屏幕上渲染出来。 在JSX语法中可以任意使用JavaScript表达式，只需用一个大括号把表达式括起来。 1).通过props传递数据Board传 -&gt; Square 123456789101112131415calss Board extends React.Component &#123; render Square(i) &#123; return &lt;Square value=&#123;i&#125; /&gt; &#125;&#125;calss Square extends React.Component &#123; render &#123; return ( &lt;button className=&apos;Square&apos;&gt; &#123;this.props.value&#125; &lt;/button&gt; ) &#125;&#125; 2).给组件添加交互功能123456789101112131415calss Square extends React.Component &#123; constructor()&#123; super(); this.state = &#123; value: null &#125; &#125; render &#123; return ( &lt;button className=&apos;Square&apos; onClick=&#123;()=&gt;this.setState(&#123;value:&apos;x&apos;&#125;)&#125;&gt; &#123;this.props.value&#125; &lt;/button&gt; ) &#125;&#125; 在Js classes中，必须使用super();方法才能在继承父类的子类中正确获取到类型的this 3).开发工具React Devtools 三、状态提升1).不可变性当遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，把子组件的state数据提升至其共同的父组件当中保存，之后父组件可以通过props将状态数据传递到子组件当中，这样应用当中的状态数据就能够更方便的交流共享了。 不可变性在React相当重要 slice()方法可以对已有的数组数据进行浅拷贝 改变应用数据方法 直接修改 12var player = &#123;score:1,name:&apos;Jeff&apos;&#125;;player.score = 2; 替换修改 12var player = &#123;&#125;var newPlayer = &#123;...player,score:2&#125; 2).函数定义组件React专门为只有render方法的组件提供了一种更简便的定义组件的方法：函数定义组件（写一个props为参数的function返回JSX元素即可） 1234567function Square (props) &#123; return( &lt;burron className=&apos;Square&apos; onClick=&#123;props.onClick&#125; &#123;props.value&#125; &lt;/button&gt; )&#125; props.onClick 不能加(),会立即触发 3).轮流落子用一个xIsNext操控 4).判断赢家四、保存历史记录1).展示每步历史记录链接React元素事实上都是JS当中的对象，我们可以把元素当做参数或定义到变量中使用。在React当中渲染多个重复的项目时，我们一般都以数组的方式传递React元素，最基本的方法是使用数组的map方法。 12345678const moves = history.map( (step,move)=&gt;&#123; const desc = move?&apos;Move #&apos;+move:&apos;Game start&apos;; return ( &lt;li&gt; &lt;a href=&apos;#&apos; onClick=&#123;()=&gt;this.jumpTo(move)&#125;&#123;desc&#125;&lt;/a&gt; &lt;/li&gt; )&#125;) 2).keys强烈建议在渲染列表项时添加keys值，key值会和对应元素绑定。 所以 1&lt;li key=&#123;move&#125;&gt; 2.class判断 12:class=&quot;&#123;test:isTest==true&#125;&quot;:class=&quot;test&gt;0?&apos;test&apos;:&apos;&apos;&quot; 3.React文档 一、JSX简历JSX，一种javascrpt的语法扩展，用来声明react当中的元素。 1.在JSX中使用表达式 可任意在JSX中使用JS表达式：但要在大括号里；不要套引号，会识别为字符串；JSX标签是闭合的 结尾处用&lt;/&gt;；reactDom使用小驼峰命名定义属性的名称，class=&gt;className 2.书写JSX时，一般要带上换行和缩进——可读性在JSX代码外，扩上一个小括号，防止分号自动插入 二、元素渲染1).将元素渲染到DOM中要把它们传递给ReactDom.render() 1&lt;div id=&apos;root&apos;&gt;&lt;/div&gt; 2).更新元素渲染React元素都是不可变的，当元素被创建之后，无法改变其内容或属性，一个元素就像动画里的一帧，代表应用界面在某一时间点的样子。 React只会更新必要的部分 三、组件 &amp; props1).函数定义/类定义组件123456789function Welcome(props) &#123; return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;h1&gt;&#125;class Welcome extends React.Component &#123; render()&#123; return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;h1&gt; &#125;&#125; 2).组件名称必须大写字母开头3).props只读性四、state &amp; 生命周期]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>百田</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.1]]></title>
    <url>%2F2018%2F10%2F08%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F2018.10%2F</url>
    <content type="text"><![CDATA[2018.10.081.使用chorme开发者工具中的performance 123456统计汇总扇形图：HTML 蓝色脚本 黄色样式表 紫色媒体文件 绿色其他资源 灰色 2.demo工作模式 因为代码很多时候是多人合作，在开发时，先开个demo完成自己的功能再迁移过去。 3.vue性能优化 不要老想在技术的角度解决问题，要试着从设计上去规避问题。 12345678910111213- 慎用deep watch- 尽可能的减少watch的数量- v-show v-if 涉及权限相关，v-if 没有涉及权限 根据用户点击的频次选择 频繁切换 v-show 不频繁 v-if- 不要过多在模板里写表达式与判断- 循环调用子组件时添加key (item,index) in arr :key=&apos;index&apos;- 对路由组件进行懒加载，即调用到对应的组件时才加载它，否则不加载 const login = ()=&gt; import(&apos;@/pages/login&apos;) 类似这种- style scoped 2018.10.091.ES6常见特性 forEach 遍历函数 12345arr.forEach((v,index)=&gt;&#123; if(v==a) &#123; //执行 &#125;&#125;) 箭头函数 map和get proxyTable 2.循环遍历 一共有83个语料，需要将其分成三个类别：普通、难度、段位。原先想着把83分别遍历三次，推到每个类别。好的方法：取出一个语料，分别与普通的，难度的，段位的语料匹配，检查是否存在level,range等字段。 3.indexOf findIndex indexOf() 可返回某个指定的字符串值在字符串中首次出现的位置。 1stringObject.indexOf(searchvalue,fromindex) 参数 描述 searchvalue 必需。规定需检索的字符串值。 fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。 findIndex() 查找目标元素，找到就返回元素的位置，找不到就返回-1。 123let a = arr.findIndex((v,index) =&gt; &#123; if(v==b) return index&#125;) 2018.10.101.如何把对象数组的一部分属性推到新数组 1234循环：创建新数组mm.name = ...array.push(m) 2.es6字符串转数组 1[...num] 2018.10.111.发现打开vscode cup到达100% 1search.followSymlinks:false 2.关于创建数组 12345a = new Array(2)=&gt; (2)[empty x 2]创建的是2个undefinepush b = [ [],[] ] =&gt; (2)[ Array(0),Array(0) ] 2018.10.12赋值问题 12345data = new Array()data.num = 1=&gt; console.log(data.num) =&gt; 1但这不是以属性的方法挂载，而是成为了一个方法，正确赋值：data = new Object() 2018.10.17前端架构设计 前端架构是一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效、可持续的工作流 模块化内容 四个核心 代码 流程 测试 文档 HTML 模块化标记 模块化css理论 OOCSS方法(object-oriented css 面向对象的css) 1234div.toggle simple div.toggle-control open div.toggle-title div.toggle-details open SMACSS方法(Scalable and Modular Architecture for CSS 模块化架构的可扩展css) 1234div.toggle toggle-simple div.toggle-control is-active div.toggle-title div.toggle-details is-active 差异： 12OOCSS -&gt; 通过皮肤进行修改SMACSS -&gt; 通过子模块进行修改 BEM方法 块名_元素_修饰符 补充 OOCSS两个主要的原则 分离结构和外观 12simple 皮肤使用直角comple 皮肤使用圆角 - 分离容器和内容1可复用的css类名toggle-title.无论放到哪里都可复用 - SMACSS把样式系统分成五个具体类别 - 基础(不加CSS类名，会以什么外观显示) - 布局(把页面分成一些区域) - 模块(设计中的模块化，可复用的单元，toggle,toggle_title) - 状态(描述在特定的状态或情况下，模块或布局的显示方式 is-active) - 主题(一个可选的视觉外观层，可更换不同主题) CSS 单一联真原则 规定你创建的所有东西必须有单一的，高度聚焦的理由 单一样式来源 组件修饰符 12div.calendar calendar_nested div.calendar_header JS可复用 2018.10.18require引入Js 12345require( [path + &apos;js&apos;],function(a)&#123; xxx&#125;)path的路径不能带@ 2018.10.241.package.json和package-lock.json的区别 package.json package-lock.json 主要用来定义项目中需要依赖的包 在’npm install’时候生成一份文件，用以记录当前状态下实际安装的各个npm package的具体来源和版本号 2.生产模式和开发模式 生产模式 开发模式 npm install –save npm install –save-dev npm i xxx -S npm i xxx -D 线上环境要用的，运行时的模式 本地调试和打包时要用的 3.flex flex支持IE10，Edge… 2018.10.251.引入外部icons 1234567891011121314- 把整个打包文件引入（阿里图库）- 在main.js引入import &apos;@/assets/fonts/b-iconfont.css&apos;- iconfont.css改 [class^=&quot;b-icon&quot;], [class*=&quot; b-icon&quot;] &#123; font-family:&quot;b-FontFamily&quot; !important; /* 以下内容参照第三方图标库本身的规则 */ font-size: 18px; font-style:normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; 2.如何获取音频时间 123&lt;audio v-on:durationchange=&apos;row.edit.duration=$event.target.duration&apos; :src=&apos;row.edit.url&apos; &gt;注意：audio一开始不会立即创建dom的 3.处理时间函数 12345678910111213141516function formatTime(sc) &#123; let str = &quot;&quot; if (sc &gt; 0) &#123; let m = parseInt(sc / 60) str += ((m &gt;= 10) ? m : (&apos;0&apos; + m)); let s = parseInt(sc - m * 60) str += &quot;:&quot; str += ((s &gt;= 10) ? s : (&apos;0&apos; + s)); return str; &#125; else &#123; str = &quot;00:00&quot; return str &#125;&#125;formatTime(60) =&gt; 01:00 2018.10.29子组件给父组件传东西 12345678910子：close() &#123; this.$emit(&apos;closed&apos;,true)&#125;父：&lt;子组件 @closed=&apos;closeAudio&apos;&gt;&lt;/子组件&gt;closeAudio(e) &#123; console.log(e)&#125; 2018.10.31OAuth2.0 1.是什么？ 授权的协议，只要授权方和被授权方遵守这个协议去写代码提供服务，双方就是实现了OAuth模式 2.例子：豆瓣和QQ1打开豆瓣-&gt;需要登录（无账号，不想注册豆瓣账号）-&gt;用QQ授权登录-&gt;登录豆瓣 豆瓣-&gt;客户端，QQ-&gt;认证服务器，OAuth2.0就是客户端和认证服务器之间由于相互不信任而产生的一个授权协议。 12345678910111213141516sequenceDiagram用户浏览器-&gt;&gt;豆瓣网站: GET/leadToAuthorize 1豆瓣网站-&gt;&gt;用户浏览器: 302 location:/authorize?callback=/callback 1用户浏览器-&gt;&gt;QQ授权服务: GET/authorize 1QQ授权服务-&gt;&gt;用户浏览器: 200返回QQ登录页面 2-1用户浏览器-&gt;&gt;QQ授权服务: POST/login 2-2QQ授权服务-&gt;&gt;用户浏览器: 302 location:/callback?code=xxx 2-2用户浏览器-&gt;&gt;豆瓣网站: GET/callback?code=xxx 3豆瓣网站-&gt;&gt;QQ授权服务: POST/getToken?code=xxx 3 4QQ授权服务-&gt;&gt;豆瓣网站: 200&#123;token:YYY&#125; 3 4豆瓣网站-&gt;&gt;QQ授权服务: GET/getResource?token=yyy 3 5QQ授权服务-&gt;&gt;豆瓣网站: 200&#123;userame:tom,age:18&#125; 3 5豆瓣网站-&gt;&gt;用户浏览器: 200返回首页结果视图 3 1234561：用户第一次点击：用户点击用QQ方式授权登录按钮2-1：用户输入Q号和密码点击登录2-2：用户第二次点击：此处可能用户在浏览器输入qq密码点击授权这个过程3：之后的过程用户在浏览器端，感知不到，最终完成时在用户看来就是登录成功并进入了豆瓣的首页4：模拟发起浏览器请求的技术5：模拟发起浏览器请求的技术 12345678910第一步：点击qq方式授权登录：1).实际是向豆瓣服务器发送http://www.douban.com/leadToAuthorize的请求2).豆瓣返回重定向地址，浏览器向访问这个地址（授权，QQ登录框），注意带了callback参数（识别跳回）第二步：输入Q号密码授权登录返回重定向地址 callback code第三步：1).拿code去QQ换token2).拿token去QQ换用户信息并显示到页面 3.小爱的逻辑12345sequenceDiagram用户-&gt;&gt;小爱: （忽略）小爱-&gt;&gt;加班熊: 请求，给加班熊一个token （第一步）加班熊-&gt;&gt;用户: token用户-&gt;&gt;加班熊: token]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>百田</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.09]]></title>
    <url>%2F2018%2F09%2F20%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F2018.09%2F</url>
    <content type="text"><![CDATA[2018.9.201.提交git时切换过账号，导致提交失败版本回退，回到提交前的状态，再重新提交。 123456git config --global user.name ''git config --global user.email ''git log 查看历史版本git reset --soft 版本号 回退到指定版本rm --rf '' 删除 2.端口被占用，无法run 1234cmdnetstat -ano |findstr '8080' 看到这个端口被哪个应用占用。tasklist |findstr "进程id号" 查看到对应的进程id之后，就可以通过id查找对应的进程名称taskkill /f /t /im "进程id或者进程名称" 通过命令杀掉进程，或者是直接根据进程的名称杀掉所有的进程 3.post请求需要提交相应数据，否则报错 4.copy vue 时先检查是否数据已绑定 5.slot-scope是咋用的？ element Table-column Scoped Slotname | 说明—|—— | 自定义列的内容，参数为 { row, column, $index }header | 自定义表头的内容. 参数为 { column, $index } 2018.9.211.点击页面不立即显示内容而需要刷新 1原因：显示函数写到了mounted()，应该写在actived()，因为使用了keep-alive 2.点击返回键，跳转到其他页面 12@click.native = "$router.push('url')"// 因router-link会阻止点击事件，要加.native才能生效 3. 1this.$refs['a'] = this.$refs.a 4.将代码推送到远程仓库 12push代码前一定要pull先：git pull --rebase,pull默认的方式是用merge,这里建议用rebase，才不会出现菱形结构（如图CDGFEC）,也可以修改C:\Users\用户名.gitconfig配置rebase = true，直接使用git pull 2018.9.261.element上传函数 1因为upload组件的action为必填，但是地址并不确定，使用自定义函数，:http-request 默认参数为file，action=&apos;alter&apos; 即可 如何区别是上传还是修改？因为项目需求经常有两个：上传和修改，其核心部分（上传）都是相同的，那么可以用action或者data-type来保存信息 12345678比如组件标记 action是xxx1 &lt;el-upload class=&quot;upload-files&quot; :http-request=&quot;uploadFromFile&quot; action=&quot;xxx1&quot; :auto-upload=&quot;true&quot; :on-remove=&quot;filesRemove&quot; :on-exceed=&quot;uploadExceed&quot; multiple accept=&quot;.mp3&quot; show-file-list :limit=&quot;1&quot; :file-list=&quot;editForm_content.corpusFiles&quot;&gt;方法里uploadFromFile(file)&#123;console.log(file.action)&#125; 2.点击单选，隐藏显示 1v-if = &apos;&#123;el-radio-group的model值&#125; === label&apos; 2018.9.271.element标签页中，显示和隐藏的方式，本质是v-show 2.父子组件通信时，要传入每个组件特定职能的变量，不然会重叠，不知道哪个变量对哪个组件 3.赋值不要在actived里做，因为子组件不会每次改变状态都能触发actived，在mouted赋值 4.element的tap组件只有el-tabs才能触发点击事件@tab-click 123@tab-click = &apos;handleClick&apos;handleClick(tab,event)可以通过tab.label来操作 5.父组件调用子组件的a方法 1this.$refs[&apos;子组件&apos;].a() 6.赋值（对于对象数组不能单独赋值） 12var test = [&#123;&quot;name&quot;:&quot;wei&quot;&#125;,&#123;&quot;age&quot;:&quot;18&quot;&#125;]var test-copy = [].concat(JSON.parse(JSON.stringify(test))) 另开一条地址 7.git 12345git revert 版本号 去掉某个版本不过之前需要缓存 git stashgit branch 分支名git checkout 分支名 （一般为日期/功能 ） 8.概要设计 概要设计是一个设计师根据用户交互过程和用户需求来形成交互框架和视觉框架的过程，其结果往往以反映交互控件布置、界面元素分组以及界面整体板式的页面框架图的形式来呈现。这是一个在用户研究和设计之间架起桥梁，使用户研究和设计无缝结合，将对用户目标与需求转换成具体界面设计解决方案的重要阶段。 概要设计的主要任务是把需求分析得到的系统扩展用例图转换为软件结构和数据结构。设计软件结构的具体任务是：将一个复杂系统按功能进行模块划分、建立模块的层次结构及调用关系、确定模块间的接口及人机界面等。数据结构设计包括数据特征的描述、确定数据的结构特性、以及数据库的设计。显然，概要设计建立的是目标系统的逻辑模型，与计算机无关。 2018.9.30全排列组合 难度/段位 增减，keys相应增减，获取全排列组合 12345678910function getGroup(data, index = 0, group = []) &#123; var need_apply = new Array(); need_apply.push(data[index]); for (var j = 0; j &lt; group.length; j++) &#123; need_apply.push(group[j] + data[index]); &#125; group.push.apply(group, need_apply); if (index + 1 &gt;= data.length) return group; else return getGroup(data, index + 1, group);&#125;]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>百田</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[egret]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%8A%A8%E7%94%BB%2Fegret%2F</url>
    <content type="text"><![CDATA[Get StartedEgret 采用 TypeScript 进行编程，它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。TypeScript 扩展了 JavaScript 的语法，原生 JavaScript 的方法在 TypeScript 也是可以使用的。比如Math等。 建立工作环境Egret Wing 是一款针对 Egret 项目的集成开发环境，通过可视化的方式创建、编辑和管理项目中所有游戏用户界面，并可以同时进行 TypeScript 代码编写和断点调试。 在图形图像渲染中，Egret完全使用HTML5标准中的canvas技术,可以运行在支持 HTML5 的浏览器上。但是在我们调试项目的时候还是推荐使用 Chrome 浏览器，一个方面是对 HTML 5 支持的程度较高，二是可以方便的调试 JavaScript 和进行性能分析等。 #清理项目 打开Main.ts文件，将createGameScene中的内容全部删除，并将createGameScene方法后边的所有方法删除。 Egret程序的入口Egret是从一个称之为文档类的类作为入口的。当然，具体点儿，就是以这个文档类的构造函数作为入口。 文档类是可以配置的，每个Egret项目都有一个index.html文件,可以在Egret项目的根目录找到这个文件，后边我们称之为index文件。 index.html可以打开直接编辑。打开该文件，找到div标签可以看到一些配置属性，其中的data-entry-class，其值默认为Main，就是指Main.ts中所定义的类Main。当然这只是个默认值，我们可以根据自己的喜好随意修改，只要确保项目设定文件中的index.html属性值所指定的类名在项目中有其类定义即可。 入口函数文档类的构造函数，即为Egret程序的入口函数，可以观察到入口函数内有一行代码 1this.addEventListener(egret.Event.ADDED_TO_STAGE, this.onAddToStage, this); 这行代码保证了onAddToStage方法执行时，文档类实例已经被添加到舞台中。并且在onAddToStage方法内，this.stage属性已经有效，其指向舞台对象。 绘制一个单色背景123456789createGameScene方法var bg:egret.Shape = new egret.Shape();bg.graphics.beginFill( 0x336699 );bg.graphics.drawRect( 0, 0, this.stage.stageWidth, this.stage.stageHeight );bg.graphics.endFill();this.addChild( bg ); egret.Shape对象有图形绘制功能，Shape对象中有graphic属性，用来专门负责图形绘制的工作。 第1行，在绘制前，需要定义图形的填充颜色，我们给出一个偏蓝的颜色。注意颜色值跟大部分其他OOP语言一样，是用十六进制的RGB颜色的组合来表示。用beginFill来设置填充颜色。 第2行绘制矩形。用drawRect来绘制矩形。参数部分，给出4个数字确定了一个矩形的区域，这4个参数分为两组，分别这顶区域的起点坐标和终点坐标。 注意这两组坐标，由于我们绘制的背景要刚好覆盖整个舞台区域，所以起点坐标为(0,0)，终点坐标为舞台的宽度和舞台的高度。这一对尺寸可以直接从前一节所讲到的this.stage中获得。 类似的绘制函数还有drawCircle等，可以绘制不同的简单形状。 第3行endFill用来结束绘制工作。 到这里，一张跟舞台同样大的浅蓝色矩形图形已经准备好。但，接下来我们还需要将其添加到显示结构中，才可以在运行时显示出来，就是将某个显示对象添加到某个显示容器上。 (注意，文档类实例添加到舞台是引擎默认完成的，不需要我们写代码完成该任务。) 调整屏幕适配模式Egret提供了几种常规的适配模式 showAll 不缩放 fixedWidth 占满屏幕 fixedWidth模式下会保持原始宽高比缩放内容，缩放后应用程序内容在水平和垂直方向都填满播放器窗口，但只保持应用程序内容的原始宽度不变，高度可能会改变。 我们可以在index.html中修改适配模式，打开项目根目录下的index.html文件，找到data-scale-mode开始的代码行，将等号右边的内容修改 显示文字1234567var tx:egret.TextField = new egret.TextField();tx.text = "I'm Jack, I will use Egret create a fantasy mobile game!";tx.size = 32;this.addChild( tx );tx.x = 20;tx.y = 20;tx.width = this.stage.stageWidth - 40; 响应用户操作 在前一节的基础上，我们就对这段文字添加一些响应操作。比如，改变颜色： 12tx.touchEnabled = true;tx.addEventListener( egret.TouchEvent.TOUCH_TAP, this.touchHandler, this ); 注意，第一行设置touchEnabled为true，意即允许该显示对象响应Touch事件，这是Egret中特别需要注意的问题。因为所有的显示对象，默认都是不响应Touch事件的，这是基于性能考虑，因为打开对这种事件的响应，是对性能有不可忽略的影响的。 其中第二行代码新增一个方法的引用，这就是事件处理函数，我们需要事件处理函数中对用户操作做出对应的反应。 在Main类中，加入如下代码： 1234private touchHandler( evt:egret.TouchEvent ):void&#123; var tx:egret.TextField = evt.currentTarget; tx.textColor = 0x00ff00;&#125; 资源加载Egret中所有的资源都是动态加载的。 资源加载清单Egret的资源加载方式，是以一个资源加载清单为基础的。 如果资源是我们要购买的若干物品，资源加载配置就好比是购物清单。我们首先把需要购买的物品条理清晰地列在清单上，就可以按步骤有条不紊的去购买其上所列出的物品。 在Egret中，我们使用json格式作为RES资源加载配置文件的格式。 通常Egret中的资源加载配置文件位于项目目录的resource文件夹内，取名default.res.json。Egret项目在创建时已经包含该文件。 12345678910111213141516171819202122232425&#123; "resources": [ &#123; "name": "bgImage", "type": "image", "url": "assets/bg.jpg" &#125;, &#123; "name": "egretIcon", "type": "image", "url": "assets/egret_icon.png" &#125;, &#123; "name": "description", "type": "json", "url": "config/description.json" &#125; ], "groups": [ &#123; "name": "preload", "keys": "bgImage,egretIcon" &#125; ]&#125; 配置文件中的”resource”我们可以视为资源库，当前游戏使用到的资源都可以放到这里。其中以资源为单位分别列出。每一项资源单位都包含三个属性： name：表示这个资源的唯一标识符。注意资源比较多的项目应确定一套命名规则，避免不同资源命名之间重复或太接近而易混淆。 type：表示资源类型。紧跟着会进一步讲解其含义及取值规则。 url：表示当前资源文件的路径。通常我们约定配置类型的资源置于config子目录下；其他类型置于assets子目录下。 每个”resource”单位中的type，是Egret约定好的若干类型，最常用的有以下类型： image：表示各种常见的图片类型，包括PNG和JPG格式，载入后将解析为egret.Texture对象； text：表示文本类型，即文本文件，载入后将解析为string对象； json：也是一种文本类型，不过内容是json格式的，载入后将直接解析为json对象； “groups”是预加载资源组的配置，每项是一个资源组。 每一个资源组须包含两个属性：（将若干项资源定义为一个资源组。需要时，只需加载这个资源组即可。） name：表示资源组的组名 keys：表示这个资源组包含哪些资源，里面的逗号分隔的每一个字符串，都与”resource”下的资源name对应。 在程序中加载资源在Main.ts的loadResource中修改RES.loadGroup的资源组名字。 很显然，loadGroup就是用来加载资源组的。 显示图片1234var batman:egret.Bitmap = new egret.Bitmap( RES.getRes("hero-01") );batman.x = -30;batman.y = 20;this.addChild( batman ); 显示所需的图片，在Egret对应的类就是Bitmap。 使用Bitmap创建一个图片时，在其构造函数中传入RES载入的资源，这里取得的是一个图片的资源，图片资源通过getRes获得的将是一个Texture对象。 这段代码用01号英雄图片资源创建了一个位图(Bitmap)显示对象，然后设定其坐标。最后添加到显示列表中。 显示深度控制在某一个显示容器内的显示对象结构，可以称之为显示列表。这是由于处于同一显示容器的显示对象，是以类似列表的方式来管理的，每一个显示对象都有其索引，并且索引是从0开始的整数。显示列表索引通常称为显示深度。 我们的眼睛对着屏幕，显示列表中显示对象的索引顺序在从屏幕到眼睛方向就是从0开始，依次递增的。 例：获得当前的显示深度 1console.log( "display indexes:", this.getChildIndex( bg ), this.getChildIndex( batman ), this.getChildIndex( captain ), this.getChildIndex( superman ), this.getChildIndex( hulk ) ); 修改显示深度1this.setChildIndex( batman, this.getChildIndex( captain ) ); 关于显示深度的规则： A. 某一个显示深度只能对应一个显示对象，一个显示对象也只能有一个显示深度。 B. 显示深度总是从零开始连续的，当某个深度位置的显示对象被设置为其他深度时，原来的深度会自动被紧邻的比其深度值大1位置的显示对象占据，后续深度位置的显示对象会依次往前排。 C. 某一容器内的显示列表的深度最大值是显示列表长度-1。 可以理解每个深度位置是一个房间，这些房间从0开始依次编号。每个显示对象是一个人，显示列表维护总要确保每个人在一个自己的房间，并且这些房间之间没有空的，除非这些人都从0开始排满了前面的房间。 交换显示深度1this.swapChildren( superman, hulk ); 不可逾越的显示深度最大值1this.setChildIndex( captain, 20 ); 即使设置成20，但是打印出来的最大值仍然是4 Tween动画效果设计某种属性（比如位置、透明度和缩放）的两个不同状态，然后在给定的时间内从一个状态平滑过渡到另外一个状态。 认识锚点锚点：定位点。锚点自然地包含了两个部分：X方向锚点和Y方向锚点。anchorOffsetX和anchorOffsetY 12345// 例：hulk.anchorOffsetX = 30;hulk.anchorOffsetY = 40;hulk.x += 30;hulk.y += 40; 设计并实现一组Tween动画]]></content>
      <categories>
        <category>动画</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[element实现导航]]></title>
    <url>%2F2018%2F08%2F01%2FVue%2FElement%2Felement%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;el-header&gt; &lt;el-menu :default-active=&quot;$route.path&quot; router class=&quot;el-menu-demo&quot; mode=&quot;horizontal&quot; @select=&quot;handleSelect&quot; background-color=&quot;#545c64&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#ffd04b&quot;&gt; &lt;el-menu-item index=&quot;/Help&quot;&gt;帮助&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/Central-summary&quot;&gt;中心概括&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/Flying-Eagle-Academy&quot;&gt;飞鹰学苑&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/Strategy-comparison&quot;&gt;策略对比&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/Strategy-backtest&quot;&gt;策略回测&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;/Combined-configuration&quot;&gt;组合配置&lt;/el-menu-item&gt; &lt;/el-menu&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; activeIndex: &quot;1&quot; &#125;; &#125; &#125;;&lt;/script&gt; vue中使用element实现导航需要注意三个方面 1.启用vue-router在el-menu中添加 router 2.刷新页面后，对应menu高亮更改 :default-active=”$route.path” 3.添加各路由在el-menu-item中的index属性直接书写的路由]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue搭环境]]></title>
    <url>%2F2018%2F08%2F01%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue%2F</url>
    <content type="text"><![CDATA[搭建一个简单的vue环境1.安装vue-cli在要项目的根目录中npm install vue-cli -g2.实例化在要项目的根目录中vue init webpack &lt;项目名字&gt;会有很多选项，按需填写 因为要上传到git上，所以 3.下载包进入项目文件夹 npm install npm run dev上传git在文件夹中 git init git status git remote add origin https://gitee.com/fox9916/demo.git //fatal: remote origin already exists. //解决方法git remote remove origin git pull --rebase origin master git add . 添加目录下所有发生改变的文件 git commit -m &apos;注释信息&apos; git push -u origin master 本地仓库代码提交至远程仓库 (git push -u origin master -f )引入scssnpm install sass-loader node-sass --save-dev引入elementnpm i element-ui -S 如何局部覆盖element-ui的默认样式 在需要更改的组件里新增一个style标签【重点：不要加scoped】，然后直接获取class设置样式就可以咯，class自己去浏览器里右键审查元素可得到。 建议：在获取到的样式里加上能限制范围的父层选择器，不然就变成全局样式咯。 &lt;style&gt; .ruzhu-mess .el-form-item__label{ font-size:16px!important; } .zhuanye-mess .el-form-item__label,.zhuanye-mess .color-t{ font-size:16px!important; color:#606266; } &lt;/style&gt; &lt;style lang=&quot;scss&quot; scoped&gt; @import &apos;../../../assets/scss/pages/organizationUserCenter1.scss&apos;; &lt;/style&gt;引入pug1.安装pug和jade依赖#安装支持pug依赖 npm install pug pug-loader pug-filters -D #安装支持jade依赖 npm install jade jade-loader -D2.配置pug和jade打开webpack.base.conf，在module的rules节点下添加如下配置： { test: /\.jade$/, loader: &quot;jade&quot; }, { test: /\.pug$/, loader: &apos;pug&apos; },安装、使用vuex1.安装npm install vuex –save 2.配置 main.js : import vuex from &apos;vuex&apos; Vue.use(vuex); var store = new vuex.Store({//store对象 state:{ show:false } })在实例化 Vue对象时加入 store 对象 : new Vue({ el: &apos;#app&apos;, router, store,//使用store template: &apos;&lt;App/&gt;&apos;, components: { App } })完成到这一步 , 上述例子中的 $store.state.show 就可以使用了。 3.在vue中使用import { mapState } from &quot;vuex&quot;; computed: { ...mapState([&quot;activeTab&quot;]) },导出excel表格数据1.安装npm install -S file-saver npm install -S xlsx npm install -D script-loader2.放文件在项目中创建一个文件夹（比如vendor，一般是在src目录下创建） 把Blob.js和 Export2Excel.js这两个文件夹放到新建的文件夹内 3.在页面中使用&lt;template&gt; &lt;el-button style=&apos;margin-bottom:20px;&apos; type=&quot;primary&quot; icon=&quot;document&quot; @click=&quot;handleDownload&quot; :loading=&quot;downloadLoading&quot;&gt;导出excel&lt;/el-button&gt; &lt;el-table:data=&quot;tableData&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot;width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; handleDownload() { this.downloadLoading = true require.ensure([], () =&gt; { const { export_json_to_excel } = require(&apos;@/vendor/Export2Excel&apos;) const tHeader = [&apos;日期&apos;, &apos;姓名&apos;, &apos;地址&apos;] const filterVal = [&apos;date&apos;, &apos;name&apos;, &apos;address&apos;] const list = this.tableData const data = this.formatJson(filterVal, list) export_json_to_excel(tHeader, data, &apos;列表excel&apos;) this.downloadLoading = false }) }, formatJson(filterVal, jsonData) { return jsonData.map(v =&gt; filterVal.map(j =&gt; v[j])) }4.注意问题const { export_json_to_excel } = require(‘@/vendor/Export2Excel’)这里的@/vendor/Export2Excel路径问题关键是看build目录下的webpack.base.conf.js配置文件的alias 需要修改两个地方 Export2Excel.js require(&apos;script-loader!@/vendor/Blob&apos;); handleDownload() const { export_json_to_excel } = require(&quot;@/vendor/Export2Excel&quot;); 数据可视化npm i v-charts echarts -S]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编码规范]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%BC%80%E5%8F%91%2F%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[黄金定律不管有多少人共同参与同一项目，一定要确保每一行代码都像是同一个人编写的。 HTML1.语法1).用两个空格代表制表符2).嵌套元素应当缩进一次（两个空格）3).对于属性的定义，用双引号4).不在自闭合元素的尾部加斜线2.HTML5 doctype在每个html页面第一行添加标准模式的声明，确保在每一个浏览器拥有一致的展现。 1&lt;!DOCTYPE html&gt; 3.语言属性强烈建议为html根元素指定lang属性，从而为文档设置正确的语言。这将有助于语言合成工具确定所应该采用的发音，有助于翻译工具确定其翻译时所应遵守的规则等等。 12&lt;html lang='en'&gt;&lt;/html&gt; 4.IE兼容模式IE 支持通过特定的 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模式。 1&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt; 5.字符编码1&lt;meta charset="UTF-8"&gt; 6.引入 CSS 和 JavaScript 文件在引入 CSS 和 JavaScript 文件时一般不需要指定 type 属性 7.实用为王任何时候都要尽量使用最少的标签并保持最小的复杂度。 8.属性顺序 class id, name data-* src, for, type, href, value title, alt role, aria-* 9.布尔（boolean）型属性不用赋值。 1234567&lt;input type="text" disabled&gt;&lt;input type="checkbox" value="1" checked&gt;&lt;select&gt; &lt;option value="1" selected&gt;1&lt;/option&gt;&lt;/select&gt; 10.减少标签的数量尽量避免多余的父元素。 1234567&lt;!-- Not so great --&gt;&lt;span class="avatar"&gt; &lt;img src="..."&gt;&lt;/span&gt;&lt;!-- Better --&gt;&lt;img class="avatar" src="..."&gt; 11.JavaScript 生成的标签能避免时尽量避免。 CSS1.语法1).用两个空格代替制表符2).为选择器分组时，将单独的选择器单独放在一行。3).在每个声明块的左花括号前添加一个空格。4).声明块的右花括号应当单独成行。5).每条声明语句的 : 后应该插入一个空格。6).每条声明都应该独占一行。7).对于以逗号分隔的属性值，每个逗号后面都应该插入一个空格（例如，box-shadow）。8).不要在 rgb()、rgba()、hsl()、hsla() 或 rect() 值的内部的逗号后面插入空格。9).对于属性值或颜色参数，省略小于 1 的小数前面的 0 （例如，.5 代替 0.5；-.5px 代替 -0.5px）。10).十六进制值应该全部小写,尽量使用简写形式的十六进制值。例如：#fff11).为选择器中的属性添加双引号，例如，input[type=”text”]。12).避免为 0 值指定单位，例如，用 margin: 0; 代替 margin: 0px;。1234567891011121314151617/* Bad CSS */.selector, .selector-secondary, .selector[type=text] &#123; padding:15px; margin:0px 0px 15px; background-color:rgba(0, 0, 0, 0.5); box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF&#125;/* Good CSS */.selector,.selector-secondary,.selector[type="text"] &#123; padding: 15px; margin-bottom: 15px; background-color: rgba(0,0,0,.5); box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;&#125; 2.声明顺序 Positioning Box model Typographic Visual 1234567891011121314151617181920212223242526272829.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box-model */ display: block; float: right; width: 100px; height: 100px; /* Typography */ font: normal 13px "Helvetica Neue", sans-serif; line-height: 1.5; color: #333; text-align: center; /* Visual */ background-color: #f5f5f5; border: 1px solid #e5e5e5; border-radius: 3px; /* Misc */ opacity: 1;&#125; 3.不要使用 @import与 &lt;link&gt; 标签相比，@import 指令要慢很多 解决办法： 使用多个 元素 通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件 通过 Rails、Jekyll 或其他系统中提供过 CSS 文件合并功能 4.媒体查询（Media query）的位置不要把他们打包放在一个单一样式文件中或者放在文档底部，应放在尽可能相关规则的附近。 123456789.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (min-width: 480px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 5.带前缀的属性通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑。 12345/* Prefixed properties */.selector &#123; -webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15); box-shadow: 0 1px 2px rgba(0,0,0,.15);&#125; 6.单行规则声明对于只包含一条声明的样式，建议将语句放在同一行。 7.简写形式的属性声明应当尽量限制使用简写形式的属性声明。常见的滥用简写属性声明的情况如下： padding margin font background border border-radius 12345678910111213141516/* Bad example */.element &#123; margin: 0 0 10px; background: red; background: url("image.jpg"); border-radius: 3px 3px 0 0;&#125;/* Good example */.element &#123; margin-bottom: 10px; background-color: red; background-image: url("image.jpg"); border-top-left-radius: 3px; border-top-right-radius: 3px;&#125; 8.Less 和 Sass 中的嵌套避免不必要的嵌套。这是因为虽然你可以使用嵌套，但是并不意味着应该使用嵌套。只有在必须将样式限制在父元素内（也就是后代选择器），并且存在多个需要嵌套的元素时才使用嵌套。 123456789// Without nesting.table &gt; thead &gt; tr &gt; th &#123; … &#125;.table &gt; thead &gt; tr &gt; td &#123; … &#125;// With nesting.table &gt; thead &gt; tr &#123; &gt; th &#123; … &#125; &gt; td &#123; … &#125;&#125; 9.Less 和 Sass 中的操作符在圆括号中的数学计算表达式的数值、变量和操作符之间均添加一个空格。 10.注释不要简单地重申组件或 class 名称。 对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。 1234567891011/* Bad example *//* Modal header */.modal-header &#123; ...&#125;/* Good example *//* Wrapping element for .modal-title and .modal-close */.modal-header &#123; ...&#125; 11.class 命名 class 名称中只能出现小写字符和破折号（dashe）（不是下划线，也不是驼峰命名法）。破折号应当用于相关 class 的命名（类似于命名空间）（例如，.btn 和 .btn-danger）。 避免过度任意的简写。.btn 代表 button，但是 .s 不能表达任何意思。 class 名称应当尽可能短，并且意义明确。 使用有意义的名称。使用有组织的或目的明确的名称，不要使用表现形式（presentational）的名称。 基于最近的父 class 或基本（base） class 作为新 class 的前缀。 使用 .js-* class 来标识行为（与样式相对），并且不要将这些 class 包含到 CSS 文件中。 123456789/* Bad example */.t &#123; ... &#125;.red &#123; ... &#125;.header &#123; ... &#125;/* Good example */.tweet &#123; ... &#125;.important &#123; ... &#125;.tweet-header &#123; ... &#125; 12.选择器 对于通用元素使用 class ，这样利于渲染性能的优化。 对于经常出现的组件，避免使用属性选择器（例如，[class^=”…”]）。浏览器的性能会受到这些因素的影响。 选择器要尽可能短，并且尽量限制组成选择器的元素个数，建议不要超过 3 。 只有在必要的时候才将 class 限制在最近的父元素内（也就是后代选择器）（例如，不使用带前缀的 class 时 – 前缀类似于命名空间）。 123456789/* Bad example */span &#123; ... &#125;.page-container #stream .stream-item .tweet .tweet-header .username &#123; ... &#125;.avatar &#123; ... &#125;/* Good example */.avatar &#123; ... &#125;.tweet-header .username &#123; ... &#125;.tweet .avatar &#123; ... &#125; 13.代码组织 以组件为单位组织代码段。 制定一致的注释规范。 使用一致的空白符将代码分隔成块，这样利于扫描较大的文档。 如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动。 12345/** Component section heading*/.element &#123; ... &#125; 12345678910/** Component section heading** Sometimes you need to include optional context for the entire component. Do that up here if it's important enough.*/.element &#123; ... &#125;/* Contextual sub-component or modifer */.element-heading &#123; ... &#125; 14.编辑器配置将你的编辑器按照下面的配置进行设置，以避免常见的代码不一致和差异： 用两个空格代替制表符（soft-tab 即用空格代表 tab 符）。 保存文件时，删除尾部的空白符。 设置文件编码为 UTF-8。 在文件结尾添加一个空白行。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack(2)]]></title>
    <url>%2F2018%2F07%2F12%2F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2FWebpack%2Fwebpack(1)%2F</url>
    <content type="text"><![CDATA[概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 四个核心概念 入口(entry) 输出(output) loader 插件(plugins) 入口(entry)入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）。默认值为 ./src。 单个入口（简写）语法用法：entry: string|Array webpack.config.js const config = { entry: &apos;./path/to/my/entry/file.js&apos; }; module.exports = config;有失灵活性，如果需要快速为只有一个入口起点的应用程序或工具设置webpack配置的时候，是个不错的选择。 对象语法用法：entry: {[entryChunkName: string]: string| Array} webpack.config.js const config = { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; } };常见场景1.分离 应用程序(app) 和 第三方库(vendor) 入口webpack.config.js const config = { entry: { app: &apos;./src/app.js&apos;, vendors: &apos;./src/vendors.js&apos; } };2.多页面应用程序webpack.config.js const config = { entry: { pageOne: &apos;./src/pageOne/index.js&apos;, pageTwo: &apos;./src/pageTwo/index.js&apos;, pageThree: &apos;./src/pageThree/index.js&apos; } };根据经验：每个 HTML 文档只使用一个入口起点。 输出(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。注意，即使可以存在多个入口起点，但只指定一个输出配置。 用法(Usage)在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 webpack.config.js const config = { output: { filename: &apos;bundle.js&apos;, path: &apos;/home/proj/public/assets&apos; } }; module.exports = config; 多个入口起点应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 { entry: { app: &apos;./src/app.js&apos;, search: &apos;./src/search.js&apos; }, output: { filename: &apos;[name].js&apos;, path: __dirname + &apos;/dist&apos; } } // 写入到硬盘：./dist/app.js, ./dist/search.js高级进阶以下是使用 CDN 和资源 hash 的复杂示例： config.js output: { path: &quot;/home/proj/cdn/assets/[hash]&quot;, publicPath: &quot;http://cdn.example.com/assets/[hash]/&quot; }在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 webpack_public_path。 __webpack_public_path__ = myRuntimePublicPath // 剩余的应用程序入口模式(mode)提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。 string 用法只在配置中提供 mode 选项： module.exports = { mode: &apos;production&apos; };或者从 CLI 参数中传递： webpack --mode=production支持以下字符串值： 选项 | 描述| - | :-: | -: |development | 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。production | 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin.记住，只设置 NODE_ENV，则不会自动设置 mode。 mode: development// webpack.development.config.js module.exports = { + mode: &apos;development&apos; - plugins: [ - new webpack.NamedModulesPlugin(), - new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) }), - ] }mode: production// webpack.production.config.js module.exports = { + mode: &apos;production&apos;, - plugins: [ - new UglifyJsPlugin(/* ... */), - new webpack.DefinePlugin({ &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;production&quot;) }), - new webpack.optimize.ModuleConcatenationPlugin(), - new webpack.NoEmitOnErrorsPlugin() - ] }loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。oader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 示例例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader： npm install --save-dev css-loader npm install --save-dev ts-loader然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader： webpack.config.js module.exports = { module: { rules: [ { test: /\.css$/, use: &apos;css-loader&apos; }, { test: /\.ts$/, use: &apos;ts-loader&apos; } ] } };使用 loader 配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 配置[Configuration]module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览： module: { rules: [ { test: /\.css$/, use: [ { loader: &apos;style-loader&apos; }, { loader: &apos;css-loader&apos;, options: { modules: true } } ] } ] }插件(plugins)用法由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 根据你的 webpack 用法，这里有多种方式使用插件。 配置webpack.config.js const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); //通过 npm 安装 const webpack = require(&apos;webpack&apos;); //访问内置的插件 const path = require(&apos;path&apos;); const config = { entry: &apos;./path/to/my/entry/file.js&apos;, output: { filename: &apos;my-first-webpack.bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) }, module: { rules: [ { test: /\.(js|jsx)$/, use: &apos;babel-loader&apos; } ] }, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin({template: &apos;./src/index.html&apos;}) ] }; module.exports = config;依赖图(dependency graph)任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有依赖关系。这使得 webpack 可以接收非代码资源(non-code asset)（例如图像或 web 字体），并且可以把它们作为_依赖_提供给你的应用程序。 webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些入口起点开始，webpack 递归地构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载。]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BEM命名方法]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%BC%80%E5%8F%91%2FBEM%E5%91%BD%E5%90%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.为什么选择这种方法命名呢？ 以往命名的方法是 1234567891011121314151617181920212223242526html结构&lt;div class="main"&gt; &lt;div class="bigBox"&gt; &lt;img src="" alt=""&gt; &lt;div class="text"&gt; &lt;span&gt;&lt;/span&gt; &lt;h&gt;&lt;/h&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;stylus结构.main .bigBox img .text span hcss结构.main&#123;&#125;.main .bigBox&#123;&#125;.main .bigBox img&#123;&#125;.main .bigBox .text&#123;&#125;.main .bigBox .text span&#123;&#125;.main .bigBox .text h&#123;&#125; 如果某一天，不需要.bigBox这个层，那么整个stylus css都要改，因为所有都有.bigBox这个类前提 为更有效率的打码，更有逻辑的打码，现在有一种命名方法，BEM，即block element modifier 2.BEM命名规则block element modifier块 元素 修饰符 块与元素用__连接，元素和修饰符用.连接 对一个组件（拿到设计稿，需要看清哪些可以做成一个个组件），可以这样命名 1234&lt;div class="link-btn"&gt; &lt;span class="link-btn__main-title red"&gt;&lt;/span&gt; &lt;span class="link-btn__sub-title"&gt;&lt;/span&gt;&lt;/div&gt; 这样在stylus中就可以这样 1234.link-btn &amp;__main-title &amp;.red &amp;__sub-title 编译出来的css就是 1234.link-btn&#123;&#125;.link-btn__main-title&#123;&#125;.link-btn__main-title red&#123;&#125;.link-btn__sub-title]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vscode中使用Emmet神奇快速编写HTML代码]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%BC%80%E5%8F%91%2FVscode%2FVscode%E4%B8%AD%E4%BD%BF%E7%94%A8Emmet%E7%A5%9E%E5%A5%87%E5%BF%AB%E9%80%9F%E7%BC%96%E5%86%99HTML%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、Emmet带给我们的便利可以极大的提高代码编写的效率，不用再打&lt;&gt;这样的尖括号。它提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS 代码，同时还有多种实用的功能帮助进行前端开发。 VsCode内置了Emmet语法,在后缀为.html/.css中输入缩写后按Tab键即会自动生成相应代码 请注意在VsCode新版本中按Tab不再默认启用Emmet展开缩写!需要在首选项配置中将emmet.triggerExpansionOnTab设置为true值! 如果你的编辑器中已经有了一些html智能提示代码段,比如我的VsCode还装了HTML Snippets插件,这个与Emmet语法有部分冲突,使用Tab键时会优先使用插件的代码提示,建议禁用. 二、基础用法 元素 12345678910111213141516div =&gt; &lt;div&gt; &lt;/div&gt; //即使用元素的名称生成标签以下是特殊的几个html:5 =&gt; 将生成html5标准的包含body为空基本domhtml:xt =&gt; 生成XHTML过渡文档类型,DOCTYPE为XHTMLhtml:4s =&gt; 生成HTML4严格文档类型,DOCTYPE为HTML 4.01a:mail =&gt; &lt;a href=&quot;mailto:&quot;\&gt;&lt;/a&gt;a:link =&gt; &lt;a href=&quot;http://&quot;&gt;&lt;/a&gt;script:src =&gt; &lt;script src=&quot;&quot;&gt;&lt;/script&gt;form:get =&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt;input:hidden =&gt; &lt;input type=&quot;hidden&quot; name=&quot;&quot;\&gt; input:h亦可input:email =&gt; &lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot;\&gt;input:password =&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot;\&gt;input:checkbox =&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;\&gt;input:radio =&gt; &lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot;\&gt;btn:s =&gt; &lt;button type=&quot;submit&quot;\&gt;&lt;/button\&gt;btn:r =&gt; &lt;button type=&quot;reset&quot;\&gt;&lt;/button\&gt; 文本操作符 12div&#123;这是一段文本&#125;&lt;div&gt;这是一段文本&lt;/div&gt; //使用&#123;文字&#125; 属性操作符 id class 12div.test =&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;div#pageId =&gt; &lt;div id=&quot;pageId&quot;&gt;&lt;/div&gt; 绑定多个类名用.符号连续起来即可 123div.test1.test2.test3=&gt;&lt;div class=&quot;test1 test2 test3&quot;&gt;&lt;/div&gt; 自定义属性使用 [attr1=’’ attr2=’’] 123a[href=&apos;#&apos; data-title=&apos;customer&apos; target=&apos;_blank&apos;]=&gt;&lt;a href=&quot;#&quot; data-title=&quot;customer&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; 嵌套操作符(Nesting operators) 子级:&gt; 1234567div#pageId&gt;ul&gt;li =&gt; &lt;div id=&quot;pageId&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 同级:+ 1234div#pageId+div.child=&gt;&lt;div id=&quot;pageId&quot;&gt;&lt;/div&gt;&lt;div class=&quot;child&quot;&gt;&lt;/div&gt; 父级:^ 12345678div&gt;p.parent&gt;span.child^ul.brother&gt;li=&gt;&lt;div&gt; &lt;p class=&quot;parent&quot;&gt;&lt;span class=&quot;child&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul class=&quot;brother&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 分组操作符(Grouping) 123456789div&gt;(ul&gt;li+span)&gt;a=&gt;&lt;div&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;span&gt;&lt;/span&gt;&lt;/ul&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt; 乘法 1234567ul&gt;li*3=&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 自动计数(numbering) 这个功能挺方便的对于生成重复项时增加一个序号,只需要加上$符号即可. 123456ul&gt;li.item$&#123;item number:$&#125;*3&lt;ul&gt;&lt;li class=&quot;item1&quot;&gt;item number:1&lt;/li&gt;&lt;li class=&quot;item2&quot;&gt;item number:2&lt;/li&gt;&lt;li class=&quot;item3&quot;&gt;item number:3&lt;/li&gt;&lt;/ul&gt; 如果生成两位数则使用两个连续的$$,更多位数以此类推…使用@修饰符，可以更改编号方向（升序或降序）和基数（例如起始值）.注意这个操作符在$之后添加@-表示降序,@+表示升序,默认使用升序.@N可以改变起始值.需要注意的是如果配合升降序使用的话N是放到+-符后. 123456789101112131415ul&gt;li.item$@-*3=&gt;&lt;ul&gt;&lt;li class=&quot;item3&quot;&gt;&lt;/li&gt;&lt;li class=&quot;item2&quot;&gt;&lt;/li&gt;&lt;li class=&quot;item1&quot;&gt;&lt;/li&gt;&lt;/ul&gt;---------------------------ul&gt;li.item$@-10*3=&gt;&lt;ul&gt;&lt;li class=&quot;item12&quot;&gt;&lt;/li&gt;&lt;li class=&quot;item11&quot;&gt;&lt;/li&gt;&lt;li class=&quot;item10&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 包装文本听起来可能有点绕,通俗点解释就是把一段指定的文本包装成我们想要的结构.注意这个功能需要编辑器的支持,举个大栗子:比如PM给了这样一段文本 123456789101112131415首页产品介绍相关案例关于我们联系我们而我们预期的效果是这样&lt;nav&gt;&lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;产品介绍&lt;/li&gt; &lt;li&gt;相关案例&lt;/li&gt; &lt;li&gt;关于我们&lt;/li&gt; &lt;li&gt;联系我们&lt;/li&gt;&lt;/ul&gt;&lt;/nav&gt; 选中文本,按下ctrl+shift+p打开命令窗口输入ewrap 选择Emmet:使用缩写进行包装(Wrap with Abbreviation)选项 输入缩写字符nav&gt;ul&gt;li*按下回车键即可看到效果. 当然也可以在菜单=&gt;编辑=&gt;Emmet(M)..然后输入. 1这里需要的注意的地方是输入的缩写代码中*所在位置不同得到的效果也是不同的. 另外如果给的文本带有序号的情况,我们也是可以通过缩写来处理,而不是手动删除,主要用的是|t来处理.比如: 123456781.首页2.产品介绍3.相关案例4.关于我们5.联系我们输入包装字符命令nav&gt;ul&gt;li*|t即可看到生成的html中自动去掉了序号]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是跨域？]]></title>
    <url>%2F2018%2F03%2F23%2FJavaScript%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[由于浏览器同源策略，凡是发送请求url的协议、域名、端口三者之间任意一个与当前页面地址不同即为跨域。存在跨域的情况：123456789何谓同源:URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。同源策略:浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。从一个域上加载的脚本不允许访问另外一个域的文档属性。 网络协议不同，如http协议访问https协议。 端口不同，如80端口访问8080端口。 域名不同，如qianduanblog.com访问baidu.com。 子域名不同，如abc.qianduanblog.com访问def.qianduanblog.com。 域名和域名对应ip,如www.a.com访问20.205.28.90. 跨域请求资源的方法？如果前端，后台一家亲，用CORS，和后台说一声，拿到给的网址即可。 如果不是，需要前端解决，则可以用以下的办法 1.JSONP这种方式主要是通过动态插入一个script标签。浏览器对script的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。 1234567js代码&lt;script&gt; var _script = document.createElement(&apos;script&apos;); _script.type = &quot;text/javascript&quot;; _script.src = &quot;http://localhost:8888/jsonp?callback=f&quot;; document.head.appendChild(_script); &lt;/script&gt; 实际项目中JSONP通常用来获取json格式数据，这时前后端通常约定一个参数callback，该参数的值，就是处理返回数据的函数名称。 12345678910111213141516171819202122232425262728html代码&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;jsonp_test&lt;/title&gt; &lt;script&gt; var f = function(data)&#123; alert(data.name); &#125; /*var xhr = new XMLHttpRequest(); xhr.onload = function()&#123; alert(xhr.responseText); &#125;; xhr.open(&apos;POST&apos;, &apos;http://localhost:8888/cors&apos;, true); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;f=json&quot;);*/ &lt;/script&gt; &lt;script&gt; var _script = document.createElement(&apos;script&apos;); _script.type = &quot;text/javascript&quot;; _script.src = &quot;http://localhost:8888/jsonp?callback=f&quot;; document.head.appendChild(_script); &lt;/script&gt; &lt;/head&gt; 后端 123456789101112java代码var query = _url.query; console.log(query); var params = qs.parse(query); console.log(params); var f = &quot;&quot;; f = params.callback; res.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/javascript&quot;&#125;); res.write(f + &quot;(&#123;name:&apos;hello world&apos;&#125;)&quot;); res.end(); 缺点：这种方式无法发送post请求（这里）另外要确定jsonp的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。 2.proxy代理这种方式首先将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。 123456789101112131415161718192021222324html代码&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;proxy_test&lt;/title&gt; &lt;script&gt; var f = function(data)&#123; alert(data.name); &#125; var xhr = new XMLHttpRequest(); xhr.onload = function()&#123; alert(xhr.responseText); &#125;; xhr.open(&apos;POST&apos;, &apos;http://localhost:8888/proxy?http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer&apos;, true); xhr.send(&quot;f=json&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 后端 123456789101112131415161718192021222324java代码var proxyUrl = &quot;&quot;; if (req.url.indexOf(&apos;?&apos;) &gt; -1) &#123; proxyUrl = req.url.substr(req.url.indexOf(&apos;?&apos;) + 1); console.log(proxyUrl); &#125; if (req.method === &apos;GET&apos;) &#123; request.get(proxyUrl).pipe(res); &#125; else if (req.method === &apos;POST&apos;) &#123; var post = &apos;&apos;; //定义了一个post变量，用于暂存请求体的信息 req.on(&apos;data&apos;, function(chunk)&#123; //通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 post += chunk; &#125;); req.on(&apos;end&apos;, function()&#123; //在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 post = qs.parse(post); request(&#123; method: &apos;POST&apos;, url: proxyUrl, form: post &#125;).pipe(res); &#125;); &#125; 需要注意的是如果你代理的是https协议的请求，那么你的proxy首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。12306就提供了一个鲜活的例子。 还需要注意一点，对于同一请求浏览器通常会从缓存中读取数据，我们有时候不想从缓存中读取，所以会加一个preventCache参数，这个时 候请求url变成：url?preventCache=12345567….;这本身没有什么问题，问题出在当使用某些前端框架（比如jquery） 发送proxy代理请求时，请求url为proxy?url，同时设置preventCache：true，框架不能正确处理这个参数，结果发出去的请求 变成proxy?url&amp;preventCache=123456（正长应为proxy?url?preventCache=12356）;后端 截取后发送的请求为url&amp;preventCache=123456，根本没有这个地址，所以你得不到正确结果 3.CORS这是现代浏览器支持跨域资源请求的一种方式。 当你使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处 理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin;浏览器判断该相应头中是否包含 Origin的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据 1234567891011121314151617181920212223242526272829303132html代码&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;jsonp_test&lt;/title&gt; &lt;script&gt; /*var f = function(data)&#123; alert(data.name); &#125;*/ var xhr = new XMLHttpRequest(); xhr.onload = function()&#123; alert(xhr.responseText); &#125;; xhr.open(&apos;POST&apos;, &apos;http://localhost:8888/cors&apos;, true); xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;f=json&quot;); &lt;/script&gt; &lt;script&gt; /* var _script = document.createElement(&apos;script&apos;); _script.type = &quot;text/javascript&quot;; _script.src = &quot;http://localhost:8888/jsonp?callback=f&quot;; document.head.appendChild(_script);*/ &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 后端 12345678910if (req.headers.origin) &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html; charset=UTF-8&quot;, &quot;Access-Control-Allow-Origin&quot;:&apos;http://localhost&apos;/*, &apos;Access-Control-Allow-Methods&apos;: &apos;GET, POST, OPTIONS&apos;, &apos;Access-Control-Allow-Headers&apos;: &apos;X-Requested-With, Content-Type&apos;*/ &#125;); res.write(&apos;cors&apos;); res.end();&#125; 以上是简单请求，还有一种非简单请求 （1) 请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 详情见阮一峰的文章]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四种方式实现JS异步编程]]></title>
    <url>%2F2018%2F03%2F23%2FJavaScript%2F%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[要求使用回调、Promise、generator和asnyc/await四种方式，请求api/data中的数据为方便理解，首先封装了一个库去实现ajax的get方法，调用方式如下1http.get(&apos;api/data&apos;, callback) 但是如果以同步的方式来写，如 12345function getData (url) &#123; return http.get(url)&#125;const data = getData(&apos;api/data&apos;);console.log(data) // undefined 结果报错了，这是因为http.get(url)本身是个异步（非阻塞）的过程，这行代码运行的时候并没有马上得到结果，它的结果出现时间与服务器有关，是无法预知的。js会把它放到异步线程然后继续运行下去，下一行打印它自然是undefined。 所以才有了接下来的讨论，采用异步的方式去获取它的结果。 回调（callback）12345678910111213141516171819202122232425function getData (url, callback) &#123; http.getData(url, data =&gt; &#123; if (data.status == 200) &#123; // let err = null // callback(err, data); callback(null, data); &#125; else &#123; // let err = data // callback(err, data); callback(data); &#125; &#125;);&#125;getData(&apos;api/data&apos;, (err, data) =&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) &#125;&#125;) PromisePromise对象代表一个未完成、但预计将来会完成的操作，有三种状态： pending：初始值，不是fulfilled，也不是rejectedresolved(也叫fulfilled）：代表操作成功rejected：代表操作失败 整个promise的状态只支持两种转换：从pending转变为resolved，或从pending转变为rejected，一旦转化发生就会保持这种状态，不可以再发生变化，状态发生变化后会触发then方法。 1234567891011121314151617function getData (url) &#123; return new Promise((resolve, reject) =&gt; &#123; http.get(url, data =&gt; &#123; if (data.status == 200) &#123; resolve(data); &#125; else &#123; reject(data); &#125; &#125;); &#125;)&#125;getData(&apos;api/data&apos;).then(data =&gt; &#123; console.log(data);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) 拓展：Promise还有一个Promise.all()方法，当我们需要请求多个接口的数据时，可以这么用 12345678910111213141516171819202122232425262728293031323334353637383940function getData (url, callback) &#123; http.get(url, data =&gt; &#123; if (data.status == 200) &#123; callback(null, data); &#125; else &#123; callback(data); &#125; &#125;);&#125;const ansycTask = &#123; getData(&apos;data/api1&apos;, (err, data) =&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) return data &#125; &#125;, getData(&apos;data/api2&apos;, (err, data) =&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) return data &#125; &#125;, getData(&apos;data/api3&apos;, (err, data) =&gt; &#123; if (err) &#123; console.log(err) &#125; else &#123; console.log(data) return data &#125; &#125;&#125;Promise.all(asyncTask).then(data =&gt; &#123; console.log(data)&#125;) 全部请求得到返回后，会返回一个由3个data组成的数组，并且是按请求顺序排列的。 generator相当于Promise的升级，可以手动控制Promise的进行 12345678910111213141516171819202122function getData (url) &#123; return new Promise((resolve, reject) =&gt; &#123; http.get(url, data =&gt; &#123; if (data.status == 200) &#123; resolve(data); &#125; else &#123; reject(data); &#125; &#125;); &#125;)&#125;function *getDataGen (url) &#123; yield getData(url); yield () =&gt; &#123; console.log(&apos;end&apos;) &#125;&#125;const task = getDataGen(&apos;api/data&apos;);task.next(); // 打印datatask next(); // 打印&apos;end&apos; generator里面可以使用yield关键字来表示暂停，它接收一个promise对象，返回promise的结果并且停在此处等待，不是一次性执行完。 async/awaitasync/await是ES7新特性，必须配合使用，在function前加上async，然后在需要等待结果的代码前面加上await，函数将在await的那个东西取得结果后再赋值，可以和Promise配合使用。 1234567891011121314151617function getDataPromise (url) &#123; return new Promise((resolve, reject) =&gt; &#123; http.get(url, data =&gt; &#123; if (data.status == 200) &#123; resolve(data); &#125; else &#123; reject(data); &#125; &#125;); &#125;)&#125;async function getData(url) &#123; await getDataPromise(url);&#125;const data = await getData(&apos;data/api&apos;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp px2rem]]></title>
    <url>%2F2018%2F03%2F19%2F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2FGulp%2Fgulp%20px2rem%2F</url>
    <content type="text"><![CDATA[如何用px2rem处理css文件呢？ 先把.styl文件编译成.css文件，接着处理 123456789101112//px2rem处理gulp.task('px2rem',function() &#123; return gulp.src('./src/css/index.css') .pipe(px2rem(&#123; baseDpr: 2, // base device pixel ratio (default: 2) threeVersion: false, // whether to generate @1x, @2x and @3x version (default: false) remVersion: true, // whether to generate rem version (default: true) remUnit: 75, // rem unit value (default: 75) remPrecision: 6 // rem precision (default: 6) &#125;)) .pipe(gulp.dest('./src/css'))&#125;); 在./src/css中就会生成index.debug.css文件 最终的结果是 1234567891011121314151617181920212223.selector &#123; width: 150px; height: 64px; /*px*/ font-size: 28px; /*px*/ border: 1px solid #ddd; /*no*/&#125;.selector &#123; width: 2rem; border: 1px solid #ddd;&#125;[data-dpr="1"] .selector &#123; height: 32px; font-size: 14px;&#125;[data-dpr="2"] .selector &#123; height: 64px; font-size: 28px;&#125;[data-dpr="3"] .selector &#123; height: 96px; font-size: 42px;&#125;]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何适配移动端呢？]]></title>
    <url>%2F2018%2F03%2F19%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F%E5%A6%82%E4%BD%95%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%91%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[可使用flexible框架 在head标签引入文件 12&lt;script src="./common/flexible.debug.js"&gt;&lt;/script&gt;&lt;script src="./common/flexible_css.debug.js"&gt;&lt;/script&gt; 注释 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; --&gt; 然后html会在不同的设备下产生不同的font-size值，我们可以利用px2rem进行书写css，以达到自动适配的目的。对于gulp配置px2rem的方法，详情写gulp-px2rem]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wow.js & animate.css]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%8A%A8%E7%94%BB%2Fwow.js%20%26%20animate.css%2F</url>
    <content type="text"><![CDATA[如何实现随着滚动条滚动加载动画呢？ 使用wow.js 和animate.css即可实现随滚动条加载酷炫动画 引入js和css 123456&lt;link rel="stylesheet" href="css/animate.css"&gt;&lt;script src="js/wow.min.js"&gt;&lt;/script&gt;&lt;script&gt; new WOW().init();&lt;/script&gt; 在类名加入 wow 和喜欢的动画效果名字 123&lt;div class="wow bounceInUp"&gt; Content to Reveal Here&lt;/div&gt;]]></content>
      <categories>
        <category>动画</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2018%2F03%2F19%2FGit%2Fgit%2F</url>
    <content type="text"><![CDATA[克隆仓库到本地 git status git add . git commit -m ‘更新的内容写在这’ git pull origin master git push origin master 如果仓库更新，则在之前把仓库更新的内容拉过来 git pull如果本地文件需要改动，则直接在仓库的文件中改动 git status //可以查看状态 红色表示修改了 git add . git commit -m ‘更新的内容写在这’ git pull origin master //先从远端把代码先拉过来，在本地合并 git push origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[gulp初接触]]></title>
    <url>%2F2018%2F03%2F15%2F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2FGulp%2Fgulp%E5%88%9D%E6%8E%A5%E8%A7%A6%2F</url>
    <content type="text"><![CDATA[gulp安装 全局：npm install gulp -g 开发环境：npm install gulp –save-dev 项目结构1234567891011121314151617181920212223-dist //打包目录 -css -built.css -built.min.css -js -built.js -built.min.js -images-src //开发目录 -css -built.css -built.css.map -js -js1.js -js2.js -stylus -stylus1.styl -stylus2.styl -images -index.html //项目入口-gulpfile.js //配置文件-package-lock.json-package.json //配置信息 首先在package.json文件中添加项目信息 1234&#123; "name": "gulp_test", "version": "1.0.0"&#125; 引入模块和插件1.引入模块12// gulpfile.jsvar gulp = require('gulp'); 2.插件gulp中的几个比较常用的插件 gulp-concat : 合并文件(js/css) gulp-rename : 文件重命名 gulp-htmlmin : 压缩html文件 gulp-imagemin : 压缩图片 gulp-uglify : 压缩js文件 gulp-livereload : 实时自动编译刷新 gulp-connect : 热加载 gulp-stylus : 编译stylus gulp-clean-css : 压缩css gulp-sourcemaps : 可在浏览器调试工具中查看到对应代码在stylus的位置 gulp-postcss : 扩展的语法和特性转换成现代的浏览器友好的CSS autoprefixer : 自动添加css浏览器前缀 cssnano : 压缩，去空格，去注释，去覆盖等 API gulp.src(filePath/pathArr)：指向指定路径的所有文件，返回文件流对象，用于读取文件 gulp.dest(dirPath/pathArr)：指向指定的所有文件夹，用于向文件夹中输出文件 gulp.task(name, [deps], fn)：定义一个任务 gulp.watch()：监听文件的变化 3.各部分打包代码stylus css处理1234567891011121314gulp.task('stylusTask', function () &#123; var processor = [ autoprefixer, cssnano ]; return gulp.src('src/stylus/*.styl') .pipe(sourcemaps.init()) .pipe(stylus()) .pipe(postcss(processor)) .pipe(concat('built.css')) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('src/css')) .pipe(livereload());&#125;); 打包asset1234567gulp.task('copyAsset', function () &#123; return gulp.src([ './src/asset/**/*' // './src/asset/jquery/**/*' ]) .pipe(gulp.dest('./dist/asset'))&#125;) 打包html1234567891011121314gulp.task('copyHtml', function () &#123; return gulp.src('./src/*.html') .pipe(htmlmin(&#123; collapseWhitespace:true, collapseBooleanAttributes:true, removeComments:true, removeEmptyAttributes:true, removeScriptTypeAttributes:true, removeStyleLinkTypeAttributes:true, minifyJS:true, minifyCSS:true &#125;)) .pipe(gulp.dest('./dist'))&#125;) 打包css1234567gulp.task('cssTask', ['stylusTask'], function () &#123; return gulp.src('./src/css/built.css') .pipe(gulp.dest('./dist/css')) .pipe(rename(&#123;suffix:'.min'&#125;)) .pipe(cleanCSS(&#123;compatibility:'ie8'&#125;)) .pipe(gulp.dest('./dist/css'))&#125;) 打包js12345678gulp.task('jsTask', function () &#123; return gulp.src('./src/js/*.js') .pipe(concat('built.js')) //合并到临时文件夹 .pipe(gulp.dest('./dist/js')) //生成到目标文件夹 .pipe(rename(&#123;suffix:'.min'&#125;)) //重命名 .pipe(uglify()) //压缩 .pipe(gulp.dest('./dist/js'))&#125;) 打包图片12345678910gulp.task('copyImages', function () &#123; return gulp.src('./src/images/*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./dist/images'))&#125;) 热加载123456789101112gulp.task('reload', function () &#123; return gulp.src('src/*.html') .pipe(connect.reload())&#125;);监听gulp.task('server', function () &#123; connect.server(&#123; root: 'src', livereload: true, port: 5000 &#125;)&#125;); 123456gulp.task('auto', function() &#123; gulp.watch('src/stylus/*.styl', ['stylusTask']); gulp.watch('src/css/*.css', ['reload']) gulp.watch('src/*.html', ['reload']); gulp.watch('src/js/*.js', ['reload']);&#125;); 执行任务123gulp.task('default', ['server', 'auto']);gulp.task('product', ['cssTask', 'copyHtml', 'copyImages', 'jsTask', 'copyAsset', 'copyImages']) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// /*// * gulp-concat : 合并文件(js/css)// * gulp-rename : 文件重命名// * gulp-htmlmin : 压缩html文件// * gulp-imagemin : 压缩图片// * gulp-uglify : 压缩js文件// * gulp-livereload : 实时自动编译刷新// * gulp-connect : 热加载// * gulp-stylus : 编译stylus// * gulp-clean-css : 压缩css// * gulp-sourcemaps : 可在浏览器调试工具中查看到对应代码在stylus的位置// * gulp-postcss : 扩展的语法和特性转换成现代的浏览器友好的CSS// * autoprefixer : 自动添加css浏览器前缀// * cssnano : 压缩，去空格，去注释，去覆盖等// *// * gulp.src(filePath/pathArr)：指向指定路径的所有文件, 返回文件流对象，用于读取文件// * gulp.dest(dirPath/pathArr)：指向指定的所有文件夹，用于向文件夹中输出文件// * gulp.task(name, [deps], fn)：定义一个任务// * gulp.watch()：监视文件的变化// */var gulp = require('gulp');// common plyuginvar concat = require('gulp-concat'), rename = require('gulp-rename'), htmlmin = require('gulp-htmlmin'), imagemin = require('gulp-imagemin'), uglify = require('gulp-uglify'), livereload = require('gulp-livereload'), connect = require('gulp-connect');var stylus = require('gulp-stylus'), sourcemaps = require('gulp-sourcemaps'), postcss = require('gulp-postcss'), autoprefixer = require('autoprefixer'), cleanCSS = require('gulp-clean-css'), cssnano = require('cssnano');// var cheerio = require('gulp-cheerio');// instructiongulp.task('help',function () &#123; console.log(' gulp 自定义开发模式'); console.log(' gulp build 文件打包'); console.log(' gulp watch 文件监控打包'); console.log(' gulp help gulp参数说明'); console.log(' gulp server 测试server'); console.log(' gulp -p 生产环境（默认生产环境）'); console.log(' gulp -d 开发环境'); console.log(' gulp -m &lt;module&gt; 部分模块打包（默认全部打包）');&#125;);//stylus css处理gulp.task('stylusTask', function () &#123; var processor = [ autoprefixer, cssnano ]; return gulp.src('src/stylus/*.styl') .pipe(sourcemaps.init()) .pipe(stylus()) .pipe(postcss(processor)) .pipe(concat('built.css')) .pipe(sourcemaps.write('./')) .pipe(gulp.dest('src/css')) .pipe(livereload());&#125;);//打包assetgulp.task('copyAsset', function () &#123; return gulp.src([ './src/asset/**/*' // './src/asset/jquery/**/*' ]) .pipe(gulp.dest('./dist/asset'))&#125;)//打包htmlgulp.task('copyHtml', function () &#123; return gulp.src('./src/*.html') .pipe(htmlmin(&#123; collapseWhitespace:true, collapseBooleanAttributes:true, removeComments:true, removeEmptyAttributes:true, removeScriptTypeAttributes:true, removeStyleLinkTypeAttributes:true, minifyJS:true, minifyCSS:true &#125;)) .pipe(gulp.dest('./dist'))&#125;)//打包cssgulp.task('cssTask', ['stylusTask'], function () &#123; return gulp.src('./src/css/built.css') .pipe(gulp.dest('./dist/css')) .pipe(rename(&#123;suffix:'.min'&#125;)) .pipe(cleanCSS(&#123;compatibility:'ie8'&#125;)) .pipe(gulp.dest('./dist/css'))&#125;)//打包jsgulp.task('jsTask', function () &#123; return gulp.src('./src/js/*.js') .pipe(concat('built.js')) //合并到临时文件夹 .pipe(gulp.dest('./dist/js')) //生成到目标文件夹 .pipe(rename(&#123;suffix:'.min'&#125;)) //重命名 .pipe(uglify()) //压缩 .pipe(gulp.dest('./dist/js'))&#125;)//打包图片gulp.task('copyImages', function () &#123; return gulp.src('./src/images/*') .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: true, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: true //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest('./dist/images'))&#125;)//热加载gulp.task('reload', function () &#123; return gulp.src('src/*.html') .pipe(connect.reload())&#125;);//监听gulp.task('server', function () &#123; connect.server(&#123; root: 'src', livereload: true, port: 5000 &#125;)&#125;);gulp.task('auto', function() &#123; gulp.watch('src/stylus/*.styl', ['stylusTask']); gulp.watch('src/css/*.css', ['reload']) gulp.watch('src/*.html', ['reload']); gulp.watch('src/js/*.js', ['reload']);&#125;);//执行任务gulp.task('default', ['server', 'auto']);gulp.task('product', ['cssTask', 'copyHtml', 'copyImages', 'jsTask', 'copyAsset', 'copyImages'])]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摇头晃脑小哥]]></title>
    <url>%2F2017%2F12%2F23%2FCss3%2F%E6%91%87%E5%A4%B4%E6%99%83%E8%84%91%E5%B0%8F%E5%93%A5%2F</url>
    <content type="text"><![CDATA[因为之前做过一个动画的项目，大量运用animation，keyframe。无意中发现这个小demo，有一些启发。1.包含层不用设置高度123456789101112131415161718&lt;div class=&quot;head&quot;&gt; &lt;div class=&quot;face&quot;&gt;&lt;/div&gt; &lt;/div&gt;.head&#123; position: absolute; top: 20px; left: 50%;&#125;.face&#123; position: absolute; top:75px; left: 50%; margin-left: -60px; width: 120px; height: 170px; border-radius: 30px; background-color: #fff7e5;&#125; 到时高度会被子元素撑起 2.animation 延迟参数之前的项目用的是js的settimeout，做了demo才恍然大悟，有延迟参数呀！ 3.z-index想要设置z-index，就必须要设position：relative, absolute或者fixed都可以。 4.倾斜如果只是简单的倾斜，transform: rotate(Xdeg);就可以做到了，但是有时候还要考虑这个倾斜掉的元素的定位，所以严谨一点的话，还可以设置transform-origin这个属性。最主要就是记住：第一个值是水平（X），第二个值是竖直（Y）；默认的中心是50%，50%，左上角是0，0，右下角是100%，100%。 5.圆角上下两头是半圆、中间是长方形 只要让border-radius的值等于宽度的一半就可以了半圆形 底部两个的圆角border-radius: 0 0 10px 10px下半圆角 border-bottom-left-radius(上下左右) 6.代码优化因为keyframe,animation需要写很多兼容，所以采用stylus，可以节省很多时间]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css3实现网页平滑过渡效果]]></title>
    <url>%2F2017%2F10%2F17%2FCss3%2Fcss3%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E5%B9%B3%E6%BB%91%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[一、如何用纯css判断盒子被选中？用radio二、font-smoothing 功能：css3中用于设置字体的抗锯齿或者说光滑度的属性 语法规则： font-smoothing:subpixel-antialiased | none | antialiased 取值说明 none用于小像素的文本、subpixel-antialiased浏览器默认的、antialiased反锯齿 三、translate3d可以开启GPU硬件加速 四、backface-visibility 功能：定义当元素不面向屏幕时是否可见 语法规则： backface-visibility:visible | hidden 取值说明： visible:背面是可见的 hidden:背面是不可见的 五、图标三角背景制作当画一个大三角形的时候，可以先用css画一个大矩形，再旋转，最后放到合适的地方露出直角，隐藏其他 六、怎么实现动画过渡当写了transform时，动画是一下子变得，没有过渡。要实现过渡，需要在变换的盒子上加上transition 七、怎么实现网页平滑过渡效果12345678910111213141516171819202122232425262728293031323334353637/* 内容 */.st-scroll,.st-panel&#123; width: 100%; height:100%; position: relative; &#125;.st-scroll&#123; left: 0; top: 0; -webkit-transform: translate3d(0,0,0); -moz-transform: translate3d(0,0,0); -o-transform: translate3d(0,0,0); -ms-transform: translate3d(0,0,0); transform: translate3d(0,0,0); -webkit-backface-visibility: hidden; /* 过渡谁就写谁 */ -webkit-transition: all 0.6s ease-in-out; -moz-transition: all 0.6s ease-in-out; -o-transition: all 0.6s ease-in-out; -ms-transition: all 0.6s ease-in-out; transition: all 0.6s ease-in-out;&#125;.st-panel&#123; background: #fff; overflow: hidden;&#125;#st-control-1:checked ~ .st-scroll&#123; -webkit-transform: translateY(0%); -moz-transform: translateY(0%); -o-transform: translateY(0%); -ms-transform: translateY(0%); transform: translateY(0%);&#125; .st-scroll 是全部内容，.st-panel是单个内容。核心思想是，让每个内容100%占据网页，然后通过选择导航栏，让scroll移动（translateY) 八、@font-face实现小icon所有你要出现图标的div，都要加上data-icon的属性。里面的值就是显示的东西。css中用属性选择器进行书写，属性选择器要加[] 12345&lt;div class=&quot;st-desc&quot; data-icon=&quot;C&quot;&gt;&lt;/div&gt;[data-icon]:after&#123; content: attr(data-icon);&#125; @font-face 功能 @font-face 是css3中的一个模块，主要用于将自己定义的Web字体嵌入到网页中 语法规则 123456 @font-face&#123; font-family : &lt;YourWebFontName&gt;; src : &lt;source&gt; [&lt;format&gt;][,&lt;source&gt;[&lt;format&gt;]]*; [font-weight:&lt;weight&gt;]; [font-style:&lt;style&gt;];&#125; 取值说明 source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝对路径； format:此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型： truetype,opentype,truetype-aat,embedded-opentype,svg等； 常用的几种字体格式 TureType(.ttf)格式 OpenType(.otf)格式 Web Open Font Format(.woff)格式 Embedded Open Type(.eot)格式 SVG(.svg)格式 字体下载 网址：http://www.dafont.com/ 网址：http://www.google.com/webfonts 九、transition &amp;&amp; animation 区别transition 必须要事件触发，而animation用不用事件触发都可以]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学会使用box-sizing布局]]></title>
    <url>%2F2017%2F09%2F09%2FCss3%2F%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8box-sizing%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[盒子模型关于CSS重要的一个概念就是CSS盒子模型。它控制着页面这些元素的高度和宽度。盒子模型多少会让人产生一些困惑，尤其当涉及到高度和宽度计算的时候。真正盒子的宽度(在页面呈现出来的宽度)和高度，需要加上一些其它的属性，例如： padding + border + width= 盒子的宽度 padding+ border + height = 盒子的高度 这看起来并不是那么直观，那么我们看一个图： 这意味着，如果我们设置一个宽度为200px，而实际呈现的盒子的宽度可能会大于200px(除非没有左右边框和左右补白)。这可能看起来比较怪，CSS设置的宽度仅仅是内容区的宽度，而非盒子的宽度。同样，高度类似 这导致的直接结果是当我们希望页面呈现的盒子的宽度是200px的时候，我们需要减去它的左右边框和左右补白，然后设置为对应的CSS宽度。例如上图，我们设置希望盒子宽度为200px，则需要先减去左右补白各20px，左右边框各1px，然后设置对应的CSS宽度158px。 幸运的是，我们有更好的方法达到我们想要的目的 box-sizing语法：box-sizing: content-box | border-box | inherit; 与上面不同的是，当你设置box-sizing:border-box以后，这就能达到你想要的目的。例如，上面我们想要一个宽度为200px的盒子，那么我们直接设置宽度为200px。是不是看起来清晰多了。当再设置它的左右边框和左右补白后，它的内容区会自动调整。这可能更直接和一目了然。CSS代码如下： 123456div &#123; box-sizing: border-box; width: 200px; padding: 20px; border: 1px solid #DDD;&#125; 实际上，这更被设计者和开发者推崇 一些开发人员觉得box-sizing使用起来十分方便,所以他们主张通过通用选择器将这个属性应用于每个元素 但这样的观点未免有些偏激,而且还会导致不必要的困难,所以更好的方法是只在实际需要时才使用这个属性 12345*&#123; margin:0; padding:0; box-sizing:border-box;&#125; 写上 box-sizing: border-box; ，设置padding值 也不用担心没有减小宽度值而变形 box-sizing其它的值content-box 描述：在宽度和高度之外绘制元素的内边距和边框。 border-box 描述：为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制 inherit 描述：继承 父元素 box-sizing属性的值浏览器兼容性IE8及以上版本支持该属性，Firefox 需要加上浏览器厂商前缀-moz-，对于低版本的IOS和Android浏览器也需要加上-webkit-。实际上，很多reset.css或者normal.css里都包含如下CSS语句，也是比较赞成的用法： 12345*, *:before, *:after &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; &#125; box-sizing 布局三栏目案例12345678910111213141516171819202122div&#123; height:700px; float:left;&#125;div.left&#123; width:25%; background:red;&#125;div.cent&#123; width:50%; box-sizing:border-box;/*可以改变元素以使其宽度包含填充*/ /* 现在整个元素,包括填充在内,占页面总宽度的50%,所以元素的组合宽度为100%,这全程它们很好地适应于它们的容器.*/ background:yellow; padding:0 20px;/*加了这个会使盒子内容溢出 但是box-sizing很好的自适应了*/&#125;div.right&#123; width:25%; background:blue;&#125;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;cent&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt; 效果]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[商家页面seller.vue]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E5%95%86%E5%AE%B6%E9%A1%B5%E9%9D%A2seller.vue%2F</url>
    <content type="text"><![CDATA[主体结构html代码1234567891011121314151617181920212223&lt;div class=&quot;seller&quot; ref=&quot;seller&quot;&gt; &lt;div class=&quot;seller-content&quot;&gt; &lt;!--overview部分--&gt; &lt;div class=&quot;overview&quot;&gt; &lt;/div&gt; &lt;split&gt;&lt;/split&gt; &lt;!--bulltin部分--&gt; &lt;div class=&quot;bulletin&quot;&gt; &lt;/div&gt; &lt;split&gt;&lt;/split&gt; &lt;!--pics部分--&gt; &lt;div class=&quot;pics&quot;&gt; &lt;/div&gt; &lt;split&gt;&lt;/split&gt; &lt;!--info部分--&gt; &lt;div class=&quot;info&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; seller-contentdiv是能够扩大高度的,能够被内容增加而撑高,而seller div是固定的高度的,从而形成滚动 js代码 1234567891011121314151617181920212223242526272829303132333435363738394041import BScroll from &apos;better-scroll&apos;;import split from &apos;../split/split&apos;;export default &#123; props: &#123; seller: &#123; //app.vue里面router-view会传入一个seller type: Object &#125; &#125;, watch: &#123; //当seller变动的时候会触发 &apos;seller&apos;() &#123; this.$nextTick(() =&gt; &#123; this._initScroll(); this._initPics(); &#125;); &#125; &#125;, mounted() &#123; //在dom被渲染之后触发 this.$nextTick(() =&gt; &#123; this._initScroll(); this._initPics(); &#125;); &#125;, methods: &#123; _initScroll() &#123; if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.seller, &#123; click: true &#125;); &#125; else &#123; this.scroll.refresh(); &#125; &#125;, _initPics() &#123; //详细代码在下面,这里暂时先忽略 &#125; &#125;, components: &#123; split &#125;&#125;; 使用watch方法是为了监听数据seller的变化,因为当打开页面的时候,seller是异步获取的,并不一定是能够马上获取,没有seller的数据,相关dom就无法被渲染,并且bscroll是基于dom执行的,所以需要监听seller的变化然后来重新执行相关的初始化函数 使用mounted方法是为了保证相关dom渲染完成,因为bscroll是基于dom执行的,但是当切换页面的时候,dom会重新渲染,但未必能够马上完成,所以需要在mounted方法里面重新执行相关的初始化函数 关于watch和mounted的使用要基于vue的生命周期来理解vue生命周期 css代码 1234567.seller position: absolute top: 174px //给header留空间 bottom: 0 left: 0 width: 100% overflow: hidden //隐藏多余部分,因为需要滚动 overview部分html部分 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;overview&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;&#123;&#123;seller.name&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;desc border-1px&quot;&gt; &lt;star :size=&quot;36&quot; :score=&quot;seller.score&quot;&gt;&lt;/star&gt; &lt;span class=&quot;text&quot;&gt;(&#123;&#123;seller.ratingCount&#125;&#125;)&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;月售&#123;&#123;seller.sellCount&#125;&#125;单&lt;/span&gt; &lt;/div&gt; &lt;!--列表处理remark内容--&gt; &lt;ul class=&quot;remark&quot;&gt; &lt;!--使用一个block块包裹内容--&gt; &lt;li class=&quot;block&quot;&gt; &lt;!--标题用h2标签--&gt; &lt;h2&gt;起送价&lt;/h2&gt; &lt;!--用content块包裹内容--&gt; &lt;div class=&quot;content&quot;&gt; &lt;!--用span代表特殊字体--&gt; &lt;span class=&quot;stress&quot;&gt;&#123;&#123;seller.minPrice&#125;&#125;&lt;/span&gt;元 &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;block&quot;&gt; &lt;h2&gt;商家配送&lt;/h2&gt; &lt;div class=&quot;content&quot;&gt; &lt;span class=&quot;stress&quot;&gt;&#123;&#123;seller.deliveryPrice&#125;&#125;&lt;/span&gt;元 &lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;block&quot;&gt; &lt;h2&gt;平均配送时间&lt;/h2&gt; &lt;div class=&quot;content&quot;&gt; &lt;span class=&quot;stress&quot;&gt;&#123;&#123;seller.deliveryTime&#125;&#125;&lt;/span&gt;分钟 &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--收藏按钮--&gt; &lt;div class=&quot;favorite&quot; @click=&quot;toggleFavorite&quot;&gt; &lt;span class=&quot;icon-favorite&quot; :class=&quot;&#123;&apos;active&apos;:favorite&#125;&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;&#123;&#123;favoriteText&#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; js部分 1234567891011121314151617181920212223242526272829303132333435import BScroll from &apos;better-scroll&apos;;//引入一个利用html5的localstorage的存储模块import &#123; saveToLocal, loadFromLocal &#125; from &apos;common/js/store&apos;;export default &#123; props: &#123; seller: &#123; type: Object &#125; &#125;, data() &#123; return &#123; favorite: (() =&gt; &#123; //利用localstorage读取这个属性 return loadFromLocal(this.seller.id, &apos;favorite&apos;, false); &#125;)()//vue需要返回的data必须是函数,所以加上() &#125;; &#125;, computed: &#123; favoriteText() &#123; //通过favorite的值来计算favoriteText的值 return this.favorite ? &apos;已收藏&apos; : &apos;收藏&apos;; &#125; &#125;, methods: &#123; toggleFavorite(event) &#123; if (!event._constructed) &#123; return; &#125; //通过取反来设置切换 this.favorite = !this.favorite; //利用localstorage存储这个属性 saveToLocal(this.seller.id, &apos;favorite&apos;, this.favorite); &#125; &#125;&#125;; store.js参考:split,formatDate,store,util组件 css部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061.overviewposition: relative //设置相对布局参考位置padding: 18px.title margin-bottom: 8px line-height: 14px color: rgb(7, 17, 27) font-size: 14px.desc padding-bottom: 18px border-1px(rgba(7, 17, 27, 0.1)) font-size: 0 .star display: inline-block margin-right: 8px vertical-align: top //行内对齐 .text display: inline-block margin-right: 12px line-height: 18px vertical-align: top //行内对齐 font-size: 10px color: rgb(77, 85, 93).remark display: flex //flex布局 padding-top: 18px .block flex: 1 //flex布局等分区域 text-align: center border-right: 1px solid rgba(7, 17, 27, 0.1) &amp;:last-child border: none h2 margin-bottom: 4px line-height: 10px font-size: 10px color: rgb(147, 153, 159) .content //设置该块的公共属性 line-height: 24px font-size: 10px color: rgb(7, 17, 27) .stress //特殊大小再插入class覆盖 font-size: 24px.favorite position: absolute width: 50px //设置一个固定宽度,被text-align使用 right: 11px top: 18px text-align: center .icon-favorite display: block margin-bottom: 4px line-height: 24px font-size: 24px color: #d4d6d9 &amp;.active color: rgb(240, 20, 20) .text line-height: 10px font-size: 10px color: rgb(77, 85, 93) bulletin部分html代码 公告与活动 classMap的原理(classMap使用在之前的header组件使用过Header.vue) seller.supports的结构是这样的 12345678910111213141516171819202122“supports”: [ &#123; &quot;type&quot;: 0, &quot;description&quot;: &quot;在线支付满28减5&quot; &#125;, &#123; &quot;type&quot;: 1, &quot;description&quot;: &quot;VC无限橙果汁全场8折&quot; &#125;, &#123; &quot;type&quot;: 2, &quot;description&quot;: &quot;单人精彩套餐&quot; &#125;, &#123; &quot;type&quot;: 3, &quot;description&quot;: &quot;该商家支持发票,请下单写好发票抬头&quot; &#125;, &#123; &quot;type&quot;: 4, &quot;description&quot;: &quot;已加入“外卖保”计划,食品安全保障&quot; &#125;], classMap是[‘decrease’, ‘discount’, ‘special’, ‘invoice’, ‘guarantee’]这样的,这个顺序是按照设计需要和数据结构排的,例如type为0对应在线支付满28减5 如果要获取对应的class,就可以classMap[seller.supports[index].type],例如seller.supports[0].type就是0,那么就是classMap[0]就是decrease这个class 如果要获取对应的description就可以seller.supports[index].description,例如seller.supports[0].description就直接知道了supports数组的第一个元素的description属性的值了 js代码 123456789101112131415import split from &apos;../split/split&apos;;export default &#123; props: &#123; seller: &#123; type: Object &#125; &#125;, created() &#123; //使用自建的一个classMap数组来对应不同的类别 this.classMap = [&apos;decrease&apos;, &apos;discount&apos;, &apos;special&apos;, &apos;invoice&apos;, &apos;guarantee&apos;]; &#125;, components: &#123; split &#125;&#125;; 使用created方法是为了在加载的时候第一时间完成,因为vue的渲染需要this.classMap属性(created是vue的生命周期的第一个) css代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344@import “../../common/stylus/mixin.styl”.bulletin padding: 18px 18px 0 18px .title margin-bottom: 8px line-height: 14px color: rgb(7, 17, 27) font-size: 14px .content-wrapper padding: 0 12px 16px 12px border-1px(rgba(7, 17, 27, 0.1)) .content line-height: 24px font-size: 12px color: rgb(240, 20, 20) .supports .support-item padding: 16px 12px border-1px(rgba(7, 17, 27, 0.1)) font-size: 0 &amp;:last-child border-none() //需要引入一个mixin,处理没边框的问题 .icon display: inline-block width: 16px height: 16px vertical-align: top margin-right: 6px background-size: 16px 16px background-repeat: no-repeat &amp;.decrease //使用设计要求的大小的图标 bg-image(&apos;decrease_4&apos;) //使用mixin处理这些图标 &amp;.discount bg-image(&apos;discount_4&apos;) &amp;.guarantee bg-image(&apos;guarantee_4&apos;) &amp;.invoice bg-image(&apos;invoice_4&apos;) &amp;.special bg-image(&apos;special_4&apos;) .text line-height: 16px font-size: 12px color: rgb(7, 17, 27) pics部分html代码 商家实景 ref获取picWrapper是为了滚动图片需要,父DOM是picWrapper,子DOM是picList ref获取picList是为了计算图片列表的总长度,用来设置图片列表的横向滚动,因为滚动的触发条件是子DOM比父DOM要”大”的时候才会触发,由于图片的数量是未知的,所以需要去计算,然后写入到picList js代码 _initPics() { //编程习惯的前置下划线,代表内部使用的方法 12345678910111213141516171819if (this.seller.pics) &#123; let picWidth = 120; // let margin = 6; //这是图片列表的总长度 let width = (picWidth + margin) * this.seller.pics.length - margin; //设置图片列表的宽度等于列表的总长度 this.$refs.picList.style.width = width + &apos;px&apos;; //异步绑定滚动 this.$nextTick(() =&gt; &#123; if (!this.picScroll) &#123; this.picScroll = new BScroll(this.$refs.picWrapper, &#123; scrollX: true, //bscroll的横向滚动属性 eventPassthrough: &apos;vertical&apos; //bscroll的过滤垂直滚动 &#125;); &#125; else &#123; this.picScroll.refresh(); &#125; &#125;);&#125; 一般来说,当某页面本身是垂直滚动的时候,中间的某个DOM需要做横向滚动的话,需要处理滚动坐标的变化,例如手势滚动的时候有x,y坐标,是向上,下,左还是右会区分 图片列表的总长度是单个图片的宽度+单个图片的外边距的和乘以图片的数量,再减去最后一个图片的外边距 BScroll插件需要增加一个属性scrollX: true来传入横向的滚动坐标,也需要增加一个属性eventPassthrough: ‘vertical’过滤垂直的滚动,前者已经解释过,后者是因为需要横向滚动的页面是内嵌在垂直滚动的页面的里面的,所以会造成外面的垂直滚动事件也会传入到横向滚动的页面,为了避免影响横向滚动,所以需要屏蔽垂直滚动的事件 我们平时在做这种滚动内嵌滚动的时候也可以参考这个处理方法. 另外异步绑定滚动的常规做法,先判断是否已经有BScroll实例了,然后再确定是否需要刷新 css代码 1234567891011121314151617181920.picspadding: 18px.title margin-bottom: 12px line-height: 14px color: rgb(7, 17, 27) font-size: 14px.pic-wrapper width: 100% //图片列表区域是屏幕宽度 overflow: hidden //隐藏多余部分 white-space: nowrap //连续的空白符会被合并 .pic-list font-size: 0 //行内元素取消间隙 .pic-item display: inline-block margin-right: 6px width: 120px height: 90px &amp;:last-child //最后一个图片没有外边距 margin: 0 info部分html代码 123456&lt;div class=&quot;info&quot;&gt; &lt;h1 class=&quot;title border-1px&quot;&gt;商家信息&lt;/h1&gt; &lt;ul&gt; &lt;li class=&quot;info-item&quot; v-for=&quot;info in seller.infos&quot;&gt;&#123;&#123;info&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css代码 123456789101112131415.infopadding: 18px 18px 0 18pxcolor: rgb(7, 17, 27).title padding-bottom: 12px line-height: 14px border-1px(rgba(7, 17, 27, 0.1)) font-size: 14px.info-item padding: 16px 12px line-height: 16px border-1px(rgba(7, 17, 27, 0.1)) //1像素的border 的mixin font-size: 12px &amp;:last-child border-none() //没有border的mixin]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商品详情页food.vue]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5food.vue%2F</url>
    <content type="text"><![CDATA[主体结构html代码1234567&lt;template&gt; &lt;transition name=&quot;move&quot;&gt; &lt;!--要实现这个商品详情页的内容滚动,所以需要有一个显示标志和一个dom绑定--&gt; &lt;div v-show=&quot;showFlag&quot; class=&quot;food&quot; ref=&quot;food&quot;&gt; &lt;/div&gt; &lt;/transition&gt;&lt;/template&gt; 用ref绑定food的DOM元素,为了被bscroll做滚动处理 用transition包裹了整个food,为了实现这个页面的进入和退出动画 js代码 1234567891011121314151617181920212223242526272829import BScroll from &apos;better-scroll&apos;;export default &#123; props: &#123; food: &#123; type: Object &#125; &#125;, data()&#123; return &#123; showFlag: false &#125; &#125;, methods: &#123; show()&#123; this.showFlag = true; this.$nextTick(() =&gt; &#123; //异步添加滚动绑定 if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.food, &#123; click: true &#125;); &#125; else &#123; this.scroll.refresh(); &#125; &#125;) &#125;, hide()&#123; this.showFlag = false; &#125;&#125; 通过跟hide方法切换showFlag的值来实现显示隐藏 因为整个页面是比较长的,需要做滚动,所以异步加载bscroll css代码 12345678910111213.food position: fixed //霸占屏幕,全屏显示,所以用fixed布局 left: 0 top: 0 bottom: 48px //保留底部购物车底部栏的位置 z-index: 30 //z-index的数值是有考究的,要控制好各个页面的z-index纵深 width: 100% background: #fff transform: translate3d(0, 0, 0) &amp;.move-enter-active, &amp;.move-leave-active //用vue的动画配置实现动画 transition: all 0.2s linear &amp;.move-enter, &amp;.move-leave-active transform: translate3d(100%, 0, 0) 对于整个商品详情页的打开和关闭效果体验,需要对其做动画处理,transition 动画是3d变形,从右往左(改变的是x坐标),直线移动(linear) 商品封面html代码 123456&lt;img :src=&quot;food.image&quot;&gt;&lt;!--有一个返回按钮,绑定一个hide方法--&gt;&lt;div class=&quot;back&quot; @click=&quot;hide&quot;&gt;&lt;!--使用icon--&gt; &lt;i class=&quot;icon-arrow_lift&quot;&gt;&lt;/i&gt; &lt;/div&gt; js代码 1234567export default &#123; props: &#123; food: &#123; //用goods.vue组件传入的food数据 type: Object &#125; &#125;&#125; 在goods.vue组件上传入的food数据 css代码 1234567891011121314151617181920.image-headerposition: relativewidth: 100%height: 0padding-top: 100% //这是一个css-hack技巧img position: absolute top: 0 left: 0 width: 100% //图片撑满整个img的div height: 100%.back position: absolute top: 10px left: 0 .icon-arrow_lift //返回按钮,使用的是icon的那个css display: block padding: 10px font-size: 20px color: #fff 在w3c规定里面,padding设置100%的时候,这个值的计算是相对于这个盒子模型的宽度计算的,然后现在是宽是100%,所以padding也是100%,然后使用的是padding-top,那么就是内上边距的高度就是宽度的值,所以这样就能自然撑开一个正方形,这样的目的在于页面打开的时候更自然,不会出现闪烁 商品标题html代码 月售份好评率% ￥￥ 加入购物车 加入购物车按钮有一个动画fade,并且因为他的位置跟cartcontrol有重叠,避免穿透,所以直接.click.stop.prevent 加入购物车按钮的显示是通过判断food.count实现的,这个属性默认是没有的,当点击购物车按钮的时候强制生成Vue.set(this.food, ‘count’, 1);,这样做的目的是比较直观的增加一个属性去实现功能 cartcontrol的使用跟一般组件使用差不多. js代码 1234567891011121314151617181920212223242526import BScroll from &apos;better-scroll&apos;;import Vue from &apos;vue&apos;;import cartcontrol from &apos;../../components/cartcontrol/cartcontrol&apos;;export default &#123; props: &#123; food: &#123; type: Object &#125; &#125; methods: &#123; addFirst(event)&#123; //点击加入购物车按钮,传入事件 if (!event._constructed) &#123; //因为购物车按钮在bscroll里面,所以需要处理掉bscroll的事件类型 return; &#125; this.$emit(&apos;add&apos;, event.target); //触发当前实例food上的事件add(在goods组件上绑定在food组件的add方法) Vue.set(this.food, &apos;count&apos;, 1); &#125;, addFood(target) &#123; //跟add关联的addFood方法 this.$emit(&apos;add&apos;, target); //触发当前实例food上的事件add(在goods组件上绑定在food组件的add方法) &#125; &#125;, components: &#123; cartcontrol &#125;&#125; 两次触发当前实例的事件add是因为两个操作都是同一个动作,这个动作是绑定在food组件上的add方法,而food组件会在goods组件中被导入,而在goods组件里面,addFood方法就会指向当前goods组件的方法_drop,继而使用shopcart的小球抛物线动画this.$refs.shopcart.drop(target);,这样就是实现了使用跨组件调用方法的效果. css代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.contentposition: relativepadding: 18px.title line-height: 14px margin-bottom: 8px font-size: 14px font-weight: 700 color: rgb(7, 17, 27).detail margin-bottom: 18px line-height: 10px height: 10px font-size: 0 //注意行内元素的空格 .sell-count, .rating font-size: 10px color: rgb(147, 153, 159) .sell-count margin-right: 12px.price //这里的css样式就是在goods.vue出现过的样式,所以直接贴过来使用,也可以做成组件 font-weight: 700 line-height: 24px .now margin-right: 8px font-size: 14px color: rgb(240, 20, 20) .old text-decoration: line-through font-size: 10px color: rgb(147, 153, 159).cartcontrol-wrapper //固定cartcontrol组件的样式 position: absolute right: 12px bottom: 12px.buy //加入购物车按钮的样式 position: absolute right: 18px bottom: 18px z-index: 10 //显示在cartcontrol的更外面 height: 24px line-height: 24px padding: 0 12px box-sizing: border-box //不希望padding和border把整个div撑大 border-radius: 12px font-size: 10px color: #fff background: rgb(0, 160, 220) opacity: 1 //加入动画,一个是为了体验,另外一个是为了延迟触发隐藏,避免小球抛物线动画出现问题 &amp;.fade-enter-active, &amp;.fade-leave-active transition: all 0.2s &amp;.fade-enter, &amp;.fade-leave-active opacity: 0 z-index: -1 这里的z-index是10,因为加入购物车按钮和cartcontrol的按钮重叠了,所以需要设置一个比较靠外的z坐标 这里的box-sizing可以直观的设置盒子模型的实际大小,而不用计算边框和内边距的影响, 这是box-sizing:border-size之后的图,注意这个auto,这是因为盒子的大小被固定了,边框和内边距也是固定的,然后内容会根据被固定的大小进行auto适配,这种从外到内的空间设置比较直观和方便 这里加入动画的原因是当点击加入购物车的按钮时候(addFirst),因为food.count被添加了数据Vue.set(this.food, ‘count’, 1);,所以加入购物车按钮会被隐藏(v-show的display:none),但同时会执行this.$emit(‘add’, event.target);,只不过这个是异步执行的,并且这个被异步执行的方法add是抛物线小球动画计算初始目标高度的地方,所以当传入的购物车按钮被设置为display:none的时候,动画的目标初始高度无法计算,就会去使用父层div的高度,从而影响了抛物线小球动画效果. 设置一个动画延迟隐藏购物车按钮,从而给足够的时间vue将数据传递到异步执行的方法,不影响抛物线小球的动画初始目标计算商品信息 123456789101112131415161718192021222324252627282930&lt;!--引入split组件负责隔离行--&gt; &lt;split v-show=&quot;food.info&quot;&gt;&lt;/split&gt; &lt;div class=&quot;info&quot; v-show=&quot;food.info&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;商品信息&lt;/h1&gt; &lt;p class=&quot;text&quot;&gt;&#123;&#123;food.info&#125;&#125;&lt;/p&gt; &lt;/div&gt; import split from &apos;../../components/split/split&apos;; export default &#123; props: &#123; food: &#123; type: Object &#125; &#125;, components: &#123; split &#125; &#125; .info padding: 18px .title line-height: 14px margin-bottom: 6px font-size: 14px color: rgb(7, 17, 27) .text line-height: 24px padding: 0 8px font-size: 12px color: rgb(77, 85, 93) 商品评价html代码 1234567891011121314151617181920212223242526272829&lt;div class=&quot;rating&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;商品评价&lt;/h1&gt; &lt;!--ratingselect组件--&gt; &lt;ratingselect @select=&quot;selectRating&quot; @toggle=&quot;toggleContent&quot; :selectType=&quot;selectType&quot; :onlyContent=&quot;onlyContent&quot; :desc=&quot;desc&quot; :ratings=&quot;food.ratings&quot;&gt;&lt;/ratingselect&gt; &lt;div class=&quot;rating-wrapper&quot;&gt; &lt;!--根据ratings长度显示ratings--&gt; &lt;ul v-show=&quot;food.ratings &amp;&amp; food.ratings.length&quot;&gt; &lt;!--根据不同类型的rateType来切换不同类型的rate--&gt; &lt;li v-show=&quot;needShow(rating.rateType,rating.text)&quot; v-for=&quot;rating in food.ratings&quot; class=&quot;rating-item border-1px&quot;&gt; &lt;div class=&quot;user&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;rating.username&#125;&#125;&lt;/span&gt; &lt;img class=&quot;avatar&quot; width=&quot;12&quot; height=&quot;12&quot; :src=&quot;rating.avatar&quot;&gt; &lt;/div&gt; &lt;!--使用vue过滤器filter来处理时间--&gt; &lt;div class=&quot;time&quot;&gt;&#123;&#123;rating.rateTime | formatDate&#125;&#125;&lt;/div&gt; &lt;p class=&quot;text&quot;&gt; &lt;!--根据不同类型的rateType来控制icon的显示--&gt; &lt;span :class=&quot;&#123;&apos;icon-thumb_up&apos;:rating.rateType===0,&apos;icon-thumb_down&apos;:rating.rateType===1&#125;&quot;&gt;&lt;/span&gt; &#123;&#123;rating.text&#125;&#125; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!--没有rate的时候显示--&gt; &lt;div class=&quot;no-rating&quot; v-show=&quot;!food.ratings || !food.ratings.length&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 绑定一个ratingselect组件,负责处理rate选择的 然后划分一个rating-wrapper区域,负责显示相关rate的信息 在子组件ratingselect选择的信息会影响到父组件的rating-wrapper区域内容的变化 needShow控制当前rate的内容显示,包括不同的type和是否排除没内容的rate 绑定icon-thumb_up和icon-thumb_down的class来控制赞和批评的icon显示 根据json数据里面的ratings数组来控制是否显示rate js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const ALL = 2; //将控制type类转为常量控制import Vue from &apos;vue&apos;;import ratingselect from &apos;../../components/ratingselect/ratingselect&apos;; //引入ratingselect组件export default &#123; props: &#123; food: &#123; type: Object &#125; &#125;, data()&#123; return &#123; //这些是传入ratingselect组件的数据,并且初始化值 selectType: ALL, //默认所有rate onlyContent: true, //默认只显示有内容的rate desc: &#123; all: &apos;全部&apos;, positive: &apos;推荐&apos;, negative: &apos;吐槽&apos; &#125; &#125; &#125;, methods: &#123; needShow(type, text)&#123; if (this.onlyContent &amp;&amp; !text) &#123; //只显示有内容的 并且 没有内容就返回false return false; &#125; if (this.selectType === ALL) &#123; //显示全部类型的rate return true; &#125; else &#123; //只显示对应的类型的rate return type === this.selectType; &#125; &#125;, selectRating(type) &#123; //设置rate的类型 this.selectType = type; this.$nextTick(() =&gt; &#123;//切换的时候需要重新刷新bscroll this.scroll.refresh(); &#125;); &#125;, toggleContent() &#123; //切换显示是否有内容的rate this.onlyContent = !this.onlyContent; this.$nextTick(() =&gt; &#123; //切换的时候需要重新刷新bscroll this.scroll.refresh(); &#125;); &#125; &#125;, components: &#123; ratingselect &#125;&#125; selectRating和toggleContent使用异步$nextTick是因为vue是异步更新dom的,当改变了vue属性时候,当前的dom不是立即更新的(会导致页面的高度变化了,但是bscroll来不及更新,影响滚动体验),而是会放进去异步更新队列里面等候更新,即使这个队列的等待时间不长,但是也来不及马上更新dom,所以使用$nextTick强制刷新这个队列 在food.vue组件使用selectRating和toggleContent来更新food.vue组件的属性,而不能在子组件ratingselect里面更新,因为vue限制了子组件不能更改父组件的属性,所以通过使用类似this.$emit(‘select’, type);来调用父组件的方法来更改 css代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748.rating padding-top: 18px .title line-height: 14px margin-bottom: 6px font-size: 14px color: rgb(7, 17, 27) .rating-wrapper padding: 0 18px .rating-item position: relative; padding: 16px 0; border-1px(rgba(7, 17, 27, 0.1)) .user position: absolute right: 0 top: 16px line-height: 12px font-size: 0 //注意行内元素的空隙 .name display: inline-block margin-right: 6px vertical-align: top font-size: 10px color: rgb(147, 153, 159) .avatar border-radius: 50% .time margin-bottom: 6px line-height: 12px font-size: 10px color: rgb(147, 153, 159) .text line-height: 16px font-size: 12px color: rgb(7, 17, 27) .icon-thumb_up, .icon-thumb_down margin-right: 4px line-height: 16px font-size: 12px .icon-thumb_up color: rgb(0, 160, 220) .icon-thumb_down color: rgb(147, 153, 159) .no-rating padding: 16px 0 font-size: 12px color: rgb(147, 153, 159) 商品评价里的时间处理split组件和formatDate组件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[split,formatDate,store,util组件]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2Fsplit%2CformatDate%2Cstore%2Cutil%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[split组件(vue)的代码split组件因为常使用,所以单独独立出来,并且结构相当简单.12345678910111213141516&lt;template&gt; &lt;div class=&quot;split&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;;&lt;/script&gt;&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt; .split width: 100% height: 16px border-top: 1px solid rgba(7, 17, 27, 0.1) border-bottom: 1px solid rgba(7, 17, 27, 0.1) background: #f3f5f7&lt;/style&gt; formatDate.js组件 123456789101112&lt;div class=&quot;time&quot;&gt;&#123;&#123;rating.rateTime | formatDate&#125;&#125;&lt;/div&gt;//在es6下,export 函数function的导入需要这样写import &#123; formatDate &#125; from &apos;../../common/js/date&apos;; //导入自定义的date模块//vue里面的filtersfilters: &#123; formatDate(time) &#123; let date = new Date(time); //调用date模块的formatDate函数来解析时间 return formatDate(date, &apos;yyyy-MM-dd hh:mm&apos;); &#125; &#125;, formatDate.js是一个自定义的js组件,不是vue组件,目录位于:src/common/js,这种写法是为了练习js的模块化编程 将单独的一个函数写成一个模块 通过export导出函数 通过import导入函数 1234567891011121314151617181920212223242526272829export function formatDate(date, fmt) &#123; //在es6下导出一个函数//对一个或多个y进行匹配,匹配到就进行年的替换(年有四位,所以需要特殊处理) if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &apos;&apos;).substr(4 - RegExp.$1.length)); &#125; let o = &#123; &apos;M+&apos;: date.getMonth() + 1, //js的月是从0开始算,所以要加1 &apos;d+&apos;: date.getDate(), &apos;h+&apos;: date.getHours(), &apos;m+&apos;: date.getMinutes(), &apos;s+&apos;: date.getSeconds() &#125;; //对月,日,时,分,秒进行匹配替换(这些都是两位,可以一起处理) for (let k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; //匹配到key例如MM let str = o[k] + &apos;&apos;; //然后o[&apos;MM&apos;] 就是date.getMonth() + 1 //如果匹配到的时间是1位数,例如是M,那么就直接使用date.getMonth() + 1的值, //如果是两位数,那么就在前面补0,使用padLeftZero函数 fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)); &#125; &#125; return fmt;&#125;;//先加两个0,然后再根据长度截取(因为最长也就2个0的长度)function padLeftZero(str) &#123; return (&apos;00&apos; + str).substr(str.length);&#125; store.js组件这是一个js模块,负责html5的localstoage存储和读取的,位置: src/common/js/store.js 使用的方法是: 12//在es6下,export 函数function的导入需要这样写 import &#123; saveToLocal, loadFromLocal &#125; from &apos;../../common/js/store&apos;; 代码: 123456789101112131415161718192021222324252627282930313233//存储//传入三个参数,seller的id,要存储的key和valueexport function saveToLocal (id, key, value) &#123;//需要加上window对象来使用localstorage let seller = window.localStorage.__seller__; //使用__只是一种标记写法,标记是自定义的某种编码规范,这里代表这只是seller的数据 if (!seller) &#123; //第一次生成seller的时候初始化 seller = &#123;&#125;; seller[id] = &#123;&#125;; &#125; else &#123; seller = JSON.parse(seller); //json字符串需要解析 if (!seller[id]) &#123; //不同seller的时候初始化 seller[id] = &#123;&#125;; &#125; &#125; seller[id][key] = value; //生成当前的seller对象 //localStorage只能存储字符串,需要转成json字符串 window.localStorage.__seller__ = JSON.stringify(seller);&#125;//读取三个参数,seller的id,之前存储的key,和一个默认值export function loadFromLocal (id, key, def) &#123; let seller = window.localStorage.__seller__; if (!seller) &#123; //读取不到返回默认值 return def; &#125; seller = JSON.parse(seller)[id]; //json解析 if (!seller) &#123; //解析失败返回默认值 return def; &#125; let ret = seller[key]; return ret || def; //解析成功但是没有这个seller的id的也返回默认值&#125; 在node里面,没有默认全局window对象,所以需要指定加上才能使用window的相关方法和属性 seller[id][key] = value; 相当于是某个id的seller的某个属性(key)和值(value)保存为一个对象 关于写入的逻辑:先读取localstorage的已有值,判断是否存在,然后再去解析localstoage的已有值,判断是否等于当前的数据的key值(id),最后再处理最终的值是否存储,这里逻辑需要先判断已有值. 关于读取的逻辑:先读取localstorage判断是否有值,然后再去判断解析localstoage读取得到的值,最后再处理最终得到的值是否正常,按顺序进行逻辑处理util.js组件这个js模块负责获取url的参数,位置:src/common/js/util.js 12345678910111213141516171819202122/** * 解析url参数 * @example ?id=12345&amp;a=b * @return Object &#123;id:12345,a:b&#125; */export function urlParse () &#123; let url = window.location.search; //获取到url的所有参数 let obj = &#123;&#125;; let reg = /[?&amp;][^?&amp;]+=[^?&amp;]+/g; //正则判断获取 let arr = url.match(reg); //正则获取后会保存到一个数组 // [&apos;?id=12345&apos;,&apos;&amp;a=b&apos;] if (arr) &#123; arr.forEach((item) =&gt; &#123; let tempArr = item.substring(1).split(&apos;=&apos;); //将第一位去掉,然后用等号分隔 let key = decodeURIComponent(tempArr[0]); //URI对于utf8格式会转码,所以这里需要解码 let val = decodeURIComponent(tempArr[1]); obj[key] = val; &#125;); &#125; return obj;&#125; 读取url的所有参数,例如http://a.com/?id=12345&amp;a=b的?id=12345&amp;a=b 然后进行正则匹配,/[?&amp;][^?&amp;]+=[&amp;?&amp;]+/g,以?id=12345&amp;a=b为举例: [?&amp;] 先匹配?和&amp;的,url参数都是有这个2个字符作为连接符,就是指匹配? [^?&amp;]+ 然后匹配非?和&amp;的多个,就是指匹配id = 匹配等号 [^?&amp;]+然后匹配非?和&amp;的多个,就是指匹配12345 加起来就是能够匹配?id=12345&amp;a=b 用对象返回,方便处理.]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商品区域goods.vue]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E5%95%86%E5%93%81%E5%8C%BA%E5%9F%9Fgoods.vue%2F</url>
    <content type="text"><![CDATA[2017-09-09技术点: 定义了2个wrapper,分别是menu-wrapper和foods-wrapper,对应当前页面的架构,左右两边的区域 v-if和v-show的选择使用 v-for传递索引 vue传递原生事件$event 使用stylus的mixin处理一些border和img的问题 建立menu区域和foods区域的Y坐标对应关系,实现滚动foods区域会显示相应的menu区域,点击某个menu区域就显示某个固定的foods区域 flex布局的使用,实现foods区域的布局 技巧类:对一些需要js操作的class(但是又没有实际用途的)可以建立一个类似food-list-hook钩子类 font-size为0的技术点,处理行内元素的间隙问题 vue的$nextTick使用 vue的$refs的使用 vue的computed属性使用 vue的class绑定使用 在一些地方里面,使用table的垂直居中会很简单实现垂直居中 better-scroll的使用 html代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div class=&quot;goods&quot;&gt; //第一个区域,menu区域 &lt;div class=&quot;menu-wrapper&quot; ref=&quot;menuWrapper&quot;&gt; &lt;ul&gt; //v-for的使用,class绑定,传递原生事件 &lt;li v-for=&quot;(item,index) in goods&quot; class=&quot;menu-item&quot; :class=&quot;&#123;&apos;current&apos;:currentIndex === index&#125;&quot; @click=&quot;selectMenu(index,$event)&quot;&gt; &lt;span class=&quot;text border-1px&quot;&gt; &lt;!--v-show使用--&gt; &lt;span v-show=&quot;item.type&gt;0&quot; class=&quot;icon&quot; :class=&quot;classMap[item.type]&quot;&gt;&lt;/span&gt;&#123;&#123;item.name&#125;&#125; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; //第二个区域 food区域 //$refs的使用 &lt;div class=&quot;foods-wrapper&quot; ref=&quot;foodsWrapper&quot;&gt; &lt;ul&gt; //hook钩子类的使用(food-list-hook) &lt;li v-for=&quot;item in goods&quot; class=&quot;food-list food-list-hook&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=&quot;food in item.foods&quot; class=&quot;food-item&quot;&gt; &lt;div class=&quot;icon&quot;&gt; &lt;img width=&quot;57&quot; height=&quot;57&quot; :src=&quot;food.icon&quot;&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;h2 class=&quot;name&quot;&gt;&#123;&#123;food.name&#125;&#125;&lt;/h2&gt; &lt;p class=&quot;desc&quot;&gt;&#123;&#123;food.description&#125;&#125;&lt;/p&gt; &lt;div class=&quot;extra&quot;&gt; &lt;span class=&quot;count&quot;&gt;月售&#123;&#123;food.sellCount&#125;&#125;份&lt;/span&gt;&lt;span&gt;好评率&#123;&#123;food.rating&#125;&#125;%&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;price&quot;&gt; &lt;span class=&quot;now&quot;&gt;¥&#123;&#123;food.price&#125;&#125;&lt;/span&gt;&lt;span class=&quot;old&quot; v-show=&quot;food.oldPrice&quot;&gt;¥&#123;&#123;food.price&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; //第三个区域,shopcart区域 &lt;shopcart ref=&quot;shopcart&quot; :selectFoods=&quot;selectFoods&quot; :deliveryPrice=&quot;seller.deliveryPrice&quot; :minPrice=&quot;seller.minPrice&quot;&gt;&lt;/shopcart&gt; //第四个区域,隐藏的食物详情区域 &lt;food @add=&quot;addFood&quot; :food=&quot;selectedFood&quot; ref=&quot;food&quot;&gt;&lt;/food&gt; &lt;/div&gt;&lt;/template&gt; 备注: v-for使用已经很常见了,不过这里需要了解,vue1和2有区别,现在是用vue2,所以index变量传递会变成现在这种模式(item,index) in goods vue传递原生事件使用$event :class=”{‘current’:currentIndex === index}”是vue的绑定class的使用方法,通过绑定一个class变量来直接操作,并且这里的逻辑会跟js代码里面对应 通过currentIndex和index做对比,来确认是否添加current类,他们之间的对比关系也就是menu区域和foods区域的显示区域的对比关系 通过添加current类来实现当前页面的区域的样式变化 currentIndex是一个计算属性,可以随时变化并且直接反应到dom上(看js里面逻辑) v-show和v-if的区别官网已经说过 v-if 是“真正的”条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件不太可能改变，则使用 v-if 较好。 $refs的使用是vue操作dom的一种方式: ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素; 如果用在子组件上，引用就指向组件实例: hook钩子类的使用,需要结合js里面的语法来看,这个类只是用来操作,不会产生dom的渲染,方便js控制清晰. js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;script&gt; import BScroll from &apos;better-scroll&apos;; //导入better-scroll import shopcart from &apos;../../components/shopcart/shopcart&apos;;//导入shopcart购物车组件 import cartcontrol from &apos;../../components/cartcontrol/cartcontrol&apos;; //导入购物组件 import food from &apos;../../components/food/food&apos;; //导入食物详情组件 const ERR_OK = 0; //常量,方便解耦 export default &#123; props: &#123; seller: &#123; type: Object &#125; &#125;, data()&#123; return &#123; goods: [], listHeight: [], //用来储存foods区域的各个区块的高度(clientHeight) scrollY: 0 //用来存储foods区域的滚动的Y坐标 selectedFood: &#123;&#125; //用来存储当前已被选择的food数据,对象保存形式 &#125; &#125;, computed: &#123; currentIndex()&#123; //计算到达哪个区域的区间的时候的对应的索引值 for (let i = 0; i &lt; this.listHeight.length; i++) &#123; let height1 = this.listHeight[i]; //当前menu子块的高度 let height2 = this.listHeight[i + 1]; //下一个menu子块的高度 //滚动到底部的时候,height2为undefined,需要考虑这种情况 //需要确定是在两个menu子块的高度区间 if (!height2 || (this.scrollY &gt;= height1 &amp;&amp; this.scrollY &lt; height2)) &#123; return i; //返回这个menu子块的索引 &#125; &#125; return 0; &#125;, selectFoods() &#123; //自动将所有的goods.food添加一个count属性,方便做数量运算 let foods = []; this.goods.forEach((good) =&gt; &#123; good.foods.forEach((food) =&gt; &#123; if (food.count) &#123; foods.push(food); &#125; &#125;); &#125;); return foods; &#125; &#125;, created()&#123; this.classMap = [&apos;decrease&apos;, &apos;discount&apos;, &apos;special&apos;, &apos;invoice&apos;, &apos;guarantee&apos;]; this.$http.get(&apos;/api/goods&apos;).then((response) =&gt; &#123; response = response.body; if (response.errno === ERR_OK) &#123; this.goods = response.data; this.$nextTick(() =&gt; &#123; //使用$nextTick来等待异步完成之后更新dom this._initScroll(); //绑定滚动dom this._calculateHeight(); //计算foods区域的各个区域的高度 &#125;); &#125; &#125;); &#125;, methods: &#123; selectFood(food, event)&#123; if (!event._constructed) &#123;//忽略掉BScroll的事件 return; &#125; this.selectedFood = food; //写入当前选择的food this.$refs.food.show(); //显示当前选择的food的详情页 &#125;, selectMenu(index, event)&#123; if (!event._constructed) &#123; //忽略掉BScroll的事件 return; &#125; let foodsList = this.$refs.foodsWrapper.getElementsByClassName(&apos;food-list-hook&apos;); let el = foodsList[index]; //类似jump to的功能,通过这个方法,跳转到指定的dom this.foodsScroll.scrollToElement(el, 300); &#125;, addFood(target) &#123; this._drop(target); &#125;, _drop(target) &#123; // 体验优化,异步执行下落动画 this.$nextTick(() =&gt; &#123; this.$refs.shopcart.drop(target); //调用shopcart的下落动画 &#125;); &#125;, _initScroll()&#123; //初始化scroll区域 this.menuScroll = new BScroll(this.$refs.menuWrapper, &#123; click: true //结合BScroll的接口使用,是否将click事件传递,默认被拦截了 &#125;); this.foodsScroll = new BScroll(this.$refs.foodsWrapper, &#123; probeType: 3 //结合BScroll的接口使用,3实时派发scroll事件 &#125;); //结合BScroll的接口使用,监听scroll事件(实时派发的),并获取鼠标坐标 this.foodsScroll.on(&apos;scroll&apos;, (pos) =&gt; &#123; this.scrollY = Math.abs(Math.round(pos.y));//滚动坐标会出现负的,并且是小数,所以需要处理一下 &#125;) &#125;, //计算foods内部块的高度 _calculateHeight()&#123; let foodList = this.$refs.foodsWrapper.getElementsByClassName(&apos;food-list-hook&apos;); //获取每一个food的dom对象 let height = 0; this.listHeight.push(height); //初始化第一个高度为0 for (let i = 0; i &lt; foodList.length; i++) &#123; let item = foodList[i]; //每一个item都是刚才获取的food的每一个dom height += item.clientHeight; //主要是为了获取每一个foods内部块的高度 this.listHeight.push(height); &#125; &#125; &#125;, components: &#123; shopcart, cartcontrol, food &#125; &#125;&lt;/script&gt; 备注: 是通过selectFood方法写入到vue实例里面,然后传给子组件food &lt;shopcart ref=”shopcart” :selectFoods=”selectFoods” 这里selectFoods被自动添加了count属性,是为了让购物车更加简单的计算已选择的food 这里最关键的是menu和food两个区域的对应处理: 在vue实例生命周期的开始created分别加载_initScroll和_calculateHeight 通过_calculateHeight计算foods内部每一个块的高度,组成一个数组listHeight 在_initScroll里面,设置了bscroll插件的一个监听事件scroll,将food区域当前的滚动到的位置的y坐标设置到一个vue实例属性scrollY this.scrollY = Math.abs(Math.round(pos.y)); 通过计算属性currentIndex,获取到food滚动区域对应的menu区域的子块的索引,然后通过设置一个class来做样式切换变化:class=”{‘current’:currentIndex === index},实现联动 另外当点击menu 区域的时候,会触发selectMenu事件,也会根据点击到的menu子块的索引然后去触发food区域滚动到对应的高度区块区间this.foodsScroll.scrollToElement(el, 300); 这样完成整个对应. 抛物线小球动画横跨多个vue组件(也可以说是横跨了多个DOM),整个动画会在关于购物车添加按钮的动画里面说 better-scroll需要安装,npm安装,具体参看better-scroll官网 关于在selectMenu中点击,在pc界面会出现两次事件,在移动端就只出现一次事件的问题: 原因: bsScrooler会监听事件(例如touchmove,click之类),并且阻止默认事件(prevent stop),并且他只会监听移动端的,pc端的没有监听 在pc页面上 bsScroller也派发了一次click事件,原生也派发了一次click事件 //bsScroll的事件,有_constructed: true MouseEvent {isTrusted: false, _constructed: true, screenX: 0, screenY: 0, clientX: 0…} //pc的事件 MouseEvent {isTrusted: true, screenX: -1867, screenY: 520, clientX: 53, clientY: 400…} 解决: 针对bsScroole的事件,有_constructed: true,所以做处理,return掉非bsScroll的事件 css代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt; @import &quot;../../common/stylus/mixin.styl&quot; .goods display: flex position: absolute //根据设计图实现, top: 174px //去掉header和tab的位置 bottom: 46px //预留购物车位置 width: 100% overflow: hidden .menu-wrapper flex: 0 0 80px //flex布局预留空间 width: 80px //兼容android浏览器,不加的话会没办法预留空间 background: #f3f5f7 .menu-item display: table height: 54px width: 56px padding: 0 12px line-height: 14px &amp;.current position: relative z-index: 10 margin-top: -1px background: #ffffff font-weight: 700 .text border-none() .icon display: inline-block vertical-align: top width: 12px height: 12px margin-right: 2px background-size: 12px 12px background-repeat: no-repeat &amp;.decrease bg-image(&apos;decrease_3&apos;) &amp;.discount bg-image(&apos;discount_3&apos;) &amp;.guarantee bg-image(&apos;guarantee_3&apos;) &amp;.invoice bg-image(&apos;invoice_3&apos;) &amp;.special bg-image(&apos;special_3&apos;) .text display: table-cell width: 56px vertical-align: middle //table默认支持垂直居中 border-1px(rgba(7, 17, 27, 0.1)) font-size: 12px .foods-wrapper flex: 1 .title padding-left: 14px height: 26px line-height: 26px border-left: 2px solid #d9dde1 font-size: 12px color: rgb(147, 153, 159) background: #f3f5f7 .food-item display: flex margin: 18px padding-bottom: 18px border-1px: (rgba(7, 17, 27, 0.1)) &amp;:last-child border-none() margin-bottom: 0 .icon flex: 0 0 57px margin-right: 10px .content flex: 1 //flex布局等分剩下空间 .name margin: 2px 0 8px 0 height: 14px line-height: 14px font-size: 14px color: rgb(7, 17, 27) .desc, .extra line-height: 10px font-size: 10px color: rgb(147, 153, 159) .desc margin-bottom: 8px line-height: 12px .extra .count margin-right: 12px .price font-weight: 700 line-height: 24px .now margin-right: 8px font-size: 14px color: rgb(240, 20, 20) .old text-decoration: line-through font-size: 10px color: rgb(240, 20, 20) .cartcontrol-wrapper position: absolute right: 0 bottom: 12px &lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shopcart.vue]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2Fshopcart.vue%2F</url>
    <content type="text"><![CDATA[html代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt;&lt;!--vue的render渲染需要有一个root的根dom层,所以创建一个单独的div来包裹--&gt; &lt;div&gt; &lt;!--这是shopcart的主代码--&gt; &lt;div class=&quot;shopcart&quot;&gt; &lt;!--用toggleList点击显示隐藏购物车列表--&gt; &lt;div class=&quot;content&quot; @click=&quot;toggleList&quot;&gt; &lt;div class=&quot;content-left&quot;&gt; &lt;div class=&quot;logo-wrapper&quot;&gt; &lt;div class=&quot;logo&quot; :class=&quot;&#123;&apos;highlight&apos;:totalCount&gt;0&#125;&quot;&gt; &lt;i class=&quot;icon-shopping_cart&quot; :class=&quot;&#123;&apos;highlight&apos;:totalCount&gt;0&#125;&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;num&quot; v-show=&quot;totalCount&gt;0&quot;&gt;&#123;&#123;totalCount&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;price&quot; :class=&quot;&#123;&apos;highlight&apos;:totalPrice&gt;0&#125;&quot;&gt;￥&#123;&#123;totalPrice&#125;&#125;&lt;/div&gt; &lt;div class=&quot;desc&quot;&gt;另需配送费￥&#123;&#123;deliveryPrice&#125;&#125;元&lt;/div&gt; &lt;/div&gt; &lt;!--支付--&gt; &lt;div class=&quot;content-right&quot; @click.stop.prevent=&quot;pay&quot;&gt; &lt;!--这里class绑定的是一个payClass计算属性--&gt; &lt;div class=&quot;pay&quot; :class=&quot;payClass&quot;&gt; &#123;&#123;payDesc&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--省略了ball-container是动画小球的部分--&gt; &lt;!--shopcart的列表详情部分--&gt; &lt;transition name=&quot;fold&quot;&gt; &lt;div class=&quot;shopcart-list&quot; v-show=&quot;listShow&quot;&gt; &lt;div class=&quot;list-header&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;购物车&lt;/h1&gt; &lt;span class=&quot;empty&quot; @click=&quot;empty&quot;&gt;清空&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;list-content&quot; ref=&quot;listContent&quot;&gt; &lt;ul&gt; &lt;li class=&quot;food&quot; v-for=&quot;food in selectFoods&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;food.name&#125;&#125;&lt;/span&gt; &lt;div class=&quot;price&quot;&gt; &lt;span&gt;￥&#123;&#123;food.price * food.count&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;!--列表里面可以进行操作,所以会复用一个cartcontrol的组件--&gt; &lt;div class=&quot;cartcontrol-wrapper&quot;&gt; &lt;cartcontrol @add=&quot;addFood&quot; :food=&quot;food&quot;&gt;&lt;/cartcontrol&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;!--打开shopcart列表的时候背景需要虚化并且动画--&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div class=&quot;list-mask&quot; @click=&quot;hideList&quot; v-show=&quot;listShow&quot;&gt;&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt; js代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import BScroll from &apos;better-scroll&apos;;import cartcontrol from &apos;../../components/cartcontrol/cartcontrol&apos;;export default&#123; props: &#123; selectFoods: &#123; type: Array, default()&#123; //data必须是一个函数,这是默认值data的写法 return [ &#123;&#125; ]; &#125; &#125;, deliveryPrice: &#123; type: Number, default: 0 &#125;, minPrice: &#123; type: Number, default: 0 &#125; &#125;, data()&#123; return &#123; fold: true //通过这个变量来控制隐藏和显示购物车列表,true代表隐藏,折叠起来 &#125; &#125;, computed: &#123; totalPrice()&#123; //计算总价 let total = 0; this.selectFoods.forEach((food) =&gt; &#123; total += food.price * food.count; //这个count就是在goods组件里面添加的 &#125;) return total; &#125;, totalCount()&#123; //计算总数量 let count = 0; this.selectFoods.forEach((food) =&gt; &#123; count += food.count; &#125;) return count; &#125;, payDesc()&#123; //只是简单的做一些支付显示的计算 if (this.totalPrice === 0) &#123; return `¥$&#123;this.minPrice&#125;元起送`; &#125; else if (this.totalPrice &lt; this.minPrice) &#123; let diff = this.minPrice - this.totalPrice; return `还差¥$&#123;diff&#125;元配送`; &#125; else &#123; return `去结算`; &#125; &#125;, payClass()&#123; if (this.totalPrice &lt; this.minPrice) &#123; return &apos;not-enough&apos;; &#125; else &#123; return &apos;enough&apos;; &#125; &#125;, listShow()&#123; //自动计算购物车列表是否显示和隐藏 if (!this.totalCount) &#123; //自动判断商品数量为空 this.fold = true; //直接隐藏 return false; &#125; let show = !this.fold; //当flod为false的时候显示购物车列表 if (show) &#123; this.$nextTick(() =&gt; &#123; //异步执行滚动列表初始化 if (!this.scroll) &#123; this.scroll = new BScroll(this.$refs.listContent, &#123; click: true &#125;); &#125; else &#123; this.scroll.refresh(); &#125; &#125;); &#125; return show; &#125; &#125;, methods: &#123; toggleList()&#123; if (!this.totalCount) &#123; return; &#125; this.fold = !this.fold; &#125;, empty() &#123; //通过清空数据属性来控制购物车清空 this.selectFoods.forEach((food) =&gt; &#123; food.count = 0; &#125;); &#125;, hideList() &#123; this.fold = true; &#125;, pay() &#123; if (this.totalPrice &lt; this.minPrice) &#123; return; &#125; window.alert(`支付$&#123;this.totalPrice&#125;元`); &#125; &#125;, components: &#123; cartcontrol &#125;&#125; 购物车列表的显示和隐藏(折叠)是通过数据fold来决定的,他是通过计算属性listshow来实现的,这样达到了不用操作dom就可以改变dom行为的效果,vue的数据驱动设计. 清空按钮也是这样实现的,通过批量设置count属性来实现 抛物线小球部分参考:关于购物车添加按钮的动画 因为打开shopcart详情页会出现两个内容: -shopcart-list部分参考:八.shopcart-list购物车详情页 cartcontrol部分参考:cartcontrol.vue购物车操作按钮 又因为这个cartcontrol是有几个地方都需要用到的,所以将其组件化处理css代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990@import &quot;../../common/stylus/mixin.styl&quot; .shopcart position: fixed //这是固定在页面底部的购物车栏目 left: 0 bottom: 0 z-index: 50 width: 100% height: 48px .content display: flex //flex布局 background: #141d27 font-size: 0 .content-left flex: 1 .logo-wrapper display: inline-block position: relative top: -10px //因为要凸出购物车栏目一点点,设计需要 margin: 0 12px padding: 6px width: 56px //因为使用了border-box的关系,可以直接写设计的尺寸 height: 56px box-sizing: border-box //border-box可以省去计算border和内边距 vertical-align: top border-radius: 50% background: #141d27 .logo width: 100% height: 100% border-radius: 50% text-align: center background: #2b343c &amp;.highlight background: rgb(0, 160, 220) .icon-shopping_cart line-height: 44px font-size: 24px color: #80858a &amp;.highlight color: #ffffff .num position: absolute top: 0 right: 0 width: 24px height: 16px line-height: 16px text-align: center border-radius: 16px font-size: 9px color: #ffffff background: rgb(240, 20, 20) box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.4) .price display: inline-block vertical-align: top margin-top: 12px line-height: 24px padding-right: 12px box-sizing: border-box border-right: 1px solid rgba(255, 255, 255, 0.1) font-size: 16px font-weight: 700 color: rgba(255, 255, 255, 0.4) &amp;.highlight color: #ffffff .desc display: inline-block vertical-align: top margin: 12px 0 0 12px line-height: 24px color: rgba(255, 255, 255, 0.4) font-size: 10px .content-right flex: 0 0 105px //flex布局固定右边空间 width: 105px .pay height: 48px line-height: 48px text-align: center font-size: 12px color: rgba(255, 255, 255, 0.4) font-weight: 700 &amp;.not-enough background: #2b333b &amp;.enough background: #00b43c color: #ffffff//省略了小球动画的css 这里主要注意border-box的使用,举例logo-wrapper 宽高都是56px,并且需要实现内边距是6px 不用border-box的话,就要计算图片的区域是多大,然后加上6px内边距等于56px 用了border-box的话,就不需要计算图片区域了,直接写56px,即使加上6px内边距也不撑大56px的区域,只会自动缩小内部图片区]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0组件之间通信]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2FVue2.0%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[123456789101112App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;app&apos;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 一 .我们先来创建中央事件总线，在src/assets/下创建一个eventBus.js,内容如下123import Vue from &apos;Vue&apos;export default new Vue eventBus中我们只创建了一个新的Vue实例，以后它就承担起了组件之间通信的桥梁了，也就是中央事件总线。 二 . 创建一个firstChild组件，引入eventBus这个事件总线，接着添加一个按钮并绑定一个点击事件12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;firstChild&quot;&gt; &lt;h2&gt;firstChild组件&lt;/h2&gt; &lt;button @click=&quot;sendMsg&quot;&gt;向组件传值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import bus from &apos;../assets/eventBus&apos;export default &#123; methods:&#123; sendMsg:function()&#123; bus.$emit(&quot;userDefinedEvent&quot;,&quot;this message is from firstChild&quot;) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 我们在响应点击事件的sendMsg函数中用$emit触发了一个自定义的userDefinedEvent事件，并传递了一个字符串参数 PS:$emit实例方法触发当前实例(这里的当前实例就是bus)上的事件,附加参数都会传给监听器回调。 三 . 我们再创建一个secondChild组件，引入eventBus事件总线，并用一个p标签来显示传递过来的值12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div id=&quot;secondChild&quot;&gt; &lt;h2&gt;secondChild组件&lt;/h2&gt; &lt;p&gt;从firstChild接收的字符串参数：&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import bus from &apos;../assets/eventBus&apos;export default &#123; data()&#123; return&#123; msg:&quot;默认值&quot; &#125; &#125;, mounted()&#123; var self = this bus.$on(&quot;userDefinedEvent&quot;,function(msg)&#123; self.msg = msg &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 我们在mounted中，监听了userDefinedEvent,并把传递过来的字符串参数传递给了$on监听器的回调函数 PS: mounted:是一个Vue生命周期中的钩子函数，简单点说就类似于jquery的ready，Vue会在文档加载完毕后调用mounted函数。 $on:监听当前实例上的自定义事件(此处当前实例为bus)。事件可以由$emit触发，回调函数会接收所有传入事件触发函数($emit)的额外参数。 四 . 在父组件中，注册这两个组件，并添加这两个组件的标签1234567891011121314151617181920App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;firstChild&gt;&lt;/firstChild&gt; &lt;secondChild&gt;&lt;/secondChild&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import firstChild from &apos;./components/firstChild&apos;import secondChild from &apos;./components/secondChild&apos;export default &#123; name: &apos;app&apos;, components:&#123; firstChild, secondChild &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 保存所有修改的文件，然后打开浏览器窗口，内容如下(css请自行处理) 点击向组件传值按钮，我们可以看到传值成功]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue-传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.0子父组件通信]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2FVue2.0%E5%AD%90%E7%88%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[一.父组件向子组件传值 创建子组件，在src/components/文件夹下新建一个Child.vue Child.vue的中创建props，然后创建一个名为message的属性 在App.vue中注册Child组件，并在template中加入child标签，标签中添加message属性并赋值 保存修改的文件，查看浏览器 我们依然可以对message的值进行v-bind动态绑定 父组件向子组件传值成功总结一下： 子组件在props中创建一个属性，用以接收父组件传过来的值 父组件中注册子组件 在子组件标签中添加子组件props中创建的属性 把需要传给子组件的值赋给该属性 二.子组件向父组件传值1.在子组件中创建一个按钮，给按钮绑定一个点击事件 2.在响应该点击事件的函数中使用$emit来触发一个自定义事件，并传递一个参数 3.在父组件中的子标签中监听该自定义事件并添加一个响应该事件的处理方法 4.保存修改的文件，在浏览器中点击按钮 子组件向父组件传值成功总结一下： 子组件中需要以某种方式例如点击事件的方法来触发一个自定义事件 将需要传的值作为$emit的第二个参数，该值将作为实参传给响应自定义事件的方法 在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听 在通信中，无论是子组件向父组件传值还是父组件向子组件传值，他们都有一个共同点就是有中间介质，子向父的介质是自定义事件，父向子的介质是props中的属性。抓准这两点对于父子通信就好理解了]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue-传值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue动画效果配置和弹层css sticky footer]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2Fvue%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%E9%85%8D%E7%BD%AE%E5%92%8C%E5%BC%B9%E5%B1%82css%20sticky%20footer%2F</url>
    <content type="text"><![CDATA[vue动画效果配置有两种方式: 一种是css方式需要注意 4 个(CSS)类名在 enter/leave 的过渡中切换: v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。 v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。 一般的使用方式是:在html里面用transition包裹起来,然后建立一个name,这个name对应css的class名字的前缀,例如这里name是fade,class就是fade前缀命名 html代码 12&lt;transition name=&quot;fade&quot;&gt;&lt;/transition&gt; css代码 12&amp;.fade-enter-active, &amp;.fade-leave-active&amp;.fade-enter, &amp;.fade-leave-active 总的来说:在enter里面会代表状态从没有到有的变化,在leave里面会代表状态从有到没有的变化,在使用的时候可以按照需要使用,需要考虑好动画的变化再开始写代码 一种是js钩子的方式 123456789101112131415161718192021222324252627282930313233343536373839methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 一般的使用方式是 12&lt;transition @before-enter=&quot;beforeDrop&quot; @enter=&quot;dropping&quot; @after-enter=&quot;afterDrop&quot;&gt;&lt;/transition&gt; 通过绑定js方法来实现 总的来说:js钩子会更加细腻,会在变化的过程中也加入一个钩子管理变化,其他跟css方式动画差不多 弹层和css sticky footer原理css sticky footer解释:如果页面内容不够长的时候，页脚块粘贴在视窗底部；如果内容足够长时，页脚块会被内容向下推送。 这里主要使用clearfix这个类的伪类来完成. 原理简述如下: 在IE6, 7下zoom: 1会触发hasLayout，从而使元素闭合内部的浮动。 在标准浏览器下，.clearfix:after这个伪类会在应用到.clearfix的元素后面插入一个clear: both的块级元素，从而达到清除浮动的作用。 在需要清除浮动的时候，只要写一个.clearfix就行了，然后在需要清浮动的元素中 添加clearfix类名就好了 防止Collapsing margins(外边距折叠) 保证跨浏览器的兼容性 相关代码如下: 1234567891011.clearfix:before, clearfix:after &#123; content: &quot;.&quot;; display: block; clear: both; visibility: hidden; line-height: 0; //行高为0 height: 0; //高度为0 font-size:0; //字体大小为0&#125;.clearfix &#123; *zoom:1;&#125; //这是针对于IE6的，因为IE6不支持:after伪类，这个神奇的zoom:1让IE6的元素可以清除浮动来包裹内部元素 备注: zoom: 1 为了兼容 IE6/7,在IE6, 7下zoom: 1会触发hasLayout，从而使元素闭合内部的浮动。 :before 用来防止 top-margin collapse 和保证当 IE6/7 应用 zoom:1 时的是视觉一致性 :after 用来清除浮动 visibility: hidden 可见度设为隐藏。注意它和display:none;是有区别的。visibility:hidden;仍然占据空间，只是看不到而已 clear: both 清除左右两边浮动 display: block需要将元素转为块级元素才可以实现效果,inline-block也可以 content: “.” 内容为“.”就是一个英文的句号而已。也可以不写。 line-height: 0行高为0,设置这些主要是为了避免一些占用位置或者间隔的问题 height: 0高度为0,同上 font-size:0 字体大小为0,同上 另外需要注意的是避免Collapsing margins(外边距压扁)有两种情况会引起 Collapsing margin: 父子元素(不一定是直接父子)之间会发生 margin-top 和 margin-bottom 的折叠 (如果之间没有 border、padding、inlne-content、height、min-height、max-height 分割的话) 邻近元素同时设置margin,前面的margin-bottom 和后面的margin-top融合取最大的 所以这里能够实现避免Collapsing margins是因为 父子的话,给父元素添加.clearfix 紧邻的话,给前一个元素添加.clearfix这样主要利用 :before psudo-element 给元素内部前面添加一个空的元素 display:block 保证它是一个BFC(BFC可以隔断外边距折叠) 课程里面使用因为clearfix是一个比较常用的class,所以在base.styl里面添加,方便其他组件调用 12345678.clearfix display: inline-block &amp;:before, &amp;:after contain: &apos;&apos; height: 0 line-height: 0 clear: both visibility: hidden 这里没有去兼容ie6,7,因为移动端基本不包含这些浏览器使用inline-block是因为做的是行内块处理 在Header.vue里面使用1234&lt;div class=&quot;detail&quot;&gt; &lt;div class=&quot;detail-wrapper clearfix&quot;&gt;&lt;/div&gt; &lt;div class=&quot;detail-close&quot;&gt;&lt;/div&gt;&lt;/div&gt; 先用一个div包裹其需要做css sticky的内容,如detail的div 然后footer是detail-close按钮,而需要显示并且要持续撑开的内容块是detail-wrapper,那么在detail-wrapper上添加一个clearfix 的class,就会在这个元素后面使用after的伪类生成内容,从而不断推开footer]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus相关和1像素边框问题]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2Fstylus%E7%9B%B8%E5%85%B3%E5%92%8C1%E5%83%8F%E7%B4%A0%E8%BE%B9%E6%A1%86%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1像素边框问题1像素边框问题其实就是Dpr的比例问题,例如 Retina屏设置1px边框，实际显示2px,因为Dpr是2,所以会显示为2px目前这里用的是伪元素 + transform 实现:伪元素:总结伪类与伪元素 12::after 在某元素之后插入某些内容::before 在某元素之前插入某些内容 原理是利用 :before 或者 :after 重做 border,并且根据媒体查询设置不同的缩放比例(transform 的 scale)具体操作会在stylus里面实现 stylus相关 使用stylus的写法,通过缩进表示层次与嵌套关系 使用mixins方法来更方便的组件化css,相关写法可以参考:官网的mixins 创建/sell/src/common/stylus这个目录,用来存放stylus相关的文件 12345src/common/stylus├── base.styl├── icon.styl├── index.styl└── mixin.styl 以下分别是四个文件的代码(名字只是为了区分不同的作用): base.styl1234567891011121314151617181920212223&lt;!--这里是对于使用reset.css之后的一些自定义的默认的css初始化--&gt;&lt;!--字体是一些移动端比较流行的字体,所以这里使用--&gt;&lt;!--其他都是为了方便开发,避免css的属性继承影响模块的代码--&gt;body, html line-height: 1 font-weight: 200 &lt;!--设置一些移动端的常用的字体--&gt; font-family: &apos;PingFang SC&apos;, &apos;STHeitiSc-Light&apos;, &apos;Helvetica-Light&apos;, Arial, sans-serif&lt;!--根据媒体查询@media设置不同的缩放比例(transform 的 scale)来修复1像素边框的问题--&gt;@media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &lt;!--使用伪元素::after--&gt; &amp;::after &lt;!--dpr是1.5的时候缩放0.7倍--&gt; -webkit-transform: scaleY(0.7) transform: scaleY(0.7)@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after &lt;!--dpr是2的时候缩放0.5倍--&gt; -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 这里的修复1像素边框问题会拆分为2个部分,一个部分是这里的base.styl里面处理缩放,另外一部分是在mixin.styl里面处理重做border 这里是一个base模块文件,只保留了基本的共用的css,需要结合其他的css文件(stylus)来合并理解 dpr一般是1或者2,1.5只是为了更精细的去适配1和2之间的手机型号 mixin.styl1234567891011121314151617//这里是负责1像素边框问题border-1px($color) //stylus的mixins语法支持传入变量 position: relative //创建相对定位布局,为after和before的border的绝对布局做定位 &amp;::after //使用伪元素::after,在元素之后插入内容 display: block position: absolute left: 0 bottom: 0 width: 100% //需要横向撑开边框宽度 border-top: 1px solid $color //因为是在元素之后插入,所以是用上边框 content: &apos; &apos; //after或者before使用的时候,不传入东西也要填一个空字符串//这里是负责图片的不同dpr下显示高清问题bg-image($url) //这是图片的mixin,也是类似,不过这里是图片根据dpr来进行适配 background-image: url($url + &quot;@2x.png&quot;) @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio: 3) background-image: url($url + &quot;@3x.png&quot;) 这里的border-1px($color) 就是真正处理1像素边框问题的关键,通过伪元素after重做border,并且支持传入颜色变了$color来自定义颜色 这里的bg-image($url) 是负责处理图片在不同dpr下显示的问题,原来跟1像素边框问题差不多,不过这里不需要重做,只是根据不同的media query来调用不同的图片显示,而这些图片是需要放在相对于的文件夹的,在这个项目的话,是放在.vue文件的文件夹下. icon.styl这个其实是用icomoon生成的icon样式文件,通过将小图片转为字体,然后通过css样式调用,这样做的目的可以减少小图片的http请求,也方便管理和使用这些小图片,例如可以直接使用某个图片的class就可以调用该图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!--这个其实就是之前图标字体生成的css文件改过来的--&gt;&lt;!--因为使用webpack打包的关系,需要修改一下url路径,这个按照当前目录查找到文件就可以了--&gt;@font-face font-family: &apos;sell-ico&apos; src: url(&apos;../fonts/sell-ico.eot?gr00o7&apos;) src: url(&apos;../fonts/sell-ico.eot?gr00o7#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;../fonts/sell-ico.ttf?gr00o7&apos;) format(&apos;truetype&apos;), url(&apos;../fonts/sell-ico.woff?gr00o7&apos;) format(&apos;woff&apos;), url(&apos;../fonts/sell-ico.svg?gr00o7#sell-ico&apos;) format(&apos;svg&apos;) font-weight: normal font-style: normal[class^=&quot;icon-&quot;], [class*=&quot; icon-&quot;] /* use !important to prevent issues with browser extensions that change fonts */ font-family: &apos;sell-ico&apos; !important speak: none font-style: normal font-weight: normal font-variant: normal text-transform: none line-height: 1 /* Better Font Rendering =========== */ -webkit-font-smoothing: antialiased -moz-osx-font-smoothing: grayscale.icon-arrow_lift:before content: &quot;\e900&quot;.icon-thumb_up:before content: &quot;\e901&quot;.icon-thumb_down:before content: &quot;\e902&quot;.icon-shopping_cart:before content: &quot;\e903&quot;.icon-favorite:before content: &quot;\e904&quot;.icon-check_circle:before content: &quot;\e905&quot;.icon-close:before content: &quot;\e906&quot;.icon-remove_circle_outline:before content: &quot;\e907&quot;.icon-add_circle:before content: &quot;\e908&quot;.icon-keyboard_arrow_right:before content: &quot;\e909&quot;index.styl使用一个主的styl来包含所有的stylus文件@import &quot;./icon&quot; @import &quot;./mixin&quot;@import &quot;./base&quot;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头部组件header.vue]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E5%A4%B4%E9%83%A8%E7%BB%84%E4%BB%B6header.vue%2F</url>
    <content type="text"><![CDATA[弹层制作 vue动画效果配置和弹层css sticky footer原理 使用css sticky footer技术 vue的v-for遍历 vue的v-show和事件监听 vue动画处理 header和公告栏制作 text-overflow:ellipsis的使用 font-size:0和vertical-align的使用 mixin的运用 stylus相关和1像素边框问题 背景图片的虚化 flex布局的使用 html部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;template&gt; &lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;content-wrapper&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img width=&quot;64&quot; height=&quot;64&quot; :src=&quot;seller.avatar&quot;&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;span class=&quot;brand&quot;&gt;&lt;/span&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;seller.name&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;description&quot;&gt; &#123;&#123;seller.description&#125;&#125; / &#123;&#123;seller.deliveryTime&#125;&#125;分钟送达 &lt;/div&gt; &lt;div v-if=&quot;seller.supports&quot; class=&quot;supports&quot;&gt; &lt;!--只列出第一个support的内容--&gt; &lt;span class=&quot;icon&quot; :class=&quot;classMap[seller.supports[0].type]&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;&#123;&#123;seller.supports[0].description&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-if=&quot;seller.supports&quot; class=&quot;support-count&quot; @click=&quot;showDetail&quot;&gt; &lt;span class=&quot;count&quot;&gt;&#123;&#123;seller.supports.length&#125;&#125;个&lt;/span&gt; &lt;i class=&quot;icon-keyboard_arrow_right&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--绑定showDetail事件--&gt; &lt;div class=&quot;bulletin-wrapper&quot; @click=&quot;showDetail&quot;&gt; &lt;span class=&quot;bulletin-title&quot;&gt;&lt;/span&gt;&lt;span class=&quot;bulletin-text&quot;&gt;&#123;&#123;seller.bulletin&#125;&#125;&lt;/span&gt; &lt;i class=&quot;icon-keyboard_arrow_right&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;background&quot;&gt; &lt;img width=&quot;100%&quot; height=&quot;100%&quot; :src=&quot;seller.avatar&quot;&gt; &lt;/div&gt; &lt;!--这里使用了vue的动画配置transition--&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;detailShow&quot; class=&quot;detail&quot;&gt; &lt;!--使用clearfix这个class来做css sticky footer--&gt; &lt;div class=&quot;detail-wrapper clearfix&quot;&gt; &lt;div class=&quot;detail-main&quot;&gt; &lt;h1 class=&quot;name&quot;&gt;&#123;&#123;seller.name&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;star-wrapper&quot;&gt; &lt;!--这里传值给star组件--&gt; &lt;star :size=&quot;48&quot; :score=&quot;seller.score&quot;&gt;&lt;/star&gt; &lt;/div&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;text&quot;&gt;优惠信息&lt;/div&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--列出全部的support的内容--&gt; &lt;ul v-if=&quot;seller.supports&quot; class=&quot;supports&quot;&gt; &lt;li class=&quot;support-item&quot; v-for=&quot;(item,index) in seller.supports&quot;&gt; &lt;span class=&quot;icon&quot; :class=&quot;classMap[seller.supports[index].type]&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;&#123;&#123;seller.supports[index].description&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;text&quot;&gt;商家公告&lt;/div&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bulletin&quot;&gt; &lt;p class=&quot;content&quot;&gt;&#123;&#123;seller.bulletin&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--绑定hideDetail事件--&gt; &lt;div class=&quot;detail-close&quot; @click=&quot;hideDetail&quot;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt; js部分 星星组件参看:star.vue 123456789101112131415161718192021222324252627&lt;script&gt; import star from &apos;../star/star.vue&apos;; //导入星星组件 export default&#123; props: &#123; seller: &#123; //将seller对象传给组件 type: Object //这是vue的prop验证属性的写法 &#125; &#125;, data()&#123; return &#123; //设置一个变量来控制显示隐藏,vue直接会关联到dom detailShow: false &#125; &#125;, methods: &#123; showDetail()&#123; this.detailShow = true; //变量控制显示公告详情页 &#125; &#125;, created()&#123; //主要看这个classMap this.classMap = [&apos;decrease&apos;, &apos;discount&apos;, &apos;special&apos;, &apos;invoice&apos;, &apos;guarantee&apos;]; &#125;, components: &#123; &apos;star&apos;: star &#125; &#125;&lt;/script&gt; 这里需要注意的是: 使用一个classMap的映射方法来实现数字和类型之间的转换 元数据supports是一个数组: 12345678910111213141516171819202122&quot;supports&quot;: [ &#123; &quot;type&quot;: 0, &quot;description&quot;: &quot;在线支付满28减5&quot; &#125;, &#123; &quot;type&quot;: 1, &quot;description&quot;: &quot;VC无限橙果汁全场8折&quot; &#125;, &#123; &quot;type&quot;: 2, &quot;description&quot;: &quot;单人精彩套餐&quot; &#125;, &#123; &quot;type&quot;: 3, &quot;description&quot;: &quot;该商家支持发票,请下单写好发票抬头&quot; &#125;, &#123; &quot;type&quot;: 4, &quot;description&quot;: &quot;已加入“外卖保”计划,食品安全保障&quot; &#125; ], 然后页面需要根据不同的type来显示不同的description,并且还要显示不同的图片 这就需要做一个关联,将数组的值跟图片关联起来,而图片的关联是根据class来识别的,从而可以实现数组的方式来调用对应的图片. 1234567891011&lt;!--这是css里面的--&gt;&amp;.decrease bg-image(&apos;decrease_1&apos;)&amp;.discount bg-image(&apos;discount_1&apos;)&amp;.guarantee bg-image(&apos;guarantee_1&apos;)&amp;.invoice bg-image(&apos;invoice_1&apos;)&amp;.special bg-image(&apos;special_1&apos;) 通过做一个对应关系 1234this.classMap = [&apos;decrease&apos;, &apos;discount&apos;, &apos;special&apos;, &apos;invoice&apos;, &apos;guarantee&apos;];//classMap数组的顺序就对应supports数组的顺序//例如supports数组的第一个元素就对应decrease,而decrease又对应到.decrease的classclassMap[seller.supports[0].type] //seller.supports[0].type就是0,然后classMap的第0个就是decrease,就能够指向到.decrease 这里只需要用数组第一个元素即可 1234&lt;div v-if=&quot;seller.supports&quot; class=&quot;supports&quot;&gt; &lt;span class=&quot;icon&quot; :class=&quot;classMap[seller.supports[0].type]&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;&#123;&#123;seller.supports[0].description&#125;&#125;&lt;/span&gt;&lt;/div&gt; 这里是用到全部的元素 123456&lt;ul v-if=&quot;seller.supports&quot; class=&quot;supports&quot;&gt; &lt;li class=&quot;support-item&quot; v-for=&quot;(item,index) in seller.supports&quot;&gt; &lt;span class=&quot;icon&quot; :class=&quot;classMap[seller.supports[index].type]&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;&#123;&#123;seller.supports[index].description&#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; css部分 考虑到行内元素的不一致的对齐,需要大量使用line-height和vertical-align font-size为0,为了去掉行内元素的间隙,这个可以继承,所以需要在子孙元素里面再单独设置font-size 对于text-overflow:ellipsis的长度取决于块的长度 用合并代替换行来取消多余字符,这种情况也是可以避免设置font-size为0 使用vertical-align :top之后还需要margin-top :7px,在没办法完全对齐的情况下使用 clearfix的css sticky footer部分需要参看:vue动画效果配置和弹层css sticky footer原理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt; @import &quot;../../common/stylus/mixin.styl&quot; //导入minxin .header position relative //这里的相对定位是为了让下面的绝对定位做参考 overflow: hidden color: #ffffff background: rgba(7, 17, 27, 0.5) .content-wrapper padding: 24px 12px 18px 24px font-size: 0 //这里为0是为了去掉行内元素的间隙,这个可以继承,所以需要在子孙元素里面再单独设置font-size position: relative //这里的相对定位是为了让下面的绝对定位做参考 .avatar display: inline-block vertical-align: top img border-radius: 2px .content display: inline-block margin-left: 16px .title margin: 2px 0 8px 0 .brand display: inline-block vertical-align: top width: 30px height: 18px bg-image(&apos;brand&apos;) //这里使用了一个图片的mixin background-size: 30px 18px background-repeat: no-repeat .name margin-left: 6px font-size: 16px line-height: 18px font-weight: bold .description margin-bottom: 10px line-height: 12px font-size: 12px .supports .icon display: inline-block vertical-align: top width: 12px height: 12px margin-right: 4px background-size: 12px 12px background-repeat: no-repeat &amp;.decrease //这里就是配合classMap进行图片切换的 bg-image(&apos;decrease_1&apos;) //这是图片的mixin,在mixin.styl里面可以看到 &amp;.discount bg-image(&apos;discount_1&apos;) &amp;.guarantee bg-image(&apos;guarantee_1&apos;) &amp;.invoice bg-image(&apos;invoice_1&apos;) &amp;.special bg-image(&apos;special_1&apos;) .text line-height: 12px font-size: 10px .support-count position: absolute right: 12px bottom: 14px padding: 0 8px height: 24px line-height: 24px border-radius: 14px background: rgba(0, 0, 0, 0.2) text-align: center .count vertical-align: top //考虑到行内元素的不一致的对齐,需要大量使用line-height和vertical-align font-size: 10px .icon-keyboard_arrow_right margin-left: 2px line-height: 24px font-size: 10px .bulletin-wrapper position: relative //做相对定位,给icon-keyboard_arrow_right绝对定位做参照 height: 28px line-height: 28px padding: 0 22px 0 12px white-space: nowrap overflow: hidden text-overflow: ellipsis //这里是字数太长的省略处理 background: rgba(7, 17, 27, 0.2) .bulletin-title display: inline-block vertical-align: top margin-top: 8px width: 22px height: 12px bg-image(&apos;bulletin&apos;) background-size: 22px .bulletin-text vertical-align: top margin: 0 4px font-size: 10px font-weight: 200 .icon-keyboard_arrow_right position: absolute font-size: 10px right: 12px top: 8px .background //这里使用的是图片做背景,所以需要做下面这些处理 position absolute //背景图片需要绝对定位 top: 0 //设置位置 left: 0 width: 100% //设置大小 height: 100% z-index: -1 //将背景图片设置里层,避免突出位置看到外露部分 filter: blur(10px) //背景图片虚化 .detail position: fixed //弹出层,所以用fixed z-index: 100 //需要设置z-index保持一定的高度 top: 0 left: 0 width: 100% height: 100% overflow: auto //加overflow hidden来把多余的背景阴影去掉 opacity: 1 //这是动画设置 background: rgba(7, 17, 27, 0.8) &amp;.fade-enter-active, &amp;.fade-leave-active //vue的动画需要参考vue动画配置理解 transition: all 0.5s &amp;.fade-enter, &amp;.fade-leave-active opacity: 0 background: rgba(7, 17, 27, 0) .detail-wrapper width: 100% min-height: 100% //因为不知道有多少内容,所以用min-height .detail-main margin-top: 64px padding-bottom: 64px //预留下面close按钮的位置,所以下内边距顶起 .name line-height: 16px text-align: center font-size: 16px font-weight: 700 .star-wrapper margin-top: 18px padding: 2px 0 text-align center .title display: flex //使用flex布局等分详情页优惠界面 width: 80% margin: 28px auto 24px auto .line flex: 1 //使用1的比例的flex块 position: relative //这里使用相对布局加top对齐,可以也可以margin-bottom top: -6px border-bottom: 1px solid rgba(255, 255, 255, 0.2) //使用border生成线,因为使用的是div .text padding: 0 12px font-size: 14px font-weight 700 .supports width: 80% margin: 0 auto .support-item padding: 0 12px margin-bottom: 12px font-size: 0 &amp;:last-child margin-bottom: 0 .icon display: inline-block width: 16px height: 16px vertical-align: top margin-right: 6px background-size: 16px 16px background-repeat: no-repeat //通过对应不同的class来对应不同的图片 &amp;.decrease bg-image(&apos;decrease_2&apos;) &amp;.discount bg-image(&apos;discount_2&apos;) &amp;.guarantee bg-image(&apos;guarantee_2&apos;) &amp;.invoice bg-image(&apos;invoice_2&apos;) &amp;.special bg-image(&apos;special_2&apos;) .text line-height: 16px font-size: 12px .bulletin width: 80% margin: 0 auto .content padding: 0 12px line-height: 24px font-size: 12px .detail-close position: relative width: 32px height: 32px margin: -64px auto 0 auto //使用之前预留了的位置 clear: both font-size: 32px&lt;/style&gt; 备注: text-overflow :ellipsis显示在底部.不是中间,是浏览器的显示处理不同关于文字内容溢出用点点点-省略号表示]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的v-if与v-show]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue%E7%9A%84v-if%E4%B8%8Ev-show%2F</url>
    <content type="text"><![CDATA[1.共同点都是动态显示DOM元素2.区别（1）手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；（2）编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换； （3）编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留； （4）性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗； （5）使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。 Tips：（1）如果v-show作用的元素，css文件中display:none，通过v-show进行设置不能显示该元素；原因：v-show控制显隐，是通过js代码去修改元素的element style，如果value为false，设置display: none;如果value为true，设置display: ‘’；于是value为true时，只能将element style中的display效果清除，并不能覆盖css中的display效果； 如下图所示，value=true时，v-show改变的是element.style，由于无效，显示效果由css文件中的display决定。 解决办法：使用v-show的话，在vue解析之前隐藏DOM的话，尽量在style属性里面设置display的值，不要在css文件中。 1&lt;ul v-touch:tap=&quot;message=2&quot; style=&quot;display: none&quot; v-show=&quot;show&quot;&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shopcart-list购物车列表页]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2Fshopcart-list%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%88%97%E8%A1%A8%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[需要使用better-scroll进行列表内容滚动绑定 使用vue2的transition动画过渡处理动画 使用子组件cartcontrol处理购物车的添加删除操作cartcontrol.vue购物车操作按钮 1234567&lt;!--transition是vue2的动画格式--&gt;&lt;transition name=&quot;fold&quot;&gt; &lt;div class=&quot;shopcart-list&quot; v-show=&quot;listShow&quot;&gt; &lt;div class=&quot;list-header&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list-content&quot; ref=&quot;listContent&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/transition&gt; 购物车详情内容shopcart-list一共有两块,list-header,list-content,这是根据设计稿内容确定的 list-header绑定清空按钮 12345&lt;div class=&quot;list-header&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;购物车&lt;/h1&gt; &lt;!--绑定empty方法清空购物车内容--&gt; &lt;span class=&quot;empty&quot; @click=&quot;empty&quot;&gt;清空&lt;/span&gt;&lt;/div&gt; 通过设置selectFoods里面所有数据的count为0来实现清空的目的 12345empty() &#123; //清空购物车内容 this.selectFoods.forEach((food) =&gt; &#123; food.count = 0; &#125;);&#125;, list-content这里也分开两部分来说: 第一部分: 使用ref来绑定一个dom,然后被vue使用,ref=”listContent”,这是为了将list-content的dom被使用,然后实例化better-scroll实现滚动list的效果 购物车的清单是通过遍历selectFoods数组(通过父组件goods处理并传入goods.vue)得到的,v-for=”food in selectFoods” shopcart-list本身也有一个渐入渐出的动画 list-content本身没有高度,是靠header和content撑开 第二部分: 复用子组件cartcontrol,因为这个子组件在购物车内容和购物车详情页的列表里都有使用,所以单独独立出来,复用代码 子组件cartcontrol会有2个动画,一个动画是他自己本身的水平滚动,一个是动画是要跟shopcart关联的抛物线滚动cartcontrol.vue购物车操作按钮 代码部分:html代码 12345678910111213141516&lt;!--ref是用来给better-scroll绑定的dom--&gt;&lt;div class=&quot;list-content&quot; ref=&quot;listContent&quot;&gt; &lt;ul&gt; &lt;!--遍历selectFoods获得被勾选的所有数据--&gt; &lt;li class=&quot;food&quot; v-for=&quot;food in selectFoods&quot;&gt; &lt;span class=&quot;name&quot;&gt;&#123;&#123;food.name&#125;&#125;&lt;/span&gt; &lt;div class=&quot;price&quot;&gt; &lt;span&gt;￥&#123;&#123;food.price * food.count&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;!--购物车详情列表里面的购物车按钮组件cartcontrol--&gt; &lt;div class=&quot;cartcontrol-wrapper&quot;&gt; &lt;cartcontrol @add=&quot;addFood&quot; :food=&quot;food&quot;&gt;&lt;/cartcontrol&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import BScroll from &apos;better-scroll&apos;; //导入better-scrollimport cartcontrol from &apos;../../components/cartcontrol/cartcontrol&apos;; //导入cartcontrol组件export default&#123; //导出到当前vue文件内使用 props: &#123; //父组件goods传入数据 selectFoods: &#123; //被勾选的所有foods的数据 type: Array, //默认值类型 default()&#123; //默认值,并且vue的data数据是一个函数写法实现的 return [ &#123;&#125; ]; &#125; &#125;, &#125;, data()&#123; return &#123; fold: true // 控制购物车折叠效果的标志,默认是true代表折叠 &#125; &#125;, computed: &#123; totalCount()&#123; //在这里被用来判断购物车是否有东西 let count = 0; this.selectFoods.forEach((food) =&gt; &#123; count += food.count; &#125;) return count; &#125;, listShow()&#123; //购物车是否展示内部列表处理 if (!this.totalCount) &#123; //判断没有数量的情况 this.fold = true; //折叠属性设置为true,即折叠起来,主要是更新fold的状态 return false; //返回false是给v-show使用,false会display none &#125; let show = !this.fold; //使用fold的状态取反来实现常用的切换状态处理逻辑 if (show) &#123; //展示购物车列表内容 this.$nextTick(() =&gt; &#123; //异步处理,提高体验,防止卡顿 if (!this.scroll) &#123; //如果没有绑定过better-scroll就绑定一个 //用$refs来绑定vue的dom元素 this.scroll = new BScroll(this.$refs.listContent, &#123; click: true //让better-scroll将click事件也传递 &#125;); &#125; else &#123; //使用better-scroll的内置事件refresh直接更新绑定,不用重新实例化一次better-scroll this.scroll.refresh(); &#125; &#125;); &#125; return show; //返回布尔值给v-show使用 &#125; &#125;, methods: &#123; toggleList()&#123; //封装一个方法来控制购物车列表的显示 if (!this.totalCount) &#123; return; &#125; this.fold = !this.fold; //切换状态的处理 &#125;, &#125;, components: &#123; cartcontrol //注册cartcontrol组件,以便当前vue文件能够调用 &#125; css代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@import &quot;../../common/stylus/mixin.styl&quot; .shopcart-list position: absolute //因为需要固定在app主界面的底部(非footer) left: 0 top: 0 z-index: -1 //因为要避免遮挡footer的图标 width: 100% transform: translate3d(0, -100%, 0) //设置css方式的vue动画初始值,纵坐标的-100%是指相反方向的当前元素的100%高度,这是&quot;入&quot; &amp;.fold-enter-active, &amp;.fold-leave-active //shopcart-list的渐入渐出动画,这是&quot;渐&quot; transition: all 0.5s //全部元素0.5秒过渡变化 &amp;.fold-enter, &amp;.fold-leave-active // 这是&quot;出&quot; transform: translate3d(0, 0, 0) //3d变形 .list-header height: 40px line-height: 40px padding: 0 18px background: #f3f5f7 border-bottom: 1px solid rgba(7, 17, 27, 0.1) .title float: left font-size: 14px color: rgb(7, 17, 27) .empty float: right font-size: 12px color: rgb(0, 160, 220) .list-content padding: 0 18px max-height: 217px //因为不固定高度,所以用max-height overflow: hidden //要实现滚动,就要隐藏超出部分 background: #fff .food position: relative padding: 12px 0 box-sizing: border-box border-1px(rgba(7, 17, 27, 0.1))//要处理1px边框问题,引入mixin.styl .name line-height: 24px font-size: 14px color: rgb(7, 17, 27) .price position: absolute right: 90px bottom: 12px line-height: 24px font-size: 14px font-weight: 700 color: rgb(240, 20, 20) .cartcontrol-wrapper position: absolute right: 0 bottom: 6px 购物车遮罩list-mask1234567&lt;!--购物车详情页的遮罩并且动画处理--&gt;&lt;transition name=&quot;fade&quot;&gt; &lt;div class=&quot;list-mask&quot; @click=&quot;hideList&quot; v-show=&quot;listShow&quot;&gt;&lt;/div&gt;&lt;/transition&gt;hideList() &#123; //遮罩隐藏 this.fold = true; &#125;, 遮罩的动画是普通的渐隐渐现,使用css3实现 只需要操作数据属性就能够实现 遮罩的层级是跟shopcart-list同级的,是因为同一层 遮罩触发会放到shopcart组件的content元素,使用的方法是toggleList 123456789101112131415.list-mask //遮罩的样式 position: fixed top: 0 left: 0 width: 100% height: 100% z-index: 40 backdrop-filter: blur(10px) //遮罩虚化 opacity: 1 background: rgba(7, 17, 27, 0.6) &amp;.fade-enter-active, &amp;.fade-leave-active //遮罩动画 transition: all 0.5s &amp;.fade-enter, &amp;.fade-leave-active opacity: 0 background: rgba(7, 17, 27, 0)]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[星星组件star.vue]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E6%98%9F%E6%98%9F%E7%BB%84%E4%BB%B6star.vue%2F</url>
    <content type="text"><![CDATA[整个流程是: 绑定星星类型的class(48,36,24尺寸),使用starType 使用class来显示星星,有3种类型,全星,半星,无星,使用star-item代表星星本身,然后分别使用on,off,half代表三种不同类型的星星 一个span代表一个星星项目,并且使用v-for循环将星星项目输出 组合出来的星星html就类似这样 1234567&lt;div class=&quot;star star-48&quot;&gt;&lt;span class=&quot;star-item on&quot;&gt;&lt;/span&gt;&lt;span class=&quot;star-item on&quot;&gt;&lt;/span&gt;&lt;span class=&quot;star-item on&quot;&gt;&lt;/span&gt;&lt;span class=&quot;star-item on&quot;&gt;&lt;/span&gt;&lt;span class=&quot;star-item half&quot;&gt;&lt;/span&gt;&lt;/div&gt; html部分 12345&lt;template&gt; &lt;div class=&quot;star&quot; :class=&quot;starType&quot;&gt; &lt;span v-for=&quot;itemClass in itemClasses&quot; :class=&quot;itemClass&quot; class=&quot;star-item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; js部分 设置常量是为了方便解耦 星星计算比较巧妙(根据分数转换为星星数) 对于分数score进行2然后向下取整,然后再除以2,是为了获取所有星星的数量,并且这个数量是0.5倍数的,例如4.6 2就是9.2,然后向下取整是9,然后再除以2就是4.5,那么就可以得到一个0.5倍数的星星数,可以转换为4个全星+一个半星 对于非整数的星星算作是半个星星,需要知道是否有存在这种情况,所以分数score%1 ,例如8 % 1是0, 8.5 % 1就不是0,并且这个半星只会出现一次,因为半星状态就只要一个 没有星星的部分是要补全的,这里使用while循环来处理这种情况 123456789101112131415161718192021222324252627282930313233343536373839&lt;script&gt; //设置常量 const LENGTH = 5; const CLS_ON = &apos;on&apos;; const CLS_HALF = &apos;half&apos;; const CLS_OFF = &apos;off&apos;; export default&#123; props: &#123; size: &#123; //传入的size变量 type: Number //设置变量类型 &#125;, score: &#123; //传入的score变量 type: Number &#125; &#125;, computed: &#123; starType()&#123; //通过计算属性,返回组装过的类型,用来对应class类型 return &apos;star-&apos; + this.size; &#125;, itemClasses()&#123; let result = []; //返回的是一个数组,用来遍历输出星星 let score = Math.floor(this.score * 2) / 2; //计算所有星星的数量 let hasDecimal = score % 1 !== 0; //非整数星星判断 let integer = Math.floor(score); //整数星星判断 for (let i = 0; i &lt; integer; i++) &#123; //整数星星使用on result.push(CLS_ON);//一个整数星星就push一个CLS_ON到数组 &#125; if (hasDecimal) &#123; //非整数星星使用half result.push(CLS_HALF);//类似 &#125; while (result.length &lt; LENGTH) &#123; //余下的用无星星补全,使用off result.push(CLS_OFF);//类似 &#125; return result; &#125; &#125; &#125;&lt;/script&gt; css部分 引入mixin.styl是为了使用bg-image的mixin,因为之前做了一个mixin是专门处理2x和3x图片的转换 因为这里有3种类型的星星图片,分别是48尺寸,36尺寸,24尺寸,所以对于每一个类别的图片分别使用一种class做对应 每一种星星的尺寸都是有一种相对应的图片的,例如48尺寸的星星就会有,并且图片放在相对应的vue文件目录下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556star48_half@2x.pngstar48_half@3x.pngstar48_off@2x.pngstar48_off@3x.pngstar48_on@2x.pngstar48_on@3x.png&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt; @import &quot;../../common/stylus/mixin.styl&quot; //引入mixin文件 .star .star-item display: inline-block background-repeat: no-repeat &amp;.star-48 //48尺寸的星星 .star-item //每一个星星的基本css信息 width: 20px height: 20px margin-right: 22px //每一个星星dom都有外边距 background-size: 20px 20px &amp;:last-child //最后一个的外边距就是0 margin-right: 0 &amp;.on //全星状态的class bg-image(&apos;star48_on&apos;) &amp;.half //半星状态的class bg-image(&apos;star48_half&apos;) &amp;.off //无星状态的class bg-image(&apos;star48_off&apos;) &amp;.star-36 .star-item width: 15px height: 15px margin-right: 6px background-size: 15px 15px &amp;:last-child margin-right: 0 &amp;.on bg-image(&apos;star36_on&apos;) &amp;.half bg-image(&apos;star36_half&apos;) &amp;.off bg-image(&apos;star36_off&apos;) &amp;.star-24 .star-item width: 10px height: 10px margin-right: 3px background-size: 10px 10px &amp;:last-child margin-right: 0 &amp;.on bg-image(&apos;star24_on&apos;) &amp;.half bg-image(&apos;star24_half&apos;) &amp;.off bg-image(&apos;star24_off&apos;)&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cartcontrol.vue购物车操作按钮]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2Fcartcontrol.vue%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%93%8D%E4%BD%9C%E6%8C%89%E9%92%AE%2F</url>
    <content type="text"><![CDATA[html代码知识点: 使用了vue2的动画实现方式-transition,这里主要在css上设计来配合vue2 cartcontrol这个模块主要通过三个小模块实现,删除按钮,显示数量块,增加按钮 删除按钮和增加按钮都带有一个click方法,并且都有v-show来根据food的数量来控制显示,而显示数量块就只是单纯显示food的数量 js代码知识点: 引入vue模块,因为需要使用Vue.set方法 接收来自goods.vue的food数据,然后使用 有2个方法,一个是addCart,一个是decreaseCart,分别对应html代码中的@click addCart方法,默认会传入event原生dom事件 鉴于bsscrol插件的原因,需要return掉非bscrol的事件 需要注意的是这里的food并没有count属性,所需要手动设置,虽然之前goods会将有count属性的food做自动处理,但是最开始的时候,所有food都没有count属性,并且cartcontrol是最开始触发对food的count属性进行添加的(点击一次就会对count++,增加一个food) food数据是从父组件goods.vue传入的,所以对这个数据的修改,也能够反应到父组件,而这里使用Vue.set直接对vue的data进行对象数据写入,对food数据添加了一个count的属性,用来控制每一个food的被选中的数量,也因为shopcart.vue的数据也是从父组件goods.vue传入的,使用同一个food数据,从而关联到shopcart.vue购物车的food的购买数量统计 decreaseCart方法,同上 1234567891011121314151617181920212223242526272829303132&lt;script&gt; import Vue from &apos;vue&apos;; export default&#123; props: &#123; food: &#123; type: Object &#125; &#125;, methods: &#123; addCart(event)&#123; if (!event._constructed) &#123; return false; &#125; if (!this.food.count) &#123; Vue.set(this.food, &apos;count&apos;, 1); //遇到没有这个属性的,会强行添加一个 &#125; else &#123; this.food.count++; &#125; this.$emit(&apos;add&apos;, event.target); &#125;, decreaseCart(event)&#123; if (!event._constructed) &#123; return false; &#125; if (this.food.count) &#123; this.food.count--; &#125; &#125; &#125; &#125;;&lt;/script&gt; css代码知识点: vue2的动画 Vue 提供了 transition 的封装组件,就是之前的 这个动画是一个滚动淡入和淡出的效果 首先,定义了这个动画效果的名字为move(),并且将需要这个效果的内容用一个dom的div包裹起来,这个效果分2层,外层和内层inner(外层和内层用class来区分,通过增加一个内层class inner来区分) 然后,设置原始的动画状态(外层和内层) 外层设置了透明度为1和transform变形的3d位置 内层设置了滚动角度和淡入淡出效果 然后,设置vue的动画过渡属性 move-enter-active和move-leave-active 这里设置匀速过渡效果是为了在动画进入过渡的结束状态和动画离开过渡的结束状态都是匀速过渡的变化效果,至于变化成什么效果需要看move-enter和move-leave-active move-enter和move-leave-active 这里设置外层的透明度为0(内层会继承)和变形的3d位置 这里设置了内层滚动角度 这么做实现了动画在进入过渡后和离开过渡后都会内外层,并且会出现内层一边滚动到指定位置然后消失的效果 font-size的使用 因为使用行内元素,所以需要通过设置font-size为0来取消间隙 对于一些设计上的图标过小(操作区域太小)影响用户操作体验的情况,需要增加一个padding来实现增大操作区域的目的 1234567891011121314151617181920212223242526272829303132333435363738&lt;style lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt; .cartcontrol font-size: 0 .cart-decrease //外层动画原始状态 display: inline-block padding: 6px opacity: 1 transform: translate3d(0, 0, 0) .inner //内层动画原始状态 display: inline-block line-height: 24px font-size: 24px color: rgb(0, 160, 220) transition: all 0.4s linear transform: rotate(0) &amp;.move-enter-active, &amp;.move-leave-active //vue动画过渡属性 transition: all 0.4s linear &amp;.move-enter, &amp;.move-leave-active //vue动画过渡属性 opacity: 0 transform: translate3d(24px, 0, 0) .inner transform: rotate(180deg) .cart-count display: inline-block vertical-align: top width: 12px padding-top: 6px line-height: 24px text-align: center font-size: 10px color: rgb(147, 153, 159) .cart-add display: inline-block padding: 6px line-height: 24px font-size: 24px color: rgb(0, 160, 220)&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评价列表ratings组件]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E8%AF%84%E4%BB%B7%E5%88%97%E8%A1%A8ratings%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[需要注意的是main.js里面需要取消vue-router的默认路由,src/main.js的router.replace(‘/goods’);需要去掉原因是在添加了其他页面(原来路由只有一个页面goods,现在多了页面ratings)之后,在浏览器加载页面的时候: 首先会先加载所有页面 在各个页面都在加载的过程中,会跳到默认路由 然后这些页面被中断了加载,导致了页面内部的一些靠dom渲染的代码无法执行,例如bs-scroll 所以会出现一些报错,TypeError: Cannot read property ‘children’ of undefined 所以要做默认路由的时候,直接用url做,不用vue-router自己去跳转,直接写第一个url的地址 主体框架123456&lt;div class=&quot;ratings&quot; ref=&quot;ratings&quot;&gt; &lt;div class=&quot;overview&quot;&gt; &lt;/div&gt;&lt;!--里面是所有的内容--&gt;&lt;/div&gt; 需要加一个ref,为了让bscroll可以初始化dom ratings内容html代码 1234567891011121314151617181920212223242526&lt;div class=&quot;ratings-content&quot;&gt; &lt;div class=&quot;overview&quot;&gt; &lt;div class=&quot;overview-left&quot;&gt; &lt;h1 class=&quot;score&quot;&gt;&#123;&#123;seller.score&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;title&quot;&gt;综合评分&lt;/div&gt; &lt;div class=&quot;rank&quot;&gt;高于周边商家&#123;&#123;seller.rankRate&#125;&#125;%&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;overview-right&quot;&gt; &lt;!--三个一样的模块,服务态度,商品评分,送达时间--&gt; &lt;div class=&quot;score-wrapper&quot;&gt; &lt;span class=&quot;title&quot;&gt;服务态度&lt;/span&gt; &lt;!--引入了star组件--&gt; &lt;star :size=&quot;36&quot; :score=&quot;seller.serviceScore&quot;&gt;&lt;/star&gt; &lt;span class=&quot;score&quot;&gt;&#123;&#123;seller.serviceScore&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;score-wrapper&quot;&gt; &lt;span class=&quot;title&quot;&gt;商品评分&lt;/span&gt; &lt;star :size=&quot;36&quot; :score=&quot;seller.foodScore&quot;&gt;&lt;/star&gt; &lt;span class=&quot;score&quot;&gt;&#123;&#123;seller.foodScore&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;delivery-wrapper&quot;&gt; &lt;span class=&quot;title&quot;&gt;送达时间&lt;/span&gt; &lt;span class=&quot;delivery&quot;&gt;&#123;&#123;seller.deliveryTime&#125;&#125;分钟&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 三个一样的模块共用一套样式代码,分别代入不同的数据 这里的数据都是获取seller的数据,是父组件传入的props js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import star from &apos;../star/star&apos;;export default &#123; props: &#123; seller: &#123; type: Object &#125; &#125;, components: &#123; star &#125;&#125;;css代码.ratings position: absolute top: 174px //留空一部分,给header使用 bottom: 0 left: 0 width: 100% overflow: hidden .overview display: flex padding: 18px 0 .overview-left flex: 0 0 137px //flex布局,固定左边,右边自动适配 padding: 6px 0 width: 137px border-right: 1px solid rgba(7, 17, 27, 0.1) text-align: center @media only screen and (max-width: 320px) //适配i5屏幕 flex: 0 0 120px //适配的flex数值可以从根据设计稿计算 width: 120px .score margin-bottom: 6px line-height: 28px font-size: 24px color: rgb(255, 153, 0) .title margin-bottom: 8px line-height: 12px font-size: 12px color: rgb(7, 17, 27) .rank line-height: 10px font-size: 10px color: rgb(147, 153, 159) .overview-right flex: 1 //flex布局,固定左边,右边自动适配 padding: 6px 0 6px 24px @media only screen and (max-width: 320px) //适配i5屏幕 padding-left: 6px .score-wrapper //三个一样的模块的共用样式 margin-bottom: 8px font-size: 0 .title display: inline-block line-height: 18px //针对模块内部的元素的对齐行,所以需要写到内部元素里面去 vertical-align: top font-size: 12px color: rgb(7, 17, 27) .star display: inline-block margin: 0 12px vertical-align: top .score display: inline-block line-height: 18px vertical-align: top font-size: 12px color: rgb(255, 153, 0) .delivery-wrapper font-size: 0 .title line-height: 18px font-size: 12px color: rgb(7, 17, 27) .delivery margin-left: 12px font-size: 12px color: rgb(147, 153, 159) 关于适配iphone5,因为设计稿是以iphone6为模板设计的,如果不适配一些小的屏幕的话,对于一些比较宽的div(例如overview-left,overview-right)就会出现换行,被挤压的显示清空,所以需要使用media query来做一些基本的适配,这里只是以iphone5为适配参考,具体做法就是针对不同的屏幕宽度做处理 ratingselect组件这个引入类似ratingselect组件 html代码 12345&lt;!--引入split组件--&gt;&lt;split&gt;&lt;/split&gt;&lt;!-- 引入ratingselect组件 --&gt; &lt;ratingselect @select=&quot;selectRating&quot; @toggle=&quot;toggleContent&quot; :selectType=&quot;selectType&quot; :onlyContent=&quot;onlyContent&quot; :ratings=&quot;ratings&quot;&gt;&lt;/ratingselect&gt; ratings列表html代码 12345678910111213141516171819202122232425262728&lt;div class=&quot;rating-wrapper&quot;&gt; &lt;ul&gt; &lt;!--使用needShow方法控制显示--&gt; &lt;li v-for=&quot;rating in ratings&quot; v-show=&quot;needShow(rating.rateType, rating.text)&quot; class=&quot;rating-item&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img width=&quot;28&quot; height=&quot;28&quot; :src=&quot;rating.avatar&quot;&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;h1 class=&quot;name&quot;&gt;&#123;&#123;rating.username&#125;&#125;&lt;/h1&gt; &lt;div class=&quot;star-wrapper&quot;&gt; &lt;!--引入star组件--&gt; &lt;star :size=&quot;24&quot; :score=&quot;rating.score&quot;&gt;&lt;/star&gt; &lt;span class=&quot;delivery&quot; v-show=&quot;rating.deliveryTime&quot;&gt;&#123;&#123;rating.deliveryTime&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;p class=&quot;text&quot;&gt;&#123;&#123;rating.text&#125;&#125;&lt;/p&gt; &lt;!--recommend的处理,尤其注意class跟布局的使用--&gt; &lt;div class=&quot;recommend&quot; v-show=&quot;rating.recommend &amp;&amp; rating.recommend.length&quot;&gt; &lt;span class=&quot;icon-thumb_up&quot;&gt;&lt;/span&gt; &lt;span class=&quot;item&quot; v-for=&quot;item in rating.recommend&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;!--过滤时间格式--&gt; &lt;div class=&quot;time&quot;&gt; &#123;&#123;rating.rateTime | formatDate&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 需要注意recommend的布局处理 needShow和过滤时间类似food.vue组件里面使用九.商品详情页food.vue js代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import BScroll from &apos;better-scroll&apos;;import &#123; formatDate &#125; from &apos;../../common/js/date&apos;; //相对路径导入import star from &apos;../star/star&apos;;const ALL = 2; //设置常量,比较好的代码风格,代替直接写数字到代码里面去const ERR_OK = 0;export default &#123; props: &#123; seller: &#123; type: Object &#125; &#125;, data() &#123; return &#123; ratings: [] &#125;; &#125;, created() &#123; //初始化数据,从api那里获取 this.$http.get(&apos;/api/ratings&apos;).then((response) =&gt; &#123; response = response.body; if (response.errno === ERR_OK) &#123; this.ratings = response.data; this.$nextTick(() =&gt; &#123; //异步初始化滚动 this.scroll = new BScroll(this.$refs.ratings, &#123; click: true &#125;); &#125;); &#125; &#125;); &#125;, methods: &#123; needShow(type, text) &#123; //控制显示是否有内容的rate if (this.onlyContent &amp;&amp; !text) &#123; return false; &#125; if (this.selectType === ALL) &#123; return true; &#125; else &#123; return type === this.selectType; &#125; &#125; &#125;, filters: &#123; //过滤时间 formatDate(time) &#123; let date = new Date(time); return formatDate(date, &apos;yyyy-MM-dd hh:mm&apos;); &#125; &#125;, components: &#123; star &#125;&#125;; css代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@import &quot;../../common/stylus/mixin.styl&quot; .rating-wrapper padding: 0 18px .rating-item display: flex //使用flex布局 padding: 18px 0 border-1px(rgba(7, 17, 27, 0.1)) .avatar flex: 0 0 28px //使用flex布局 width: 28px margin-right: 12px img border-radius: 50% .content position: relative //重新定义相对布局的参考父div,被内部元素做绝对布局使用 flex: 1 //使用flex布局 .name margin-bottom: 4px line-height: 12px font-size: 10px color: rgb(7, 17, 27) .star-wrapper margin-bottom: 6px font-size: 0 .star display: inline-block margin-right: 6px vertical-align: top .delivery display: inline-block vertical-align: top line-height: 12px font-size: 10px color: rgb(147, 153, 159) .text margin-bottom: 8px line-height: 18px color: rgb(7, 17, 27) font-size: 12px .recommend line-height: 16px font-size: 0 .icon-thumb_up, .item //共有属性 display: inline-block margin: 0 8px 4px 0 //分配右外边距和下外边距 font-size: 9px .icon-thumb_up //个别属性,因为icon没有颜色,需要配置 color: rgb(0, 160, 220) .item //个别属性 padding: 0 6px //设置左右内边距,撑开布局,形成类似button的效果 border: 1px solid rgba(7, 17, 27, 0.1) border-radius: 1px color: rgb(147, 153, 159) background: #fff .time position: absolute top: 0 right: 0 line-height: 12px font-size: 10px color: rgb(147, 153, 159) 这里的flex布局是左边固定28px,然后右边占满剩下的空间 flex: 0 0 28px 是flex-grow为0(项目不放大比例),flex-shrink为0(项目不缩小比例),flex-basis为28px(固定占用28px) flex: 1是flex 1 1 auto的缩写,就是会放大项目比例,并且剩余的项目空间也占有参考:Flex 布局教程：语法篇 针对recommend的布局: 每一个内容都是一个span,span是行内元素,可以并列一行 设置外边距是为了span之间能够形成独立的间隙 设置内边距是为了让span和文字形成button的效果]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue过渡动画]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[在vue中，实现过渡动画一般是下面这样:123&lt;transition name=&quot;fade&quot;&gt; &lt;div&gt;&lt;/div&gt;&lt;/transition&gt; 用一个transition对元素或者组件进行封装.在过渡的时候，会有 4 个(CSS)类名在 enter/leave 的过渡中切换。 v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。 v-enter-active: 定义进入过渡的结束状态。在元素被插入时生效，在 transition/animation 完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。 v-leave-active: 定义离开过渡的结束状态。在离开过渡被触发时生效，在 transition/animation 完成之后移除。 上面是官方文档的原话，但是这4个类名如何运用呢？下面看个例子 12345678910111213141516&lt;transition name=&quot;fold&quot;&gt; &lt;div v-show=&quot;show&quot; class=&quot;example&quot;&gt;&lt;/div&gt;&lt;/transition&gt;css:.example &#123; width: 100px; height: 100px; transform: translate3d(0, -100px, 0);&#125;.fold-enter-active, .fold-leave-active &#123; transition: all .5s;&#125;.fold-enter, .fold-leave-active &#123; transform: translate3d(0, 0, 0);&#125; 当show = true时: 这里的fold-enter，是在元素显示的一瞬间被加入，然后瞬间被移除，在上面的例子中，example这个块状元素本来因为有了transform: translate3d(0, -100px, 0)这个样式，所以被上移了100px,但是因为fold-enter，所以将example这个块状元素移到了原位，但是fold-enter因为瞬间就被移除掉了，所以这时候的元素的样式又变成了transform: translate3d(0, -100px, 0),但是这时候fold-enter-active这个样式就生效了，因为设置了transition: all .5s,所以元素会在0.5s的时间内上移100px,在过渡动画结束之后,fold-enter-active这个类马上被移除. 当show = false时: example不会马上消失，这个时候fold-leave-active这个类就起作用了,example这时的位置是在-100px，fold-leave-active定义的是过渡的结束状态：transform: translate3d(0, 0, 0);，但是同时又设置了transition: all .5s，所以这时元素会在0.5s的时间内下移100px.之后fold-leave-active被移除. 另外，还可以在动画中调用js钩子函数: 1234567891011&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;/transition&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[饿了么教程]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、准备工作1.需求分析2.项目资源准备resource文件3.图标字体制作在iconmoonhttps://icomoon.io/将resource中的svg文件转为font4.项目目录设计 vue init webpack 项目名字 cd 文件 npm install npm run dev 删除src中asset文件夹 直接删除会报错，需要把vue.vue中的图片引入注释掉 创建common文件夹 创建font文件夹（将前面下载的字体打包中的font移入） 创建js文件夹 创建stylus文件夹（将前面下载的字体打包中的css移入，并改名为icon.styl） 在components中创建header文件夹，文件夹中创建header.vue 5.mock数据（模拟后台数据） 在根目录下引入data文件 在/build/dev-server.js中 12345678910111213141516171819202122232425262728293031var app = express()var appData = require(&apos;../data.json&apos;);var seller = appData.seller;var goods = appData.goods;var ratings = appData.ratings;var apiRoutes = express.Router();apiRoutes.get(&apos;/seller&apos;,function(req,res)&#123; res.json(&#123; erron: 0, data : seller &#125;);&#125;);apiRoutes.get(&apos;/goods&apos;,function(req,res)&#123; res.json(&#123; erron: 0, data : goods &#125;);&#125;);apiRoutes.get(&apos;/ratings&apos;,function(req,res)&#123; res.json(&#123; erron: 0, data : ratings &#125;);&#125;);app.use(&apos;/api&apos;,apiRoutes); 在网址后面加上/api/seller检查 二、页面骨架开发1.组件拆分（上）在static中创建css文件夹，里面引入reset.css 2.组件拆分（中）在header.vue中编写 12345678910111213&lt;template&gt; &lt;div class=&quot;header&quot;&gt; I am header &lt;/div&gt;&lt;/template&gt; &lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;style lang=&quot;stylus&quot;&gt;&lt;/style&gt; 在app.vue中的script引入 1234567import header from &apos;./components/header/header.vue&apos;export default &#123; components: &#123; &apos;v-header&apos;: header &#125;&#125; 下载插件 1npm install stylus-loader stylus --save-dev 3.组件拆分（下）在app.vue的style中 123456789#app .tab display:flex width:100% height:40px line-height 40px .tab-item flex 1 text-align center 使用flex布局，依赖node_modules中的postcss插件搞定css兼容问题 4.vue-router设置选项卡 1234567891011&lt;div class=&quot;tab&quot;&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link to=&apos;./goods&apos;&gt;商品&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link to=&apos;./ratings&apos;&gt;评论&lt;/router-link&gt; &lt;/div&gt; &lt;div class=&quot;tab-item&quot;&gt; &lt;router-link to=&apos;./seller&apos;&gt;商家&lt;/router-link&gt; &lt;/div&gt;&lt;/div&gt; 在/router/index.js中 12345678910111213141516171819202122import goods from &apos;@/components/goods/goods&apos;import ratings from &apos;@/components/ratings/ratings&apos;import seller from &apos;@/components/seller/seller&apos;export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, redirect:&apos;/goods&apos; //设置首页为goods &#125;, &#123; path: &apos;/ratings&apos;, name: &apos;ratings&apos;, component: ratings &#125;, &#123; path: &apos;/seller&apos;, name: &apos;seller&apos;, component: seller &#125; ]&#125;) 各自编写goods,ratings,seller组件 写css样式 5.像素实现因为不太会配置estin,会有很多报错，所以不装它。为了实现像素自适应，引入flexible插件，因为稿子宽度为750，所以html基准为750/10，使用px-rem插件（注意配置默认值为75，一般不配置的话为16） 在common文件夹引入两个文件 在App.vue中引入 12window._ = require(&apos;./common/js/flexible.debug&apos;)window._ = require(&apos;./common/js/flexible_css.debug&apos;) 6.实现手机预览将localhost改成ip地址，复制地址到草料生成二维码，扫码 三、项目实战-header组件开发1.Axios从远程读取数据 安装axious 1npm install axios --save 在所在页面引入axious 1import axios from &apos;axios&apos; 服务端拉取常用商品数据 1234567created()&#123;[ axios.get(&apos;/api/seller&apos;).then((response) =&gt; &#123; if(response.data.erron === 0)&#123; this.seller = response.data.data &#125; &#125;)]&#125; 之前要分好数据（dev-server.js），然后在router的index.js中，加入 1mode: &apos;history&apos; 为了去掉地址中的# 2.外部组件(1).将app.vue拉取的数据与header.vue连接 1234567export default &#123;props:&#123;seller:&#123; type:Object&#125;&#125;, (2).获取数据中图片地址 1&lt;img width=&quot;64&quot; height=&quot;64&quot; :src=&quot;seller.avatar&quot;&gt; (3).判断2x图还是3x图写/src/common/stylus/mixin.styl 123456789bg-image($url) background-image: url($url+&quot;@2x.png&quot;) @media (-webkit-min-device-pixel-ratio:3),(min-device-pixel-ratio:3) background-image: url($url+&quot;@3x.png&quot;)在header.vue引入@import &quot;../../common/stylus/mixin&quot;css书写bg-imge(‘decrease’) (4).引入图标 1@import &quot;../../common/stylus/icon&quot; 记得改里面的路径 (5).判断是减/折/套…绑定class，建立classMap数组 12345&lt;span class=&quot;icon&quot; :class=&quot;classMap[seller.supports[0].type]&quot;&gt;&lt;/span&gt;created ()&#123; this.classMap = [&apos;decrease&apos;,&apos;discount&apos;,&apos;special&apos;,&apos;invoice&apos;,&apos;guarantee&apos;,&apos;special&apos;]&#125; 用 12345678910&amp;.decrease bg-image(&apos;decrease_1&apos;)&amp;.discount bg-image(&apos;discount_1&apos;)&amp;.guarantee bg-image(&apos;guarantee_1&apos;)&amp;.invoice bg-image(&apos;invoice_1&apos;)&amp;.special bg-image(&apos;special_1&apos;) (6).做背景图最后做背景，用定位定上去 3.详情弹层页(1).星星评分新建/src/components/star/star.vue将half,on,off等图片放进star文件夹中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div class=&quot;star&quot; :class=&quot;starType&quot;&gt; &lt;span v-for=&quot;itemClass in itemClasses&quot; :class=&quot;itemClass&quot; class=&quot;star-item&quot;&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&apos;text/ecmascript-6&apos;&gt; const LENGTH = 5 const CLS_ON = &apos;on&apos; const CLS_HALF = &apos;half&apos; const CLS_OFF = &apos;off&apos; export default &#123; props:&#123; size:&#123; type:Number &#125;, score:&#123; type:Number &#125; &#125;, computed:&#123; starType()&#123; return &apos;star-&apos;+this.size; &#125;, itemClasses()&#123; let result = [] let score = Math.floor(this.score*2)/2 let hasDecimal = score %1 !== 0; let integer = Math.floor(score); for(let i = 0;i&lt;integer;i++)&#123; result.push(CLS_ON) &#125; if(hasDecimal)&#123; result.push(CLS_HALF) &#125; while(result.length&lt;LENGTH)&#123; result.push(CLS_OFF); &#125; return result &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&apos;stylus&apos;&gt;@import &quot;../../common/stylus/mixin&quot; .star font-size 0 .star-item display inline-block background-repeat no-repeat &amp;.star-48 .star-item width .533333rem height .533333rem margin-right .586667rem background-size .533333rem .533333rem &amp;:last-child margin-right 0 &amp;.on bg-image(&apos;star48_on&apos;) &amp;.half bg-image(&apos;star48_half&apos;) &amp;.off bg-image(&apos;star48_off&apos;) &amp;.star-36 .star-item width .2rem height .2rem margin-right .16rem background-size .2rem .2rem &amp;:last-child margin-right 0 &amp;.on bg-image(&apos;star36_on&apos;) &amp;.half bg-image(&apos;star36_half&apos;) &amp;.off bg-image(&apos;star36_off&apos;) &amp;.star-24 .star-item width .133333rem height .133333rem margin-right .08rem background-size .133333rem .133333rem &amp;:last-child margin-right 0 &amp;.on bg-image(&apos;star24_on&apos;) &amp;.half bg-image(&apos;star24_half&apos;) &amp;.off bg-image(&apos;star24_off&apos;)&lt;/style&gt; 用： 123&lt;div class=&quot;star-wrapper&quot;&gt; &lt;star :size=&apos;48&apos; :score=&apos;seller.score&apos;&gt;&lt;/star&gt;&lt;/div&gt; (2).线-文字-线布局flex布局 12345678910111213.title display flex width 80% margin .746667rem auto .64rem auto .line flex 1 position relative top -0.16rem border-bottom .013333rem solid rgba(255,255,255,0.2) .text padding 0 .32rem font-weight 700 font-size .373333rem (3).减、折、特、票、保列表的遍历 123456&lt;ul v-if=&quot;seller.supports&quot; class=&quot;supports&quot;&gt; &lt;li class=&quot;support-item&quot; v-for=&quot;(item, index) in seller.supports&quot;&gt; &lt;span class=&quot;icon&quot; :class=&quot;classMap[seller.supports[index].type]&quot;&gt;&lt;/span&gt; &lt;span class=&apos;text&apos;&gt;&#123;&#123;seller.supports[index].description&#125;&#125;&lt;/span&gt; &lt;/li&gt;&lt;/ul&gt; (4).动画 123456789101112131415&lt;transition name=&quot;fade&quot;&gt; &lt;div transition=&quot;fade&quot; class=&quot;detail&quot;&gt;&lt;/div&gt;&lt;/transition&gt;.detail background rgba(7,17,27,0.8) backdrop-filter blur(.133333rem) &amp;.fade-enter-active,&amp;.fade-leave, &amp;.fade-leave-active opacity 1 background rgba(7,17,27,0.8) transition all 0.5s &amp;.fade-enter opacity 0 background rgba(7,17,27,0) transition all 0.5s (5).Sticky footers问题 如果页面内容不够长的时候，页脚块粘贴在视窗底部；如果内容足够长时，页脚块会被内容向下推送。 解决方案 123456789101112131415161718192021222324&lt;div v-show=&apos;detailShow&apos; class=&quot;detail&quot; transition=&quot;fade&quot;&gt; &lt;div class=&quot;detail-wrapper clearfix&quot;&gt; &lt;div class=&quot;detail-main&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;detail-close&quot; @click=&apos;hideDetail&apos;&gt; &lt;i class=&quot;icon-close&quot;&gt;&lt;/i&gt; &lt;/div&gt;&lt;/div&gt;.detail-wrapper min-height 100% width 100% .detail-main margin-top 1.706667rem padding-bottom .853333rem.detail-close position relative width .853333rem height .853333rem margin:-1.7067rem auto 0 auto clear both 在base.styl中 123456789.clearfix display: inline-block &amp;:after display: block content:&quot;.&quot; height: 0 line-height: 0 clear: both visibility: hidden (6).点击显示/关闭 123456789101112131415161718&lt;div v-show=&apos;detailShow&apos; class=&quot;detail&quot; transition=&quot;fade&quot;&gt;&lt;div class=&quot;detail-close&quot; @click=&apos;hideDetail&apos;&gt; data() &#123; return &#123; detailShow:false &#125; &#125;, methods: &#123; showDetail() &#123; this.detailShow = true; &#125;, hideDetail() &#123; this.detailShow = false; &#125; &#125;, food商品详情页实现1.将food组件和goods组件连接在一起在goods template中引用food标签 1234567891011121314151617181920&lt;food :food=&apos;selectedFood&apos;&gt;&lt;/food&gt;在goods script 中引入food组件import food from &apos;../food/food&apos;在goods script components中引入food组件goods组件输出food数据data()&#123; return&#123; selectedFood:&#123;&#125; &#125;&#125;在food组件注册属性foodprops:&#123; food:&#123; type:Object &#125;&#125; 2.获取点击的物品在商品中绑定点击事件 goods组件 1&lt;li @click=&quot;selectFood(food,$event)&quot; v-for=&quot;food in item.foods&quot; class=&quot;food-item&quot;&gt; 在goods methods中加selectFood事件 123456selectFood(food,event)&#123; if(!event._constructed)&#123; //忽略掉BScroll的事件 return &#125; this.selectedFood = food //写入当前选择的food&#125; 3.点击物品弹出层在food组件中添加methods 123456789101112methods:&#123; show()&#123; this.showFlag = true &#125;&#125;在food组件中注册showFlag值data()&#123; return&#123; showFlag:false &#125;&#125;, 在goods组件 food标签添加ref属性，连接子组件 ref=”food”在goods组件 selectFood方法中调用子组件show方法 1this.$refs.food.show() 4.实现弹出层从右到左动画给food组件 template最外层中 加一个标签 1&lt;transition name=&apos;move&apos;&gt;&lt;/transition&gt; 5.在 food组件 css中123456789101112131415161718.food transform: translate3d(0, 0, 0) &amp;.move-enter-active, &amp;.move-leave-active transition: all 0.2s linear &amp;.move-enter, &amp;.move-leave-active transform: translate3d(100%, 0, 0)5.让图片宽高一样的黑魔法.image-header position relative width 100% height 0 padding-top 100% img position absolute top 0 left 0 width 100% height 100% 6.返回小图标可以在外面套给div，里面的i标签用padding定位 123456789.back position absolute top .266667rem left 0 .icon-arrow_lift display block padding .266667rem font-size .533333rem color #ffffff 7.隐藏滚动条(food)引入better.scroll插件 1import BScroll from &apos;better-scroll&apos; 在最外层div，加注册 ref=’food’在show方法上加 123456789this.$nextTick(()=&gt;&#123; //在这个函数中调用以防内容还未加载完就执行，获取不到元素的高度导致无法滑动 if(!this.scroll)&#123; this.scroll = new BScroll(this.$refs.food,&#123; click:true &#125;) &#125;else&#123; this.scroll.refresh() &#125;&#125;) 8.点击购物车，数量加一在methods,addCart()中加 12345678910addCart(event)&#123; if (!event._constructed) &#123; return; &#125; if(!this.food.count)&#123; Vue.set(this.food,&apos;count&apos;,1) //不能像平常那样this.food.count = 1 &#125;else&#123; this.food.count++ &#125;&#125; 引入vue 1import Vue from &apos;vue&apos; 9.分割线因为出现次数多，所以直接写一个组件 10.商品评价编写ratingselect组件加属性 1234567891011121314151617181920212223242526272829303132const POSITIVE = 0const NEGATIVE = 1const ALL = 2export default&#123; props:&#123; ratings:&#123; type:Array, default()&#123; return [] &#125; &#125;, selectType:&#123; type:Number, default:ALL &#125;, onlyContent:&#123; type:Boolean, default:false &#125;, desc:&#123; type:Object, default()&#123; return&#123; all:&apos;全部&apos;, positive:&apos;满意&apos;, negative:&apos;不满意&apos; &#125; &#125; &#125; &#125;&#125; 引入到food组件中（常规方法） 11.food组件改ratingselect组件（父组件改子组件数据）data输出数据 1234567891011data()&#123; return&#123; selectType:ALL, onlyContent:true, desc:&#123; all:&apos;全部&apos;, positive:&apos;推荐&apos;, negative:&apos;吐槽&apos; &#125; &#125;&#125; 标签绑定数据 别忘了在show()中初始化数据 1234show()&#123; this.selectType = ALL this.onlyContent = true&#125; 12.消除间隙，把父元素的font-size设置为013.如何添加active类(选中)设置selectType属性将每个描述与selectType属性链接（desc属性）判断selectType属性 1:class=&quot;&#123;&apos;active&apos;:selectType===2&#125;&quot; 14.点击 只显示有内容的评价1:class=&quot;&#123;&apos;on&apos;:onlyContent&#125;&quot; 绑定属性 15.点击只显示有内容的评价 切换添加toggleContent()方法 1234567toggleContent(event)&#123; if(!event._constructed)&#123; //better.scroll 会给pc端添加click事件，需要阻止 return &#125; this.onlyContent = !this.onlyContent this.$emit(&apos;toggle&apos;) //与food相关联，将数据传出去&#125; 16.全部 推荐 吐槽 按钮的切换在标签中引用 12345678910@click=&quot;select(2,$event)&quot;添加 select(type,event)方法select(type,event)&#123; if(!event._constructed)&#123; return &#125; this.selectType = type this.$emit(&apos;select&apos;,type)&#125; 之后会根据css写的样式进行展示 17.可以同时判断两个类1&lt;span :class=&quot;&#123;&apos;icon-thumb_up&apos;:rating.rateType===0,&apos;icon-thumb_down&apos;:rating.rateType===1&#125;&quot;&gt;&lt;/span&gt; 18.实现点击全部 推荐 吐槽，显示该显示的内容1.在评论区加上展示的方法12&lt;li v-show=&quot;needShow(rating.rateType,rating.text)&quot; v-for=&quot;rating in food.ratings&quot; class=&quot;rating-item&quot;&gt; 2.needShow(type,text)12345678910needShow(type, text) &#123; if (this.onlyContent &amp;&amp; !text) &#123; return false; &#125; if (this.selectType === ALL) &#123; return true; &#125; else &#123; return type === this.selectType; &#125;&#125; 3.实现food组件和ratingselect组件链接ratingselect组件 1234567891011121314methods: &#123; select(type, event) &#123; if (!event._constructed) &#123; return; &#125; this.$emit(&apos;select&apos;, type); &#125;, toggleContent(event) &#123; if (!event._constructed) &#123; return; &#125; this.$emit(&apos;toggle&apos;); &#125;&#125; food组件绑定ratingselect组件的方法 123&lt;ratingselect @select=&quot;selectRating&quot; @toggle=&quot;toggleContent&quot; :selectType=&quot;selectType&quot;:onlyContent=&quot;onlyContent&quot; :desc=&quot;desc&quot;:ratings=&quot;food.ratings&quot;&gt;&lt;/ratingselect&gt; 写绑定的方法 1234567891011121314selectRating(type) &#123;this.selectType = type;this.$nextTick(() =&gt; &#123; this.scroll.refresh();&#125;);&#125;,toggleContent() &#123;this.onlyContent = !this.onlyContent;this.$nextTick(() =&gt; &#123; this.scroll.refresh();&#125;);&#125; 19.将时间戳转化为日期格式 yyyy-MM-dd hh:mm1.filters 把时间戳传到函数里12345678&lt;div class=&quot;time&quot;&gt;&#123;&#123;rating.rateTime | formatDate&#125;&#125;&lt;/div&gt;filters:&#123; formatDate(time)&#123; let date = new Date(time) return formatDate(date,&apos;yyyy-MM-dd hh:mm&apos;) &#125;&#125; 2.传入formaDate模块，因为用的export ，所以要用{}1import &#123;formatDate&#125; from &apos;../../common/js/date&apos; 3.date.js1234567891011121314151617181920212223export function formatDate(date,fmt)&#123; if(/(y+)/.test(fmt))&#123; fmt = fmt.replace(RegExp.$1,(date.getFullYear()+&apos;&apos;).substr(4-RegExp.$1.length)) &#125; let o = &#123; &apos;M+&apos;:date.getMonth() +1, &apos;d+&apos;:date.getDate(), &apos;h+&apos;:date.getHours(), &apos;m+&apos;:date.getMinutes(), &apos;s+&apos;:date.getSeconds() &#125; for(let k in o)&#123; if(new RegExp(`($&#123;k&#125;)`).test(fmt))&#123; let str = o[k] + &apos;&apos; fmt = fmt.replace(RegExp.$1,(RegExp.$1.length === 1)?str:padLeftZero(str)) &#125; &#125; return fmt&#125;function padLeftZero(str)&#123; return (&apos;00&apos;+str).substr(str.length)&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ratingselect组件]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2Fratingselect%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[html代码 备注:父组件food.vue传入的数据 123&lt;ratingselect @select=&quot;selectRating&quot; @toggle=&quot;toggleContent&quot; :selectType=&quot;selectType&quot;:onlyContent=&quot;onlyContent&quot; :desc=&quot;desc&quot;:ratings=&quot;food.ratings&quot;&gt;&lt;/ratingselect&gt; 方法有:@select=”selectRating” @toggle=”toggleContent”,通过将子组件的方法和父组件的方法进行关联,这样就能够实现跨组件通讯和操作 属性有::selectType=”selectType”:onlyContent=”onlyContent” :desc=”desc”:ratings=”food.ratings”,这是通过pros传入到子组件的属性,将父组件的数据传到子组件里面,也带有一种通过父组件来初始化子组件属性的意思. ratingselect的html代码1234567891011121314151617&lt;div class=&quot;ratingselect&quot;&gt;&lt;!--有使用一个border-1px的mixin--&gt; &lt;div class=&quot;rating-type border-1px&quot;&gt; &lt;!--绑定一个select方法控制切换,绑定class控制切换之后的按钮样式显示--&gt; &lt;span @click=&quot;select(2,$event)&quot; class=&quot;block positive&quot; :class=&quot;&#123;&apos;active&apos;:selectType ===2&#125;&quot;&gt;&#123;&#123;desc.all&#125;&#125;&lt;span class=&quot;count&quot;&gt;&#123;&#123;ratings.length&#125;&#125;&lt;/span&gt;&lt;/span&gt; &lt;span @click=&quot;select(0,$event)&quot; class=&quot;block positive&quot; :class=&quot;&#123;&apos;active&apos;:selectType ===0&#125;&quot;&gt;&#123;&#123;desc.positive&#125;&#125;&lt;span class=&quot;count&quot;&gt;&#123;&#123;positives.length&#125;&#125;&lt;/span&gt;&lt;/span&gt; &lt;span @click=&quot;select(1,$event)&quot; class=&quot;block negative&quot; :class=&quot;&#123;&apos;active&apos;:selectType ===1&#125;&quot;&gt;&#123;&#123;desc.negative&#125;&#125;&lt;span class=&quot;count&quot;&gt;&#123;&#123;negatives.length&#125;&#125;&lt;/span&gt;&lt;/span&gt; &lt;/div&gt; &lt;!--绑定一个toggleContent方法来控制有内容和无内容的显示--&gt; &lt;div @click=&quot;toggleContent&quot; class=&quot;switch&quot; :class=&quot;&#123;&apos;on&apos;:onlyContent&#125;&quot;&gt; &lt;span class=&quot;icon-check_circle&quot;&gt;&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;只看有内容的评价&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; @click=”select(2,$event)” select方法传入类型和事件,然后在methods里面调用父组件的方法,实现子组件控制父组件的目的 :class=”{‘active’:selectType ===2}” 根据类型来确定显示的class,实现不同类型显示不同样式的目的 positives.length 使用计算属性自动计算类型数组的长度,用来显示不同类型的数量 @click=”toggleContent” :class=”{‘on’:onlyContent}” toggleContent控制是否展示有内容的rate,也是在methods里面调用父组件的方法,实现子组件控制父组件的目的 绑定on这个class来控制该按钮的样式 js代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const POSITIVE = 0; //设置显示常量const NEGATIVE = 1;const ALL = 2;export default&#123; props: &#123; ratings: &#123; //传入ratings数组,跟food.ratings关联 type: Array, default()&#123; return []; &#125; &#125;, selectType: &#123; //跟selectType关联,通过在父组件里面设置这3个值来实现控制子组件的操作 type: Number, default: ALL &#125;, onlyContent: &#123; //跟onlyContent关联 type: Boolean, default: true &#125;, desc: &#123; //跟desc关联 type: Object, default()&#123; return &#123; all: &apos;全部&apos;, positive: &apos;满意&apos;, negative: &apos;不满意&apos; &#125; &#125; &#125; &#125;, computed: &#123; positives()&#123; //自动过滤rateType(正向的rate) return this.ratings.filter((rating) =&gt; &#123; //js的filter函数会返回一个处理后的(为true)结果的结果数组 return rating.rateType === POSITIVE; &#125;) &#125;, negatives()&#123; //自动过滤rateType(反向的rate) return this.ratings.filter((rating) =&gt; &#123; return rating.rateType === NEGATIVE; &#125;) &#125; &#125;, methods: &#123; select(type, event) &#123; //选择rateType并且通知父组件 if (!event._constructed) &#123; return; &#125; this.$emit(&apos;select&apos;, type); //调用父组件的方法 &#125;, toggleContent(event) &#123; //选择是否显示有内容的rate,并且通知父组件 if (!event._constructed) &#123; return; &#125; this.$emit(&apos;toggle&apos;); &#125; &#125;&#125; css代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@import &quot;../../common/stylus/mixin.styl&quot;.ratingselect .rating-type padding: 18px 0 margin: 0 18px border-1px(rgba(7, 17, 27, 0.1)) //1像素边框的mixin font-size: 0 //去除行内元素间隙 .block display: inline-block padding 8px 12px margin-right: 8px border-radius: 1px line-height: 16px font-size: 12px color: rgb(77, 85, 93) &amp;.active //被选中的按钮的class(由:class控制) color: #ffffff .count margin-left: 2px font-size: 8px &amp;.positive //设置支持的按钮的样式 background: rgba(0, 160, 220, 0.2) &amp;.active background: rgb(0, 160, 220) &amp;.negative background: rgba(77, 85, 93, 0.2) &amp;.active background: rgb(77, 85, 93) .switch padding: 12px 18px line-height: 24px border-bottom: 1px solid rgba(7, 17, 27, 0.1) color: rgb(147, 153, 159) font-size: 0 &amp;.on //on的class样式 .icon-check_circle color: #00c850 .icon-check_circle display: inline-block vertical-align: top margin-right: 4px font-size: 24px .text vertical-align: top font-size: 12px]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于购物车添加按钮的动画]]></title>
    <url>%2F2017%2F09%2F09%2FVue%2F%E9%A5%BF%E4%BA%86%E4%B9%88%E6%95%99%E7%A8%8B%2F%E5%85%B3%E4%BA%8E%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%B7%BB%E5%8A%A0%E6%8C%89%E9%92%AE%E7%9A%84%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[html代码 生成一个动画小球的div,并且生成五个小球,五个是为了生成一定数量的小球来作为操作使用,按照小球动画的速度,一般来说五个也可以保证有足够的小球数量来运行动画 动画的内容分别是外层和内层,外层控制动画小球的轨道和方向,内层控制动画小球的运行状态 动画使用vue的js钩子实现 因为小球动画只有一个方向(只执行单方向从上到下滚落),所以只用了before-enter,enter,after-enter 用v-show控制小球的可见性,在动画执行期间可见,其余时候隐藏 123456789101112&lt;div class=&quot;ball-container&quot;&gt; &lt;div v-for=&quot;ball in balls&quot;&gt; //用了两种方式的动画,css和js钩子 &lt;transition name=&quot;drop&quot; @before-enter=&quot;beforeDrop&quot; @enter=&quot;dropping&quot; @after-enter=&quot;afterDrop&quot;&gt; //外层动画 &lt;div class=&quot;ball&quot; v-show=&quot;ball.show&quot;&gt; //内层动画 &lt;div class=&quot;inner inner-hook&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/div&gt; js代码 设置了balls数组来代表五个小球 设置了dropBalls数组正在运行的小球 123456789101112data()&#123; return &#123; balls: [ &#123;show: false&#125;, &#123;show: false&#125;, &#123;show: false&#125;, &#123;show: false&#125;, &#123;show: false&#125; ], dropBalls: [] &#125;&#125;, 只要触发了drop事件,不止是drop事件里面的代码会执行,另外几个vue的js监听钩子也会一起按顺序执行 触发了drop事件 beforeDrop开始执行 dropping开始执行 afterDrop开始执行 drop事件的触发可以通过点击cartcontrol组件的添加小球按钮addCart事件触发使用$emit,也可以父组件 this.$refs.shopcart.drop(target);直接触发 这么做的目的是实现,在子组件cartcontrol点击之后,可以将该dom传给父组件goods然后再传给子组件shopcart,(因为目前他们之间的通道就是这样,shopcart子组件并没有导入cartcontrol子组件,所以没有直接通讯)这样就实现了多个组件之间的通讯,从而可以实现需求,例如这里就是实现点击子组件cartcontrol后添加一个动画,将小球滑落到另外一个组件shopcart $emit是触发当前实例上的事件。附加参数都会传给监听器回调。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455methods: &#123; drop(el) &#123; //触发一次事件就会将所有小球进行遍历 for (let i = 0; i &lt; this.balls.length; i++) &#123; let ball = this.balls[i]; if (!ball.show) &#123; //将false的小球放到dropBalls ball.show = true; ball.el = el; //设置小球的el属性为一个dom对象 this.dropBalls.push(ball); return; &#125; &#125; &#125;, beforeDrop(el)&#123; //这个方法的执行是因为这是一个vue的监听事件 let count = this.balls.length; while (count--) &#123; let ball = this.balls[count]; if (ball.show) &#123; let rect = ball.el.getBoundingClientRect(); //获取小球的相对于视口的位移(小球高度) let x = rect.left - 32; let y = -(window.innerHeight - rect.top - 22); //负数,因为是从左上角往下的的方向 el.style.display = &apos;&apos;; //清空display el.style.webkitTransform = `translate3d(0,$&#123;y&#125;px,0)`; el.style.transform = `translate3d(0,$&#123;y&#125;px,0)`; //处理内层动画 let inner = el.getElementsByClassName(&apos;inner-hook&apos;)[0]; //使用inner-hook类来单纯被js操作 inner.style.webkitTransform = `translate3d($&#123;x&#125;px,0,0)`; inner.style.transform = `translate3d($&#123;x&#125;px,0,0)`; &#125; &#125; &#125;, dropping(el, done) &#123; //这个方法的执行是因为这是一个vue的监听事件 /* eslint-disable no-unused-vars */ let rf = el.offsetHeight; //触发重绘html this.$nextTick(() =&gt; &#123; //让动画效果异步执行,提高性能 el.style.webkitTransform = &apos;translate3d(0,0,0)&apos;; el.style.transform = &apos;translate3d(0,0,0)&apos;; //处理内层动画 let inner = el.getElementsByClassName(&apos;inner-hook&apos;)[0]; //使用inner-hook类来单纯被js操作 inner.style.webkitTransform = &apos;translate3d(0,0,0)&apos;; inner.style.transform = &apos;translate3d(0,0,0)&apos;; el.addEventListener(&apos;transitionend&apos;, done); //Vue为了知道过渡的完成，必须设置相应的事件监听器。 &#125;); &#125;, afterDrop(el) &#123; //这个方法的执行是因为这是一个vue的监听事件 let ball = this.dropBalls.shift(); //完成一次动画就删除一个dropBalls的小球 if (ball) &#123; ball.show = false; el.style.display = &apos;none&apos;; //隐藏小球 &#125; &#125; &#125; 关于transitionend 关于drop方法,是实现每一个ball的show属性和el属性处理,并且点击一次会自动将一个小球放到dropBalls数组里面,放到里面就代表的是一个小球已经被开始执行动画,但是由于动画是异步的,所以先主动设置. 关于getBoundingClientRect(位移的计算是从左上角开始) 使用getBoundingClientRect获取到当前元素的坐标,然后需要位移的left减去元素的宽获取真正的最终位移x坐标 使用getBoundingClientRect获取到当前元素的坐标,然后需要当前屏幕的高度减去元素的top再减去元素本身的高度获取到真正的最终位移y坐标,并且这个是负数,因为是从左上角往下的方向 关于html重绘 因为浏览器对于重绘是有要求并且是有队列完成的,这是主要为了性能,虽然动画隐藏了小球display none,但没有触发html重绘,或者说没有立即触发html重绘,所以需要手动 let rf = el.offsetHeight; 这是一个手动触发html重绘的方法 网页性能管理详解 高性能JavaScript 重排与重绘 css代码 12345678910111213.ball-container .ball position: fixed //小球动画必须脱离html布局流 left: 32px bottom: 22px z-index: 200 transition: all 0.4s cubic-bezier(0.49, -0.29, 0.75, 0.41) .inner width: 16px height: 16px border-radius: 50% background: rgb(0, 160, 220) transition: all 0.4s linear 关于cubic-bezier(0.49, -0.29, 0.75, 0.41),是动画抛物曲线(贝塞尔曲线)的配置,基于css3实现,http://cubic-bezier.com/#.17,.67,.83,.67,参考贝塞尔曲线与CSS3动画、SVG和canvas的基情 ,至于抛物线放在外层就是为了控制内层的元素的轨道和方向的.]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>饿了么教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2017%2F08%2F24%2FCss3%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为 Flex 布局。123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署项目到服务器]]></title>
    <url>%2F2017%2F08%2F22%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%2F%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 购买服务器阿里云学生机 Centos 系统 —— 服务器 Ubuntu 系统 —— 桌面软件 2. 安装Nginx 下载 xshell 在 服务器运维 设置登录密码 使用 SSH 登录 12$ yum install nginx$ service nginx start 3. 创建网站的根目录1$ sudo mkdir -p /var/www 4. 配置nginx服务器12$ cd /etc/nginx$ sudo vim /etc/nginx/nginx.conf 打开nginx的配置文件之后，找到server这一块，大概是长这个样子的 1234567891011121314server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /usr/share/nginx/html; # 改成放代码的目录，一般是在/var/www里面 index index.html index.htm; server_name localhost; # 配置域名 location / &#123; try_files $uri $uri/ =404; &#125;&#125; 配置好后，重启一下服务器 5. 测试 使用 Filezilla软件 -&gt; SFTP协议 连接上服务器，可以得到服务器的目录，往 /var/www 加一个 index.html 输入 ip地址 或 配置的域名，查看 index.html 是否正确显示 5. 打开端口因为阿里云服务器默认没打开nginx配置里的80端口，所以要去配置 6. 查错笔记1234567891011121314$ sudo vim/var/log/nginx$ sudo vim/var/log/access.log$ sudo vim/var/log/error.log# 看nginx服务是否正常$ sudo service nginx status # 重新开nginx$ sudo service nginx restart # 查错$ sudo nginx -t]]></content>
      <categories>
        <category>服务器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1. 安装Git Bash我一直不太喜欢在cmd中操作各种命令，所以挑了这个比较好使的Git Bash, 我的是windows环境，所以下载windows版本并安装就可以了。 下载地址https://git-for-windows.github.io/ 安装步骤：双击下载好的exe文件，一路next就好啦 安装好后，打开gitbash，查看版本： 命令：git version 然后你就可以在这里发挥你的聪明才智了 2. 安装NodeJsHexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧 下载地址https://nodejs.org/en/(说明：LTS为长期支持版，Current为当前最新版) 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。 查看版本： 命令：node -v 又到自由发挥的时候了 3. 安装hexo看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：npm i -g hexo 安装完成后，查看版本：hexo -v 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 做好这些前置工作之后接下来的就是各种配配配置了。 4. 搭桥到github 没账号的创建账号，有账号的看下面。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用哦，如下： 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）： git config –global user.name ‘yourname’ git config –global user.email ‘youremail’ 创建SSH 在gitbash中输入：ssh-keygen -t rsa -C “youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。 将上面获取的ssh放到github中： 添加一个 New SSH key ，title随便取，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com 完成下一步你就成功啦！ 5. 一步之遥 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令： hexo clean hexo generate hexo server 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server。 打开浏览器输入：http://localhost:4000 接着你就可以遇见天使的微笑了~ 6. 上传到github 先安装一波：npm install hexo-deployer-git -–save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)： 123hexo cleanhexo generatehexo deploy 注意deploy的过程中要输入你的username及passward。如下： 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！ 感觉gitbash中东西太多的时候输入clear命令清空。 7. 绑定个人域名 登录进入万网的域名控制台，点击”域名和网站”中的”云DNS” 点击对应域名的”解析” 点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是whitescholars.github.io。 这些全部设置完成后，此时你并不能要申请的域名访问你的博客。 接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：penglei.com。 运行hexo指令使配置修改起效： hexo g //会在public中生成一个GNAME文件 hexo d //修改内容提交到github博客上 域名绑定： 这是比较重要的一步，打开博客在Github中的地址，然后切换到 Settings页，设置Custom domain内容为我们自己的域名值（例如：我的域名是linshuhe.tech），点击Save按钮保存 实践证明如果此时你填写的是www.penglei.top那么以后你只能用www.penglei.top访问，而如果你填写的是penglei.top。那么用www.penglei.top和penglei.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。 搭建完成访问出现404 可能的原因是： 绑定了个人域名，但是域名解析错误。 域名解析正确但你的域名是通过国内注册商注册的，你的域名因没有实名制而无法访问。 你认为配置没有问题，那么可能只是你的浏览器在捣鬼，可尝试清除浏览器缓存再访问或者换个浏览器访问。 也有可能是你的路由器缓存导致的错觉，所以也可以尝试换个局域网访问你的网站。 最有可能的原因是你下载的hexo有问题，导致所有的东西都上传到了github,而导致index页面在主域名的下一级目录。你可以尝试查看上传的内容，找到index页面，在域名后面添加下一级目录。若能访问index页面（此时样式可能是乱的），则证明是hexo安装有问题，笔者当时遇到的就是这个问题。可卸载重新安装。 注：1，2默认你的CNAME文件配置没有问题，如果没有绑定个人域名，则不需要CNAME文件。 8.修改主题 下载主题到theme 站点配置文件中(根目录下的_config.yml)，把theme改成对应的名字 hexo clean hexo g &amp;&amp; hexo d 如何配置标签？1234title: 标签测试文章tags: - Testing - Another Tag]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli]]></title>
    <url>%2F2017%2F08%2F18%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue-cli%2F</url>
    <content type="text"><![CDATA[一、Vue-cli，开始吧骚年一、安装vue-cli安装vue-cli的前提是你已经安装了npm，安装npm你可以直接下载node的安装包进行安装。你可以在命令行工具里输入npm -v 检测你是否安装了npm和版本情况。出现版本号说明你已经安装了npm和node，我这里的npm版本为3.10.10。如果该命令不可以使用，需要安装node软件包，根据你的系统版本选择下载安装就可以了。 下载地址：http://nodejs.cn/download/ npm没有问题，接下来我们可以用npm 命令安装vue-cli了，在命令行输入下面的命令： 1npm install vue-cli -g -g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue -V来进行查看 vue-cli的版本号。注意这里的V是大写的。我这里版本号是2.8.1. 如果vue -V的命令管用了，说明已经顺利的把vue-cli安装到我们的计算机里了。 二、初始化项目我们用vue init命令来初始化项目，具体看一下这条命令的使用方法。 1$ vue init &lt;template-name&gt; &lt;project-name&gt; init：表示我要用vue-cli来初始化项目 ：表示模板名称，vue-cli官方为我们提供了5种模板， webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。 webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。 browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。 browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。 simple-一个最简单的单页应用模板。 ：标识项目名称，这个你可以根据自己的项目来起名字。 在实际开发中，一般我们都会使用webpack这个模板，那我们这里也安装这个模板，在命令行输入以下命令： 1vue init webpack vuecliTest 输入命令后，会询问我们几个简单的选项，我们根据自己的需要进行填写就可以了。 Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitest Project description:项目描述，默认为A Vue.js project,直接回车，不用编写。 Author：作者，如果你有配置git的作者，他会读取。 Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择Y Use ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。 setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。 Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。 命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。 1、cd vuecliTest 进入我们的vue项目目录。 2、npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。 3、npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。 二、Vue-cli项目结构讲解vue-cli脚手架工具就是为我们搭建了开发所需要的环境，为我们省去了很多精力。有必要对这个环境进行熟悉，我们就从项目的结构讲起。 Ps：由于版本实时更新和你选择安装的不同（这里列出的是模板为webpack的目录结构），所以你看到的有可能和下边的有所差别。 123456789101112131415161718192021222324252627282930.|– build // 项目构建(webpack)相关代码| |– build.js // 生产环境构建代码| |– check-version.js // 检查node、npm等版本| |– dev-client.js // 热重载相关| |– dev-server.js // 构建本地服务器| |– utils.js // 构建工具相关| |– webpack.base.conf.js // webpack基础配置| |– webpack.dev.conf.js // webpack开发环境配置| |– webpack.prod.conf.js // webpack生产环境配置|– config // 项目开发环境配置| |– dev.env.js // 开发环境变量| |– index.js // 项目一些配置变量| |– prod.env.js // 生产环境变量| |– test.env.js // 测试环境变量|– src // 源码目录| |– components // vue公共组件| |– store // vuex的状态管理| |– App.vue // 页面入口文件| |– main.js // 程序入口文件，加载各种公共组件|– static // 静态文件，比如一些图片，json数据等| |– data // 群聊分析得到的数据用于数据可视化|– .babelrc // ES6语法编译配置|– .editorconfig // 定义代码格式|– .gitignore // git上传需要忽略的文件格式|– README.md // 项目说明|– favicon.ico|– index.html // 入口页面|– package.json // 项目基本信息. 重要文件讲解： package.jsonpackage.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。 package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。 1234“scripts”: &#123;“dev”: “node build/dev-server.js”,“build”: “node build/build.js”&#125;, dependencies字段和devDependencies字段 dependencies字段指项目运行时所依赖的模块；devDependencies字段指定了项目开发时所依赖的模块；在命令行中运行npm install命令，会自动安装dependencies和devDempendencies字段中的模块。package.json还有很多相关配置，如果你想全面了解，可以专门去百度学习一下。 webpack配置相关我们在上面说了运行npm run dev 就相当于执行了node build/dev-server.js,说明这个文件相当重要，先来熟悉一下它。 我贴出代码并给出重要的解释。 dev-server.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// 检查 Node 和 npm 版本require(‘./check-versions’)()// 获取 config/index.js 的默认配置var config = require(‘../config’)// 如果 Node 的环境无法判断当前是 dev / product 环境// 使用 config.dev.env.NODE_ENV 作为当前的环境if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)// 使用 NodeJS 自带的文件路径工具var path = require(‘path’)// 使用 expressvar express = require(‘express’)// 使用 webpackvar webpack = require(‘webpack’)// 一个可以强制打开浏览器并跳转到指定 url 的插件var opn = require(‘opn’)// 使用 proxyTablevar proxyMiddleware = require(‘http-proxy-middleware’)// 使用 dev 环境的 webpack 配置var webpackConfig = require(‘./webpack.dev.conf’)// default port where dev server listens for incoming traffic// 如果没有指定运行端口，使用 config.dev.port 作为运行端口var port = process.env.PORT || config.dev.port// Define HTTP proxies to your custom API backend// https://github.com/chimurai/http-proxy-middleware// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置var proxyTable = config.dev.proxyTable// 使用 express 启动一个服务var app = express()// 启动 webpack 进行编译var compiler = webpack(webpackConfig)// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中var devMiddleware = require(‘webpack-dev-middleware’)(compiler, &#123;publicPath: webpackConfig.output.publicPath,stats: &#123;colors: true,chunks: false&#125;&#125;)// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reloadvar hotMiddleware = require(‘webpack-hot-middleware’)(compiler)// force page reload when html-webpack-plugin template changescompiler.plugin(‘compilation’, function (compilation) &#123;compilation.plugin(‘html-webpack-plugin-after-emit’, function (data, cb) &#123;hotMiddleware.publish(&#123; action: ‘reload’ &#125;)cb()&#125;)&#125;)// proxy api requests// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) &#123;var options = proxyTable[context]if (typeof options === ‘string’) &#123;options = &#123; target: options &#125;&#125;app.use(proxyMiddleware(context, options))&#125;)// handle fallback for HTML5 history API// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址app.use(require(‘connect-history-api-fallback’)())// serve webpack bundle output// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 将 Hot-reload 挂在到 express 服务上app.use(hotMiddleware)// serve pure static assets// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 为静态资源提供响应服务app.use(staticPath, express.static(‘./static’))// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露module.exports = app.listen(port, function (err) &#123;if (err) &#123;console.log(err)return&#125;var uri = ‘http://localhost:’ + portconsole.log(‘Listening at ‘ + uri + ‘\n’)// when env is testing, don’t need open it// 如果不是测试环境，自动打开浏览器并跳到我们的开发地址if (process.env.NODE_ENV !== ‘testing’) &#123;opn(uri)&#125;&#125;) webpack.base.confg.js webpack的基础配置文件123456789101112131415161718192021222324252627282930……module.export = &#123;// 编译入口文件entry: &#123;&#125;,// 编译输出路径output: &#123;&#125;,// 一些解决方案配置resolve: &#123;&#125;,resolveLoader: &#123;&#125;,module: &#123;// 各种不同类型文件加载器配置loaders: &#123;……// js文件用babel转码&#123;test: /.js$/,loader: ‘babel’,include: projectRoot,// 哪些文件不需要转码exclude: /node_modules/&#125;,……&#125;&#125;,// vue文件一些相关配置vue: &#123;&#125;&#125; .babelrcBabel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。如果你想了解更多，可以查看babel的知识。 1234567891011121314151617&#123;//设定转码规则“presets”: [[“env”, &#123; “modules”: false &#125;],“stage-2”],//转码用的插件“plugins”: [“transform-runtime”],“comments”: false,//对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作“env”: &#123;“test”: &#123;“presets”: [“env”, “stage-2”],“plugins”: [ “istanbul” ]&#125;&#125;&#125; .editorconfig该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。 123456789root = true[] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格 三、解读Vue-cli的模板一、npm run build 命令有小伙伴问我，如何把写好的Vue网页放到服务器上，那我就在这里讲解一下，主要的命令就是要用到npm run build 命令。我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。 package.json的scripts 字段： 1234“scripts”: &#123;“dev”: “node build/dev-server.js”,“build”: “node build/build.js”&#125;, 在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。 dist文件夹下目录包括： index.html 主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。 static 静态资源文件夹：里边js、CSS和一些图片。 二、main.js文件解读main.js是整个项目的入口文件,在src文件夹下： 12345678910111213import Vue from ‘vue’import App from ‘./App’import router from ‘./router’Vue.config.productionTip = false //生产环境提示，这里设置成了false/ eslint-disable no-new */new Vue(&#123;el: ‘#app’,router,template: ‘‘,components: &#123; App &#125;&#125;) 通过代码可以看出这里引进了App的组件和的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件，打开查看。 三、App.vue文件:12345678910111213141516&lt;script&gt;export default &#123; name: &apos;app&apos;&#125;&lt;/script&gt;&lt;style&gt;#app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;&#125;&lt;/style&gt; app.vue文件我们可以分成三部分解读， 标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和标签，标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。 标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。 标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用来声明这些css样式只在本模板中起作用。 四、router/index.js 路由文件引文在app.vue中我们看到了路由文件，虽然router的内容比较多，但是我们先简单的看一下。下篇文章我们就开始讲Vue-router。 123456789101112131415import Vue from ‘vue’import Router from ‘vue-router’import Hello from ‘@/components/Hello’Vue.use(Router)export default new Router(&#123;routes: [&#123;path: ‘/‘,name: ‘Hello’,component: Hello&#125;]&#125;) 我们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue-Cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex]]></title>
    <url>%2F2017%2F08%2F18%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvuex%2F</url>
    <content type="text"><![CDATA[vuex是一个专门为vue.js设计的集中式状态管理架构。状态？我把它理解为在data中的属性需要共享给其他vue组件使用的部分，就叫做状态。简单的说就是data中需要共用的属性。比如：我们有几个页面要显示用户名称和用户等级，或者显示用户的地理位置。如果我们不把这些属性设置为状态，那每个页面遇到后，都会到服务器进行查找计算，返回后再显示。在中大型项目中会有很多共用的数据，所以尤大神给我们提供了vuex。 第1节：初出茅庐 来个小Demo引入vuex1.利用npm包管理工具，进行安装 vuex。在控制命令行中输入下边的命令就可以了。 1npm install vuex --save 需要注意的是这里一定要加上 –save，因为你这个包我们在生产环境中是要使用的。 2.新建一个vuex文件夹（这个不是必须的），并在文件夹下新建store.js文件，文件中引入我们的vue和vuex。 12import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;; 3.使用我们vuex，引入之后用Vue.use进行引用。 1Vue.use(Vuex); 一个demo：加减按钮这次要用的是vuex来进行制作，并实现数据的共享。 1.现在我们store.js文件里增加一个常量对象。store.js文件就是我们在引入vuex时的那个文件。 123const state=&#123; count:1&#125; 2.用export default 封装代码，让外部可以引用。 1234export default new Vuex.Store(&#123; state&#125;) 3.新建一个vue的模板，位置在components文件夹下，名字叫count.vue。在模板中我们引入我们刚建的store.js文件，并在模板中用输出count 的值。 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;hr/&gt; &lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import store from &apos;@/vuex/store&apos; export default&#123; data()&#123; return&#123; msg:&apos;Hello Vuex&apos;, &#125; &#125;, store &#125;&lt;/script&gt; 4.在store.js文件中加入两个改变state的方法。 12345678const mutations=&#123; add(state)&#123; state.count++; &#125;, reduce(state)&#123; state.count--; &#125;&#125; 这里的mutations是固定的写法，意思是改变的，我们到时候会用一节课专门讲这个mutations，所以你先不用着急，只知道我们要改变state的数值的方法，必须写在mutations里就可以了。 5.在count.vue模板中加入两个按钮，并调用mutations中的方法。 1234&lt;div&gt; &lt;button @click=&quot;$store.commit(&apos;add&apos;)&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;$store.commit(&apos;reduce&apos;)&quot;&gt;-&lt;/button&gt;&lt;/div&gt; 第2节：state访问状态对象在第1节我们已经写了一个 const state ，这个就是我们说的访问状态对象，它就是我们SPA（单页应用程序）中的共享值。今天我们主要学习状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式，我们一个一个来学习一下。 一、通过computed的计算属性直接赋值computed属性可以在输出前，对data中的值进行改变，我们就利用这种特性把store.js中的state值赋值给我们模板中的data值。 12345computed:&#123; count()&#123; return this.$store.state.count; &#125;&#125; 这里需要注意的是return this.$store.state.count这一句，一定要写this，要不你会找不到$store的。这种写法很好理解，但是写起来是比较麻烦的，那我们来看看第二种写法。 二、通过mapState的对象来赋值我们首先要用import引入mapState。 1import &#123;mapState&#125; from &apos;vuex&apos;; 然后还在computed计算属性里写如下代码： 123computed:mapState(&#123; count:state=&gt;state.count &#125;) 这里我们使用ES6的箭头函数来给count赋值。 三、通过mapState的数组来赋值1computed:mapState([&quot;count&quot;]) 这个算是最简单的写法了，在实际项目开发当中也经常这样使用。 这就是三种赋值方式，是不是很简单，虽然简单，但是在实际项目中经常使用，一定要自己动手练习两遍啊。 第4节：getters计算过滤操作getters从表面是获得的意思，可以把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工。你可以把它看作store.js的计算属性。 getters基本用法：比如我们现在要对store.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100. 我们首先要在store.js里用const声明我们的getters属性。 12345const getters = &#123; count:function(state)&#123; return state.count +=100; &#125;&#125; 写好了gettters之后，我们还需要在Vuex.Store()里引入，由于之前我们已经引入了state盒mutations，所以引入里有三个引入属性。代码如下， 123export default new Vuex.Store(&#123; state,mutations,getters&#125;) 在store.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。 123456computed:&#123; ...mapState([&quot;count&quot;]), count()&#123; return this.$store.getters.count; &#125;&#125;, 需要注意的是，你写了这个配置后，在每次count 的值发生变化的时候，都会进行加100的操作。 用mapGetters简化模板写法：我们都知道state和mutations都有map的引用方法把我们模板中的编码进行简化，我们的getters也是有的，我们来看一下代码。 首先用import引入我们的mapGetters 1import &#123; mapState,mapMutations,mapGetters &#125; from &apos;vuex&apos;; 在computed属性中加入mapGetters 1...mapGetters([&quot;count&quot;]) 第5节：actions异步修改状态actions和之前讲的Mutations功能基本一样，不同点是，actions是异步的改变state状态，而Mutations是同步改变状态。至于什么是异步什么是同步这里我就不做太多解释了，如果你不懂自己去百度查一下吧。（视频中有讲解） 在store.js中声明actionsactions是可以调用Mutations里的方法的，我们还是继续在上节课的代码基础上进行学习，在actions里调用add和reduce两个方法。 12345678const actions =&#123; addAction(context)&#123; context.commit(&apos;add&apos;,10) &#125;, reduceAction(&#123;commit&#125;)&#123; commit(&apos;reduce&apos;) &#125;&#125; 在actions里写了两个方法addAction和reduceAction，在方法体里，我们都用commit调用了Mutations里边的方法。细心的小伙伴会发现这两个方法传递的参数也不一样。 context：上下文对象，这里你可以理解称store本身。 {commit}：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。 模板中的使用我们需要在count.vue模板中编写代码，让actions生效。我们先复制两个以前有的按钮，并改成我们的actions里的方法名，分别是：addAction和reduceAction。 1234&lt;p&gt; &lt;button @click=&quot;addAction&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;reduceAction&quot;&gt;-&lt;/button&gt;&lt;/p&gt; 改造一下我们的methods方法，首先还是用扩展运算符把mapMutations和mapActions加入。 123456methods:&#123; ...mapMutations([ &apos;add&apos;,&apos;reduce&apos; ]), ...mapActions([&apos;addAction&apos;,&apos;reduceAction&apos;])&#125;, 你还要记得用import把我们的mapActions引入才可以使用。 增加异步检验我们现在看的效果和我们用Mutations作的一模一样，肯定有的小伙伴会好奇，那actions有什么用，我们为了演示actions的异步功能，我们增加一个计时器（setTimeOut）延迟执行。在addAction里使用setTimeOut进行延迟执行。 12setTimeOut(()=&gt;&#123;context.commit(reduce)&#125;,3000);console.log(&apos;我比reduce提前执行&apos;); 我们可以看到在控制台先打印出了‘我比reduce提前执行’这句话。 第6节：module模块组随着项目的复杂性增加，我们共享的状态越来越多，这时候我们就需要把我们状态的各种操作进行一个分组，分组后再进行按组编写。那今天我们就学习一下module：状态管理器的模块组操作。 声明模块组：在vuex/store.js中声明模块组，我们还是用我们的const常量的方法声明模块组。代码如下： 123const moduleA=&#123; state,mutations,getters,actions&#125; 声明好后，我们需要修改原来 12345Vuex.Stroe里的值：export default new Vuex.Store(&#123; modules:&#123;a:moduleA&#125;&#125;) 在模板中使用现在我们要在模板中使用count状态，要用插值的形式写入。 1&lt;h3&gt;&#123;&#123;$store.state.a.count&#125;&#125;&lt;/h3&gt; 如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。写法如下： 12345computed:&#123; count()&#123; return this.$store.state.a.count; &#125;&#125;,]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网页进度条]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2F%E5%B8%B8%E7%94%A8%E7%BD%91%E9%A1%B5%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[1234&lt;div class = &quot;loading&quot;&gt; //覆盖层 &lt;div class = &quot;pic&quot;&gt; //loading图片/动画 &lt;/div&gt;&lt;/div&gt; 一、用定时器的方法实现加载12345$(function()&#123; setInterval(function()&#123; $(&quot;.loading&quot;).fadeOut(); &#125;,3000)&#125;) 获取loading图片的网站：https://preloaders.net/ 二、通过加载状态事件实现加载12345document.onreadystatechange = function()&#123; if(document.readyState == &quot;complete&quot;)&#123; $(&quot;.loading&quot;).fadeOut(); &#125;&#125; document.onreadystatechange 页面加载状态改变时的事件 document.readyState 返回当前文档的状态 uninitialized 还未开始载入 loading 载入中 interactive 已加载，文档与用户可以开始交互 complete 载入完成 三、css3进度条小动画主要依靠 transform,animation,@keyframes实现 可以将代码兼容的网站：http://autoprefixer.github.io/ loading动画直接生成css的网站:https://loading.io/ 四、定位在头部的加载通过向特定的一段html后面加入 123&lt;script&gt; $(&quot;.loading .pic&quot;).animate(&#123;width:&quot;30%&quot;&#125;,100)&lt;/script&gt; 最后 123$(&quot;.loading .pic&quot;).animate(&#123;width:&quot;100%&quot;&#125;,100,function()&#123; $(&quot;.loading&quot;).fadeOut();&#125;) 五、实时获取加载数据的进度条123456789101112131415161718$(function()&#123; var img = $(&quot;img&quot;); var num = 0; img.each(function(i)&#123; var oImg = new Image(); //建立图像对象 oImg.onload = function()&#123; oImg.onload = null; num++; $(&quot;.loading b&quot;).html(parseInt(num/$(&quot;img&quot;).size()*100)+&quot;%&quot;); if(num&gt;=i)&#123; $(&quot;.loading&quot;).fadeOut(); &#125; &#125; oImg.src = img[i].src; //src属性一定要写到onload的后面，否则程序在IE中会出错 &#125;);&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>进度条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器页面加载解析渲染机制]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%B5%8F%E8%A7%88%E5%99%A8%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一：为什么要了解浏览器渲染页面和加载页面机制，主要还是性能的优化。 了解浏览器如何进行加载，我们可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。 了解浏览器如何进行解析，我们可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。 了解浏览器如何进行渲染，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少”重绘“”重新布局“的消耗。 二：用户访问网页都发生了什么。 用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址，找到后，系统会向对应IP地址的网络服务器发送一个http请求。 网络服务器解析请求，并发送请求给数据库服务器。 数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器。 浏览器解析 http response。 浏览器解析 http response后，需要下载html文件，以及html文件内包含的外部引用文件，及文件内涉及的图片或者多媒体文件。（这里进入主题了也就是下面的第三大点） 1~4步骤HTTP协议的一些内容，访问服务器端可能遭遇的问题：如果网络服务器无法获取数据库服务器返回的资源文件（http response 404），或者由于并发原因暂时无法处理用户的http请求（http response 500）。 三：浏览器加载页面机制加载，即为获取资源文件的过程，不同浏览器，以及他们的不同版本在实现这一过程时，会有不同的实现效果(资源间互相阻塞，可以用timeline来做测试)。这里先说下浏览器的5个常驻线程： 浏览器GUI渲染线程 javascript引擎线程 浏览器定时器触发线程（setTimeout） 浏览器事件触发线程 浏览器http异步请求线程（.jpg 这类请求） 备注：现代浏览器存在 prefetch 优化，浏览器会另外开启线程，提前下载js、css文件，需要注意的是，预加载js并不会改变dom结构，他将这个工作留给主加载。 注意：这里也涉及到 阻塞 的现象，当js引擎线程（第二个）进行时，会挂起其他一切线程，这个时候3、4、5这三类线程也会产生不同的异步事件，由于 javascript引擎线程为单线程，所以代码都是先压到队列，采用先进先出的方式运行，事件处理函数，timer函数也会压在队列中，不断的从队头取出事件，这就叫：javascript-event-loop。简单点说应该是当在进行第二线程的时候，1，3，4，5都会挂起，比如这时候触发click事件，即使先前JS已经加载完成，click事件会压在队列里，这里也要先完成第二线程才会执行click事件。 加载顺序： 浏览器解析http response 下载html文件会”自上而下“加载，并在加载过程中进行解析渲染。“自上而下”加载时遇到图片、视频之类资源时便会进入第5个线程，这是异步请求，并不会影响html文档进行加载。 加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。这里也是第5个线程，这里css解析会生成一个rule tree（规则树），这个以后会更新。 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。 原因：JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。 办法：可以将外部引用的js文件放在前。 4、 css可能影响js的执行造成阻塞。 原因：如js里面var width = $(‘#id’).width();这里js执行前，浏览器必须保证之前的css文件已下载和解析完成(后面的不会影响)，这也是css阻塞后续js的根本原因。当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。 5、 预加载网页，利用空余时间来提前加载该网页的后续网页。 1&lt;link rel="prefetch" href="http://"&gt; 6、为js脚本添加defer属性，其不会阻塞后续DOM的的渲染。但是因为这个defer只是IE专用，所以一般用得比较少。 而我们标准的的HTML5也加入了一个异步载入javascript的属性：async，无论你对它赋什么样的值，只要它出现，它就开始异步加载js文件。 但是， async的异步加载会有一个比较严重的问题，那就是它忠实地践行着“载入后马上执行”这条军规，所以，虽然它并不阻塞页面的渲染，但是你也无法控制他执行的次序和时机。 四、浏览器解析渲染机制1.浏览器是如何对网页进行渲染的（1）.浏览器将从服务器获取的HTML文档构建成文档对象模型DOM(Document Object Model) （2）.样式将被载入和解析，构成层叠样式表模型CSSOM(CSS Object Model) （3）.在DOM和CSSOM之上，渲染树(rendering tree)将会被创建，代表一系列将被渲染的对象（这在Webkit内核中被称为renderer或者渲染对象render object，在Gecko内核中被称为框架frame）。渲染树映射除了不可见元素（例如或者含有display:none;的标签）外的所有DOM结构。每一段文本字符串都将划分在不同的渲染对象中，每一个渲染对象都包含了它相应的DOM对象以及计算后的样式。换句话讲，渲染树是DOM的直观表示。 （4）.渲染树的每个元素包含的内容都是计算过的，它被称之为布局layout.浏览器使用一种流式处理的方法，只需要一次pass绘制操作就可以布局所有的元素（tables需要多次pass绘制，pass表示像素处理和顶点处理）。 （5）.最后布局完成，渲染树将转化为屏幕上的实际内容，这一步被称为绘制painting。 DOM-CSSOM-rendering tree-layout-painting 2.重绘Repaint当页面元素样式的改变不影响元素在文档流中的位置时（例如background-color, border-color,visibility）,浏览器只会将新样式赋予元素并进行重绘操作。 3.回流Reflow当改变影响文档内容或者结构，或者元素位置时，回流操作就会被触发，一般有以下几种情况： DOM操作（对元素的增删改，顺序变化等） 内容变化，包括表单区域内的文本改变 CSS属性的更改或重新计算 增删样式表内容 修改class属性 浏览器窗口变化（滚动或缩放） 伪类样式激活（:hover等） 4.浏览器如何优化渲染浏览器本身会尽可能地减少其重绘或回流的次数，只更改必要的元素。例如一个position设置为absolute/fixed的元素的更改只会影响其本身和其子元素，而static的元素变化则会影响其之后的所有页面元素。 另外一项优化的技术则是在JavaScript代码运行时，浏览器会缓存所有的变化，然后只通过一次pass绘制操作来应用这些更改。例如下面这段代码只会触发一次重绘和回流： 12345var $body = $(&apos;body&apos;);$body.css(&apos;padding&apos;, &apos;1px&apos;); // 触发重绘与回流$body.css(&apos;color&apos;, &apos;red&apos;); // 触发重绘$body.css(&apos;margin&apos;, &apos;2px&apos;); // 触发重绘与回流// 最终只有一次重绘和回流被触发 然而，根据我们之前提到过的，获取某个元素的属性将会触发强制回流。比如我们在刚才的代码中加上一句读取元素属性的操作： 12345var $body = $(&apos;body&apos;);$body.css(&apos;padding&apos;, &apos;1px&apos;);$body.css(&apos;padding&apos;); // 此处触发强制回流$body.css(&apos;color&apos;, &apos;red&apos;);$body.css(&apos;margin&apos;, &apos;2px&apos;); 结果就会有两次回流发生。因此，我们应该尽量合并读取元素属性的操作来优化性能。 当然也有我们不得不触发强制回流的情况。比如说对同一个元素的margin-left属性进行两次操作——开始的时候赋值100px的距离，之后为了实现动画效果，再加上transition属性将距离改变到50px. 我们先定义一个CSS类： 123456.has-transition &#123; -webkit-transition: margin-left 1s ease-out; -moz-transition: margin-left 1s ease-out; -o-transition: margin-left 1s ease-out; transition: margin-left 1s ease-out;&#125; 之后再对页面元素进行操作： 1234567891011121314// 我们的元素开始默认含有 "has-transition" 的class属性var $targetElem = $('#targetElemId');// 移除默认的 "has-transition"$targetElem.removeClass('has-transition');// 此处的属性改变没有动画效果$targetElem.css('margin-left', 100);// 再加上原来的属性名$targetElem.addClass('has-transition');// 这次改变有动画效果$targetElem.css('margin-left', 50); 但事实上这段代码并不会像注释描述的那样运作，每条语句的操作将被缓存，只有结果会在页面上显示，所以我们就需要手动进行一次强制回流： 1234567891011121314// 移除默认的 "has-transition"$(this).removeClass('has-transition');// 此处的属性改变没有动画效果$(this).css('margin-left', 100);// 触发强制回流，上述两条语句的效果会马上在页面中显示$(this)[0].offsetHeight; // 只是举个例子，别的触发方法也可以// 再加上原来的属性名$(this).addClass('has-transition');// 这次改变有动画效果$(this).css('margin-left', 50); 5.优化渲染效率的几条最佳实践1.合法地书写HTML和CSS，不要忘了文档编码类型。样式文件应当在 标签中，脚本文件在 结束前。 2.简化并优化你的CSS选择器（有些人可能CSS预处理器用习惯了从来不关注这一点）。将嵌套层减少到最小。CSS选择器根据其优先级具有不同的运行效率（从快到慢）： ID选择器： #id 类选择器： .class 标签选择器： div 相邻选择器： a + i 子元素选择器： ul &gt; li 通用选择器： * 属性选择器： input[type=”text”] 伪类选择器： a:hover 浏览器中CSS选择器是从右到左进行匹配的（为什么浏览器要从右到左匹配样式选择器），这也是为什么越短的选择器运行越快的原因（别提通用选择器，它会遍历所有元素）： 1234div * &#123;...&#125; // ×.list li &#123;...&#125; // ×.list-item &#123;...&#125; // √#list .list-item &#123;...&#125; // √ 3.在你的脚本代码中，尽量减少DOM操作。缓存所有的内容，包括属性和对象（如果他们需要被复用的话）。尽量将元素缓存到本地之后再进行操作，最后再添加到DOM当中。 4.如果你使用jQuery进行DOM操作的话，最好遵循jQuery最佳实践。 5.修改元素样式时，更改其class属性是性能最高的方法。你的选择器越有针对性越好（这同样也有助于分离页面样式和逻辑）。 6.尽量只对 position 为 absolute/fixed 的元素设置动画。 7.在页面滚动时禁用 :hover 样式效果： 12345678910111213141516.disable-hover &#123; pointer-events: none;&#125;var body = document.body, timer;window.addEventListener('scroll', function() &#123; clearTimeout(timer); if(!body.classList.contains('disable-hover')) &#123; body.classList.add('disable-hover') &#125; timer = setTimeout(function()&#123; body.classList.remove('disable-hover') &#125;,500);&#125;, false);]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[三种居中]]></title>
    <url>%2F2017%2F08%2F18%2FCss3%2F%E4%B8%89%E7%A7%8D%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[一、垂直居中用绝对定位实现垂直居中1.创建一个div包裹图片2.对父元素添加1position: relative;3.对子元素添加123position: absolute; top: 50%; margin-top: -50px; /* half the size of image */ 利用Display: table;来实现垂直居中1.创建一个div元素以及另外一个包含图片的div元素 2.为父元素设置 display 为table 3.把包裹图片的那个div元素的display属性设置为table-cell。为了垂直居中，给包裹图片的div元素设置vertical-align: middle;属性。 使用flex实现垂直居中（IE8 IE9不支持）1.创建一个包裹着图片的div元素 2.把div元素的display属性设置为flex 3.div添加另外一条属性align-items: center; 二、水平居中采用margin的方法实现水平居中1margin： 0 auto; 需要满足三个条件： 1.元素定宽 2.元素为块级元素或行内元素设置 display:block 3.元素的margin-left 和margin-right 都必须设置为auto 以文本对齐实现水平居中12父级元素设置 text-align:center;子元素设置为内嵌块元素 display:inline-block; 使用于文本/内嵌块元素，所要居中的所有元素的父级应该是“块”或“内嵌块”级元素 对于单行文字来说，直接使用text-align: center即可。 多行文字可以看作一个块级元素参考margin法和定位法。 定位法父级：relative 子级：position：absolute;left:50%;magin-left: -自己宽度的一半； 三个条件： 1.元素定宽 2.元素绝对定位，并设置left:50% 3.元素负左边距margin-left为宽度的一半 如果不定宽，此时需要用到css3中的transform属性中的translate，可以使元素移动时相对于自身的宽度和高度。需要注意，这种方法需要IE9+才可以实现。 三、绝对垂直居中绝对垂直居中父级：relative 子级： 123456position: absolute;top: 0;right: 0;bottom: 0;left: 0;margin: auto; flexbox块级 12345678.md-warp&#123;display:flex;&#125;.md-main&#123;margin: auto;&#125; 文字 123456789101112.md-warp&#123;display:flex;&#125;.md-main&#123;display: flex;align-items: center;justify-content: center;margin: auto;&#125;]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[懒加载]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2F%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[1.后台分页（异步）jq Ajax123456789101112131415$(document).ready(function () &#123; $.ajax(&#123; url: url, //必需。规定把请求发送到哪个 URL type: &apos;GET&apos;, //提交类型：GET POST dataType: &apos;dataType&apos;, //可选。规定预期的服务器响应的数据类型。默认执行智能判断（xml、json、script 或 html）。 data:data, //可选。规定连同请求发送到服务器的数据。 success: function (data) &#123; &#125;, error: function (error) &#123; alert(error); &#125; &#125;);&#125;) 他那边的数据是一个个写好了的（比如page=1），比如一个页面20个图片，然后第一页就是20个图片地址，我们传入地址url（url+page=1）获取里面的图片地址，再把原来div中的图片地址用js替换（像推书那样）。 2.js实现加载首先，在页面中准备一个id为div1的div,在这个div中放一个ul,ul中准备了一些li,然而这些li都有一个data-src的属性，准备着图片的地址，具体结构如下： 123456789&lt;div id=&quot;div1&quot;&gt; &lt;ul&gt; &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt; &lt;li data-src=&quot;img/w.png&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 图片的动态加载就是通过读取li元素，然后获得li元素的data-src属性的值赋予动态创建的图片的src，从而实现了图片的创建。 123456789101112131415function setImg(index)&#123; var oDiv=document.getElementById(&quot;div1&quot;) var oUl=oDiv.children[0]; var aLi=oUl.children; if (aLi[index].dataset) &#123; var src=aLi[index].dataset.src; &#125; else&#123; var src=aLi[index].getAttribute(&apos;data-src&apos;); &#125; var oImg=document.createElement(&apos;img&apos;); oImg.src=src; if (aLi[index].children.length==0) &#123; aLi[index].appendChild(oImg); &#125;&#125; 那么怎么识别是否在可视区域呢？这里需要一个函数，能够实现获得当前元素距离网页顶部的距离！ 123456789//获得对象距离页面顶端的距离 function getH(obj) &#123; var h = 0; while (obj != window.document.body&amp;&amp;obj != null) &#123; h += obj.offsetTop; obj = obj.offsetParent; &#125; return h; &#125; //就是沿着dom树一层层往上找，把相对于offsetParent的偏移累加，直到body，这样就可以得到当前元素相对于顶端的偏移量。 当网页的滚动条滚动时要时时判断当前li的位置！ 123456789101112131415window.onscroll = function () &#123; var oDiv = document.getElementById(&apos;div1&apos;); var oUl = oDiv.children[0]; var aLi = oUl.children; for (var i = 0, l = aLi.length; i &lt; l; i++) &#123; var oLi = aLi[i]; //检查oLi是否在可视区域 var t = document.documentElement.clientHeight + (document.documentElement.scrollTop || document.body.scrollTop); var h = getH(oLi); if (h &lt; t) &#123; setTimeout(&quot;setImg(&quot; + i + &quot;)&quot;, 500); &#125; &#125;&#125;; // document.documentElement.clientHeight ==&gt; 可见区域高度 当页面加载完成以后要主动运行一下window.onscroll，从而获得当前可视范围内的图片 另外，像这样的页面，障眼法和美化都是必须的，比如给每个li一个loading的图片作为背景，从而实现了当前图片正在加载的效果，美化工作就是做好合理的布局。 123456789101112131415161718192021222324* &#123; margin: 0; padding: 0;&#125;#div1 &#123; width: 520px; margin: 30px auto; border: 1px solid red; overflow: hidden;&#125;li &#123; width: 160px; height: 160px; float: left; list-style: none; margin: 5px; background: url(loading.gif) center center no-repeat; border: 1px dashed green;&#125;img&#123;width:100%&#125; data- ,可以设置我们需要的自定义属性。如果想获取某个属性的值： 如 data-src:dataset.src注意：带连字符连接的名称在使用的时候需要命名驼峰化： data-meal-time ：dataset.mealTime 3.jq插件 lazyload使用方法 引用jquery和jquery.lazyload.js到你的页面 为图片加入样式lazy 图片路径引用方法用data-original js出始化lazyload并设置图片显示方式 在图片中也可以不使用 class=”lazy”，初始化时使用： 1$(&quot;img&quot;).lazyload(&#123;effect: &quot;fadeIn&quot;&#125;); 这样就可以对全局的图片都有效！ 参数 1234567891011121314$(&quot;img.lazy&quot;).lazyload(&#123; placeholder : &quot;img/grey.gif&quot;, //用图片提前占位 // placeholder,值为某一图片路径.此图片用来占据将要加载的图片的位置,待图片加载时,占位图则会隐藏 effect: &quot;fadeIn&quot;, // 载入使用何种效果 // effect(特效),值有show(直接显示),fadeIn(淡入),slideDown(下拉)等,常用fadeIn threshold: 200, // 提前开始加载 // threshold,值为数字,代表页面高度.如设置为200,表示滚动条在离目标位置还有200的高度时就开始加载图片,可以做到不让用户察觉 event: &apos;click&apos;, // 事件触发时才加载 // event,值有click(点击),mouseover(鼠标划过),sporty(运动的),foobar(…).可以实现鼠标莫过或点击图片才开始加载,后两个值未测试… container: $(&quot;#container&quot;), // 对某容器中的图片实现效果 // container,值为某容器.lazyload默认在拉动浏览器滚动条时生效,这个参数可以让你在拉动某DIV的滚动条时依次加载其中的图片 failurelimit : 10 // 图片排序混乱时 // failurelimit,值为数字.lazyload默认在找到第一张不在可见区域里的图片时则不再继续加载,但当HTML容器混乱的时候可能出现可见区域内图片并没加载出来的情况,failurelimit意在加载N张可见区域外的图片,以避免出现这个问题.&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css媒体查询]]></title>
    <url>%2F2017%2F08%2F18%2FCss3%2Fcss%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1.语法1234567891011&lt;!-- link元素中的CSS媒体查询 --&gt;&lt;link rel="stylesheet" media="(max-width: 800px)" href="example.css" /&gt;&lt;!-- 样式表中的CSS媒体查询 --&gt;&lt;style&gt;@media (max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125;&lt;/style&gt; 即使媒体查询返回false, 标签指向的样式表也将会被下载(但是它们不会被应用) 2.逻辑操作符(1).and1@media tv and (min-width: 700px) and (orientation: landscape) &#123; ... &#125; 现在，上面媒体查询仅在电视媒体上，可视区域不小于700像素宽度并且是横屏时有效。 (2).逗号分隔列表1@media (min-width: 700px), handheld and (orientation: landscape) &#123; ... &#125; 等同于 or 逻辑操作符。 (3).not12345@media not all and (monochrome) &#123; ... &#125;@media not (all and (monochrome)) &#123; ... &#125;@media not screen and (color), print and (color)@media (not (screen and (color))), print and (color) (4).onlyonly 关键字防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式： 1&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (color)&quot; href=&quot;example.css&quot; /&gt; 3.媒体属性(1).颜色（color）指定输出设备每个像素单元的比特值。如果设备不支持输出颜色，则该值为0。 1234567向所有能显示颜色的设备应用样式表：@media all and (color) &#123; ... &#125;向每个颜色单元至少有4个比特的设备应用样式表：@media all and (min-color: 4) &#123; ... &#125; (2).颜色索引（color-index）向所有使用索引颜色的设备应用样式表 123456，你可以这么做：@media all and (color-index) &#123; ... &#125;向所有使用至少256个索引颜色的设备应用样式表：&lt;link rel=&quot;stylesheet&quot; media=&quot;all and (min-color-index: 256)&quot; href=&quot;http://foo.bar.com/stylesheet (3).宽高比（aspect-ratio）描述了输出设备目标显示区域的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。 (4).设备宽高比（device-aspect-ratio）描述了输出设备的宽高比。该值包含两个以“/”分隔的正整数。代表了水平像素数（第一个值）与垂直像素数（第二个值）的比例。 1@media screen and (device-aspect-ratio: 16/9), screen and (device-aspect-ratio: 16/10) &#123; ... &#125; 宽高比或者16：9或者16：10。 (5).设备高度（device-height）描述了输出设备的高度（整个屏幕或页的高度，而不是仅仅像文档窗口一样的渲染区域）。 向显示在最大宽度800px的屏幕上的文档应用样式表，你可以这样做： 1&lt;link rel=&quot;stylesheet&quot; media=&quot;screen and (max-device-width: 799px)&quot; /&gt; (6).设备宽度（device-width）描述了输出设备的宽度（整个屏幕或页的高度，而不是仅仅像文档窗口一样的渲染区域）。 (7).网格（grid）是否接受 min/max 前缀： 否 判断输出设备是网格设备还是位图设备。如果设备是基于网格的（例如电传打字机终端或只能显示一种字形的电话），该值为1，否则为0。 (8).高度（height）height 媒体属性描述了输出设备渲染区域（如可视区域的高度或打印机纸盒的高度）的高度。 (9).黑白（monochrome）指定了一个黑白（灰度）设备每个像素的比特数。如果不是黑白设备，值为0。 (10).方向（orientation）值：landscape | portrait 指定了设备处于横屏（宽度大于高度）模式还是竖屏（高度大于宽度）模式。 向竖屏设备应用样式表： 1@media all and (orientation: portrait) &#123; ... &#125; (11).分辨率（resolution）指定输出设备的分辨率（像素密度）。分辨率可以用每英寸（dpi）或每厘米（dpcm）的点数来表示。 (12).扫描（scan）值： progressive | interlace 向以顺序方式扫描的电视机上应用样式表： 1@media tv and (scan: progressive) &#123; ... &#125; (13).宽度（width）width 媒体属性描述了输出设备渲染区域（如可视区域的宽度或打印机纸盒的宽度）的宽度。]]></content>
      <categories>
        <category>Css3</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[px pd pid 等移动端知识]]></title>
    <url>%2F2017%2F08%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2Fpx%20pd%20pid%20%E7%AD%89%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1.PX（css pixels）——虚拟像素px是一个相对单位，相对的是设备像素显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为ppi和dpi： ppi：每英寸多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。 dpi：每英寸多少点。 2.DP(device pixels)——设备像素（物理像素）pt在css单位中属于真正的绝对单位，1pt = 1/72(inch),inch及英寸，而1英寸等于2.54厘米。 屏幕普遍采用RGB色域(红、绿、蓝三个子像素构成),而印刷行业普遍使用CMYK色域(青、品红、黄和黑) 3.设备像素(DP)与CSS像素之间的关系1DPR = 设备像素/CSS像素 当这个比率为1:1时，使用1个设备像素显示1个CSS像素。当这个比率为2:1时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。 window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。 4.DIP(Device independent Pixel)设备独立像素，也称为逻辑像素，简称dip。 1CSS像素 =设备独立像素 = 逻辑像素 5.PPI(pixels per inch)每英寸像素取值，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。 6.ppi和dpr到底什么关系？设备像素比与ppi相关，一般是ppi/160的整数倍： 7.分辨率、像素和屏幕尺寸PPI 说的是像素密度，而分辨率说的是块屏幕的像素尺寸，譬如说 1334*750 就是 iPhone（67）的分辨率，说 iPhone（67）的分辨率是 326 是错误的表述，326 是它的像素密度，单位是 PPI。 8.Viewportppk认为，移动设备上有三个viewport。 layout viewport document.documentElement.clientWidth 来获取 visual viewport的宽度可以通过window.innerWidth 来获取 viewport——移动设备的理想viewport。根据不同的设备有不同的宽度 (1).怎么让layout viewport=visual viewport？(2).关于缩放以及initial-scale的默认值12visual viewport宽度 = ideal viewport宽度 / 当前缩放值当前缩放值 = ideal viewport宽度 / visual viewport宽度 在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>单位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个viewport的故事(一)]]></title>
    <url>%2F2017%2F08%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F%E4%B8%A4%E4%B8%AAviewport%E7%9A%84%E6%95%85%E4%BA%8B(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[一、设备像素和css像素(1).设备像素dp(device pixels)设备像素又称物理像素（physical pixel），设备能控制显示的最小单位，我们可以把这些像素看作成显示器上一个个的点。(2).CSS像素 CSS像素是Web编程的概念，独立于设备的用于逻辑上衡量像素的单位，也就是说我们在做网页时用到的CSS像素单位，是抽象的，而不是实际存在的。 设备独立像素比独立于设备的用于逻辑上衡量像素的单位。（(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”，两个基本一样） 不管是移动端还是PC端通过screen.width/height获取的这个值是设备独立像素（CSS 像素），而不是设备的屏幕分辨率 (3).PPIPPI就是设备像素dp的单位 pixel per inch 翻译下就是每英寸内有多少个像素点,这个像素点指的是设备像素点（物理像素），说得接地气点PPI就是像素密度（pixel density）。 (4).设备像素比1设备像素比 = 设备像素/设备独立像素 // 在某一方向上，x方向或者y方向 可以通过JavaScript 中的window.devicePixelRatio来获取设备中的像素比值。 它可以告诉我们，一个设备像素对应多少个css像素 科普：什么是Retina视网膜屏幕？PPI 值超过 300 的叫做超高密度屏幕，只是 Apple 给它换了个高大尚的名称：Retina 视网膜屏幕而已。 (5).屏幕尺寸意义：用户屏幕的整体大小。 度量单位：设备像素。 screen.width和screen.height (6).窗口尺寸意义：浏览器窗口的整体大小，包括滚动条。 度量单位：CSS像素。 它告诉了你用户到底有多少空间可以用来做CSS布局。你可以通过window.innerWidth和window.innerHeight来获取这些尺寸。 (7).滚动距离意义：页面滚动的距离。 度量单位：CSS像素。 (8).viewportviewport的功能是用来约束你网站中最顶级包含块元素（containing block）的。 viewport，接着，实际上等于浏览器窗口：它就是那么定义的。 (9).度量viewportdocument.documentElement.clientWidth/Height 意义：Viewport尺寸。 度量单位：CSS像素。 不等于html的尺寸 (10).度量元素1document.documentElement.offsetWidth/Height 意义：元素（也就是页面）的尺寸。 度量单位：CSS像素。 (11).事件中的坐标 pageX/Y提供了相对于元素的以CSS像素度量的坐标。(IEb不支持) clientX/Y提供了相对于viewport的以CSS像素度量的坐标。 screenX/Y提供了相对于屏幕的以设备像素进行度量的坐标。 90%的时间你将会使用pageX/Y；通常情况下你想知道的是相对于文档的事件坐标。其他的10%时间你将会使用clientX/Y。你永远不需要知道事件相对于屏幕的坐标。 (12).媒体查询关于媒体查询的事。原理很简单：你可以声明「只在页面宽度大于，等于或者小于一个特定尺寸的时候才会被执行」的特殊的CSS规则。比如： 1234567891011div.sidebar &#123; width: 300px;&#125;@media all and (max-width: 400px) &#123; // styles assigned when width is smaller than 400px; div.sidebar &#123; width: 100px; &#125;&#125; 当前sidebar是300px宽，除了当宽度小于400px的时候，在那种情况下sidebar变得100px宽。 这个宽度是 viewport的宽高 width/height使用和documentElement .clientWidth/Height（换句话说就是viewport宽高）一样的值。它是工作在CSS像素下的。]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两个viewport的故事(二)]]></title>
    <url>%2F2017%2F08%2F18%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F%E4%B8%A4%E4%B8%AAviewport%E7%9A%84%E6%95%85%E4%BA%8B(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[1.两个viewport(1).visual viewportvisual viewport是页面当前显示在屏幕上的部分。用户可以通过滚动来改变他所看到的页面的部分，或者通过缩放来改变visual viewport的大小。 (2).layout viewport(3).度量visual viewport(4).滚动距离Scrolling offset你还需知道的是visual viewport当前相对于layout viewport的位置。这是滚动距离，并且就像在桌面一样，它被存储在window.pageX/YOffset之中。 (5). 元素就像在桌面上一样，document.documentElement.offsetWidth/Height提供了以CSS像素为单位的元素的整个尺寸。 (6).媒体查询Media queries媒体查询和其在桌面环境上的工作方式一样。width/height使用layout viewport做为参照物，并且以CSS像素进行度量，device-width/height使用设备屏幕，并且以设备像素进行度量。 换句话说，width/height是document.documentElement.clientWidth/Height值的镜像，同时device-width/height是screen.width/height值的镜像。（它们在所有浏览器中实际上就是这么做的，即使这个镜像的值不正确。） (7).事件坐标pageX/Y仍然是相对于页面，以CSS像素为单位，并且它是目前为止三个属性对中最有用的，就像它在桌面环境上的那样。 clientX/Y是相对于visual viewport来计算，以CSS像素为单位的。这有道理的，即使我还不能完全指出这么做的好处。 screenX/Y是相对于屏幕来计算，以设备像素为单位。当然，这和clientX/Y用的参照系是一样的，并且设备像素在这没有用处。所以我们不需要担心screenX/Y；跟在桌面环境上一样没有用处。 (8).viewport meta标签]]></content>
      <categories>
        <category>移动端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2017%2F08%2F18%2F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%2FWebpack%2Fwebpack%2F</url>
    <content type="text"><![CDATA[一、Hello Webpack1.webpack介绍webpack是一个现代的JavaScript应用模块打包器（module bundler），它能把各种资源，例如JS（含JSX）、coffee、样式（less/sass）、图片等都作为模块来处理和使用。它有着难以置信的配置和神奇的效果，大大提高了我们程序员的工作效率。举个例子：我们可以直接使用require（xxx）的形式来引入各模块，即使他们可能需要经过编译（比如JSX和sass），但我们无须再上面花费太多心思，webpack有着各种健全的加载器（loader）在默默处理这些事情。它可以部分代替Grunt和gulp的功能。 2.webpack的安装1、全局安装 1$npm install webpack -g 2、直接安装到项目的依赖里，也就是写入package.json 12npm initnpm install webpack –save-dev 3.配置文件webpack.config.js重点:什么是入口文件？模块打包的起点称之为入口起点（entry point）。入口起点告诉webpack从哪里开始，并遵循着依赖关系进行打包。可以将您的应用入口起点认为是根上下文（contextual root）或app第一个启动文件。 4.我们来作一个实例（Hello World！）1.建立index.html文件 2.建立main.js文件 3.建立webpack.config.js文件 4.命令行输入webpack 5.安装live-server 并预览程序 index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 123456789document.write(&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;);webpack.config.jsmodule.exports = &#123; entry: &quot;./main.js&quot;, output: &#123; filename: &apos;bundle.js&apos; &#125;&#125;; 安装live-server,只要用npm install就可以安装了。 1npm install live-server -g 二、多入口文件（Multiple entry files）1.webpack配置多路口文件当我们需要时webpack 是允许我们有多个输出文件的。也就是说，我们可以在html文件中引入2个js文件或者其他的文件。 我们来做个多入口文件的例子： 1、首先我们建立两个JavaScript文件，分别是main1.js 和main2.js。然后在里边输出 Hello world 和 Hello webpack 。 main1.js 1document.write(&quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;); main2.js 1document.write(&quot;&lt;h2&gt;Hello Webpack!&lt;/h2&gt;&quot;); 2、建立indx.html文件，引入bundle1.js和bundle2.js，这两个文件就是我们要打包的两个js文件。index.html 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;webpack example02&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle2.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、建立webpack.config.js配置文件。123456789module.exports = &#123; entry: &#123; bundle1: &apos;./main1.js&apos;, bundle2: &apos;./main2.js&apos; &#125;, output: &#123; filename: &apos;[name].js&apos; &#125;&#125;; 三、使用Webpack CSS loader加载器1.什么是loaderloader用于转换应用程序的资源文件，他们是运行在nodejs下的函数，使用参数来获取一个资源的来源并且返回一个新的来源（资源的位置），例如：你可以使用loader来告诉webpack去加载一个coffeeScript或者Babel文件。 2.loader的解析loader的解析类似模块，一个loader模块会导出一个方法并且可被nodejs写为可兼容的JavaScript,通常情况下通过npm来管理loader,但你也可以把loader放在自己的应用里。 3.安装loader你可以通过npm来安装loader 1$ npm install xxx-loader --save-dev 或者 1$ npm install xxx-loader --save 4.CSS-loader 实例1、先建立一个html文件，并引入bundle.js文件。 index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、建立main.js文件，并用require引入app.css文件。然后写一句话。 main.js 12require(&apos;./app.css&apos;);document.write(&apos;&lt;h1&gt;Hello Webpack!&lt;/h1&gt;&apos;); 3、建立app.css文件，把body 的背景设置为红色。 app.css 123body &#123; background-color: red;&#125; 4、建立webpack.config.js配置文件，在里边加入加载器。 1234567891011module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\.css$/, loader: &apos;style-loader!css-loader!stylus-loader&apos; &#125;, ] &#125;&#125;; 5、用npm 安装 css-loader 和style-loader 12345$ npm install style-loader --save-dev$ npm install css-loader --save-devnpm install stylus-loader stylus --save-dev 6、在控制台输入 webpack 进行打包 1$ webpack 这样就用webpack的加载器成功打包了css样式文件。以后我们的html里就可以不用看到css的引入语句了。 四、使用webpack Image loader 加载图片直接用一个例子说明 1、新建main.js文件， 创建img标签后，把src的值用require引进来。然后插入标签。1234567var img1 = document.createElement(&quot;img&quot;);img1.src = require(&quot;./small.png&quot;);document.body.appendChild(img1);var img2 = document.createElement(&quot;img&quot;);img2.src = require(&quot;./big.png&quot;);document.body.appendChild(img2); 2、建立index.html文件，引入bundle.js 1234567891011121314&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3、建立webpack.config.js配置文件1234567891011module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos; &#125;, ] &#125;&#125;; 这里需要说明的是limit ，它的左右是如果图片的大小，小于8192bytes就以Data URL的形式引入图片，大于就用图片地址引用。 4、打开命令行，用cnpm 安装url-loader包。1$ cnpm install url-loader --save-dev 5、用webpack命令进行打包1$ webpack 五、使用uglify-js 压缩打包JS代码1.webpack 插件机制介绍：插件可以完成更多loader不能完成的功能。插件的使用一般是在webpack的配置信息 plugins选定中指定。Webpack本身内置了一些常用的插件，还可以通过npm安装第三方插件。 2.uglify-js介绍：ugligy-js是一个用npm安装的JavaScript代码压工具，我们在grunt和gulp中经常使用。 用npm命令进行安装： 1npm install uglify-js g 最常用的方法： 123uglifyjs [input files] [options]uglifyjs demo.js -o demo-min.js -c 3.用Webpack中的uglify-js压缩Demo这里我就不贴出index.html和main.js的代码了，我只贴出webpack.config.js的代码。如果你想完整的做出例子，可以按照视频步骤一步一步的操作。 123456789101112131415var webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; path: __dirname, filename: &apos;bundle.js&apos; &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ]&#125;; 六、使用webpack构建本地服务器我们之前一直都在用live-server充当本地服务器，其实它和webpack是不搭的，我们可以利用webpack自带的webpack-dev-server来构建一个本地服务器。它让你的浏览器检测你的代码修改，并自动刷新修改后的结果，它是基于node.js构建。webpack-dev-server是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。 1、安装webpack-dev-server本地依赖 1npm install --save-dev webpack-dev-server 全局安装 1npm install -g webpack-dev-server 2、在webpack.config.js中配置devserver选项： contentBase : 默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录。 port ：设置默认监听端口，如果省略，默认为”8080″ inline : 设置为true，当源文件改变时会自动刷新页面 colors ： 设置为true，使终端输出的文件为彩色的 historyApiFallback ：在开发单页时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html host ： 主机地址，如果是开发本机搭建，需要使用本机IP地址，否则会报错。 配置文件如下： 12345678910111213141516module.exports = &#123; entry: __dirname + &apos;/main.js&apos;, output: &#123; path: __dirname + &apos;/&apos;, filename: &apos;bundle.js&apos; &#125;, devServer: &#123; contentBase: &apos;./&apos;, //本地服务器所加载的页面所在的目录 host: &apos;192.168.1.158&apos;, //本地IP地址 colors: true, //终端输出结果为彩色 historyApiFallback: true, //不跳转 inline: true, //实时刷新 port: &apos;3333&apos; //端口号 &#125;&#125; 3、在终端中输入命令，开启运行本地服务器。它不仅提供了服务器，还会监视我们的文件变化自动更新效果，但是它不是真正的打包，它类似于在内存中进行了打包。所以本地文件并没有变化。1webpack-dev-server 其实webpack构建服务器才是正道，如果你使用了webpack，那么尽量使用webpack-dev-server吧，这能大大提高您的工作效率。]]></content>
      <categories>
        <category>打包工具</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript运行机制详解：event loop]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2Fjavascript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%EF%BC%9Aevent%20loop%2F</url>
    <content type="text"><![CDATA[一、为什么JavaScript是单线程？JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 二、任务队列单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。 JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。） （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 （3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 （4）主线程不断重复上面的第三步。 三、事件和回调函数“任务队列”是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。 所谓”回调函数”（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。 “任务队列”是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 四、Event Loop主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。 上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。请看下面这个例子。 12345var req = new XMLHttpRequest();req.open(&apos;GET&apos;, url); req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; req.send(); 上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取”任务队列”。所以，它与下面的写法等价。 12345var req = new XMLHttpRequest();req.open(&apos;GET&apos;, url);req.send();req.onload = function ()&#123;&#125;; req.onerror = function ()&#123;&#125;; 也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取”任务队列”。 五、定时器除了放置异步任务的事件，”任务队列”还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做”定时器”（timer）功能，也就是定时执行的代码。 定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。 setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。 123console.log(1);setTimeout(function()&#123;console.log(2);&#125;,1000);console.log(3); 上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。 如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。 12setTimeout(function()&#123;console.log(1);&#125;, 0);console.log(2); 上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。 总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在”任务队列”的尾部添加一个事件，因此要等到同步任务和”任务队列”现有的事件都处理完，才会得到执行。 HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。 需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>运行机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dom事件探秘]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2Fdom%E4%BA%8B%E4%BB%B6%E6%8E%A2%E7%A7%98%2F</url>
    <content type="text"><![CDATA[一、事件流描述的是从页面中接受事件的顺序1.事件冒泡事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播至最不具体的那个节点（文档）。2.事件捕获不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件 二、使用事件处理程序1.HTML事件处理程序缺点： js和html紧密在一起如需修改，要改两个地方 2.DOM0级事件处理程序较传统的方式：把一个函数赋值给一个事件的处理程序属性 用的比较多的方法 简单 跨浏览器的优势 3.DOM2级事件处理程序DOM2级事件定义了两个方法： 用于处理指定和删除事件处理程序的操作 addEventListener()和removeEventListener(). 接收三个参数：要处理的事件名、作为事件处理程序的函数和布尔值（默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。） 总结： 1、DOM0级和DOM2级的共同优点： 能添加多个事件处理程序，按顺序执行，HTML事件处理程序无法做到~ 2、关于dom0级和dom2级的区别 DOM0级事件处理：同时绑定几个不同的事件，例如在绑定onclick的基础上再绑定一个onmouseover为按钮2设置背景颜色（这里注意不能onclick、onmouseover事件都设为alert弹出哦，可能有冲突，dom0和dom2都不能成功）；但是不能同时绑定多个相同的事件，比如onclick；会覆盖，只会执行最后一个的函数； DOM2级事件处理：优点：同时绑定几个事件（相同或不同），然后顺序执行，不会覆盖。缺点：不具有跨浏览器优势。 4.IE事件处理程序 attchEvent()添加事件 detachEvent()删除事件 接受相同的两个参数：事件处理程序的名称和事件处理程序的函数 不使用第三个参数的原因：IE8以及更早的浏览器版本只支持事件冒泡 5.跨浏览器的事件处理程序三、事件对象在触发DOM上的事件时都会产生一个对象 事件对象event 1.DOM中的事件对象（1）.type属性 用于获取事件类型 （2）.target属性 用于获取事件目标 （3）.stopPropagation()方法 用于阻止事件冒泡 （4）.preventDefault()方法 阻止事件的默认行为 2.IE中的事件对象（1）.type属性 用于获取事件类型 （2）.srcElement属性 用于获取事件目标 （3）.cancelBubble()方法 用于阻止事件冒泡 设置为true表示阻止冒泡，设置为false表示不阻止冒泡 （4）.returnValue()方法 阻止事件的默认行为 设置为false表示阻止事件的默认行为 四、事件类型1.鼠标事件onmousedown:在用户按下任何鼠标按钮时触发 onmousemove:当鼠标指针在元素内部移动时重复地触发 onmouseup:当用户释放鼠标按钮时触发 鼠标事件都是在浏览器窗口中的特定位置上发生的。这个位置信息保存在事件的clientX和clientY属性中。所有浏览器都支持这俩个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。不包括页面滚动的距离。 2.键盘事件keyDown：当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件 keyPress:当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件 keyUp:当用户释放键盘上的键时触发]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Css 单位]]></title>
    <url>%2F2017%2F08%2F18%2FCss3%2FCss%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[前言除了平时经常使用的 px 、rem，Css 其实还提供了很多单位，接下来看一看吧~ px 像素 一个固定大小的单元 rem CSS3 新增，相对于根元素 html 文字大小 本质是等比缩放 使用：根元素 html 中写固定像素或百分比：1rem = 16px，再在具体元素上设置rem em 相对于父元素 文字大小 如果父元素设置了字体大小，1em = 1/父元素文字大小；没有设置，则使用浏览器 body 默认字体大小 16px 如果自身设置了字体大小，em 相对于自身，1em = 1/自身字体大小 vw 与 vh 视窗宽度 与 视窗高度 1vw = 视窗宽度的 1% 1vh = 视窗高度的 1% ie11 以上都兼容 vmin 与 vmax vmin：vm、vh 较小的那个 vmax：vm、vh 较大的那个 ie11不兼容 其它 单位 描述 % 百分比 in 寸 cm 厘米 mm 毫米 pt: point 大约 1/72 寸 pc: pica 大约 6 pt, 1/6 寸 ex 以“x”字符为基准在无法确定x高度的情况下以0.5em计算IE11及以下均不支持，firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀 ch 以“0”字符为基准找不到时为0.5emie10+,chrome31+,safair7.1+,opera26+,ios safari 7.1+,android browser4.4+支]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>单位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylus]]></title>
    <url>%2F2017%2F08%2F18%2FCss3%2Fstylus%2F</url>
    <content type="text"><![CDATA[一、选择器(1).使用缩排和凹排代替花括号{以及}123456789body color whitebody &#123; color: #fff;&#125;body color: white(2).允许你使用逗号为多个选择器同时定义属性 1234567textarea, input border 1px solid #eeetextarea,input &#123; border: 1px solid #eee;&#125; 唯一的例外就是长得像属性的选择器。例如，下面的foo bar baz可能是个属性或者是选择器。 123foo bar baz&gt; input border 1px solid 为解决这个原因，我们可以在尾部加个逗号： 1234foo bar baz,form input,&gt; a border 1px solid (3).字符&amp;指向父选择器。 1234567891011121314textareainput color #A7A7A7 &amp;:hover color #000textarea,input &#123; color: #a7a7a7;&#125;textarea:hover,input:hover &#123; color: #000;&#125; (4).unquote() 处理Stylus无法处理的属性值 123filter unquote(&apos;progid:DXImageTransform.Microsoft.BasicImage(rotation=1)&apos;)filter progid:DXImageTransform.Microsoft.BasicImage(rotation=1) 二、变量(1).可以指定表达式为变量，然后在我们的样式中贯穿使用 1234567font-size = 14pxbody font font-size Arial, sans-seribody &#123; font: 14px Arial, sans-serif;&#125; (2).变量甚至可以组成一个表达式列表 12345678font-size = 14pxfont = font-size &quot;Lucida Grande&quot;, Arialbody font font sans-serifbody &#123; font: 14px &quot;Lucida Grande&quot;, Arial sans-serif;&#125; (3).不需要分配值给变量就可以定义引用属性。 12345678#logo position: absolute top: 50% left: 50% width: 150px height: 80px margin-left: -(@width / 2) margin-top: -(@height / 2) 三、插值通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。 1234567891011121314151617181920table for row in 1 2 3 4 5 tr:nth-child(&#123;row&#125;) height: 10px * rowtable tr:nth-child(1) &#123; height: 10px;&#125;table tr:nth-child(2) &#123; height: 20px;&#125;table tr:nth-child(3) &#123; height: 30px;&#125;table tr:nth-child(4) &#123; height: 40px;&#125;table tr:nth-child(5) &#123; height: 50px;&#125; 四、运算符当在属性值内使用/时候，你必须用括号包住。 1font: (14px/1.5); 五、Mixins 混合书写混入和函数定义方法一致，但是应用却大相径庭。 下面有定义的border-radius(n)方法，其却作为一个mixin（如，作为状态调用，而非表达式）调用。 当border-radius()选择器中调用时候，属性会被扩展并复制在选择器中。 12345678910111213border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius form input[type=button] border-radius(5px)编译成：form input[type=button] &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;&#125; 注意到我们混合书写中的border-radius当作了属性，而不是一个递归函数调用 1234border-radius() -webkit-border-radius arguments -moz-border-radius arguments border-radius arguments 六、方法(1).返回值 12345678910111213很简单的例子，两数值相加的方法：add(a, b) a + b我们可以在特定条件下使用该方法，如在属性值中：body padding add(10px, 5)渲染：body &#123; padding: 15px;&#125; (2).默认参数可选参数往往有个默认的给定表达。在Stylus中，我们甚至可以超越默认参数。 1234567891011121314例如：add(a, b = a) a + badd(10, 5)// =&gt; 15add(10)// =&gt; 20注意：因为参数默认是赋值，我们可可以使用函数调用作为默认值。add(a, b = unit(a, px)) a + b (3).函数体通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。 1234567add(a, b = a) a = unit(a, px) b = unit(b, px) a + badd(15%, 10deg)// =&gt; 25 (4).变量函数我们可以把函数当作变量传递到新的函数中。例如，invoke()接受函数作为参数，因此，我们可以传递add()以及sub(). 123456789101112131415invoke(a, b, fn) fn(a, b)add(a, b) a + bbody padding invoke(5, 10, add) padding invoke(5, 10, sub)结果：body &#123; padding: 15; padding: -5;&#125; (5).参数 12345678910arguments是所有函数体都有的局部变量，包含传递的所有参数。例如：sum() n = 0 for num in arguments n = n + numsum(1,2,3,4,5)// =&gt; 15 七、关键字Stylus支持关键字参数，或”kwargs”. 允许你根据相关参数名引用参数。 12345678910111213body &#123; color: rgba(255, 200, 100, 0.5); color: rgba(red: 255, green: 200, blue: 100, alpha: 0.5); color: rgba(alpha: 0.5, blue: 100, red: 255, 200); color: rgba(alpha: 0.5, blue: 100, 255, 200);&#125;等同于：body &#123; color: rgba(255,200,100,0.5); color: rgba(255,200,100,0.5); color: rgba(255,200,100,0.5); color: rgba(255,200,100,0.5);&#125; 查看函数或混合书写中接受的参数，可以使用p()方法。 123p(rgba)生成：inspect: rgba(red, green, blue, alpha) 八、内置方法Stylus支持name…形式的其余参数。这些参数可以消化传递给混写或函数的参数们。这在处理浏览器私有属性，如-moz或-webkit的时候很管用。 12345678910111213box-shadow() -webkit-box-shadow arguments -moz-box-shadow arguments box-shadow argumentsbody box-shadow #ddd 1px 1px, #eee 2px 2pxbody &#123; -webkit-box-shadow: #ddd 1px 1px, #eee 2px 2px; -moz-box-shadow: #ddd 1px 1px, #eee 2px 2px; box-shadow: #ddd 1px 1px, #eee 2px 2px;&#125; 九、注释Stylus支持三种注释，单行注释，多行注释，以及多行缓冲注释。 (1).单行注释跟JavaScript一样，双斜杠，CSS中不输出。 123// 我是注释!body padding 5px // 蛋疼的padding (2).多行注释多行注释看起来有点像CSS的常规注释。然而，它们只有在compress选项未启用的时候才会被输出。 123456/* * 给定数值合体 */add(a, b) a + b (3).多行缓冲注释跟多行注释类似，不同之处在于开始的时候，这里是/*!. 这个相当于告诉Stylus压缩的时候这段无视直接输出。 123456/*! * 给定数值合体 */add(a, b) a + b 十、条件十一、迭代十二、@import十三、@media123456789101112@media print #header #footer display none生成为：@media print &#123; #header, #footer &#123; display: none; &#125;&#125; 十四、@font-face12345678910111213141516@font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf).ingeo font-family Geo生成为：@font-face &#123; font-family: Geo; font-style: normal; src: url(&quot;fonts/geo_sans_light/GensansLight.ttf&quot;);&#125;.ingeo &#123; font-family: Geo;&#125; 十五、@keyframes1234567891011121314151617181920212223242526272829303132333435363738394041424344@keyframes pulse0% background-color red opacity 1.0 -webkit-transform scale(1.0) rotate(0deg)33% background-color blue opacity 0.75 -webkit-transform scale(1.1) rotate(-5deg)67% background-color green opacity 0.5 -webkit-transform scale(1.1) rotate(5deg)100% background-color red opacity 1.0 -webkit-transform scale(1.0) rotate(0deg)生成为：@-webkit-keyframes pulse &#123; 0% &#123; background-color: red; opacity: 1; -webkit-transform: scale(1) rotate(0deg); &#125; 33% &#123; background-color: blue; opacity: 0.75; -webkit-transform: scale(1.1) rotate(-5deg); &#125; 67% &#123; background-color: green; opacity: 0.5; -webkit-transform: scale(1.1) rotate(5deg); &#125; 100% &#123; background-color: red; opacity: 1; -webkit-transform: scale(1) rotate(0deg); &#125;&#125; 十六、@extend12345678910111213141516171819message,.warning &#123; padding: 10px; border: 1px solid #eee;&#125;.warning &#123; color: #E2E21E;&#125;.message &#123; padding: 10px; border: 1px solid #eee;&#125;.warning &#123; @extend .message; color: #E2E21E;&#125; 十七、url()十八、字面量css如果遇到Stylus搞不定的特殊需求，你可以使用@css使其作为CSS字面量解决之。 123456789@css &#123; body &#123; font: 14px; &#125;&#125;编译为：body &#123; font: 14px;&#125; 十九、CSS样式解析支持css,stylus 二十、使用1#npm -g stylus 在.styl文件夹中 stylus &lt;demo.styl&gt; demo.css 1stylus -w demo.styl -o demo.css]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Css预处理器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动事件]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2F%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[实现滚动超过一定高度，出现图标，点击回到顶部 window.onscroll函数，获取document.body.scrollTop即滚动条高度，当滚动条高度超过特定高度，小图标显示，否则隐藏（一定要设置else) 123456789window.onscroll = function()&#123; var top = document.body.scrollTop; var triangle = document.getElementById(&apos;triangle bottom&apos;); if( top &gt;500 )&#123; triangle.style.display = &apos;block&apos;; &#125;else&#123; triangle.style.display = &apos;none&apos;; &#125; &#125; 点击盒子，window.scroll(0,0) 回到顶端]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>滚动事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue(1) 内部指令]]></title>
    <url>%2F2017%2F08%2F18%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue(1)%20%E5%86%85%E9%83%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.走起我的vue2.0live-server使用用npm进行全局安装1npm install live-server -g在项目目录中打开1live-server2.v-if v-else v-show v-if 和v-show的区别： v-if： 判断是否加载，可以减轻服务器的压力，在需要时加载。 v-show：调整css dispaly属性，可以使客户端操作更加流畅。 3.v-for数字排序 123456789computed:&#123; sortItems:function()&#123; return this.items.sort(sortNumber); &#125;&#125; function sortNumber(a,b)&#123; return a-b &#125; 对象循环输出 123456789101112//数组对象方法排序:function sortByKey(array,key)&#123; return array.sort(function(a,b)&#123; var x=a[key]; var y=b[key]; return ((x&lt;y)?-1:((x&gt;y)?1:0)); &#125;);&#125;sortStudent:function()&#123; return sortByKey(this.students,&apos;age&apos;);&#125; 4.v-text &amp; v-html123&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;=&lt;span v-text=&quot;message&quot;&gt;&lt;/span&gt;&lt;span v-html=&quot;msgHtml&quot;&gt;&lt;/span&gt; 需要注意的是：在生产环境中动态渲染HTML是非常危险的，因为容易导致XSS攻击。所以只能在可信的内容上使用v-html，永远不要在用户提交和可操作的网页上使用。 5.v-on：绑定事件监听器1v-on: = @ ps:文本框的数字会默认转变成字符串，所以我们需要用parseInt()函数进行整数转换。 6.v-model指令绑定数据源。就是把数据绑定在特定的表单元素上，可以很容易的实现双向数据绑定。 7.v-bind指令缩写 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; 8.v-pre&amp;v-cloak&amp;v-oncev-pre1&lt;div v-pre&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 这时并不会输出我们的message值，而是直接在网页中显示 v-cloak在vue渲染完指定的整个DOM后才进行显示。它必须和CSS样式一起使用， 1234567[v-cloak] &#123; display: none;&#125;&lt;div v-cloak&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; v-once在第一次DOM时进行渲染，渲染完成后视为静态内容，跳出以后的渲染过程。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue(2) 全局API]]></title>
    <url>%2F2017%2F08%2F18%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue(2)%20%E5%85%A8%E5%B1%80API%2F</url>
    <content type="text"><![CDATA[1.Vue.directive 自定义指令什么是全局API？在构造器外部用Vue提供给我们的API函数来定义新的功能。自定义指令中传递的三个参数el: 指令所绑定的元素，可以用来直接操作DOM。binding: 一个对象，包含指令的很多信息。 vnode: Vue编译生成的虚拟节点。 自定义指令的生命周期自定义指令有五个生命周期（也叫钩子函数），分别是 bind,inserted,update,componentUpdated,unbind bind:只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。 inserted:被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。 update:被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 componentUpdated:被绑定元素所在模板完成一次更新周期时调用。 unbind:只调用一次，指令与元素解绑时调用。 2.Vue.extend构造器的延伸什么是Vue.extend？以简单理解为当在模板中遇到该组件名称作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂载到自定义元素上。 3.Vue.set全局操作就是在构造器外部操作构造器内部的数据、属性或者方法。 引用构造器外部数据什么是外部数据，就是不在Vue构造器里里的data处声明，而是在构造器外部声明，然后在data处引用就可以了。 为什么要有Vue.set的存在?由于Javascript的限制，Vue不能自动检测以下变动的数组。 *当你利用索引直接设置一个项时，vue不会为我们自动更新。 *当你修改数组的长度时，vue不会为我们自动更新。 4.Vue的生命周期（钩子函数）5.Template 制作模版1.直接写在选项里的模板直接在构造器里的template选项后边编写。这种写法比较直观，但是如果模板html代码太多，不建议这么写。 123456789var app=new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&apos;hello Vue!&apos; &#125;, template:` &lt;h1 style=&quot;color:red&quot;&gt;我是选项模板&lt;/h1&gt; `&#125;) 2.写在这种写法更像是在写HTML代码，就算不会写Vue的人，也可以制作页面 12345678910111213&lt;template id=&quot;demo2&quot;&gt; &lt;h2 style=&quot;color:red&quot;&gt;我是template标签模板&lt;/h2&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app=new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&apos;hello Vue!&apos; &#125;, template:&apos;#demo2&apos; &#125;)&lt;/script&gt; 3.写在标签里的模板这种写模板的方法，可以让模板文件从外部引入。 12345678910111213&lt;script type=&quot;x-template&quot; id=&quot;demo3&quot;&gt; &lt;h2 style=&quot;color:red&quot;&gt;我是script标签模板&lt;/h2&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app=new Vue(&#123; el:&apos;#app&apos;, data:&#123; message:&apos;hello Vue!&apos; &#125;, template:&apos;#demo3&apos; &#125;)&lt;/script&gt; 6.Component 初识组件组件就是制作自定义的标签，这些标签在HTML中是没有的。 1.全局化注册组件全局化就是在构造器的外部用Vue.component来注册 2.局部注册组件部注册组件和全局注册组件是向对应的，局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。 但是你需要注意的是，构造器里的components 是加s的，而全局注册是不加s的。 3.组件和指令的区别组件注册的是一个标签，而指令注册的是已有标签里的一个属性。 7.Component 组件props 属性设置props选项就是设置和获取标签上的属性值的 1.定义属性并获取属性值定义属性我们需要用props选项，加上数组形式的属性名称，例如：props:[‘here’]。在组件的模板里读出属性值只需要用插值的形式，例如. 2.属性中带’-‘的处理方式小驼峰式写法 3.在构造器里向组件中传值把构造器中data的值传递给组件，我们只要进行绑定就可以了。 8.Component 父子组件关系在实际开发中我们经常会遇到在一个自定义组件中要使用其他自定义组件，这就需要一个父子组件关系。 1.构造器外部写局部注册组件2.父子组件的嵌套 9.Component 标签标签是Vue框架自定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jquery(一)样式篇]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2FjQuery%2Fjquery(%E4%B8%80)%E6%A0%B7%E5%BC%8F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1.$(document).ready作用是等页面的文档（document）中的节点都加载完毕后，再执行后续的代码，因为我们在执行代码的时候，可能会依赖页面的某一个元素，我们要确保这个元素真正的的被加载完毕后才能正确的使用。 2.jQuery对象与DOM对象通过一个简单的例子，简单区分下jQuery对象与DOM对象：我们要获取页面上这个id为imooc的p元素，然后给这个文本节点增加一段文字：“您好！通过慕课网学习jQuery才是最佳的途径”，并且让文字颜色变成红色。 普通处理，通过标准JavaScript处理： v 123ar p = document.getElementById(&apos;imooc&apos;);p.innerHTML = &apos;您好！通过慕课网学习jQuery才是最佳的途径&apos;;p.style.color = &apos;red&apos;; 通过原生DOM模型提供的document.getElementById(“imooc”) 方法获取的DOM元素就是一个DOM对象，再通过innerHTML与style属性处理文本与颜色。 jQuery的处理： 12var $p = $(&apos;#imooc&apos;);$p.html(&apos;您好！通过慕课网学习jQuery才是最佳的途径&apos;).css(&apos;color&apos;,&apos;red&apos;); 通过$(‘#imooc’)方法会得到一个$p的jQuery对象，$p是一个类数组对象。这个对象里面包含了DOM对象的信息，然后封装了很多操作方法，调用自己的方法html与css，得到的效果与标准的JavaScript处理结果是一致的。 3.jQuery对象转化成DOM对象在很多场景中，我们需要jQuery与DOM能够相互的转换，它们都是可以操作的DOM元素，jQuery是一个类数组对象，而DOM对象就是一个单独的DOM元素。 如何把jQuery对象转成DOM对象？ (1).利用数组下标的方式读取到jQuery中的DOM对象HTML代码 元素一 元素二 元素三JavaScript代码 123var $div = $(&apos;div&apos;) //jQuery对象var div = $div[0] //转化成DOM对象div.style.color = &apos;red&apos; //操作dom对象的属性 用jQuery找到所有的div元素（3个），因为jQuery对象也是一个数组结构，可以通过数组下标索引找到第一个div元素，通过返回的div对象，调用它的style属性修改第一个div元素的颜色。这里需要注意的一点是，数组的索引是从0开始的，也就是第一个元素下标是0 (2).通过jQuery自带的get()方法jQuery对象自身提供一个.get() 方法允许我们直接访问jQuery对象中相关的DOM节点，get方法中提供一个元素的索引： 123var $div = $(&apos;div&apos;) //jQuery对象var div = $div.get(0) //通过get方法，转化成DOM对象div.style.color = &apos;red&apos; //操作dom对象的属性 其实我们翻开源码，看看就知道了，get方法就是利用的第一种方式处理的，只是包装成一个get让开发者更直接方便的使用。 4.DOM对象转化成jQuery对象相比较jQuery转化成DOM，开发中更多的情况是把一个dom对象加工成jQuery对象。$(参数)是一个多功能的方法，通过传递不同的参数而产生不同的作用。 如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象 通过$(dom)方法将普通的dom对象加工成jQuery对象之后，我们就可以调用jQuery的方法了 HTML代码 元素一 元素二 元素三JavaScript代码 1234var div = document.getElementsByTagName(&apos;div&apos;); //dom对象var $div = $(div); //jQuery对象var $first = $div.first(); //找到第一个div元素$first.css(&apos;color&apos;, &apos;red&apos;); //给第一个元素设置颜色 通过getElementsByTagName获取到所有div节点的元素，结果是一个dom合集对象，不过这个对象是一个数组合集(3个div元素)。通过$(div)方法转化成jQuery对象，通过调用jQuery对象中的first与css方法查找第一个元素并且改变其颜色。 5.jQuery选择器之id选择器1$( &quot;#id&quot; ) id是唯一的，每个id值在一个页面中只能使用一次。如果多个元素分配了相同的id，将只匹配该id选择集合的第一个DOM元素。但这种行为不应该发生;有超过一个元素的页面使用相同的id是无效的 6.jQuery选择器之类选择器1$( &quot;.class&quot; ) 7.jQuery选择器之元素选择器1$( &quot;element&quot; ) 8.jQuery选择器之全选择器（*选择器）1$( &quot;*&quot; ) 9.jQuery选择器之层级选择器 层级选择器都有一个参考节点 后代选择器包含子选择器的选择的内容 一般兄弟选择器包含相邻兄弟选择的内容 相邻兄弟选择器和一般兄弟选择器所选择到的元素，必须在同一个父元素下10.jQuery选择器之基本筛选选择器 :eq(), :lt(), :gt(), :even, :odd 用来筛选他们前面的匹配表达式的集合元素，根据之前匹配的元素在进一步筛选，注意jQuery合集都是从0开始索引 gt是一个段落筛选，从指定索引的下一个开始，gt(1) 实际从2开始11.jQuery选择器之内容筛选选择器 :contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。 :parent与:empty是相反的，两者所涉及的子元素，包括文本节点12.jQuery选择器之可见性筛选选择器 元素可以被认为是隐藏的几个情况： 他们的CSS display值是none。 他们是type=”hidden”的表单元素。 它们的宽度和高度都显式设置为0。 一个祖先元素是隐藏的，因此该元素是不会在页面上显示。13.jQuery选择器之属性筛选选择器 在这么多属性选择器中[attr=”value”]和[attr*=”value”]是最实用的 12[attr=&quot;value&quot;]能帮我们定位不同类型的元素，特别是表单form元素的操作，比如说input[type=&quot;text&quot;],input[type=&quot;checkbox&quot;]等[attr*=&quot;value&quot;]能在网站中帮助我们匹配不同类型的文件 14.jQuery选择器之子元素筛选选择器子元素筛选选择器不常使用，其筛选规则比起其它的选择器稍微要复杂点 :first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1) :last 只匹配一个单独的元素， :last-child 选择器可以匹配多个元素：即，为每个父级元素匹配最后一个子元素 如果子元素只有一个的话，:first-child与:last-child是同一个 :only-child匹配某个元素是父元素中唯一的子元素，就是说当前子元素是父元素中唯一的元素，则匹配 jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的 nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算15.jQuery选择器之表单元素选择器 除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。大部分表单类别筛选器可以使用属性筛选器替换。比如 $(‘:password’) == $(‘[type=password]’) 16.jQuery选择器之表单对象属性筛选选择器 选择器适用于复选框和单选框，对于下拉框元素, 使用 :selected 选择器 在某些浏览器中，选择器:checked可能会错误选取到元素，所以保险起见换用选择器input:checked，确保只会选取元素17.jQuery选择器之特殊选择器this 1234567891011121314HTMLp.addEventListener(&apos;click&apos;,function()&#123; //this === p //以下两者的修改都是等价的 this.style.color = &quot;red&quot;; p.style.color = &quot;red&quot;;&#125;,false); this.style.color = &quot;red&quot;$(&apos;p&apos;).click(function()&#123; //把p元素转化成jQuery的对象 var $this= $(this) $this.css(&apos;color&apos;,&apos;red&apos;)&#125;) this，表示当前的上下文对象是一个html对象，可以调用html对象所拥有的属性和方法。$(this),代表的上下文对象是一个jquery的上下文对象，可以调用jQuery的方法和属性值。 18.jQuery的属性与样式之.attr()与.removeAttr()(1).attr()有4个表达式 attr(传入属性名)：获取属性的值 attr(属性名, 属性值)：设置属性的值 attr(属性名,函数值)：设置属性的函数值 attr(attributes)：给指定元素设置多个属性值，即：{属性名一: “属性值一” , 属性名二: “属性值二” , … … }(2).removeAttr()删除方法.removeAttr( attributeName ) : 为匹配的元素集合中的每个元素中移除一个属性（attribute） (3).注意的问题dom中有个概念的区分：Attribute和Property翻译出来都是“属性”，《js高级程序设计》书中翻译为“特性”和“属性”。简单理解，Attribute就是dom节点自带的属性 获取Attribute就需要用attr，获取Property就需要用prop 19.jQuery的属性与样式之html()及.text()读取、修改元素的html结构或者元素的文本内容是常见的DOM操作，jQuery针对这样的处理提供了2个便捷的方法.html()与.text() (1).html()方法获取集合中第一个匹配元素的HTML内容 或 设置每一个匹配元素的html内容，具体有3种用法： .html() 不传入值，就是获取集合中第一个匹配元素的HTML内容 .html( htmlString ) 设置每一个匹配元素的html内容 .html( function(index, oldhtml) ) 用来返回设置HTML内容的一个函数(2).注意事项：.html()方法内部使用的是DOM的innerHTML属性来处理的，所以在设置与获取上需要注意的一个最重要的问题，这个操作是针对整个HTML内容（不仅仅只是文本内容） (3).text()方法得到匹配元素集合中每个元素的文本内容结合，包括他们的后代，或设置匹配元素集合中每个元素的文本内容为指定的文本内容。，具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本，包括他们的后代 .text( textString ) 用于设置匹配元素内容的文本 .text( function(index, text) ) 用来返回设置文本内容的一个函数(4).注意事项：.text()结果返回一个字符串，包含所有匹配元素的合并文本 (5).html与.text的异同: .html与.text的方法操作是一样，只是在具体针对处理对象不同 .html处理的是元素内容，.text处理的是文本内容 .html只能使用在HTML文档中，.text 在XML 和 HTML 文档中都能使用 如果处理的对象只有一个子文本节点，那么html处理的结果与text是一样的 火狐不支持innerText属性，用了类似的textContent属性，.text()方法综合了2个属性的支持，所以可以兼容所有浏览器20.jQuery的属性与样式之.val()jQuery中有一个.val()方法主要是用于处理表单元素的值，比如 input, select 和 textarea。 (1).val()方法 .val()无参数，获取匹配的元素集合中第一个元素的当前值 .val( value )，设置匹配的元素集合中每个元素的值 .val( function ) ，一个用来返回设置值的函数 (2)注意事项： 通过.val()处理select元素， 当没有选择项被选中，它返回null .val()方法多用来设置表单的字段的值 如果select元素有multiple（多选）属性，并且至少一个选择项被选中， .val()方法返回一个数组，这个数组包含每个选中选择项的值 (3).html(),.text()和.val()的差异总结： .html(),.text(),.val()三种方法都是用来读取选定元素的内容；只不过.html()是用来读取元素的html内容（包括html标签），.text()用来读取元素的纯文本内容，包括其后代元素，.val()是用来读取表单元素的”value”值。其中.html()和.text()方法不能使用在表单元素上,而.val()只能使用在表单元素上；另外.html()方法使用在多个元素上时，只读取第一个元素；.val()方法和.html()相同，如果其应用在多个元素上时，只能读取第一个表单元素的”value”值，但是.text()和他们不一样，如果.text()应用在多个元素上时，将会读取所有选中元素的文本内容。 .html(htmlString),.text(textString)和.val(value)三种方法都是用来替换选中元素的内容，如果三个方法同时运用在多个元素上时，那么将会替换所有选中元素的内容。 .html(),.text(),.val()都可以使用回调函数的返回值来动态的改变多个元素的内容。 21.jQuery的属性与样式之增加样式.addClass()通过动态改变类名（class），可以让其修改元素呈现出不同的效果。在HTML结构中里，多个class以空格分隔，当一个节点（或称为一个标签）含有多个class时，DOM元素响应的className属性获取的不是class名称的数组，而是一个含有空格的字符串，这就使得多class操作变得很麻烦。同样的jQuery开发者也考虑到这种情况，增加了一个.addClass()方法，用于动态增加class类名 (1).addClass( className )方法 .addClass( className ) : 为每个匹配元素所要增加的一个或多个样式名 .addClass( function(index, currentClass) ) : 这个函数返回一个或更多用空格隔开的要增加的样式名(2).注意事项：.addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上(3).简单的描述下：在p元素增加一个newClass的样式 12&lt;p class=&quot;orgClass&quot;&gt;$(&quot;p&quot;).addClass(&quot;newClass&quot;) 那么p元素的class实际上是 class=”orgClass newClass”样式只会在原本的类上继续增加，通过空格分隔 22.jQuery的属性与样式之删除样式.removeClass()jQuery通过.addClass()方法可以很便捷的增加样式。如果需要样式之间的切换，同样jQuery提供了一个很方便的.removeClass()，它的作用是从匹配的元素中删除全部或者指定的class (1).removeClass( )方法 .removeClass( [className ] )：每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) ) ： 一个函数，返回一个或多个将要被移除的样式名(2).注意事项如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除 23.jQuery的属性与样式之切换样式.toggleClass()在做某些效果的时候，可能会针对同一节点的某一个样式不断的切换，也就是addClass与removeClass的互斥切换，比如隔行换色效果 jQuery提供一个toggleClass方法用于简化这种互斥的逻辑，通过toggleClass方法动态添加删除Class，一次执行相当于addClass，再次执行相当于removeClass (1).toggleClass( )方法：在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类 .toggleClass( className )：在匹配的元素集合中的每个元素上用来切换的一个或多个（用空格隔开）样式类名 .toggleClass( className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass( [switch ] )：一个用来判断样式类添加还是移除的 布尔值 .toggleClass( function(index, class, switch) [, switch ] )：用来返回在匹配的元素集合中的每个元素上用来切换的样式类名的一个函数。接收元素的索引位置和元素旧的样式类作为参数(2).注意事项： toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加 toggleClass会保留原有的Class名后新增，通过空格隔开 24.jQuery的属性与样式之样式操作.css()通过JavaScript获取dom元素上的style属性，我们可以动态的给元素赋予样式属性。在jQuery中我们要动态的修改style属性我们只要使用css()方法就可以实现了 .css() 方法：获取元素样式属性的计算值或者设置元素的CSS属性 (1).获取： .css( propertyName ) ：获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames )：传递一组数组，返回一个对象结果 (2).设置：.css(propertyName, value )：设置CSS 12css(“background-color”,”red”)css(“backgroundColor”,”yellow”) .css( propertyName, function )：可以传入一个回调函数，返回取到对应的值进行处理 .css( properties )：可以传一个对象，同时设置多个样式 12345css(&#123; &apos;font-size&apos; :&quot;15px&quot;, &quot;background-color&quot; :&quot;#40E0D0&quot;, &quot;border&quot; :&quot;1px solid red&quot;&#125;) (3).注意事项： 浏览器属性获取方式不同，在获取某些值的时候都jQuery采用统一的处理，比如颜色采用RBG，尺寸采用px .css()方法支持驼峰写法与大小写混搭的写法，内部做了容错的处理 当一个数只被作为值（value）的时候， jQuery会将其转换为一个字符串，并添在字符串的结尾处添加px，例如 .css(“width”,50}) 与 .css(“width”,”50px”})一样 25.jQuery的属性与样式之.css()与.addClass()设置样式的区别(1).可维护性：.addClass()的本质是通过定义个class类的样式规则，给元素添加一个或多个类。css方法是通过JavaScript大量代码进行改变元素的样式 通过.addClass()我们可以批量的给相同的元素设置统一规则，变动起来比较方便，可以统一修改删除。如果通过.css()方法就需要指定每一个元素是一一的修改，日后维护也要一一的修改，比较麻烦 (2).灵活性：通过.css()方式可以很容易动态的去改变一个样式的属性，不需要在去繁琐的定义个class类的规则。一般来说在不确定开始布局规则，通过动态生成的HTML代码结构中，都是通过.css()方法处理的 (3).样式值：.addClass()本质只是针对class的类的增加删除，不能获取到指定样式的属性的值，.css()可以获取到指定的样式值。 (4).样式的优先级通过.css方法设置的样式属性优先级要高于.addClass方法 (5).总结.addClass与.css方法各有利弊，一般是静态的结构，都确定了布局的规则，可以用addClass的方法，增加统一的类规则 如果是动态的HTML结构，在不确定规则，或者经常变化的情况下，一般多考虑.css()方式 26.jQuery的属性与样式之元素的数据存储.data( key, value ) //实例接口,存数据.data( key ) //实例接口,存数据 删除 jQuery.removeData( element [, name ] ).removeData( [name ] )]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue(3) 构造器里的选项]]></title>
    <url>%2F2017%2F08%2F18%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue(3)%20%E6%9E%84%E9%80%A0%E5%99%A8%E9%87%8C%E7%9A%84%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[1.propsData Option 全局扩展的数据传递他用在全局扩展时进行传递数据。总结：propsData在实际开发中我们使用的并不多，我们在后边会学到Vuex的应用，他的作用就是在单页应用中保持状态和数据的。 2.computed Option 计算选项computed 的作用主要是对原数据进行改造输出。改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号。。。 3.Methods Option 方法选项1.methods中参数的传递2.methods中的$event参数传递的$event参数都是关于你点击鼠标的一些事件和属性。 3.native 给组件绑定构造器里的原生事件。在实际开发中经常需要把某个按钮封装成组件，然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。就需要用到我们的.native修饰器了。 4.作用域外部调用构造器里的方法这种不经常使用，如果你出现了这种情况，说明你的代码组织不够好。 4.Watch 选项 监控数据数据变化的监控经常使用 5.Mixins 混入选项操作Mixins一般有两种用途： 1、在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。 2、很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 1.mixins的调用顺序从执行的先后顺序来说，都是混入的先执行，然后构造器里的再执行，需要注意的是，这并不是方法的覆盖，而是被执行了两边。 PS：当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。 2.全局API混入方式我们也可以定义全局的混入，这样在需要这段代码的地方直接引入js，就可以拥有这个功能了。 PS：全局混入的执行顺序要前于混入和构造器里的方法。 6.Extends Option 扩展选项1.通过外部增加对象的形式，对构造器进行扩展。它和我们上节课讲的混入非常的类似。 2.delimiters 选项elimiters的作用是改变我们插值的符号。Vue默认的插值是双大括号。但有时我们会有需求更改这个插值的形式。 1delimiters:[&apos;$&#123;&apos;,&apos;&#125;&apos;]]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue(4) 实例和内置组件]]></title>
    <url>%2F2017%2F08%2F18%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue(4)%20%E5%AE%9E%E4%BE%8B%E5%92%8C%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[实例就是在构造器外部操作构造器内部的属性选项或者方法，就叫做实例？实例的作用就是给原生的或者其他javascript框架一个融合的接口或者说是机会，让Vue和其他框架一起使用。1.实例入门-实例属性2.实例方法 1.$mount方法$mount方法是用来挂载我们的扩展的 2.$destroy() 卸载方法用$destroy()进行卸载。 3.$forceUpdate() 更新方法4.$nextTick() 数据修改方法当Vue构造器里的data值被修改完成后会调用这个方法，也相当于一个钩子函数吧，和构造器里的updated生命周期很像。 3.实例事件实例事件就是在构造器外部写一个调用构造器内部的方法。这样写的好处是可以通过这种写法在构造器外部调用构造器内部的数据。 1.$on 在构造器外部添加事件。2.$once执行一次的事件3.$off关闭事件4.内置组件 -slot讲解slot是标签的内容扩展，也就是说你用slot就可以在自定义组件时传递给组件内容，组件接收内容并输出。 slot的使用需要两步： 在HTML的组件中用slot属性传递值。 在组件模板中用标签接收值。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js进阶知识]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2Fjs%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[一、变量名1.命名1.必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。 2.变量名区分大小写，如:A与a是两个不同变量。 3.不允许使用JavaScript关键字和保留字做变量名。 2.声明12var mynum ; //声明一个变量mynumvar num1,mun2 ; //声明一个变量num1 3.变量赋值= 是赋值，==是等于号 123var num1 = 123; // 123是数值var num2 = &quot;一二三&quot;; //&quot;一二三&quot;是字符串var num3=true; //布尔值true（真），false(假) 二、数组1.二维数组12345678var myarr=new Array(); //先声明一维 for(var i=0;i&lt;2;i++)&#123; //一维长度为2 myarr[i]=new Array(); //再声明二维 for(var j=0;j&lt;3;j++)&#123; //二维长度为3 myarr[i][j]=i+j; // 赋值，每个数组元素的值为i+j &#125; &#125;var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]] 三、鼠标事件1.onfocus（获得焦点事件）当一个文本框获得焦点时，它里面的文本就像“好123”网站上的百度搜索输入框那样全部被自动选中，这样的操作可以利用onfocus来实现。 以下的文本框，当鼠标指针移过去时，里面的文字全部被选中： 请输入网址 这是怎么做的呢？看以下代码及解释： 1&lt;input type=&quot;text&quot;name=&quot;url&quot; value=&quot;http://www.gxblk.com&quot; size=&quot;30&quot;onmousemove=&quot;this.focus();this.select();&quot;&gt; 代码里，input标签内嵌入了onmousemove（鼠标指针经过）事件的JS语句，其等号后面的this.focus()意为其自身获得焦点；获得焦点的标志是该文本框内将出现输入光标，但要让其内的文字全部被选中，我们还得用上this.select()语句，它的意思就是选中全部文本框里的文字。 2.onblur（失去焦点事件）我们经常会检测文本框是否已经被正确输入，检测工作通常在用户点击了提交按钮之后进行，事实上，利用控件失去焦点的时候，我们就可以实时进行这个检测工作，这样的话，onblur事件就派上用场了。 以下例子有四个文本框，如果还没有任何单击它们当中的任意一个的操作，那么什么事情也不会发生，但是，当你单击了其中的任何一个使其拥有了焦点（输入光标在里面），如果什么都没有输入并且单击了别的地方令其失去焦点，就会弹出一个警告，试试看 姓名 性别 年龄 住址 以下是代码和解释： 表单代码 123456789101112&lt;form name=&quot;blur_test&quot;&gt; &lt;p&gt;姓名 &lt;input type=&quot;text&quot; name=&quot;name&quot;value=&quot;&quot; size=&quot;30&quot;onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 性别 &lt;inputtype=&quot;text&quot; name=&quot;sex&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 年龄 &lt;inputtype=&quot;text&quot; name=&quot;age&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;br&gt; 住址 &lt;inputtype=&quot;text&quot; name=&quot;addr&quot; value=&quot;&quot;size=&quot;30&quot; onblur=&quot;chkvalue(this)&quot;&gt;&lt;/p&gt; &lt;/form&gt;&lt;scriptlanguage=&quot;javascript&quot;&gt; function chkvalue(txt) &#123; if(txt.value==&quot;&quot;) alert(&quot;文本框里必须填写内容!&quot;); &#125; &lt;/script&gt; 表单代码里，每一个方框框的代码都嵌入一个onblur JS语句，它们都调用后面的JS代码中的自定义函数chkvalue(this)，意思是，当文本框失去焦点时就调用chkvalue()函数；这chkvalue()函数检测文本框是否为空，如果是就弹出警告窗口。该函数有一个参数（txt），对应于前面文本框调用该函数的参数（this）即自身。 3.onselect事件选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。 4.文本框内容改变事件（onchange）通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。 5.加载事件（onload）事件会在页面加载完成后，立即发生，同时执行被调用的程序。 注意： 1、加载页面时，触发onload事件，事件写在标签内。 2、此节的加载页面，可理解为打开一个新页面时。 如下代码,当加载一个新页面时，弹出对话框“加载中，请稍等…”。 支持的标签：, , , , , 提交提交, , ,，写在内监听页面加载，正如写在监听图像加载。 6.卸载事件（onunload）当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。 *注意：不同浏览器对onunload事件支持不同。* 如下代码,当退出页面时，弹出对话框“您确定离开该网页吗？”。 四、 JavaScript内置对象1.Date 日期对象定义一个时间对象 : 1var Udate=new Date(); 使 Udate 成为日期对象，并且已有初始值：当前时间(当前电脑系统时间)。 访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;” (1).返回星期方法getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下: 12345678&lt;script type=&quot;text/javascript&quot;&gt; var mydate=new Date();//定义日期对象 var weekday=[&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;];//定义数组对象,给每个数组项赋值 var mynum=mydate.getDay();//返回值存储在变量mynum中 document.write(mydate.getDay());//输出getDay()获取值 document.write(&quot;今天是：&quot;+ weekday[mynum]);//输出星期几&lt;/script&gt; (2).返回/设置时间方法get/setTime() 返回/设置时间，单位毫秒数，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。 2.String字符串对象(1).toUpperCase()，toLowerCase()使用 String 对象的 toUpperCase() 方法来将字符串小写字母转换为大写,另一个反之 (2).charAt()stringObject.charAt(index)可返回指定位置的字符。返回的字符是长度为 1 的字符串。 (3).字符串分割split()split() 方法将字符串分割为字符串数组，并返回此数组。 1stringObject.split(separator,limit) 注意：如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。 123456789101112var mystr = &quot;www.imooc.com&quot;;document.write(mystr.split(&quot;.&quot;)+&quot;&lt;br&gt;&quot;);document.write(mystr.split(&quot;.&quot;, 2)+&quot;&lt;br&gt;&quot;);www,imooc,comwww,imoocdocument.write(mystr.split(&quot;&quot;)+&quot;&lt;br&gt;&quot;);document.write(mystr.split(&quot;&quot;, 5));w,w,w,.,i,m,o,o,c,.,c,o,mw,w,w,.,i (4).提取字符串substring()substring() 方法用于提取字符串中介于两个指定下标之间的字符 1stringObject.substring(startPos,stopPos) 注意： 返回的内容是从 start开始(包含start位置的字符)到 stop-1 处的所有字符，其长度为 stop 减start。 如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。 如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。(5).提取指定数目的字符substr()substr() 方法从字符串中提取从 startPos位置开始的指定数目的字符串。 1stringObject.substr(startPos,length) 注意： 如果参数startPos是负数，从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。如果startPos为负数且绝对值大于字符串长度，startPos为0。 123string.substring( 起点 ， 终点 )string.substr( 起点 ，长度 ) 3.Math对象Math 对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法。这是它与Date,String对象的区别。 Math 对象属性 Math 对象方法 123456789&lt;script type=&quot;text/javascript&quot;&gt; var mypi=Math.PI; var myabs=Math.abs(-15); document.write(mypi); document.write(myabs);&lt;/script&gt;3.14159265358979315 (1).向上取整ceil()1Math.ceil(x) ceil() 方法可对一个数进行向上取整。x必须是一个数值 注意：它返回的是大于或等于x，并且与x最接近的整数。 (2).向下取整floor()1Math.floor(x) floor() 方法可对一个数进行向下取整。 注意：返回的是小于或等于x，并且与 x 最接近的整数。 (3).四舍五入round()1Math.round(x) round() 方法可把一个数字四舍五入为最接近的整数。 注意： 返回与 x 最接近的整数。 对于 0.5，该方法将进行上舍入。(5.5 将舍入为 6) 如果 x 与两侧整数同等接近，则结果接近 +∞方向的数字值 。(如 -5.5 将舍入为 -5; -5.52 将舍入为 -6) (4).随机数 random()1Math.random(); random() 方法可返回介于 0 ~ 1（大于或等于 0 但小于 1 )之间的一个随机数。 注意：返回一个大于或等于 0 但小于 1 的符号为正的数字值。 4.Array 数组对象(1).数组连接concat()concat() 方法用于连接两个或多个数组。此方法返回一个新数组，不改变原来的数组。 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var mya = new Array(3); mya[0] = &quot;1&quot;; mya[1] = &quot;2&quot;; mya[2] = &quot;3&quot;; document.write(mya.concat(4,5)+&quot;&lt;br&gt;&quot;); document.write(mya); &lt;/script&gt;1,2,3,4,51,2,3 (2).指定分隔符连接数组元素join()join()方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。不改变原来数组 (3).颠倒数组元素顺序reverse()该方法会改变原来的数组，而不会创建新的数组。 (4).选定元素slice()1arrayObject.slice(start,end) 注意： 可使用负值从数组的尾部选取元素。 如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 String.slice() 与 Array.slice() 相似。 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 该方法并不会修改数组，而是返回一个子数组 (5).数组排序sort()1arrayObject.sort(方法函数) 注意 1.如果不指定&lt;方法函数&gt;，则按unicode码顺序排列。 2.如果指定&lt;方法函数&gt;，则按&lt;方法函数&gt;所指定的排序方法排序。 排序函数： 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; function sortNum(a,b) &#123; return a - b; //升序，如降序，把“a - b”该成“b - a”&#125; var myarr = new Array(&quot;80&quot;,&quot;16&quot;,&quot;50&quot;,&quot;6&quot;,&quot;100&quot;,&quot;1&quot;); document.write(myarr + &quot;&lt;br&gt;&quot;); document.write(myarr.sort(sortNum));&lt;/script&gt;80,16,50,6,100,11,6,16,50,80,100 五、浏览器对象window对象是BOM的核心，window对象指当前的浏览器窗口。 window对象方法: 1.计时器在JavaScript中，我们可以在设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行。计时器类型： 一次性计时器：仅在指定的延迟时间之后触发一次。 间隔性触发计时器：每隔一定的时间间隔就触发一次。 计时器方法： (1).setInterval()在执行时,从载入页面后每隔指定的时间执行代码。 1setInterval(代码,交互时间); 参数说明： 代码：要调用的函数或要执行的代码串。 交互时间：周期性执行或调用表达式之间的时间间隔，以毫秒计（1s=1000ms）。 返回值: 一个可以传递给 clearInterval() 从而取消对”代码”的周期性执行的值。 1234调用函数格式(假设有一个clock()函数):setInterval(&quot;clock()&quot;,1000)或setInterval(clock,1000) 我们设置一个计时器，每隔100毫秒调用clock()函数，并将时间显示出来，代码如下: 12345678910111213141516171819&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;计时器&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; var int=setInterval(clock, 100) function clock()&#123; var time=new Date(); document.getElementById(&quot;clock&quot;).value = time; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; id=&quot;clock&quot; size=&quot;50&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; (2).取消计时器clearInterval()clearInterval() 方法可取消由 setInterval() 设置的交互时间。 1clearInterval(id_of_setInterval) 参数说明: id_of_setInterval：由 setInterval() 返回的 ID 值。 每隔 100 毫秒调用 clock() 函数,并显示时间。当点击按钮时，停止时间,代码如下: 123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;title&gt;计时器&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; function clock()&#123; var time=new Date(); document.getElementById(&quot;clock&quot;).value = time; &#125;// 每隔100毫秒调用clock函数，并将返回值赋值给i var i=setInterval(&quot;clock()&quot;,100);&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; id=&quot;clock&quot; size=&quot;50&quot; /&gt; &lt;input type=&quot;button&quot; value=&quot;Stop&quot; onclick=&quot;clearInterval(i)&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; (3).计时器setTimeout()setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次。 1setTimeout(代码,延迟时间); 参数说明： 要调用的函数或要执行的代码串。 延时时间：在执行代码前需等待的时间，以毫秒为单位（1s=1000ms)。 要创建一个运行于无穷循环中的计数器，我们需要编写一个函数来调用其自身。在下面的代码，当按钮被点击后，输入域便从0开始计数。 12345678910111213141516171819&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt;var num=0;function numCount()&#123; document.getElementById(&apos;txt&apos;).value=num; num=num+1; setTimeout(&quot;numCount()&quot;,1000); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt;&lt;input type=&quot;text&quot; id=&quot;txt&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;Start&quot; onClick=&quot;numCount()&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; (4).取消计时器clearTimeout()setTimeout()和clearTimeout()一起使用，停止计时器。 123456789101112131415161718192021222324clearTimeout(id_of_setTimeout)&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot;&gt; var num=0,i; function timedCount()&#123; document.getElementById(&apos;txt&apos;).value=num; num=num+1; i=setTimeout(timedCount,1000); &#125; setTimeout(timedCount,1000); function stopCount()&#123; clearTimeout(i); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Stop&quot; onClick=&quot;stopCount()&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2.History对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能。 注意: 从窗口被打开的那一刻开始记录，每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。 window.history.[属性|方法]（window可以省略。） History 对象属性 History 对象方法 (1).返回前一个浏览的页面back()方法，加载 history 列表中的前一个 URL。 1window.history.back(); 比如，返回前一个浏览的页面，代码如下： 1window.history.back(); 注意：等同于点击浏览器的倒退按钮。 back()相当于go(-1),代码如下: 1window.history.go(-1); (2).返回下一个浏览的页面forward()方法，加载 history 列表中的下一个 URL。 如果倒退之后，再想回到倒退之前浏览的页面，则可以使用forward()方法,代码如下: 1window.history.forward(); 注意：等价点击前进按钮。 forward()相当于go(1),代码如下: 1window.history.go(1); (3).返回浏览历史中的其他页面go()方法，根据当前所处的页面，加载 history 列表中的某个具体的页面。 12345window.history.go(number);go(1)等价forward()go(0)等价当前页面go(-1)等价back() 3.Location对象location用于获取或设置窗体的URL，并且可以用于解析URL。 location.[属性|方法]location对象属性图示: location 对象属性： location 对象方法: 4.Navigator对象Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 对象属性: 5.screen对象screen对象用于获取用户的屏幕信息。 window.screen.属性对象属性: (1).屏幕分辨率的高和宽window.screen 对象包含有关用户屏幕的信息。 screen.height 返回屏幕分辨率的高 screen.width 返回屏幕分辨率的宽 注意: 1.单位以像素计。 window.screen 对象在编写时可以不使用 window 这个前缀。 2.屏幕可用高和宽度 screen.availWidth 属性返回访问者屏幕的宽度，以像素计，减去界面特性，比如任务栏。 screen.availHeight 属性返回访问者屏幕的高度，以像素计，减去界面特性，比如任务栏。 注意: 不同系统的任务栏默认高度不一样，及任务栏的位置可在屏幕上下左右任何位置，所以有可能可用宽度和高度不一样。 六、DOM文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。 HTML文档可以说由节点构成的集合，DOM节点有: 元素节点：上图中、、等都是元素节点，即标签。 文本节点:向用户展示的内容，如…中的JavaScript、DOM、CSS等文本。 属性节点:元素属性，如标签的链接属性href=”http://www.imooc.com&quot;。 节点属性: 遍历节点树: DOM操作: 注意:前两个是document方法。 (1).getElementsByName()方法注意: 因为文档中的 name 属性可能不唯一，所有 getElementsByName() 方法返回的是元素的数组，而不是一个元素。 和数组类似也有length属性，可以和访问数组一样的方法来访问，从0开始。 (2).getElementsByTagName()方法返回带有指定标签名的节点对象的集合。返回元素的顺序是它们在文档中的顺序。 说明: Tagname是标签的名称，如p、a、img等标签名。 和数组类似也有length属性，可以和访问数组一样的方法来访问，所以从0开始。 (3).getAttribute()方法通过元素节点的属性名称获取属性的值。 1elementNode.getAttribute(name) (4).setAttribute()setAttribute() 方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。 1elementNode.setAttribute(name,value) 说明： 1.name: 要设置的属性名。 2.value: 要设置的属性值。 注意： 1.把指定的属性设置为指定的值。如果不存在具有指定名称的属性，该方法将创建一个新属性。 2.类似于getAttribute()方法，setAttribute()方法只能通过元素节点对象调用的函数。 5.节点属性在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ： nodeName : 节点的名称 nodeValue ：节点的值 nodeType ：节点的类型 一、nodeName 属性: 节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document二、nodeValue 属性：节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 6.访问子节点childNodes访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，他具有length属性。 1elementNode.childNodes 注意：如果选定的节点没有子节点，则该属性返回不包含节点的 NodeList。 1234567运行结果:IE: UL子节点个数:3 节点类型:1其它浏览器: UL子节点个数:7 节点类型:3 注意: IE全系列、firefox、chrome、opera、safari兼容问题 节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点，所以IE是3，其它浏览器是7，如下图所示: 如果把代码改成这样: javascriptjQueryPHP 123运行结果:（IE和其它浏览器结果是一样的） UL子节点个数:3 节点类型:1 7.访问子节点的第一和最后项一、firstChild 属性返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 1node.firstChild 说明：与elementNode.childNodes[0]是同样的效果。 二、 lastChild 属性返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 1node.lastChild 说明：与elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 8.访问父节点parentNode获取指定节点的父节点 1elementNode.parentNode 注意:父节点只能有一个。 9.访问兄弟节点nextSibling 属性可返回某个节点之后紧跟的节点（处于同一树层级中）。 1nodeObject.nextSibling 说明：如果无此节点，则该属性返回 null。 previousSibling 属性可返回某个节点之前紧跟的节点（处于同一树层级中）。 1nodeObject.previousSibling 说明：如果无此节点，则该属性返回 null。 注意: 两个属性获取的是节点。Internet Explorer 会忽略节点间生成的空白文本节点（例如，换行符号），而其它浏览器不会忽略。 10.插入节点appendChild()在指定节点的最后一个子节点列表之后添加一个新的子节点。 1appendChild(newnode) 1234运行结果:HTMLJavaScriptThis is a new p 11.插入节点insertBefore()insertBefore() 方法可在已有的子节点前插入一个新的子节点。 1insertBefore(newnode,node); 1234运行结果:This is a new pJavaScriptHTML 12.删除节点removeChild()removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。 1nodeObject.removeChild(node) 12345运行结果:HTML删除节点的内容: javascript注意: 把删除的子节点赋值给 x，这个子节点不在DOM树中，但是还存在内存中，可通过 x 操作。如果要完全删除对象，给 x 赋 null 值，代码如下: 13.替换元素节点replaceChild()replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 1node.replaceChild (newnode,oldnew ) 效果: 将文档中的 Java 改为 JavaScript。注意: 当 oldnode 被替换时，所有与之相关的属性内容都将被移除。 newnode 必须先被建立。 只有父结点才能调用 replaceChild(newnode,oldnode).这个方法，所以，要想替换当前结点的内容或者属性，那么首先得获得父节点，才可以操作，这就是为什么 oldnode.parentNode.replaceChild(newnode,oldnode) 14.创建元素节点createElementcreateElement()方法可创建元素节点。此方法可返回一个 Element 对象。 1document.createElement(tagName) tagName：字符串值，这个字符串用来指明创建元素的类型。 注意：要与appendChild() 或 insertBefore()方法联合使用，将元素显示在页面中。 15.创建文本节点createTextNodecreateTextNode() 方法创建新的文本节点，返回新创建的 Text 节点。 1document.createTextNode(data) 16.浏览器窗口可视区域大小获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）的方法: 一、对于IE9+、Chrome、Firefox、Opera 以及 Safari： • window.innerHeight - 浏览器窗口的内部高度 • window.innerWidth - 浏览器窗口的内部宽度 二、对于 Internet Explorer 8、7、6、5： • document.documentElement.clientHeight表示HTML文档所在窗口的当前高度。 • document.documentElement.clientWidth表示HTML文档所在窗口的当前宽度。 或者 Document对象的body属性对应HTML文档的标签 • document.body.clientHeight • document.body.clientWidth 12345在不同浏览器都实用的 JavaScript 方案：var w= document.documentElement.clientWidth || document.body.clientWidth;var h= document.documentElement.clientHeight || document.body.clientHeight; 17.网页尺寸scrollHeightscrollHeight和scrollWidth，获取网页内容高度和宽度。 一、针对IE、Opera:scrollHeight 是网页内容实际高度，可以小于 clientHeight。 二、针对NS、FF:scrollHeight 是网页内容高度，不过最小值是 clientHeight。也就是说网页内容实际高度小于 clientHeight 时，scrollHeight 返回 clientHeight 。 三、浏览器兼容性 1234var w=document.documentElement.scrollWidth || document.body.scrollWidth;var h=document.documentElement.scrollHeight || document.body.scrollHeight; 注意:区分大小写scrollHeight和scrollWidth还可获取Dom元素中内容实际占用的高度和宽度。 18.网页尺寸offsetHeightoffsetHeight和offsetWidth，获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)。 一、值 1offsetHeight = clientHeight + 滚动条 + 边框。 二、浏览器兼容性 1234var w= document.documentElement.offsetWidth || document.body.offsetWidth;var h= document.documentElement.offsetHeight || document.body.offsetHeight; 19.网页卷去的距离与偏移量scrollLeft:设置或获取位于给定对象左边界与窗口中目前可见内容的最左端之间的距离 ，即左边灰色的内容。 scrollTop:设置或获取位于对象最顶端与窗口中可见内容的最顶端之间的距离 ，即上边灰色的内容。 offsetLeft:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 。 offsetTop:获取指定对象相对于版面或由 offsetParent 属性指定的父坐标的计算顶端位置 。 注意: 区分大小写offsetParent：布局中设置postion属性(Relative、Absolute、fixed)的父容器，从最近的父节点开始，一层层向上找，直到HTML的body。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jquery(四)动画篇]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2FjQuery%2Fjquery(%E5%9B%9B)%E5%8A%A8%E7%94%BB%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1.jQuery中隐藏元素的hide方法12.hide( options ).hide(&quot;fast / slow&quot;)隐藏有动画效果2.jQuery中显示元素的show方法12.hide( options ).hide(&quot;fast / slow&quot;) 注意事项： 如果使用!important在你的样式中，比如display: none !important，如果你希望.show()方法正常工作，必须使用.css(‘display’, ‘block !important’)重写样式 3.jQuery中显示与隐藏切换toggle方法12toggle();toggle( [duration ] [, complete ] ) 如果元素是最初显示，它会被隐藏如果隐藏的，它会显示出来 4.jQuery中下拉动画slideDown.slideDown()：用滑动动画显示一个匹配元素 .slideDown( [duration ] [, complete ] ) 持续时间（duration）是以毫秒为单位的，数值越大，动画越慢，不是越快。字符串 ‘fast’ 和 ‘slow’ 分别代表200和600毫秒的延时。如果提供任何其他字符串，或者这个duration参数被省略，那么默认使用400 毫秒的延时。 具体使用： 123$(&quot;ele&quot;).slideDown(1000, function() &#123; //等待动画执行1秒后,执行别的动作....&#125;); 5.jQuery中上卷动画slideUp123$(&quot;elem&quot;).slideUp();.slideUp( [duration ] [, easing ] [, complete ] ) 因为动画是异步的，所以要在动画之后执行某些操作就必须要写到回调函数里面，这里要特别注意 6.jQuery中上卷下拉切换slideToggle12slideToggle();.slideToggle( [duration ] ,[ complete ] ) 7.jQuery中淡出动画fadeOut1.fadeOut( [duration ], [ complete ] ) 8.jQuery中淡入动画fadeIn1.fadeIn( [duration ], [ complete ] ) 淡入的动画原理：操作元素的不透明度从0%逐渐增加到100% 9.jQuery中淡入淡出切换fadeToggle1.fadeToggle( [duration ] ,[ complete ] ) 10.jQuery中淡入效果fadeTo1.fadeTo( duration, opacity ,callback) 相比fadeOut,fadeIn,可以改变透明度 11.toggle、sildeToggle以及fadeToggle的区别： toggle：切换显示与隐藏效果 sildeToggle：切换上下拉卷滚效果 fadeToggle：切换淡入淡出效果 12.jQuery中动画animate(上).animate( properties ,[ duration ], [ easing ], [ complete ] )参数分解： properties：一个或多个css属性的键值对所构成的Object对象。要特别注意所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的jQuery功能。比如常见的，border、margin、padding、width、height、font、left、top、right、bottom、wordSpacing等等这些都是能产生动画效果的。background-color很明显不可以，因为参数是red或者GBG这样的值，非常用插件，否则正常情况下是不能只用动画效果的。注意，CSS 样式使用 DOM 名称（比如 “fontSize”）来设置，而非 CSS 名称（比如 “font-size”）。 特别注意单位，属性值的单位像素（px）,除非另有说明。单位em 和 %需要指定使用 123456.animate(&#123; left: 50, width: &apos;50px&apos; opacity: &apos;show&apos;, fontSize: &quot;10em&quot;,&#125;, 500); 除了定义数值，每个属性能使用’show’, ‘hide’, 和 ‘toggle’。这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏 123.animate(&#123; width: &quot;toggle&quot;&#125;); 如果提供一个以+= 或 -=开始的值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的 123.animate(&#123; left: &apos;+=50px&apos;&#125;, &quot;slow&quot;); duration时间 动画执行的时间，持续时间是以毫秒为单位的；值越大表示动画执行的越慢，不是越快。还可以提供’fast’ 和 ‘slow’字符串，分别表示持续时间为200 和 600毫秒。 easing动画运动的算法 jQuery库中默认调用 swing。如果需要其他的动画算法，请查找相关的插件 complete回调 动画完成时执行的函数，这个可以保证当前动画确定完成后发会触发 13.jQuery中动画animate(下)1.animate( properties, options ) options参数 duration - 设置动画执行的时间 easing - 规定要使用的 easing 函数，过渡使用哪种缓动函数 step：规定每个动画的每一步完成之后要执行的函数 progress：每一次动画调用的时候会执行这个回调，就是一个进度的概念 complete：动画完成回调 其中最关键的一点就是： 如果多个元素执行动画，回调将在每个匹配的元素上执行一次，不是作为整个动画执行一次 12345678910111213$(&apos;#elem&apos;).animate(&#123; width: &apos;toggle&apos;, height: &apos;toggle&apos; &#125;, &#123; duration: 5000, specialEasing: &#123; width: &apos;linear&apos;, height: &apos;easeOutBounce&apos; &#125;, complete: function() &#123; $(this).after(&apos;&lt;div&gt;Animation complete.&lt;/div&gt;&apos;); &#125;&#125;); 14.jQuery中停止动画stop stop() 停止当前动画 stop(true) 停止当前执行动画元素的所有动画行为 stop(true,true) 停止当前执行动画元素的所有动画行为，并且直接到达动画最后一帧 15.jQuery中each方法的应用用来处理对象和数组的遍历 12345678910111213141516171819202122jQuery.each(array, callback )jQuery.each( object, callback )$.each([&quot;Aaron&quot;, &quot;慕课网&quot;], function(index, value) &#123; //index是索引,也就是数组的索引 //value就是数组中的值了&#125;);$.each([&quot;Aaron&quot;, &quot;慕课网&quot;], function(index, value) &#123; return false; //停止迭代&#125;);例子$.each([&apos;Aaron&apos;, &apos;慕课网&apos;], function(i, item) &#123; $aaron.append(&quot;索引=&quot; + i + &quot;; 元素=&quot; + item);&#125;);$.each(&#123; name: &quot;张三&quot;, age: 18&#125;, function(property, value) &#123; $aaron.append(&quot;属性名=&quot; + property + &quot;; 属性值=&quot; + value);&#125;); 16.jQuery中查找数组中的索引inArrayjQuery.inArray()函数用于在数组中搜索指定的值，并返回其索引值。如果数组中不存在该值，则返回 -1。，可以通过fromIndex规定查找的起始值，默认数组是0开始。 1jQuery.inArray( value, array ,[ fromIndex ] ) 例如：在数组中查找值是5的索引 1$.inArray(5,[1,2,3,4,5,6,7]) //返回对应的索引：4 注意： 如果要判断数组中是否存在指定值，你需要通过该函数的返回值不等于(或大于)-1来进行判断 17.jQuery中去空格神器trim方法jQuery.trim()函数用于去除字符串两端的空白字符 这个函数很简单，没有多余的参数用法 需要注意： 移除字符串开始和结尾处的所有换行符，空格(包括连续的空格)和制表符（tab） 如果这些空白字符在字符串中间时，它们将被保留，不会被移除18.jQuery中DOM元素的获取get方法 12345.get( [index ] )&lt;a&gt;1&lt;/a&gt;&lt;a&gt;2&lt;/a&gt;&lt;a&gt;3&lt;/a&gt; 注意2点 get方法是获取的dom对象，也就是通过document.getElementById获取的对象 get方法是从0开始索引所以第二个a元素的查找： $(a).get(1) 负索引值参数get方法还可以从后往前索引，传递一个负索引值，注意的负值的索引起始值是-1 同样是找到第二元素，可以传递 $(a).get(-2) get方法是获取dom对象，eq方法是获取jq对象.那么js取得的元素后面就必须跟js的方法或者属性，既$().get().style()。而不是$().get().css()。因为style是js独有的方法，而css()是jq独有的方法，get()方法后取得的js元素，它只能识别style()，而不能识别css()。 19.jQuery中DOM元素的获取index方法123.index().index( selector ).index( element ) 如果不传递任何参数给 .index() 方法，则返回值就是jQuery对象中第一个元素相对于它同辈元素的位置 如果在一组元素上调用 .index() ，并且参数是一个DOM元素或jQuery对象， .index() 返回值就是传入的元素相对于原先集合的位置 如果参数是一个选择器， .index() 返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则 .index() 返回 -1例如 123456&lt;ul&gt; &lt;a&gt;&lt;/a&gt; &lt;li id=&quot;test1&quot;&gt;1&lt;/li&gt; &lt;li id=&quot;test2&quot;&gt;2&lt;/li&gt; &lt;li id=&quot;test3&quot;&gt;3&lt;/li&gt;&lt;/ul&gt; $(“li”).index() 没有传递参数，反正的结果是1，它的意思是返回同辈的排列循序，第一个li之前有a元素,同辈元素是a开始为0，所以li的开始索引是1 如果要快速找到第二个li在列表中的索引,可以通过如下2种方式处理 12$(&quot;li&quot;).index(document.getElementById(&quot;test2&quot;)) //结果：1$(&quot;li&quot;).index($(&quot;#test2&quot;)) //结果:1]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery(三)事件篇]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2FjQuery%2Fjquery(%E4%B8%89)%E4%BA%8B%E4%BB%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[jQuery鼠标事件之click与dblclick事件前者单击，后者双击jQuery鼠标事件之mousedown与mouseup事件jQuery鼠标事件之mousemove事件移动事件jQuery鼠标事件之mouseover与mouseout事件 jQuery鼠标事件之mouseenter与mouseleave事件mouseenter事件只会在绑定它的元素上被调用，而不会在后代节点上被触发 jQuery鼠标事件之hover事件1(selector).hover(handlerIn, handlerOut) handlerIn(eventObject)：当鼠标指针进入元素时触发执行的事件函数 handlerOut(eventObject)：当鼠标指针离开元素时触发执行的事件函数jQuery鼠标事件之focusin事件当一个元素，或者其内部任何一个元素获得焦点的时候，例如：input元素，用户在点击聚焦的时候，如果开发者需要捕获这个动作的时候，jQuery提供了一个focusin事件 jQuery鼠标事件之focusout事件当一个元素，或者其内部任何一个元素失去焦点的时候，比如input元素，用户在点击失去焦的时候，如果开发者需要捕获这个动作，jQuery提供了一个focusout事件 jQuery表单事件之blur与focus事件focus与blur事件：不支持冒泡，focusin与focusout支持冒泡 jQuery表单事件之change事件元素，和元素的值都是可以发生改变的，开发者可以通过change事件去监听这些改变的动作 (1).input元素监听value值的变化，当有改变时，失去焦点后触发change事件。对于单选按钮和复选框，当用户用鼠标做出选择时，该事件立即触发。 (2).select元素对于下拉选择框，当用户用鼠标作出选择时，该事件立即触发 (3).textarea元素多行文本输入框，当有改变时，失去焦点后触发change事件 jQuery表单事件之select事件当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。 select事件只能用于元素与元素 jQuery表单事件之submit事件(1).具体能触发submit事件的行为： 提交提交 当某些表单元素获取焦点时，敲击Enter（回车键） (2).这里需要特别注意：form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为传统的方式是调用事件对象 e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可 123$(&quot;#target&quot;).submit(function(data) &#123; return false; //阻止默认行为，提交表单&#125;); 13.jQuery键盘事件之keydown()与keyup()事件14.jQuery键盘事件之keypress()事件在input元素上绑定keydown事件会发现一个问题：每次获取的内容都是之前输入的，当前输入的获取不到 keypress()可以捕获当前的值，但是中文不可以，e.target.value返回之前所有的输入字符，这个时候中文 就会被提取并打印出来！ 15.on()的多事件绑定(1).基本用法：.on( events ,[ selector ] ,[ data ] ) 123$(&quot;#elem&quot;).click(function()&#123;&#125;) //快捷方式$(&quot;#elem&quot;).on(&apos;click&apos;,function()&#123;&#125;) //on方式最大的不同点就是on是可以自定义事件名 (2).多个事件绑定同一个函数 1$(&quot;#elem&quot;).on(&quot;mouseover mouseout&quot;,function()&#123; &#125;); (3).多个事件绑定不同函数 1234$(&quot;#elem&quot;).on(&#123; mouseover:function()&#123;&#125;, mouseout:function()&#123;&#125;&#125;); (4).将数据传递到处理程序 123456function greet( event ) &#123; alert( &quot;Hello &quot; + event.data.name ); //Hello 慕课网&#125;$( &quot;button&quot; ).on( &quot;click&quot;, &#123; name: &quot;慕课网&quot;&#125;, greet ); 可以通过第二参数（对象），当一个事件被触发时，要传递给事件处理函数的 16.on()的高级用法事件绑定在最上层div元素上，当用户触发在a元素上，事件将往上冒泡，一直会冒泡在div元素上。如果提供了第二参数，那么事件在往上冒泡的过程中遇到了选择器匹配的元素，将会触发事件回调函数 1234567&lt;div class=&quot;left&quot;&gt; &lt;p class=&quot;aaron&quot;&gt; &lt;a&gt;目标节点&lt;/a&gt; //点击在这个元素上 &lt;/p&gt;&lt;/div&gt;$(&quot;div&quot;).on(&quot;click&quot;,&quot;a&quot;,fn) 17.卸载事件off()方法(1).绑定2个事件 1$(&quot;elem&quot;).on(&quot;mousedown mouseup&quot;,fn) (2).删除一个事件 1$(&quot;elem&quot;).off(&quot;mousedown&quot;) (3).删除所有事件 1$(&quot;elem&quot;).off(&quot;mousedown mouseup&quot;) 快捷方式删除所有事件，这里不需要传递事件名了，节点上绑定的所有事件讲全部销毁 1$(&quot;elem&quot;).off() 18.jQuery事件对象的作用123456&lt;ul&gt; &lt;li class=&quot;even1&quot;&gt;&lt;/li&gt; &lt;li class=&quot;even2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;even2&quot;&gt;&lt;/li&gt; .........&lt;/ul&gt; ul有N个子元素li(这里只写了3个)，如果我要响应每一个li的事件，那么常规的方法就是需要给所有的li都单独绑定一个事件监听，这样写法很符合逻辑，但是同时有显得繁琐 因为li都有一个共同的父元素，而且所有的事件都是一致的，这里我们可以采用要一个技巧来处理，也是常说的”事件委托” 事件没直接和li元素发生关系，而且绑定父元素了。由于浏览器有事件冒泡的这个特性，我们可以在触发li的时候把这个事件往上冒泡到ul上，因为ul上绑定事件响应所以就能够触发这个动作了。唯一的问题怎么才知道触发的li元素是哪个一个？ 这里就引出了事件对象了 事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁 event.target代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素 19.jQuery事件对象的属性和方法事件对象的属于与方法有很多，但是我们经常用的只有那么几个，这里我主要说下作用与区别 (1).event.type：获取事件的类型触发元素的事件类型 123$(&quot;a&quot;).click(function(event) &#123; alert(event.type); // &quot;click&quot;事件&#125;); (2).event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标 通过这2个属性，可以确定元素在当前页面的坐标值，鼠标相对于文档的左边缘的位置（左边）与 （顶边）的距离，简单来说是从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化 (3).event.preventDefault() 方法：阻止默认行为这个用的特别多，在执行这个方法后，如果点击一个链接（a标签），浏览器不会跳转到新的 URL 去了。我们可以用 event.isDefaultPrevented() 来确定这个方法是否(在那个事件对象上)被调用过了 (4).event.stopPropagation() 方法：阻止事件冒泡事件是可以冒泡的，为防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数 (5).event.which：获取在鼠标单击时，单击的是鼠标的哪个键 event.which 将 event.keyCode 和 event.charCode 标准化了。event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3 (6).event.currentTarget : 在事件冒泡过程中的当前DOM元素冒泡前的当前触发事件的DOM对象, 等同于this. (7).this和event.target的区别： js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素； (8).this和event.target都是dom对象 如果要使用jquey中的方法可以将他们转换为jquery对象。比如this和$(this)的使用、event.target和$(event.target)的使用； 20.jQuery自定义事件之trigger事件trigger() 方法触发被选元素的指定事件类型。 1234567891011121314151617181920&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function()&#123; $(&quot;input&quot;).select(function()&#123; $(&quot;input&quot;).after(&quot;文本被选中！&quot;); &#125;); $(&quot;button&quot;).click(function()&#123; $(&quot;input&quot;).trigger(&quot;select&quot;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt;&lt;br /&gt;&lt;button&gt;激活 input 域的 select 事件&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 21.jQuery自定义事件之triggerHandler事件triggerHandler() 方法触发被选元素的指定事件类型。但不会执行浏览器默认动作，也不会产生事件冒泡。 triggerHandler() 方法与 trigger() 方法类似。不同的是它不会触发事件（比如表单提交）的默认行为，而且只影响第一个匹配元素。 123456789101112131415161718192021&lt;html&gt;&lt;head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/jquery/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function()&#123; $(&quot;input&quot;).select(function()&#123; $(&quot;input&quot;).after(&quot;发生 Input select 事件！&quot;); &#125;); $(&quot;button&quot;).click(function()&#123; $(&quot;input&quot;).triggerHandler(&quot;select&quot;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; name=&quot;FirstName&quot; value=&quot;Hello World&quot; /&gt;&lt;br /&gt;&lt;button&gt;激活 input 域的 select 事件&lt;/button&gt;&lt;p&gt;请注意，与 trigger() 方法不同，triggerHandler() 方法不会引起所发生事件的默认行为（文本不会被选中）。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery(二)DOM篇]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2FjQuery%2Fjquery(%E4%BA%8C)DOM%E7%AF%87%2F</url>
    <content type="text"><![CDATA[1.jQuery节点创建与属性的处理(1).创建元素节点：可以有几种方式，后面会慢慢接触。常见的就是直接把这个节点的结构给通过HTML标记字符串描述出来，通过$()函数处理，$(“html结构”)1$(&quot;&lt;div&gt;&lt;/div&gt;&quot;) (2).创建为本节点：与创建元素节点类似，可以直接把文本内容一并描述 1$(&quot;&lt;div&gt;我是文本节点&lt;/div&gt;&quot;) (3).创建为属性节点：与创建元素节点同样的方式 12$(&quot;&lt;div id=&apos;test&apos; class=&apos;aaron&apos;&gt;我是文本节点&lt;/div&gt;&quot;)$(&quot;&lt;div class=&apos;right&apos;&gt;&lt;div class=&apos;aaron&apos;&gt;动态创建DIV元素节点&lt;/div&gt;&lt;/div&gt;&quot;) 2.DOM内部插入append()与appendTo()append()前面是被插入的对象，后面是要在对象内插入的元素内容 appendTo()前面是要插入的元素内容，而后面是被插入的对象 3.DOM外部插入after()与before()before与after都是用来对相对选中元素外部增加相邻的兄弟节点 2个方法都是都可以接收HTML字符串，DOM 元素，元素数组，或者jQuery对象，用来插入到集合中每个匹配元素的前面或者后面 2个方法都支持多个参数传递after(div1,div2,….) 可以参考右边案例代码注意点： after向元素的后边添加html代码，如果元素后面有元素了，那将后面的元素后移，然后将html代码插入 before向元素的前边添加html代码，如果元素前面有元素了，那将前面的元素前移，然后将html代码插 4.DOM内部插入prepend()与prependTo() append()向每个匹配的元素内部追加内容 prepend()向每个匹配的元素内部前置内容 appendTo()把所有匹配的元素追加到另一个指定元素的集合中 prependTo()把所有匹配的元素前置到另一个指定的元素集合中 5.DOM外部插入insertAfter()与insertBefore() before()和.insertBefore()实现同样的功能。主要的区别是语法——内容和目标的位置。 对于before()选择表达式在函数前面，内容作为参数，而.insertBefore()刚好相反，内容在方法前面，它将被放在参数里元素的前面 .after()和.insertAfter() 实现同样的功能。主要的不同是语法——特别是（插入）内容和目标的位置。 对于after()选择表达式在函数的前面，参数是将要插入的内容。对于 .insertAfter(), 刚好相反，内容在方法前面，它将被放在参数里元素的后面 before、after与insertBefore。insertAfter的除了目标与位置的不同外，后面的不支持多参数处理 注意事项： insertAfter将JQuery封装好的元素插入到指定元素的后面，如果元素后面有元素了，那将后面的元素后移，然后将JQuery对象插入； insertBefore将JQuery封装好的元素插入到指定元素的前面，如果元素前面有元素了，那将前面的元素前移，然后将JQuery对象插入； 6.DOM节点删除之empty()的基本用法empty 顾名思义，清空方法，但是与删除又有点不一样，因为它只移除了 指定元素中的所有子节点。 这个方法不仅移除子元素（和其他后代元素），同样移除元素里的文本。因为，根据说明，元素里任何文本字符串都被看做是该元素的子节点。请看下面的HTML： 1&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt; 如果我们通过empty方法移除里面div的所有元素，它只是清空内部的html代码，但是标记仍然留在DOM中 12345//通过empty处理$(&apos;.hello&apos;).empty()//结果：&lt;p&gt;慕课网&lt;/p&gt;被移除&lt;div class=&quot;hello&quot;&gt;&lt;/div&gt; 7.DOM节点删除之remove()的有参用法和无参用法remove与empty一样，都是移除元素的方法，但是remove会将元素自身移除，同时也会移除元素内部的一切，包括绑定的事件及与该元素相关的jQuery数据。 12&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt;$(&apos;.hello&apos;).on(&quot;click&quot;,fn) 如果不通过remove方法删除这个节点其实也很简单，但是同时需要把事件给销毁掉，这里是为了防止”内存泄漏”，所以前端开发者一定要注意，绑了多少事件，不用的时候一定要记得销毁 通过remove方法移除div及其内部所有元素，remove内部会自动操作事件销毁方法，所以使用使用起来非常简单 1234//通过remove处理$(&apos;.hello&apos;).remove()//结果：&lt;div class=&quot;hello&quot;&gt;&lt;p&gt;慕课网&lt;/p&gt;&lt;/div&gt; 全部被移除//节点不存在了,同事事件也会被销毁 remove表达式参数： remove比empty好用的地方就是可以传递一个选择器表达式用来过滤将被移除的匹配元素集合，可以选择性的删除指定的节点 我们可以通过$()选择一组相同的元素，然后通过remove（）传递筛选的规则，从而这样处理 1$(&quot;p&quot;).filter(&quot;:contains(&apos;3&apos;)&quot;).remove() 8.DOM节点删除之empty和remove区别(1).empty方法 严格地讲，empty()方法并不是删除节点，而是清空节点，它能清空元素中的所有后代节点 empty不能删除自己本身这个节点 (2).remove方法 该节点与该节点所包含的所有后代节点将同时被删除 提供传递一个筛选的表达式，删除指定合集中的元素 9.DOM节点删除之保留数据的删除操作detach()如果我们希望临时删除页面上的节点，但是又不希望节点上的数据与事件丢失，并且能在下一个时间段让这个删除的节点显示到页面，这时候就可以使用detach方法来处理 detach从字面上就很容易理解。让一个web元素托管。即从当前页面中移除该元素，但保留这个元素的内存模型对象。来看看jquery官方文档的解释： 这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。 $(“div”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。 当然这里要特别注意，detach方法是JQuery特有的，所以它只能处理通过JQuery的方法绑定的事件或者数据 参考右边的代码区域，通过 $(“p”).detach()把所有的P元素删除后，再通过append把删除的p元素放到页面上，通过点击文字，可以证明事件没有丢失 10.DOM节点删除之detach()和remove()区别(1).remove：移除节点 无参数，移除自身整个节点以及该节点的内部的所有节点，包括节点上事件与数据 有参数，移除筛选出的节点以及该节点的内部的所有节点，包括节点上事件与数据 (2).detach：移除节点 移除的处理与remove一致 与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来 例如：$(“p”).detach()这一句会移除对象，仅仅是显示效果没有了。但是内存中还是存在的。当你append之后，又重新回到了文档流中。就又显示出来了。 11.DOM拷贝clone()克隆节点是DOM的常见操作，jQuery提供一个clone方法，专门用于处理dom的克隆 .clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。 clone方法比较简单就是克隆节点，但是需要注意，如果节点有事件或者数据之类的其他处理，我们需要通过clone(ture)传递一个布尔值ture用来指定，这样不仅仅只是克隆单纯的节点结构，还要把附带的事件与数据给一并克隆了 123456789101112例如：HTML部分&lt;div&gt;&lt;/div&gt;JavaScript部分$(&quot;div&quot;).on(&apos;click&apos;, function() &#123;//执行操作&#125;)//clone处理一$(&quot;div&quot;).clone() //只克隆了结构，事件丢失//clone处理二$(&quot;div&quot;).clone(true) //结构、事件与数据都克隆 使用上就是这样简单，使用克隆的我们需要额外知道的细节： clone()方法时，在将它插入到文档之前，我们可以修改克隆后的元素或者元素内容，如右边代码我 $(this).clone().css(‘color’,’red’) 增加了一个颜色 通过传递true，将所有绑定在原始元素上的事件处理函数复制到克隆元素上 clone()方法是jQuery扩展的，只能处理通过jQuery绑定的事件与数据 元素数据（data）内对象和数组不会被复制，将继续被克隆元素和原始元素共享。深复制的所有数据，需要手动复制每一个 12.DOM替换replaceWith()和replaceAll()(1). .replaceWith( newContent )： 用提供的内容替换集合中所有匹配的元素并且返回被删除元素的集合 简单来说：用$()选择节点A，调用replaceWith方法，传入一个新的内容B（HTML字符串，DOM元素，或者jQuery对象）用来替换选中的节点A 看个简单的例子：一段HTML代码 12345&lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;p&gt;第二段&lt;/p&gt; &lt;p&gt;第三段&lt;/p&gt;&lt;/div&gt; 替换第二段的节点与内容 1$(&quot;p:eq(1)&quot;).replaceWith(&apos;&lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos;) 通过jQuery筛选出第二个p元素，调用replaceWith进行替换，结果如下 12345&lt;div&gt; &lt;p&gt;第一段&lt;/p&gt; &lt;a style=&quot;color:red&quot;&gt;替换第二段的内容&lt;/a&gt;&apos; &lt;p&gt;第三段&lt;/p&gt;&lt;/div&gt; (2).replaceAll( target ) ：用集合的匹配元素替换每个目标元素 .replaceAll()和.replaceWith()功能类似，但是目标和源相反，用上述的HTML结构，我们用replaceAll处理$(‘替换第二段的内容‘).replaceAll(‘p:eq(1)’) (3).总结 .replaceAll()和.replaceWith()功能类似，主要是目标和源的位置区别 .replaceWith()与.replaceAll() 方法会删除与节点相关联的所有数据和事件处理程序 .replaceWith()方法，和大部分其他jQuery方法一样，返回jQuery对象，所以可以和其他方法链接使用 .replaceWith()方法返回的jQuery对象引用的是替换前的节点，而不是通过replaceWith/replaceAll方法替换后的节点13.DOM包裹wrap()方法如果要将元素用其他元素包裹起来，也就是给它增加一个父元素，针对这样的处理，JQuery提供了一个wrap方法 (1).wrap( wrappingElement )：在集合中匹配的每个元素周围包裹一个HTML结构 简单的看一段代码： 12345678&lt;p&gt;p元素&lt;/p&gt;给p元素增加一个div包裹$(&apos;p&apos;).wrap(&apos;&lt;div&gt;&lt;/div&gt;&apos;)最后的结构，p元素增加了一个父div的结构&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; (2).wrap( function ) ： 一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象 使用后的效果与直接传递参数是一样，只不过可以把代码写在函数体内部，写法不同而已 以第一个案例为例： 123$(&apos;p&apos;).wrap(function() &#123; return &apos;&lt;div&gt;&lt;/div&gt;&apos;; //与第一种类似，只是写法不一样&#125;) (3).注意：.wrap()函数可以接受任何字符串或对象，可以传递给$()工厂函数来指定一个DOM结构。这种结构可以嵌套了好几层深，但应该只包含一个核心的元素。每个匹配的元素都会被这种结构包裹。该方法返回原始的元素集，以便之后使用链式方法。 14.DOM包裹unwrap()方法我们可以通过wrap方法给选中元素增加一个包裹的父元素。相反，如果删除选中元素的父元素要如何处理 ? jQuery提供了一个unwarp()方法 ，作用与wrap方法是相反的。将匹配元素集合的父级元素删除，保留自身（和兄弟元素，如果存在）在原来的位置。 看一段简单案例： 123&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 我要删除这段代码中的div，一般常规的方法会直接通过remove或者empty方法 1$(&apos;div&apos;).remove(); 但是如果我还要保留内部元素p，这样就意味着需要多做很多处理，步骤相对要麻烦很多，为了更便捷，jQuery提供了unwarp方法很方便的处理了这个问题 1$(&apos;p&apos;).unwarp(); 找到p元素，然后调用unwarp方法，这样只会删除父辈div元素了 结果： 1&lt;p&gt;p元素&lt;/p&gt; 这个方法比较简单，也不接受任何参数，注意参考下案例的使用即可 15.DOM包裹wrapAll()方法(1).wrapAll( wrappingElement )：给集合中匹配的元素增加一个外面包裹HTML结构 简单的看一段代码： 12&lt;p&gt;p元素&lt;/p&gt;&lt;p&gt;p元素&lt;/p&gt; 给所有p元素增加一个div包裹 1$(&apos;p&apos;).wrapAll(&apos;&lt;div&gt;&lt;/div&gt;&apos;) 最后的结构，2个P元素都增加了一个父div的结构 1234&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; (2).wrapAll( function ) ：一个回调函数，返回用于包裹匹配元素的 HTML 内容或 jQuery 对象 通过回调的方式可以单独处理每一个元素以上面案例为例， 123$(&apos;p&apos;).wrapAll(function() &#123; return &apos;&lt;div&gt;&lt;div/&gt;&apos;; &#125;) 以上的写法的结果如下，等同于warp的处理了 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 16.DOM包裹wrapInner()方法如果要将合集中的元素内部所有的子元素用其他元素包裹起来，并当作指定元素的子元素，针对这样的处理，JQuery提供了一个wrapInner方法 (1).wrapInner( wrappingElement )：给集合中匹配的元素的内部，增加包裹的HTML结构 听起来有点绕，可以用个简单的例子描述下，简单的看一段代码： 1234&lt;div&gt;p元素&lt;/div&gt;&lt;div&gt;p元素&lt;/div&gt;给所有元素增加一个p包裹$(&apos;div&apos;).wrapInner(&apos;&lt;p&gt;&lt;/p&gt;&apos;) 最后的结构，匹配的di元素的内部元素被p给包裹了 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; (2).wrapInner( function ) ：允许我们用一个callback函数做参数，每次遇到匹配元素时，该函数被执行，返回一个DOM元素，jQuery对象，或者HTML片段，用来包住匹配元素的内容 以上面案例为例， 123$(&apos;div&apos;).wrapInner(function() &#123; return &apos;&lt;p&gt;&lt;/p&gt;&apos;; &#125;) 以上的写法的结果如下，等同于第一种处理了 123456&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p元素&lt;/p&gt;&lt;/div&gt; 注意：当通过一个选择器字符串传递给.wrapInner() 函数，其参数应该是格式正确的 HTML，并且 HTML 标签应该是被正确关闭的。 17.jQuery遍历之children()方法jQuery是一个合集对象，如果想快速查找合集里面的第一级子元素，此时可以用children()方法。这里需要注意：.children(selector) 方法是返回匹配元素集合中每个元素的所有子元素（仅儿子辈，这里可以理解为就是父亲-儿子的关系） 理解节点查找关系：12345&lt;div class=&quot;div&quot;&gt; &lt;ul class=&quot;son&quot;&gt; &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 代码如果是$(“div”).children()，那么意味着只能找到ul，因为div与ul是父子关系，li与div是祖辈关系，因此无法找到。 children()无参数允许我们通过在DOM树中对这些元素的直接子元素进行搜索，并且构造一个新的匹配元素的jQuery对象 注意：jQuery是一个合集对象，所以通过children是匹配合集中每一给元素的第一级子元素 .children()方法选择性地接受同一类型选择器表达式1$(&quot;div&quot;).children(&quot;.selected&quot;) 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 . 123456789101112131415161718192021detach() 隐身.remove 自杀.empty 身体被掏空.clone 复制 （true全复制 false 浅复制，无事件）.replaceWith 删除并替换节点（结合.replaceAll()来记）.wrap 每个人加个爸爸.unwrap 爸爸没了.wrapAll 所有人加个爸爸.wrapAll（function）每个人加个爸爸.wrapInner 加个儿子.children() 找儿子 18.jQuery遍历之find()方法jQuery是一个合集对象，如果想快速查找DOM树中的这些元素的后代元素，此时可以用find()方法，这也是开发使用频率很高的方法。这里要注意 children与find方法的区别，children是父子关系查找，find是后代关系（包含父子关系） 理解节点查找关系：12345&lt;div class=&quot;div&quot;&gt; &lt;ul class=&quot;son&quot;&gt; &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 代码如果是$(“div”).find(“li”)，此时，li与div是祖辈关系，通过find方法就可以快速的查找到了。 .find()方法要注意的知识点： find是遍历当前元素集合中每个元素的后代。只要符合，不管是儿子辈，孙子辈都可以。 与其他的树遍历方法不同，选择器表达式对于 .find() 是必需的参数。如果我们需要实现对所有后代元素的取回，可以传递通配选择器 ‘*’。 find只在后代中遍历，不包括自己。 选择器 context 是由 .find() 方法实现的；因此，$(‘.item-ii’).find(‘li’) 等价于 $(‘li’, ‘.item-ii’)(找到类名为item-ii的标签下的li标签)。 注意重点： .find()和.children()方法是相似的 .children只查找第一级的子节点 .find查找范围包括子节点的所有后代节点 19.jQuery遍历之parent()方法jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的父元素（这里可以理解为就是父亲-儿子的关系），此时可以用parent()方法 因为是父元素，这个方法只会向上查找一级 理解节点查找关系：12345&lt;div class=&quot;div&quot;&gt; &lt;ul class=&quot;son&quot;&gt; &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 查找ul的父元素div, $(ul).parent()，就是这样简单的表达 parent()无参数parent()方法允许我们能够在DOM树中搜索到这些元素的父级元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象 注意：jQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素 parent()方法选择性地接受同一型选择器表达式 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 20.jQuery遍历之parents()方法jQuery是一个合集对象，如果想快速查找合集里面的每一个元素的所有祖辈元素，此时可以用parents()方法 其实也类似find与children的区别，parent只会查找一级，parents则会往上一直查到查找到祖先节点 理解节点查找关系：12345&lt;div class=&quot;div&quot;&gt; &lt;ul class=&quot;son&quot;&gt; &lt;li class=&quot;grandson&quot;&gt;1&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在li节点上找到祖 辈元素div， 这里可以用$(“li”).parents()方法 parents()无参数parents()方法允许我们能够在DOM树中搜索到这些元素的祖先元素，从有序的向上匹配元素，并根据匹配的元素创建一个新的 jQuery 对象; 返回的元素秩序是从离他们最近的父级元素开始的 注意：jQuery是一个合集对象，所以通过parent是匹配合集中所有元素的祖辈元素 parents()方法选择性地接受同一型选择器表达式 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 注意事项： 1 .parents()和.parent()方法是相似的，但后者只是进行了一个单级的DOM树查找2 $( “html” ).parent()方法返回一个包含document的集合，而$( “html” ).parents()返回一个空集合。 21.jQuery遍历之closest()方法以选定的元素为中心，往内查找可以通过find、children方法。如果往上查找，也就是查找当前元素的父辈祖辈元素，jQuery提供了closest()方法，这个方法类似parents但是又有一些细微的区别，属于使用频率很高的方法 closest()方法接受一个匹配元素的选择器字符串从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素 例如：在div元素中，往上查找所有的li元素，可以这样表达 1$(&quot;div&quot;).closet(&quot;li&apos;) 注意：jQuery是一个合集对象，所以通过closest是匹配合集中每一个元素的祖先元素closest()方法给定的jQuery集合或元素来过滤元素 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个jQuery的对象 注意事项：在使用的时候需要特别注意下粗看.parents()和.closest()是有点相似的，都是往上遍历祖辈元素，但是两者还是有区别的，否则就没有存在的意义了 起始位置不同：.closest开始于当前元素 .parents开始于父元素 遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象22.jQuery遍历之next()方法jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的后面同辈元素的元素集合，此时可以用next()方法 理解节点查找关系：如下class=”item-1”元素就是红色部分，那蓝色的class=”item-2”就是它的兄弟元素 12345&lt;ul class=&quot;level-3&quot;&gt; &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;&lt;/ul&gt; next()无参数允许我们找遍元素集合中紧跟着这些元素的直接兄弟元素，并根据匹配的元素创建一个新的 jQuery 对象。 注意：jQuery是一个合集对象，所以通过next匹配合集中每一个元素的下一个兄弟元素 next()方法选择性地接受同一类型选择器表达式1同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 23.jQuery遍历之prev()方法jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素紧邻的前面同辈元素的元素集合，此时可以用prev()方法 理解节点查找关系：如下蓝色的class=”item-2”的li元素，红色的节点就是它的prev兄弟节点 12345&lt;ul class=&quot;level-3&quot;&gt; &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;&lt;/ul&gt; prev()无参数取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合 1注意：jQuery是一个合集对象，所以通过prev是匹配合集中每一个元素的上一个兄弟元素 prev()方法选择性地接受同一类型选择器表达式1同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 24.jQuery遍历之siblings()jQuery是一个合集对象，如果想快速查找指定元素集合中每一个元素的同辈元素，此时可以用siblings()方法 理解节点查找关系：如下蓝色的class=”item-2”的li元素，红色的节点就是它的siblings兄弟节点 12345&lt;ul class=&quot;level-3&quot;&gt; &lt;li class=&quot;item-1&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item-2&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item-3&quot;&gt;3&lt;/li&gt;&lt;/ul&gt; siblings()无参数取得一个包含匹配的元素集合中每一个元素的同辈元素的元素集合 注意：jQuery是一个合集对象，所以通过siblings是匹配合集中每一个元素的同辈元素 siblings()方法选择性地接受同一类型选择器表达式 同样的也是因为jQuery是合集对象，可能需要对这个合集对象进行一定的筛选，找出目标元素，所以允许传一个选择器的表达式 25.jQuery遍历之add()方法jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。$()之后就意味着这个合集对象已经是确定的，如果后期需要再往这个合集中添加一新的元素要如何处理？jQuery为此提供add方法，用来创建一个新的jQuery对象 ，元素添加到匹配的元素集合中 .add()的参数可以几乎接受任何的$()，包括一个jQuery选择器表达式，DOM元素，或HTML片段引用。 简单的看一个案例： 操作：选择所有的li元素，之后把p元素也加入到li的合集中 12345&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;新的p元素&lt;/p&gt; 处理一：传递选择器 1$(&apos;li&apos;).add(&apos;p&apos;) 处理二：传递dom元素 1$(&apos;li&apos;).add(document.getElementsByTagName(&apos;p&apos;)[0]) 还有一种方式，就是动态创建P标签加入到合集，然后插入到指定的位置，但是这样就改变元素的本身的排列了 1$(&apos;li&apos;).add(&apos;&lt;p&gt;新的p元素&lt;/p&gt;&apos;).appendTo(目标位置) 26.jQuery遍历之each()jQuery是一个合集对象，通过$()方法找到指定的元素合集后可以进行一系列的操作。比如我们操作$(“li”).css(‘’) 给所有的li设置style值，因为jQuery是一个合集对象，所以css方法内部就必须封装一个遍历的方法，被称为隐式迭代的过程。要一个一个给合集中每一个li设置颜色，这里方法就是each .each() 方法就是一个for循环的迭代器，它会迭代jQuery对象合集中的每一个DOM元素。每次回调函数执行时，会传递当前循环次数作为参数(从0开始计数 所以大体上了解3个重点： each是一个for循环的包装迭代器 each通过回调的方式处理，并且会有2个固定的实参，索引与元素 each回调方法中的this指向当前迭代的dom元素 看一个简单的案例 1234&lt;ul&gt; &lt;li&gt;慕课网&lt;/li&gt; &lt;li&gt;Aaron&lt;/li&gt;&lt;/ul&gt; 开始迭代li，循环2次 12345$(&quot;li&quot;).each(function(index, element) &#123; index 索引 0,1 element是对应的li节点 li,li this 指向的是li&#125;) 这样可以在循环体会做一些逻辑操作了，如果需要提前退出，可以以通过返回 false以便在回调函数内中止循]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router]]></title>
    <url>%2F2017%2F08%2F18%2FVue%2F%E5%88%9D%E7%BA%A7%EF%BC%882017%EF%BC%89%2Fvue-router%2F</url>
    <content type="text"><![CDATA[由于Vue在开发时对路由支持的不足，后来官方补充了vue-router插件，它在Vue的生态环境中非常重要，在实际开发中只要编写一个页面就会操作vue-router。要学习vue-router就要先知道这里的路由是什么？这里的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。再通俗的说，vue-router就是我们WebApp的链接路径管理系统。 有的小伙伴会有疑虑，为什么我们不能像原来一样直接用标签编写链接哪？因为我们用Vue作的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，你必须使用vue-router来进行管理。 第1节：Vue-router入门安装vue-routervue-router是一个插件包，所以我们还是需要用npm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。 1npm install vue-router --save-dev 如果你安装很慢，也可以用cnpm进行安装，如果你在使用vue-cli中已经选择安装了vue-router，那这里不需要重复安装了。 解读router/index.js文件我们用vue-cli生产了我们的项目结构，你可以在src/router/index.js文件，这个文件就是路由的核心文件，我们先解读一下它。 123456789101112131415import Vue from &apos;vue&apos; //引入Vueimport Router from &apos;vue-router&apos; //引入vue-routerimport Hello from &apos;@/components/Hello&apos; //引入根目录下的Hello.vue组件Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: &apos;/&apos;, //链接路径 name: &apos;Hello&apos;, //路由名称， component: Hello //对应的组件模板 &#125; ]&#125;) 上边的代码中已经对每行都进行了注释，其实在这个路由文件里只配置了一个功能，就是在进入项目时，显示Hello.vue里边的内容代码。 增加一个Hi的路由和页面 在src/components目录下，新建 Hi.vue 文件。 编写文件内容，和我们之前讲过的一样，文件要包括三个部分 123&lt;style scoped&gt;&lt;/style&gt; 引入 Hi组件：我们在router/index.js文件的上边引入Hi组件 增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。 12345678910111213141516171819202122232425262728&#123;path:&apos;/hi&apos;,name:&apos;Hi&apos;,component:Hi&#125;import Vue from ‘vue’ //引入Vueimport Router from ‘vue-router’ //引入vue-routerimport Hello from ‘@/components/Hello’ //引入根目录下的Hello.vue组件import Hi from ‘@/components/Hi’Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123;routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: &apos;/&apos;, //链接路径 name: &apos;Hello&apos;, //路由名称， component: Hello //对应的组件模板 &#125;,&#123; path:&apos;/hi&apos;, name:&apos;Hi&apos;, component:Hi &#125;]&#125;) router-link制作导航现在通过在地址栏改变字符串地址，已经可以实现页面内容的变化了。这并不满足需求，我们需要的是在页面上有个像样的导航链接，我们只要点击就可以实现页面内容的变化。制作链接需要标签，我们先来看一下它的语法。 1&lt;router-link to=&quot;/&quot;&gt;[显示字段]&lt;/router-link&gt; to：是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成 to=”/” ， [显示字段] ：就是我们要显示给用户的导航名称，比如首页 新闻页。 明白了router-link的基本语法，我们在 src/App.vue文件中的template里加入下面代码，实现导航。 1234&lt;p&gt;导航 ： &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt;&lt;/p&gt; 第2节：vue-router配置子路由我们上节课初步了解Vue-router的初步知识，也学会了基本的跳转，那我们这节课学习一下子菜单的路由方式，也叫子路由。子路由的情况一般用在一个页面有他的基础模版，然后它下面的页面都隶属于这个模版，只是部分改变样式。我们接着第一节课的实例，在Hi页面的下面新建两个子页面，分别是 “Hi页面1” 和 “Hi页面2”，来实现子路由。 一、改造App.vue的导航代码我们需要先改造app.vue的导航代码，来实现基本的导航功能。我们用标签增加了两个新的导航链接。 App.vue代码 123456&lt;p&gt;导航 ： &lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; | &lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt; | &lt;router-link to=&quot;/hi/hi1&quot;&gt;-Hi页面1&lt;/router-link&gt; | &lt;router-link to=&quot;/hi/hi2&quot;&gt;-Hi页面2&lt;/router-link&gt;&lt;/p&gt; 二、改写components/Hi.vue页面把Hi.vue改成一个通用的模板，加入标签，给子模板提供插入位置。“Hi页面1” 和 “Hi页面2” 都相当于“Hi页面”的子页面，有点想继承关系。我们在“Hi页面”里加入标签。 components/Hi.vue,就是第5行的代码，其他代码不变。 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;router-view class=&quot;aaa&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hi&apos;, data () &#123; return &#123; msg: &apos;Hi, I am JSPang&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 三、在components目录下新建两个组件模板 Hi1.vue 和 Hi2.vue新建的模板和Hi.vue没有太多的差别，知识改变了data中message的值，也就是输出的结果不太一样了。 Hi1.vue 123456789101112131415161718&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hi&apos;, data () &#123; return &#123; msg: &apos;Hi, I am Hi1!&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Hi2.vue 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hi&apos;, data () &#123; return &#123; msg: &apos;Hi, I am Hi2&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 四、修改router/index.js代码我们现在导航有了，母模板和子模板也有了，只要改变我们的路由配置文件就可以了。子路由的写法是在原有的路由配置下加入children字段。 1234children:[&#123;path:&apos;/&apos;,component:xxx&#125;,&#123;path:&apos;xx&apos;,component:xxx&#125;,] children字段后边跟的是个数组，数组里和其他配置路由基本相同，需要配置path和component。具体看一下这个子路由的配置写法。 1234567891011121314151617181920212223242526import Vue from &apos;vue&apos; import Router from &apos;vue-router&apos; import Hello from &apos;@/components/Hello&apos; import Hi from &apos;@/components/Hi&apos; import Hi1 from &apos;@/components/Hi1&apos; import Hi2 from &apos;@/components/Hi2&apos; Vue.use(Router) export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;Hello&apos;, component: Hello &#125;,&#123; path:&apos;/hi&apos;, component:Hi, children:[ &#123;path:&apos;/&apos;,component:Hi&#125;, &#123;path:&apos;hi1&apos;,component:Hi1&#125;, &#123;path:&apos;hi2&apos;,component:Hi2&#125;, ] &#125; ]&#125;) 需要注意的是，在配置路由文件前，需要先用import引入Hi1和Hi2。 第3节：vue-router如何参数传递开发中，参数的传递是个最基本的业务需求。通过URL地址来传递参数是一个形式，这节课我们就看看vue-router为我们提供了那些传递参数的功能。我们先想象一个基本需求，就是在我们点击导航菜单时，跳转页面上能显示出当前页面的路径，来告诉用户你想在所看的页面位置（类似于面包屑导航）。 一、用name传递参数前两节课一直出现name的选项，但是我们都没有讲，这节课我们讲name的一种作用，传递参数。接着上节课的程序继续编写。 两步完成用name传值并显示在模板里： 在路由文件src/router/index.js里配置name属性。 1234567routes: [ &#123; path: &apos;/&apos;, name: &apos;Hello&apos;, component: Hello &#125;] 模板里(src/App.vue)用$router.name的形势接收，比如直接在模板中显示： 1&lt;p&gt;&#123;&#123; $route.name&#125;&#125;&lt;/p&gt; 二、通过 标签中的to传参也许你也会觉的上边的传参很不正规，也不方便，其实我们多数传参是不用name进行传参的，我们用标签中的to属性进行传参，需要您注意的是这里的to要进行一个绑定，写成:to。先来看一下这种传参方法的基本语法： 1&lt;router-link :to=&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;&gt;valueString&lt;/router-link&gt; 这里的to前边是带冒号的，然后后边跟的是一个对象形势的字符串. name：就是我们在路由配置文件中起的name值。 params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值。 了解基本的语法后，我们改造一下我们的src/App.vue里的标签,我们把hi1页面的进行修改。&lt;1router-link :to=&quot;&#123;name:&apos;hi1&apos;,params:&#123;username:&apos;jspang&apos;&#125;&#125;&quot;&gt;Hi页面1&lt;/router-link&gt; 把src/reouter/index.js文件里给hi1配置的路由起个name,就叫hi1. 1&#123;path:&apos;/hi1&apos;,name:&apos;hi1&apos;,component:Hi1&#125;, 最后在模板里(src/components/Hi1.vue)用$route.params.username进行接收. 1&#123;&#123;$route.params.username&#125;&#125; 第4节：单页面多路由区域操作这节课我们讲“单页面多路由区域操作”，实际需求是这样的，在一个页面里我们有2个以上区域，我们通过配置路由的js文件，来操作这些区域的内容。例如我们在src/App.vue里加上两个标签。我们用vue-cli建立了新的项目，并打开了src目录下的App.vue文件，在下面新写了两行标签,并加入了些CSS样式。 123&lt;router-view &gt;&lt;/router-view&gt;&lt;router-view name=&quot;left&quot; style=&quot;float:left;width:50%;background-color:#ccc;height:300px;&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;right&quot; style=&quot;float:right;width:50%;background-color:#c0c;height:300px;&quot;&gt;&lt;/router-view&gt; 现在的页面中有了三个标签，也就是说我们需要在路由里配置这三个区域，配置主要是在components字段里进行。 12345678910111213141516171819202122232425262728import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Hello from &apos;@/components/Hello&apos;import Hi1 from &apos;@/components/Hi1&apos;import Hi2 from &apos;@/components/Hi2&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default:Hello, left:Hi1, right:Hi2 &#125; &#125;,&#123; path: &apos;/Hi&apos;, components: &#123; default:Hello, left:Hi2, right:Hi1 &#125; &#125; ]&#125;) 上边的代码我们编写了两个路径，一个是默认的‘/’，另一个是’/Hi’.在两个路径下的components里面，我们对三个区域都定义了显示内容。 定义好后，我们需要在component文件夹下，新建Hi1.vue和Hi2.vue页面就可以了。 Hi1.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hi1&apos;, data () &#123; return &#123; msg: &apos;I am Hi1 page.&apos; &#125; &#125;&#125;&lt;/script&gt; Hi2.vue 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;hi2&apos;, data () &#123; return &#123; msg: &apos;I am Hi2 page.&apos; &#125; &#125;&#125;&lt;/script&gt; 最后在App.vue中配置我们的就可以了 12&lt;router-link to=&quot;/&quot;&gt;首页&lt;/router-link&gt; | &lt;router-link to=&quot;/hi&quot;&gt;Hi页面&lt;/router-link&gt; | 第5节：vue-router 利用url传递参数我们在第3节虽然已经学会传递参数，但是我们这些老程序员的情怀还是利用url来传值，因为我们以前在前后端没有分开开发的时候，经常这样做。在实际开发也是有很多用URL传值的需求，比如我们在新闻列表中有很多新闻标题整齐的排列，我们需要点击每个新闻标题打开不同的新闻内容，这时在跳转路由时跟上新闻编号就十分实用。 :冒号的形式传递参数我们可以在理由配置文件里以:冒号的形式传递参数，这就是对参数的绑定。 在配置文件里以冒号的形式设置参数。我们在/src/router/index.js文件里配置路由。 1234&#123; path:&apos;/params/:newsId/:newsTitle&apos;, component:Params&#125; 我们需要传递参数是新闻ID（newsId）和新闻标题（newsTitle）.所以我们在路由配置文件里制定了这两个值。 在src/components目录下建立我们params.vue组件，也可以说是页面。我们在页面里输出了url传递的的新闻ID和新闻标题。 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;p&gt;新闻ID：&#123;&#123; $route.params.newsId&#125;&#125;&lt;/p&gt; &lt;p&gt;新闻标题：&#123;&#123; $route.params.newsTitle&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;params&apos;, data () &#123; return &#123; msg: &apos;params page&apos; &#125; &#125;&#125;&lt;/script&gt; 在App.vue文件里加入我们的标签。这时候我们可以直接利用url传值了。 1&lt;router-link to=&quot;/params/198/jspang website is very good&quot;&gt;params&lt;/router-link&gt; | 我们已经实现了以url方式进行传值，这在实际开发中经常使用，必须完全了解。我希望你看完视频后或者学完文章后能多练习两边，并在实际项目中充分使用。 正则表达式在URL传值中的应用上边的例子，我们传递了新闻编号，现在需求升级了，我们希望我们传递的新闻ID只能是数字的形式，这时候我们就需要在传递时有个基本的类型判断，vue是支持正则的。 加入正则需要在路由配置文件里（/src/router/index.js）以圆括号的形式加入。 1path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, 加入了正则，我们再传递数字之外的其他参数，params.vue组件就没有办法接收到。 第6节 ：vue-router 的重定向-redirect开发中有时候我们虽然设置的路径不一致，但是我们希望跳转到同一个页面，或者说是打开同一个组件。这时候我们就用到了路由的重新定向redirect参数。 redirect基本重定向我们只要在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了。我们来看一个简单的配置。 123456789101112131415export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, component: Hello &#125;,&#123; path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, component:Params &#125;,&#123; path:&apos;/goback&apos;, redirect:&apos;/&apos; &#125; ]&#125;) 这里我们设置了goback路由，但是它并没有配置任何component（组件），而是直接redirect到path:’/’下了，这就是一个简单的重新定向。 重定向时传递参数我们已经学会了通过url来传递参数，那我们重定向时如果也需要传递参数怎么办？其实vue也已经为我们设置好了，我们只需要在ridirect后边的参数里复制重定向路径的path参数就可以了。可能你看的有点晕，我们来看一段代码： 1234567&#123; path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, component:Params&#125;,&#123; path:&apos;/goParams/:newsId(\\d+)/:newsTitle&apos;, redirect:&apos;/params/:newsId(\\d+)/:newsTitle&apos;&#125; 已经有了一个params路由配置，我们在设置一个goParams的路由重定向，并传递了参数。这时候我们的路由参数就可以传递给params.vue组件了。参数接收方法和正常的路由接收方法一样。 第7节：alias别名的使用上节学习了路由的重定向，我相信大家已经可以熟练使用redirect进行重定向了。使用alias别名的形式，我们也可以实现类似重定向的效果。 1.首先我们在路由配置文件里（/src/router/index.js），给上节课的Home路径起一个别名，jspang。 12345&#123; path: &apos;/hi1&apos;, component: Hi1, alias:&apos;/jspang&apos; &#125; 2.配置我们的，起过别名之后，可以直接使用标签里的to属性，进行重新定向。 1&lt;router-link to=&quot;/jspang&quot;&gt;jspang&lt;/router-link&gt; redirect和alias的区别redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。 alias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了中的内容。 填个小坑：别名请不要用在path为’/’中，如下代码的别名是不起作用的。 12345&#123; path: &apos;/&apos;, component: Hello, alias:&apos;/home&apos;&#125; 在实际项目中我们遇到了这样的坑，开始以为是自己的代码写的有问题，找了两个小时作用。后来发现不是代码问题，只是vue不支持这样使用。我们犯过错误，踩过了坑，希望大家就不要踩了。 第8节：路由的过渡动画在开发中有一种需求叫高端、大气、上档次。所以作为一个大前端有责任让你的程序开起来更酷炫。可以在页面切换时我们加入一些动画效果，提升我们程序的动效设计。这节课我们就学习一下路由的过渡动画效果制作 标签想让路由有过渡动画，需要在标签的外部添加标签，标签还需要一个name属性。 123&lt;transition name=&quot;fade&quot;&gt; &lt;router-view &gt;&lt;/router-view&gt;&lt;/transition&gt; 我们在/src/App.vue文件里添加了标签，并给标签起了一个名字叫fade。 css过渡类名：组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名： fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。 fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。 fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。 fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除。 从上面四个类名可以看出，fade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。 那我们就在App.vue页面里加入四种CSS样式效果，并利用CSS3的transition属性控制动画的具体效果。代码如下： 12345678910111213.fade-enter &#123; opacity:0;&#125;.fade-leave&#123; opacity:1;&#125;.fade-enter-active&#123; transition:opacity .5s;&#125;.fade-leave-active&#123; opacity:0; transition:opacity .5s;&#125; 上边的代码设置了改变透明度的动画过渡效果，但是默认的mode模式in-out模式，这并不是我们想要的。下面我们学一下mode模式。 过渡模式mode： in-out:新元素先进入过渡，完成之后当前元素过渡离开。 out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。 这节课只能算是一个简单的过渡入门，教会大家原理，如果想做出实用酷炫的过渡效果，你需要有较强的动画制作能力，我们下节课继续学习动画的知识。 第9节：mode的设置和404页面的处理在学习过渡效果的时候，我们学了mode的设置，但是在路由的属性中还有一个mode。这节课我们就学习一下另一个mode模式和404页面的设置。 mode的两个值 histroy:当你使用 history 模式时，URL 就像正常的 url，例如 http://jsapng.com/lms/，也好看！ hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。 具体的效果我在视频中会有所掩饰，不理解的小伙伴可以到视频中进行查看。 404页面的设置：用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，为此美工都会设计一个漂亮的页面，这个页面就是我们常说的404页面。vue-router也为我们提供了这样的机制. 1.设置我们的路由配置文件（/src/router/index.js）：1234&#123; path:&apos;*&apos;, component:Error&#125; 这里的path:’*’就是找不到页面时的配置，component是我们新建的一个Error.vue的文件。 2.新建404页面：在/src/components/文件夹下新建一个Error.vue的文件。简单输入一些有关错误页面的内容。 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: &apos;Error:404&apos; &#125; &#125;&#125;&lt;/script&gt; 3.我们在用瞎写一个标签的路径。1&lt;router-link to=&quot;/bbbbbb&quot;&gt;我是瞎写的&lt;/router-link&gt; | 预览一下我们现在的结果，就已经实现404页面的效果。 第10节：路由中的钩子我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节课就介绍这两种钩子函数的写法。 路由配置文件中的钩子函数我们知道一个组件从进入到销毁有很多的钩子函数，同样在路由中也设置了钩子函数。路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中。我们这节课就介绍这两种钩子函数的写法。 路由配置文件中的钩子函数我们可以直接在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter,就是在进入此路由配置时。先来看一段具体的代码： 123456789&#123; path:&apos;/params/:newsId(\\d+)/:newsTitle&apos;, component:Params, beforeEnter:(to,from,next)=&gt;&#123; console.log(&apos;我进入了params模板&apos;); console.log(to); console.log(from); next();&#125;, 我们在params路由里配置了bdforeEnter得钩子函数，函数我们采用了ES6的箭头函数，需要传递三个参数。我们并在箭头函数中打印了to和from函数。具体打印内容可以在控制台查看object。 三个参数： to:路由将要跳转的路径信息，信息是包含在对像里边的。 from:路径跳转前的路径信息，也是一个对象的形式。 next:路由的控制参数，常用的有next(true)和next(false)。 写在模板中的钩子函数在配置文件中的钩子函数，只有一个钩子-beforeEnter，如果我们写在模板中就可以有两个钩子函数可以使用： beforeRouteEnter：在路由进入前的钩子函数。 beforeRouteLeave：在路由离开前的钩子函数。 1234567891011121314151617export default &#123; name: &apos;params&apos;, data () &#123; return &#123; msg: &apos;params page&apos; &#125; &#125;, beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(&quot;准备进入路由模板&quot;); next(); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log(&quot;准备离开路由模板&quot;); next(); &#125;&#125;&lt;/script&gt; 这是我们写在params.vue模板里的路由钩子函数。它可以监控到路由的进入和路由的离开，也可以轻易的读出to和from的值。 第11节：编程式导航这是这篇文章的最后一节，前10节课的导航都是用标签或者直接操作地址栏的形式完成的，那如果在业务逻辑代码中需要跳转页面我们如何操作？这就是我们要说的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。 this.$router.go(-1) 和 this.$router.go(1)这两个编程式导航的意思是后退和前进，功能跟我们浏览器上的后退和前进按钮一样，这在业务逻辑中经常用到。比如条件不满足时，我们需要后退。 router.go(-1)代表着后退，我们可以让我们的导航进行后退，并且我们的地址栏也是有所变化的。 1.我们先在app.vue文件里加入一个按钮，按钮并绑定一个goback( )方法。 1&lt;button @click=&quot;goback&quot;&gt;后退&lt;/button&gt; 2.在我们的script模块中写入goback()方法，并使用this.$router.go(-1),进行后退操作。 12345678910&lt;script&gt;export default &#123; name: &apos;app&apos;, methods:&#123; goback()&#123; this.$router.go(-1); &#125; &#125;&#125;&lt;/script&gt; 打开浏览器进行预览，这时我们的后退按钮就可以向以前的网页一样后退了。 router.go(1):代表着前进，用法和后退一样，我在这里就不重复码字了（码字辛苦希望大家理解）。 this.$router.push(‘/xxx ‘)这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时，需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue-Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js深入浅出]]></title>
    <url>%2F2017%2F08%2F18%2FJavaScript%2Fjs%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%2F</url>
    <content type="text"><![CDATA[一.数据类型原始类型 number string boolean null undefined object 对象 Function Array Date 2.隐式转换字符串变数字 num - 0 数字变字符串 num + ‘’ 1237” – 7 // 30“37” + 7 // 377 a===b 类型不同 返回false 类型相同 NaN ≠ NaN new Object ≠ new Object null === null undefined === undefined a == b 类型相同 同=== 类型不同，尝试类型转换和比较: null == undefined 相等 number == string 转number1 == “1.0” // true boolean == ? 转number1 == true // true object == number | string尝试对象转为基本类型new String(‘hi’) == ‘hi’ // true 其它：false 3.包装对象1234var a = “string”;alert(a.length);a.t = 3;alert(a.t); 当对一个字符串（或数组或数字或布尔）（基本类型）进行对象访问的时候，会创建一个对象，当访问完毕，对象立刻销毁，所以a.t设置完后，不存在 4.类型检测typeof 123456789typeof 100 === “number”typeof true === “boolean”typeof function () &#123;&#125; === “function”typeof(undefined) ) === “undefined”typeof(new Object() ) === “object”typeof( [1， 2] ) === “object”typeof(NaN ) === “number”**typeof(null) === “object”** obj instanceof Object 12[1, 2] instanceof Array === truenew Object() instanceof Array === false Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。 Instanceof的判断队则是：沿着A的proto这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。 Caution！不同window或iframe间的对象类型检测不能使用instanceof！ Object.prototype.toString 123456Object.prototype.toString.apply([]); === “[object Array]”;Object.prototype.toString.apply(function()&#123;&#125;); === “[object Function]”;Object.prototype.toString.apply(null); === “[object Null]”Object.prototype.toString.apply(undefined); === “[object Undefined]”IE6/7/8 Object.prototype.toString.apply(null) 返回”[object Object]” constructorconstructor会指向构造这个对象的构造器或构造函数，constructor可以改写，使用时要小心 duck type通过一些特征来判断 类型检测小结 typeof 适合基本类型及function检测，遇到null失效。 [[Class]] 通过{}.toString拿到，适合内置对象和基元类型，遇到null和undefined失效(IE678等返回[object Object])。 instanceof 适合自定义对象，也可以用来检测原生对象，在不同iframe和window间检测时失效。 二.表达式和运算符表达式是一种JS短语，可使JS解释器用来产生一个值。 表达式1.原始表达式 1.常量、直接量 3.14, “test” 2.关键字 null, this, true 3.变量 i, k, j 复合表达式 10*20 2.数组、对象的初始化表达式 [1, 2] new Array(1, 2); [1, , , 4] [1, undefined, undefined , 4] { x : 1, y : 2} var o = new Object();o.x = 1; o.y = 2; 3.函数表达式1var fe = function()&#123;&#125;; 4.属性访问表达式1var o = &#123;x : 1&#125;; o.x o[‘x’] 5.调用表达式1func(); 6.对象创建表达式12new Func(1, 2);new Object; 运算符一元 +num 二元 a + b 三元 c ? a : b 赋值 x += 1 比较 a == b 算术 a - b 位 a | b 逻辑 exp1 &amp;&amp; exp2 字符串 “a” + “b” 特殊 1.delete obj.x123456789101112var obj = &#123;x : 1&#125;;obj.x; // 1delete obj.x;obj.x; // undefinedvar obj = &#123;&#125;;Object.defineProperty(obj, &apos;x&apos;, &#123; configurable : false, value : 1&#125;);delete obj.x; // falseobj.x;// 1 神奇的Object.defineProperty 123var a=&#123;&#125;Object.defineProperty(a,&quot;b&quot;,&#123;value:123&#125;)console.log(a,b);//123 传入参数 第一个参数:目标对象 第二个参数:需要定义的属性或方法的名字。 第三个参数:目标属性所拥有的特性。(默认为false)（descriptor） 前两个参数不多说了，一看代码就懂，主要看第三个参数descriptor，看看有哪些取值 value:属性的值(不用多说了) 12345var a= &#123;&#125;Object.defineProperty(a,&quot;b&quot;,&#123; value:123&#125;)console.log(a.b);//123 writable:如果为false，属性的值就不能被重写,只能为只读了 123456789var a = &#123;&#125;;Object.defineProperty(o, &quot;b&quot;, &#123; value : 123,writable : false &#125;);console.log(a.b); // 打印 37a.b = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）console.log(o.a); // 打印 37， 赋值不起作用。 configurable:总开关，一旦为false，就不能再设置他的（value，writable，configurable） enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。 1234567891011121314var a= &#123;&#125;Object.defineProperty(a,&quot;b&quot;,&#123; value:3445, enumerable:true&#125;)console.log(Object.keys(a));// 打印[&quot;b&quot;]改为falsevar a= &#123;&#125;Object.defineProperty(a,&quot;b&quot;,&#123; value:3445, enumerable:false //注意咯这里改了&#125;)console.log(Object.keys(a));// 打印[] get:一会细说 set:一会细说 2.in12window.x = 1;‘x’ in window; // true 3.instanceof, typeof12&#123;&#125; instanceof Object// truetypeof 100 === ‘number’ // true 4.new123456function Foo()&#123;&#125;Foo.prototype.x = 1;var obj = new Foo();obj.x; // 1obj.hasOwnProperty(&apos;x&apos;); // falseobj.__proto__.hasOwnProperty(&apos;x&apos;); // true hasOwnProperty 本身的属性 proto即原型，obj这个对象的原型指向Foo这个函数的prototype 5.this12345this; // window (浏览器)var obj = &#123;func : function()&#123;return this;&#125;&#125;;obj.func(); // obj 6.void12void 0 // undefinedvoid(0) // undefined 三.语句1.block请注意：没有块级作用域 12345var i = 0for (; i &lt; 10; i++) &#123;var str = &quot;hi&quot;;console.log(str);&#125; 为了防止混淆，把for循环中的定义变量var，拿出去写 2.var1var a = b = 1; b隐式创建了全局变量（所以一条语句定义多个变量，一定要分开） 3.try catch1234567try &#123; throw &quot;test&quot;;&#125; catch (ex) &#123;console.log(ex); // test&#125; finally &#123;console.log(&apos;finally&apos;);&#125; 先执行try catch中的代码，如果抛出了异常，会由catch从句捕获并且执行，如果没有发生异常，catch部分的代码被忽略掉，但不管是否出现异常，都会执行finally从句；try后面必须接一个catch或一个finally 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950try &#123;try &#123;throw new Error(&quot;oops&quot;);&#125;finally &#123;console.log(&quot;finally&quot;);&#125;&#125;catch (ex) &#123;console.error(&quot;outer&quot;, ex.message);&#125;&quot;finally&quot;&quot;outer&quot; &quot;oops&quot;try &#123; try &#123; throw new Error(&quot;oops&quot;); &#125; catch (ex) &#123;console.error(&quot;inner&quot;, ex.message); &#125; finally &#123;console.log(&quot;finally&quot;); &#125;&#125;catch (ex) &#123; console.error(&quot;outer&quot;, ex.message);&#125;&quot;inner&quot; &quot;oops&quot;&quot;finally&quot;try &#123; try &#123;throw new Error(&quot;oops&quot;); &#125; catch (ex) &#123;console.error(&quot;inner&quot;, ex.message);throw ex; &#125; finally &#123;console.log(&quot;finally&quot;); &#125;&#125;catch (ex) &#123; console.error(&quot;outer&quot;, ex.message);&#125;&quot;inner&quot; &quot;oops&quot;&quot;finally&quot;&quot;outer&quot; &quot;oops&quot; 4.function12345fd(); // truefunction fd() &#123;// do sth.return true;&#125; 函数声明，会被前置处理掉 1234fe(); // TypeErrorvar fe = function() &#123;// do sth.&#125;; 函数表达式，不会提前处理 5.for…in12345var p;var obj = &#123;x : 1, y: 2&#125;for (p in obj) &#123;&#125; 顺序不确定 enumerable为false时不会出现 for in对象属性时受原型链影响 6.switch7.循环8.with12345678910with (&#123;x : 1&#125;) &#123;console.log(x);&#125;with (document.forms[0]) &#123;console.log(name.value);&#125;var form = document.forms[0];console.log(form.name.value); 通俗的理解就是，with代表了那个对象。可是这样写有几个缺点：（因此，应该采用变量取对象的方法） 让JS引擎优化更难 可读性差 可被变量定义代替 严格模式下被禁用 修改当前的作用域 严格模式严格模式是一种特殊的执行模式，它修复了部分语言上的不足， 提供更强的错误检查，并增强安全性。 12345678function func() &#123;&apos;use strict&apos;;&#125; &apos;use strict&apos;;function func() &#123;&#125; 1.不允许用with123456!function() &#123; &apos;use strict&apos;; with(&#123;x : 1&#125;) &#123;console.log(x); &#125;&#125;(); //SyntaxError 2.不允许未声明的变量被赋值12345!function() &#123; &apos;use strict&apos;; x = 1; console.log(window.x);&#125;(); //ReferenceError 3.arguments变为参数的静态副本1234!function(a) &#123; arguments[0] = 100; console.log(a);&#125;(1); //100 在一般模式下，如果定义了一个函数，调用它并且传递参数，那么它对应的形参和arguments[0]有一个相互的绑定关系，就是说如果我们修改了arguments[0]，那么这个函数对应的形参b就会被修改了，所以输出100。 如果我们现在不给函数传值，就是像下面这个样子， 1234! function (a)&#123;arguments[0]=100;console.log(a);//undefined &#125;(); 那么无论我们如何修改arguments[0]的值，输出的都是undefined，因为宝宝你没有传递参数进去啊，~ o(￣▽￣)ブ !function(a) { ‘use strict’; arguments[0] = 100; console.log(a);}(1); //1在严格模式下，arguments[0]变为参数的静态副本，就是说无论函数的参数有没有传递，都不会和arguments相互影响 12345!function(a) &#123;&apos;use strict&apos;;arguments[0].x = 100;console.log(a.x);&#125;(&#123;x:1&#125;); //100 但是如果传入的是一个对象的话，将会按照共享传递，使用arguments修改对象的属性，那么还是会相互影响的。 arguments用法 每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用arguments的元素。arguments.length为函数实参个数，arguments.callee引用函数自身。 12345678var sum = function (n) &#123;if (1 == n) &#123;return 1;&#125; else &#123;return n + arguments.callee(n - 1);&#125;&#125;alert(sum(6)); 4.delete参数、函数名报错1234!function(a) &#123; &apos;use strict&apos;; delete a;&#125;(1); //SyntaxError 5.delete不可配置的属性报错1234567!function(a) &#123; &apos;use strict&apos;; var obj = &#123;&#125;; Object.defineProperty(obj, &apos;a&apos;, &#123;configurable : false&#125;); delete obj.a;&#125;(1); //TypeError 6.对象字面量重复属性名报错1234!function() &#123; &apos;use strict&apos;; var obj = &#123;x : 1, x : 2&#125;;&#125;(); //SyntaxError 7.禁止八进制字面量1234!function() &#123; &apos;use strict&apos;; console.log(0123);&#125;(); //SyntaxError 8.eval, arguments变为关键字，不能作为变量、函数名1234!function() &#123; &apos;use strict&apos;; function eval()&#123;&#125;&#125;(); //SyntaxError 9.eval独立作用域12345!function() &#123; &apos;use strict&apos;; eval(&apos;var evalVal = 2;&apos;); console.log(typeof evalVal);&#125;(); //undefined 小结 1.不允许用with 2.所有变量必须声明, 赋值给为声明的变量报错，而不是隐式创建全局变量。 3.eval中的代码不能创建eval所在作用域下的变量、函数。而是为eval单独创建一个作用域，并在eval返回时丢弃。 4.函数中得特殊对象arguments是静态副本，而不像非严格模式那样，修改arguments或修改参数变量会相互影响。 5.删除configurable=false的属性时报错，而不是忽略 6.禁止八进制字面量，如010 (八进制的8) 7.eval, arguments变为关键字，不可作为变量名、函数名等 8.一般函数调用时(不是对象的方法调用，也不使用apply/call/bind等修改this)this指向null，而不是全局对象。 9.若使用apply/call，当传入null或undefined时，this将指向null或undefined，而不是全局对象。 10.试图修改不可写属性(writable=false)，在不可扩展的对象上添加属性时报TypeError，而不是忽略。 11.arguments.caller, arguments.callee被禁用 四.对象对象中包含一系列属性，这些属性是无序的。每个属性都有一个字符串key和对应的value。 123var obj = &#123;x : 1, y : 2&#125;;obj.x; // 1obj.y; // 2 对象创建-字面量 123456789var obj1 = &#123;x : 1, y : 2&#125;;var obj2 = &#123;x : 1,y : 2,o : &#123;z : 3,n : 4&#125;&#125;; 1.创建对象-new/原型链123456789101112131415161718192021222324252627282930function foo()&#123;&#125;foo.prototype.z = 3;var obj =new foo();obj.y = 2;obj.x = 1;obj.x; // 1obj.y; // 2obj.z; // 3typeof obj.toString; // ‘function&apos;&apos;z&apos; in obj; // trueobj.hasOwnProperty(&apos;z&apos;); // falseobj.z不在obj中，会向上查找，即沿着原型链obj.z = 5;obj.hasOwnProperty(&apos;z&apos;); // truefoo.prototype.z; // still 3obj.z; // 5obj.z = undefined;obj.z; // undefineddelete obj.z; // trueobj.z; // 3delete obj.z; // true**obj.z; // still 3!!!**不能delete掉原型链的属性z 2.对象创建-Object.create1234var obj = Object.create(&#123;x : 1&#125;);obj.x // 1typeof obj.toString // &quot;function&quot;obj.hasOwnProperty(&apos;x&apos;);// false 创建一个新对象，并将这个对象的原型指向Object.propotype，create后面的属性属于object.propotype中。 12var obj = Object.create(null);obj.toString // undefined (2)属性操作1.属性读写12345678910111213141516171819var obj = &#123;x : 1, y : 2&#125;;obj.x; // 1obj[&quot;y&quot;]; // 2obj[&quot;x&quot;] = 3;obj.y = 4;var obj = &#123;x1 : 1, x2 : 2&#125;;var i = 1, n = 2;for (; i &lt;= n; i++) &#123;console.log(obj[&apos;x&apos; + i]);&#125;// 输出: 1, 2var p;for (p in obj) &#123;console.log(obj[p]);&#125; 2.属性读写-异常1234567891011var obj = &#123;x : 1&#125;;obj.y; // undefinedvar yz = obj.y.z; // TypeError: Cannot read property &apos;z&apos; of undefinedobj.y.z = 2; // TypeError: Cannot set property &apos;z&apos; of undefinedvar yz;if (obj.y) &#123; yz = obj.y.z;&#125;var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z; 3.属性删除12345678910var person = &#123;age : 28, title : &apos;fe&apos;&#125;;delete person.age; // truedelete person[&apos;title&apos;]; // trueperson.age; // undefineddelete person.age; // truedelete Object.prototype; // false,var descriptor = Object.getOwnPropertyDescriptor(Object, &apos;prototype&apos;);descriptor.configurable; // false 不能delete Object.prototype 1234567var globalVal = 1;delete globalVal; // false(function() &#123; var localVal = 1; return delete localVal;&#125;()); // false 不能delete 变量 1234567function fd() &#123;&#125;delete fd; // false(function() &#123; function fd() &#123;&#125;; return delete fd;&#125;()); // false 不能delete 函数 123ohNo = 1;window.ohNo; // 1delete ohNo; // true 可以delete 全局变量 4.属性检测1234567891011121314var cat = new Object;cat.legs = 4;cat.name = &quot;Kitty&quot;;&apos;legs&apos; in cat; // true&apos;abc&apos; in cat; // false&quot;toString&quot; in cat; // true, inherited property!!!cat.hasOwnProperty(&apos;legs&apos;); // truecat.hasOwnProperty(&apos;toString&apos;); // falsecat.propertyIsEnumerable(&apos;legs&apos;); // truecat.propertyIsEnumerable(&apos;toString&apos;); // false 如果判断的属性存在于Object对象的原型内，不管它是否可枚举都会返回false。 12345678910111213Object.defineProperty(cat, &apos;price&apos;, &#123;enumerable : false, value : 1000&#125;);cat.propertyIsEnumerable(&apos;price&apos;); // falsecat.hasOwnProperty(&apos;price&apos;); // trueif (cat &amp;&amp; cat.legs) &#123; cat.legs *= 2;&#125;if (cat.legs !== undefined) &#123; // only if cat.legs is not undefined&#125; 5.getter setter方法(另一种读写属性的方式)getter 是一种获得属性值的方法，setter是一种设置属性值的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var man = &#123; name : &apos;Bosn&apos;, weibo : &apos;@Bosn&apos;, get age() &#123; return new Date().getFullYear() - 1988; &#125;, set age(val) &#123; console.log(&apos;Age can\&apos;t be set to &apos; + val); &#125;&#125;console.log(man.age); // 27man.age = 100; // Age can&apos;t be set to 100console.log(man.age); // still 27var man = &#123; weibo : &apos;@Bosn&apos;, $age : null, get age() &#123; if (this.$age == undefined) &#123; return new Date().getFullYear() - 1988; &#125; else &#123; return this.$age; &#125; &#125;, set age(val) &#123; val = +val; if (!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) &#123; this.$age = +val; &#125; else &#123; throw new Error(&apos;Incorrect val = &apos; + val); &#125; &#125;&#125;console.log(man.age); // 27man.age = 100;console.log(man.age); // 100;man.age = &apos;abc&apos;; // error:Incorrect val = NaNget/set与原型链function foo() &#123;&#125;Object.defineProperty(foo.prototype, &apos;z&apos;, &#123;get : function()&#123;return 1;&#125;&#125;);var obj = new foo();obj.z; // 1obj.z = 10;obj.z; // still 1Object.defineProperty(obj, &apos;z&apos;, &#123;value : 100, configurable: true&#125;);obj.z; // 100;delete obj.z;obj.z; // back to 1不能修改get的属性 (3)属性标签123Object.getOwnPropertyDescriptor(&#123;pro : true&#125;, &apos;pro&apos;);// Object &#123;value: true, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(&#123;pro : true&#125;, &apos;a&apos;); // undefined Object.getOwnPropertyDescriptor 函数 语法：Object.getOwnPropertyDescriptor(object, propertyname) 参数：object 必需。包含属性的对象。propertyname 必需。属性的名称。 123456789101112var person = &#123;&#125;;Object.defineProperty(person, &apos;name&apos;, &#123; configurable : false, writable : false, enumerable : true, value : &quot;Bosn Ma&quot;&#125;);person.name; // Bosn Maperson.name = 1;person.name; // still Bosn Madelete person.name; // false defineProperty中的属性默认false 1234567891011121314151617181920212223242526272829303132333435363738394041Object.defineProperty(person, &apos;type&apos;, &#123; configurable : true, writable : true, enumerable : false, value : &quot;Object&quot;&#125;);Object.keys(person); // [&quot;name&quot;]Object.defineProperties(person, &#123; title : &#123;value : &apos;fe&apos;, enumerable : true&#125;, corp : &#123;value : &apos;BABA&apos;, enumerable : true&#125;, salary : &#123;value : 50000, enumerable : true, writable : true&#125;&#125;);Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);// Object &#123;value: 50000, writable: true, enumerable: true, configurable: false&#125;Object.getOwnPropertyDescriptor(person, &apos;corp&apos;);// Object &#123;value: &quot;BABA&quot;, writable: false, enumerable: true, configurable: false&#125;Object.defineProperties(person, &#123; title : &#123;value : &apos;fe&apos;, enumerable : true&#125;, corp : &#123;value : &apos;BABA&apos;, enumerable : true&#125;, salary : &#123;value : 50000, enumerable : true, writable : true&#125;, luck : &#123; get : function() &#123; return Math.random() &gt; 0.5 ? &apos;good&apos; : &apos;bad&apos;; &#125; &#125;, promote : &#123; set : function (level) &#123; this.salary *= 1 + level * 0.1; &#125; &#125;&#125;);Object.getOwnPropertyDescriptor(person, &apos;salary&apos;);// Object &#123;value: 50000, writable: true, enumerable: true, configurable: false&#125;Object.getOwnPropertyDescriptor(person, &apos;corp&apos;);// Object &#123;value: &quot;BABA&quot;, writable: false, enumerable: true, configurable: false&#125;person.salary; // 50000person.promote = 2;person.salary; // 60000 getOwnPropertyDescriptor属性值默认false 1.configurable为false时，不能delete,不能修改getter/setter方法，不能修改属性标签 2.writable为false时，不能通过属性赋值，修改属性的值 3.configurable和writeable都是false时，才不能修改属性的值 （4）.对象标签1.原型标签 proto2.class标签1234567891011var toString = Object.prototype.toString;function getType(o)&#123;return toString.call(o).slice(8,-1);&#125;;toString.call(null); // &quot;[object Null]&quot;getType(null); // &quot;Null&quot;getType(undefined); // &quot;Undefined&quot;getType(1); // &quot;Number&quot;getType(new Number(1)); // &quot;Number&quot;typeof new Number(1); // &quot;object&quot;getType(true); // &quot;Boolean&quot;getType(new Boolean(true)); // &quot;Boolean&quot; slice() 方法 定义和用法slice() 方法可从已有的数组中返回选定的元素。 语法arrayObject.slice(start,end) start必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。 end可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 返回值返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。 说明请注意，该方法并不会修改数组，而是返回一个子数组。 3.extensible标签扩展特性 如果一个对象可以添加新的属性，则这个对象是可扩展的。让这个对象变的不可扩展，也就是不能再有新的属性 12var obj = &#123;x : 1, y : 2&#125;;Object.isExtensible(obj); // true 对象的extensible属性用于表示是否允许在对象中动态添加新的property。ECMAScript 3标准中，所有的对象都是extensible的。 12Object.preventExtensions(obj);Object.isExtensible(obj); // false 使一个对象变成不是extensible的，可以使用Object.preventExtensions()语句 1234obj.z = 1;obj.z; // undefined, add new property failedObject.getOwnPropertyDescriptor(obj, &apos;x&apos;);// Object &#123;value: 1, writable: true, enumerable: true, configurable: true&#125; 密封特性密封对象是指那些不可 扩展 的，且所有自身属性都不可配置的（non-configurable）对象。 或则说 密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象 1234Object.seal(obj);Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);// Object &#123;value: 1, writable: true, enumerable: true, configurable: false&#125;Object.isSealed(obj); // true 冻结特性冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。 123456Object.freeze(obj);Object.getOwnPropertyDescriptor(obj, &apos;x&apos;);// Object &#123;value: 1, writable: false, enumerable: true, configurable: false&#125;Object.isFrozen(obj); // true// [caution] not affects prototype chain!!! (5).序列化v 12345678910111213141516171819202122232425262728293031323334353637383940414243444546ar obj = &#123;x : 1, y : true, z : [1, 2, 3], nullVal : null&#125;;JSON.stringify(obj); // &quot;&#123;&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullVal&quot;:null&#125;&quot;obj = &#123;val : undefined, a : NaN, b : Infinity, c : new Date()&#125;;JSON.stringify(obj); // &quot;&#123;&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:&quot;2015-01-20T14:15:43.910Z&quot;&#125;&quot;obj = JSON.parse(&apos;&#123;&quot;x&quot; : 1&#125;&apos;);obj.x; // 1var obj = &#123; x : 1, y : 2, o : &#123; o1 : 1, o2 : 2, toJSON : function () &#123; return this.o1 + this.o2; &#125; &#125;&#125;;JSON.stringify(obj); // &quot;&#123;&quot;x&quot;:1,&quot;y&quot;:2,&quot;o&quot;:3&#125;&quot;stringify()用于从一个对象解析出字符串，如var a = &#123;a:1,b:2&#125;结果：JSON.stringify(a)&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&quot;parse用于从一个字符串中解析出json对象,如var str = &apos;&#123;&quot;name&quot;:&quot;huangxiaojian&quot;,&quot;age&quot;:&quot;23&quot;&#125;&apos;结果：JSON.parse(str)Objectage: &quot;23&quot;name: &quot;huangxiaojian&quot;__proto__: Object注意：单引号写在&#123;&#125;外，每个属性名都必须用双引号，否则会抛出异常。 （5）.其他对象方法1234567891011var obj = &#123;x : 1, y : 2&#125;;obj.toString(); // “[object Object]”obj.toString = function() &#123;return this.x + this.y&#125;;“Result “ + obj; // “Result 3”, by toString+obj; // 3, from toStringobj.valueOf = function() &#123;return this.x + this.y + 100;&#125;;+obj; // 103, from valueOf&quot;Result &quot; + obj; // still &quot;Result 103&quot; object.toString( ) 返回值 toString()函数的返回值为String类型。返回当前对象的字符串形式。 Array将 Array 的每个元素转换为字符串，并将它们依次连接起来，两个元素之间用英文逗号作为分隔符进行拼接。 Boolean如果布尔值是true，则返回”true”。否则返回”false”。 Date返回日期的文本表示。 Error返回一个包含相关错误信息的字符串。 Function返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }” Number返回数值的字符串表示。还可返回以指定进制表示的字符串 String返回 String 对象的值。 Object(默认)返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。 object.valueOf( ) 返回值 函数返回指定对象的原始值。 Array数组实例对象。 Boolean布尔值。 Date以毫秒数存储的时间值，从 UTC 1970 年 1 月 1 日午夜开始计算。 Function函数本身。 Number数字值。 Object对象本身。这是默认设置。 String字符串值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var bbb = &#123; i: 10, toString: function() &#123; console.log(&apos;toString&apos;); return this.i; &#125;, valueOf: function() &#123; console.log(&apos;valueOf&apos;); return this.i; &#125; &#125; alert(bbb);// 10 toString alert(+bbb); // 10 valueOf alert(&apos;&apos;+bbb); // 10 valueOf alert(String(bbb)); // 10 toString alert(Number(bbb)); // 10 valueOf alert(bbb == &apos;10&apos;); // true valueOf alert(bbb === &apos;10&apos;); // false var aa = &#123; i: 10, toString: function() &#123; console.log(&apos;toString&apos;); return this.i; &#125; &#125; alert(aa);// 10 toString alert(+aa); // 10 toString alert(&apos;&apos;+aa); // 10 toString alert(String(aa)); // 10 toString alert(Number(aa)); // 10 toString alert(aa == &apos;10&apos;); // true toString 再看valueOf。 var bb = &#123; i: 10, valueOf: function() &#123; console.log(&apos;valueOf&apos;); return this.i; &#125; &#125; alert(bb);// [object Object] alert(+bb); // 10 valueOf alert(&apos;&apos;+bb); // 10 valueOf alert(String(bb)); // [object Object] alert(Number(bb)); // 10 valueOf alert(bb == &apos;10&apos;); // true valueOf发现有点不同吧？！它没有像上面toString那样统一规整。对于那个[object Object]，我估计是从Object那里继承过来的，我们再去掉它看看。 Object.prototype.toString = null; var cc = &#123; i: 10, valueOf: function() &#123; console.log(&apos;valueOf&apos;); return this.i; &#125; &#125; alert(cc);// 10 valueOf alert(+cc); // 10 valueOf alert(&apos;&apos;+cc); // 10 valueOf alert(String(cc)); // 10 valueOf alert(Number(cc)); // 10 valueOf alert(cc == &apos;10&apos;); // true valueOf 总结：valueOf偏向于运算，toString偏向于显示。 1、 在进行强转字符串类型时将优先调用toString方法，强转为数字时优先调用valueOf。 2、 在有运算操作符的情况下，valueOf的优先级高于toString。 3.如果只重写了toString，对象转换时会无视valueOf的存在来进行转换。但是，如果只重写了valueOf方法，在要转换为字符串的时候会优先考虑valueOf方法。在不能调用toString的情况下，只能让valueOf上阵了。对于那个奇怪的字符串拼接问题，可能是出于操作符上，翻开ECMA262-5 发现都有一个getValue操作。嗯，那么谜底应该是揭开了。重写会加大它们调用的优化高，而在有操作符的情况下，valueOf的优先级本来就比toString的高。 五.数组数组是值的有序集合。每个值叫做元素，每个元素在数组中都有数字位置编号，也就是索引。JS中的数组是弱类型的，数组中可以含有不同类型的元素。数组元素甚至可以是对象或其它数组。 1var arr = [1, true, null, undefined, &#123;x : 1&#125;, [1, 2, 3]]; 1.创建数组-字面量123456789var BAT = [&apos;Alibaba&apos;, &apos;Tencent&apos;, &apos;Baidu&apos;];var students = [&#123;name : &apos;Bosn&apos;, age : 27&#125;, &#123;name : &apos;Nunnly&apos;, age : 3&#125;];var arr = [&apos;Nunnly&apos;, &apos;is&apos;, &apos;big&apos;, &apos;keng&apos;, &apos;B&apos;, 123, true, null];var arrInArr = [[1, 2], [3, 4, 5]];var commasArr1 = [1, , 2]; // 1, undefined, 2var commasArr2 = [,,]; // undefined * 2size from 0 to 4,294,967,295(2^23 -1 ) 2.创建数组-new Array1234var arr = new Array(); var arrWithLength = new Array(100); // undefined * 100var arrLikesLiteral = new Array(true, false, null, 1, 2, &quot;hi&quot;);// 等价于[true, false, null, 1, 2, &quot;hi&quot;]; new可以省略 3.数组元素读写1234567891011var arr = [1, 2, 3, 4, 5];arr[1]; // 2arr.length; // 5arr[5] = 6;arr.length; // 6delete arr[0];arr[0]; // undefined 4.数组元素增删（动态的，无需指定大小）12345678910111213141516171819202122232425var arr = [];arr[0] = 1;arr[1] = 2;arr.push(3);arr; // [1, 2, 3]arr[arr.length] = 4; // equal to arr.push(4);arr; // [1, 2, 3, 4]arr.unshift(0);arr; // [0, 1, 2, 3, 4];delete arr[2];arr; // [0, 1, undefined, 3, 4]arr.length; // 52 in arr; // falsearr.length -= 1;arr; // [0, 1, undefined, 3, 4], 4 is removedarr.pop(); // 3 returned by poparr; // [0, 1, undefined], 3 is removedarr.shift(); // 0 returned by shiftarr; // [1, undefined] 1.向后插入元素 push() 2.向前插入元素 unshift() 3.从后移除元素 pop() 4.从前移除元素 shift() 5.length不固定，可随意更改 6.delete只会删除当前位置的值，长度不会变 5.数组迭代123456789101112131415161718192021var i = 0, n = 10;var arr = [1, 2, 3, 4, 5];for (; i &lt; n; i++) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5&#125;for(i in arr) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5&#125;Array.prototype.x = &apos;inherited&apos;;for(i in arr) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5, inherited&#125;for(i in arr) &#123; if (arr.hasOwnProperty(i)) &#123; console.log(arr[i]); // 1, 2, 3, 4, 5 &#125;&#125; for…in 会受原型影响 （2）.二维数组、稀疏数组123456789101112131415161718192021var arr = [[0, 1], [2, 3], [4, 5]];var i = 0, j = 0;var row;for (; i &lt; arr.length; i++) &#123;row = arr[i];console.log(‘row ‘ + i);for (j = 0; j &lt; row.length; j++) &#123;console.log(row[j]);&#125;&#125;// result:// row 0// 0// 1// row 1// 2// 3// row 2// 4// 5 稀疏数组并不含有从0开始的连续索引。一般length属性值比实际元素个数大。 1234567891011var arr1 = [undefined];var arr2 = new Array(1);0 in arr1; // true0 in arr2; // falsearr1.length = 100;arr1[99] = 123;99 in arr1; // true98 in arr1; // falsevar arr = [,,];0 in arr; // false （3）.数组方法1.Array.prototype.join（将数组转为字符串）123456789var arr = [1, 2, 3];arr.join(); // &quot;1,2,3&quot;arr.join(&quot;_&quot;); // &quot;1_2_3&quot;function repeatString(str, n) &#123; return new Array(n + 1).join(str);&#125;repeatString(&quot;a&quot;, 3); // &quot;aaa&quot;repeatString(&quot;Hi&quot;, 5); // &quot;HiHiHiHiHi&quot; 2.Array.prototype.reverse（将数组逆序）1234var arr = [1, 2, 3];arr.reverse(); // [3, 2, 1]arr; // [3, 2, 1]//原数组被修改 3.Array.prototype.sort（排序）1234567var arr = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];arr.sort(); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]arr = [13, 24, 51, 3];arr.sort(); // [13, 24, 3, 51]arr; // [13, 24, 3, 51]//原数组被修改， 因为sort是按字母排序的，所以数字排序运用函数 1234567891011121314arr.sort(function(a, b) &#123; return a - b;&#125;); // [3, 13, 24, 51]arr = [&#123;age : 25&#125;, &#123;age : 39&#125;, &#123;age : 99&#125;];arr.sort(function(a, b) &#123; return a.age - b.age;&#125;);arr.forEach(function(item) &#123; console.log(&apos;age&apos;, item.age);&#125;);// result:// age 25// age 39// age 99 4.Array.prototype.concat（数组合并）1234567var arr = [1, 2, 3];arr.concat(4, 5); // [1, 2, 3, 4, 5]arr; // [1, 2, 3] 原数组被修改arr.concat([10, 11], 13); // [1, 2, 3, 10, 11, 13]arr.concat([1, [2, 3]]); // [1, 2, 3, 1, [2, 3]] 5.Array.prototype.slice（返回部分数组）123456var arr = [1, 2, 3, 4, 5];arr.slice(1, 3); // [2, 3]arr.slice(1); // [2, 3, 4, 5]arr.slice(1, -1); // [2, 3, 4]arr.slice(-4, -3); // [2]//原数组未被修改 6.Array.prototype.splice（数组拼接）123456789101112var arr = [1, 2, 3, 4, 5];arr.splice(2); // returns [3, 4, 5]arr; // [1, 2];arr = [1, 2, 3, 4, 5];arr.splice(2, 2); // returns [3, 4] 第二个参数表示截取几个arr; // [1, 2, 5];arr = [1, 2, 3, 4, 5];arr.splice(1, 1, &apos;a&apos;, &apos;b&apos;); // returns [2]arr; // [1, &quot;a&quot;, &quot;b&quot;, 3, 4, 5]//原数组被修改 7.Array.prototype.forEach（数组遍历）123456789var arr = [1, 2, 3, 4, 5];arr.forEach(function(x, index, a)&#123; console.log(x + &apos;|&apos; + index + &apos;|&apos; + (a === arr));&#125;);// 1|0|true// 2|1|true// 3|2|true// 4|3|true// 5|4|true 8.Array.prototype.map（数组映射）123456var arr = [1, 2, 3];arr.map(function(x) &#123; return x + 10;&#125;); // [11, 12, 13]arr; // [1, 2, 3]//原数组未被修改 9.Array.prototype.filter（数组过滤）123456var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];arr.filter(function(x, index) &#123; return index % 3 === 0 || x &gt;= 8;&#125;); // returns [1, 4, 7, 8, 9, 10]arr; // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]//原数组未被修改 10.Array.prototype.every &amp; some（数组判断）1234567891011121314151617var arr = [1, 2, 3, 4, 5];arr.every(function(x) &#123; return x &lt; 10;&#125;); // truearr.every(function(x) &#123; return x &lt; 3;&#125;); // falsevar arr = [1, 2, 3, 4, 5];arr.some(function(x) &#123; return x === 3;&#125;); // truearr.some(function(x) &#123; return x === 100;&#125;); // false 类似逻辑与、逻辑或 11.Array.prototype.reduce&amp;reduceRight123456789101112131415161718192021var arr = [1, 2, 3];var sum = arr.reduce(function(x, y) &#123; return x + y&#125;, 0); // 6arr; //[1, 2, 3]arr = [3, 9, 6];var max = arr.reduce(function(x, y) &#123; console.log(x + &quot;|&quot; + y); return x &gt; y ? x : y;&#125;);// 3|9// 9|6max; // 9max = arr.reduceRight(function(x, y) &#123; console.log(x + &quot;|&quot; + y); return x &gt; y ? x : y;&#125;);// 6|9// 9|3max; // 9 整个数组聚合成唯一一个结果 12.Array.prototype.indexOf&amp;lastIndexOf （数组检索）123456789var arr = [1, 2, 3, 2, 1];arr.indexOf(2); // 1arr.indexOf(99); // -1arr.indexOf(1, 1); // 4arr.indexOf(1, -3); // 4arr.indexOf(2, -1); // -1arr.lastIndexOf(2); // 3arr.lastIndexOf(2, -2); // 3arr.lastIndexOf(2, -3); // 1 第一个参数是检索的对象，第二个参数是检索的位置，负数即从后面开始。 13.Array.isArray（判断是否为数组）1Array.isArray([]); // true （4）.数组 VS. 一般对象相同 都可以继承数组是对象，对象不一定是数组都可以当做对象添加删除属性 不同 数组自动更新length按索引访问数组常常比访问一般对象属性明显迅速。数组对象继承Array.prototype上的大量数组操作方法 (5).字符串和数组123456var str = &quot;hello world&quot;;str.charAt(0); // &quot;h&quot;str[1]; // eArray.prototype.join.call(str, &quot;_&quot;);// &quot;h_e_l_l_o_ _w_o_r_l_d&quot; call()和apply()方法 1、方法定义 call方法: 12&gt; 语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])&gt; 定义：调用一个对象的一个方法，以另一个对象替换当前对象。 说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法： 12&gt; 语法：apply([thisObj[,argArray]])&gt; 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 2、常用实例 a、 1234567891011&gt; function add(a,b) &gt; &#123; &gt; alert(a+b); &gt; &#125; &gt; function sub(a,b) &gt; &#123; &gt; alert(a-b); &gt; &#125; &gt; &gt; add.call(sub,3,1);&gt; 这个例子中的意思就是用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); // 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 b、 12345678910111213141516171819&gt; function Animal()&#123; &gt; this.name = &quot;Animal&quot;; &gt; this.showName = function()&#123; &gt; alert(this.name); &gt; &#125; &gt; &#125; &gt; &gt; function Cat()&#123; &gt; this.name = &quot;Cat&quot;; &gt; &#125; &gt; &gt; var animal = new Animal(); &gt; var cat = new Cat(); &gt; &gt; //通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。 &gt; //输入结果为&quot;Cat&quot; &gt; animal.showName.call(cat,&quot;,&quot;); &gt; //animal.showName.apply(cat,[]);&gt; call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name 应该是 Cat c、实现继承 1234567891011121314&gt; function Animal(name)&#123; &gt; this.name = name; &gt; this.showName = function()&#123; &gt; alert(this.name); &gt; &#125; &gt; &#125; &gt; &gt; function Cat(name)&#123; &gt; Animal.call(this, name); &gt; &#125; &gt; &gt; var cat = new Cat(&quot;Black Cat&quot;); &gt; cat.showName();&gt; Animal.call(this) 的意思就是使用 Animal对象代替this对象，那么 Cat中不就有Animal的所有属性和方法了吗，Cat对象就能够直接调用Animal的方法以及属性了. d、多重继承 12345678910111213141516171819202122&gt; function Class10() &gt; &#123; &gt; this.showSub = function(a,b) &gt; &#123; &gt; alert(a-b); &gt; &#125; &gt; &#125; &gt; &gt; function Class11() &gt; &#123; &gt; this.showAdd = function(a,b) &gt; &#123; &gt; alert(a+b); &gt; &#125; &gt; &#125; &gt; &gt; function Class2() &gt; &#123; &gt; Class10.call(this); &gt; Class11.call(this); &gt; &#125;&gt; 很简单，使用两个 call 就实现多重继承了 说了call ，当然还有 apply，这两个方法基本上是一个意思，区别在于 call 的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments还有 callee，caller.. 六.函数函数是一块JavaScript代码，被定义一次，但可执行和调用多次。JS中的函数也是对象，所以JS函数可以像其它对象那样操作和传递 所以我们也常叫JS中的函数为函数对象。 不同的调用方式直接调用foo(); 对象方法o.method(); 构造器new Foo(); call/apply/bindfunc.call(o); (2).函数声明和函数表达式1.函数声明123456function add (a, b) &#123; a = +a;b = +b;if (isNaN(a) || isNaN(b)) &#123; return;&#125;return a + b;&#125; 函数表达式 123456789101112131415161718192021// function variablevar add = function (a, b) &#123;// do sth&#125;;// IEF(Immediately Executed Function)(function() &#123;// do sth&#125;)();// first-class function return function() &#123;// do sth&#125;;// NFE (Named Function Expression)//命名函数表达式（有名字的函数表达式） var add = function foo (a, b) &#123;// do sth&#125;; 2.变量&amp;函数的声明前置123456789101112131415161718192021222324252627//函数声明会前置，即//function add(a,b) var num = add(1, 2);console.log(num); //result:3function add (a, b) &#123; a = +a; b = +b; if (isNaN(a) || isNaN(b)) &#123; return; &#125; return a + b;&#125;//函数表达式中，函数不会前置，可是变量会//var add 但是它是undefined，没有赋值，只是声明var num = add(1, 2);console.log(num);vaar add = function (a, b) &#123; a = +a; b = +b; if (isNaN(a) || isNaN(b)) &#123; return; &#125; return a + b;&#125; 3.命名函数表达式12var func = function nfe() &#123;&#125;;alert(func === nfe); IE6~8中，会弹出false窗口，即两个不相等，可是外部可以访问nfe; IE9+中，nfe undefined。即外部不可调用nfe。 123&gt; // 递归调用&gt; var func = function nfe() &#123;/** do sth.**/ nfe();&#125;&gt; 4.Function 构造器123456789var func = new Function(&apos;a&apos;, &apos;b&apos;, &apos;console.log(a + b);&apos;);func(1, 2); // 3var func = Function(&apos;a&apos;, &apos;b&apos;, &apos;console.log(a + b);&apos;); func(1, 2); // 3//CASE 1Function(&apos;var localVal = &quot;local&quot;;console.log(localVal);&apos;)();console.log(typeof localVal);// result: local, undefined localVal仍为局部变量 / 1234567/ CASE 2var globalVal = &apos;global&apos;;(function() &#123; var localVal = &apos;local&apos;; Function(&apos;console.log(typeof localVal, typeof globalVal);&apos;)();&#125;)();// result: undefined, string local不可访问，全局变量global可以访问 （2）.this1.全局的this（浏览器）123console.log(this.document === document); // trueconsole.log(this === window); // true this.a = 37;console.log(window.a); // 37 2.一般函数的this（浏览器）123456789101112function f1()&#123; return this;&#125;f1() === window; // true, global object//严格模式的this指向undefined（全局）function f2()&#123; &quot;use strict&quot;; // see strict mode return this;&#125;f2() === undefined; // true 3.作为对象方法的函数的this12345678910111213141516171819var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // logs 37var o = &#123;prop: 37&#125;;function independent() &#123; return this.prop;&#125;o.f = independent;console.log(o.f()); // logs 37 4.对象原型链上的this123456var o = &#123;f:function()&#123; return this.a + this.b; &#125;&#125;; var p = Object.create(o);p.a = 1;p.b = 4;console.log(p.f()); // 5 5.get/set方法与this1234567891011121314151617function modulus()&#123; return Math.sqrt(this.re * this.re + this.im * this.im);&#125;var o = &#123; re: 1, im: -1, get phase()&#123; return Math.atan2(this.im, this.re); &#125;&#125;;Object.defineProperty(o, &apos;modulus&apos;, &#123;get: modulus, enumerable:true, configurable:true&#125;);console.log(o.phase, o.modulus); // logs -0.78 1.4142 get,set的this指向它本身的函数 6.构造器中的this12345678910111213141516function MyClass()&#123;this.a = 37;&#125;var o = new MyClass(); console.log(o.a); // 37function C2()&#123; this.a = 37; return &#123;a : 38&#125;;&#125;o = new C2(); console.log(o.a); // 38 7.call/apply方法与this1234567891011121314151617function add(c, d)&#123;return this.a + this.b + c + d;&#125;var o = &#123;a:1, b:3&#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34 function bar() &#123; console.log(Object.prototype.toString.call(this));&#125;bar.call(7); // &quot;[object Number]&quot; 8.bind方法与this（IE9+才有)123456789function f()&#123; return this.a;&#125;var g = f.bind(&#123;a : &quot;test&quot;&#125;); console.log(g()); // testvar o = &#123;a : 37, f : f, g : g&#125;;console.log(o.f(), o.g()); // 37, test （4）.函数属性和arguments12345678910111213function foo(x, y, z) &#123;‘use strict’;arguments.length; // 2arguments[0]; // 1arguments[0] = 10;x; // change to 10; //绑定关系，严格模式下仍然是1arguments[2] = 100;z; // still undefined !! //未传参数失去绑定关系arguments.callee === foo; // true //严格模式下不能使用&#125; 1.apply/call方法（浏览器）1234567891011121314151617function foo(x, y) &#123; console.log(x, y, this);&#125;foo.call(100, 1, 2); // 1, 2, Number(100)foo.apply(true, [3, 4]); // 3, 4, Boolean(true) foo.apply(null); // undefined, undefined, window foo.apply(undefined); // undefined, undefined, windowfunction foo(x, y) &#123; &apos;use strict&apos;; console.log(x, y, this);&#125;foo.apply(null); //undefined,undefined,null foo.apply(undefined); // undefined, undefined, undefined 2.bind方法12345678910111213this.x = 9;var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 81var getX = module.getX; getX(); // 9 指向全局变量var boundGetX = getX.bind(module); boundGetX(); // 81 将这个this指向参数的module 3.bind与currying（函数颗粒化，把一个函数拆成多个单元）f 12345678910111213141516unction add(a, b, c) &#123; return a + b + c;&#125;var func = add.bind(undefined, 100); func(1, 2); // 103 //很多时候，我们不需要传入那么多参数，这里的100，固定赋值给avar func2 = func.bind(undefined, 200); func2(10); // 310function getConfig(colors, size, otherOptions) &#123; console.log(colors, size, otherOptions);&#125;var defaultConfig = getConfig.bind(null, &quot;#CC0000&quot;, &quot;1024 * 768&quot;); defaultConfig(&quot;123&quot;); // #CC0000 1024 * 768 123defaultConfig(&quot;456&quot;); // #CC0000 1024 * 768 456 4.bind 和 new123456789function foo() &#123; this.b = 100; return this.a;&#125;var func = foo.bind(&#123;a:1&#125;); func(); // 1new func(); // &#123;b : 100&#125; 直接调用foo()的话，this指向全局对象，这里面相对于创建了一个全局变量b，并且赋值为100，返回的是全局变量的a属性 用bind的方法传入一个参数，一个字面量，只有一个属性a，直接调用的话，则this会指向bind的这样的一个参数。 用new的话，return除了是一个对象，否则会以this作为返回值，并且this会被初始化为一个默认的空对象，这个对象的原型是foo.prototype。虽然前面bind了，可是new了之后，会忽略bind，this指向么有bind所指向的。意思是如果用new调用的话，bind的作用会被忽略掉。 （5）.理解闭包当一个函数被调用完毕之后，这个局部变量就可以被释放掉了 闭包，以自己的话理解就是，函数被调用完后，局部变量没有被释放。执行上下文仍在栈中，没有出栈。因为下一个执行上下文需要用到。 常见错误之循环闭包 123456789101112131415161718document.body.innerHTML = &quot;&lt;div id=div1&gt;aaa&lt;/div&gt;&quot;+ &quot;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; for (var i = 1; i &lt; 4; i++) &#123;document.getElementById(&apos;div&apos; + i). addEventListener(&apos;click&apos;, function() &#123; alert(i); // all are 4! &#125;);&#125;document.body.innerHTML = &quot;&lt;div id=div1&gt;aaa&lt;/div&gt;&quot;+ &quot;&lt;div id=div2&gt;bbb&lt;/div&gt;&lt;div id=div3&gt;ccc&lt;/div&gt;&quot;; for (var i = 1; i &lt; 4; i++) &#123;!function(i) &#123; document.getElementById(&apos;div&apos; + i). addEventListener(&apos;click&apos;, function() &#123; alert(i); // 1, 2, 3 &#125;); &#125;(i);&#125;//将每次遍历的1，2，3的值，传到匿名函数（下面那个i），然后在这个匿名函数里面，再用到这个参数i 闭包封装 123456789101112131415161718192021222324252627(function() &#123; var _userId = 23492; var _typeId = &apos;item&apos;; var export = &#123;&#125;; function converter(userId) &#123; return +userId; &#125; export.getUserId = function() &#123; return converter(_userId); &#125; export.getTypeId = function() &#123; return _typeId; &#125; window.export = export;&#125;());export.getUserId(); // 23492 export.getTypeId(); // itemexport._userId; // undefined export._typeId; // undefined export.converter; // undefined 函数有函数自己的作用域，里面定义的变量，外部是无法访问的。 我们在函数中定义变量，外部无法用，再用window.export=export这样的方式，把我们最终想输出的对象输出去 外部只能通过export这个对象提供的方法来访问到里面的具体的函数的变量 （6）.作用域12345678910111213141516var a = 10; 全局(function() &#123;var b = 20;函数&#125;)();console.log(a); // 10console.log(b); // error, b in not definedfor (var item in &#123;a : 1, b : 2&#125;) &#123; console.log(item);&#125;console.log(item); // item still in scopeeval(&quot;var a = 1;&quot;); //eval 作用域链 12345678910111213141516function outer2() &#123; var local2 = 1; function outer1() &#123; var local1 = 1; // visit local1, local2 or global3 作用域链从初开始向上找创建该作用域的函数 &#125; outer1();&#125;var global3 = 1;outer2();function outer() &#123; var i = 1; var func = new Function(&quot;console.log(typeof i);&quot;); func(); // undefined&#125; //Function中的变量外部无法访问outer(); 利用函数作用域封装 123456789(function() &#123; // do sth here var a, b;&#125;)();!function() &#123; // do sth here var a, b;&#125;(); 写成函数表达式，为了防止变量被提前声明。留下一堆括号，会报语法错误 （7）.ES3执行上下文图文详情参见《js深入了解闭包和原型》 JS解释器如何找到我们定义的函数和变量？ 变量对象(Variable Object, 缩写为VO)是一个抽象 概念中的“对象”，它用于存储执行上下文中的： 变量 函数声明 函数参数 1234567891011121314var a = 10; function test(x) &#123; var b = 20;&#125;test(30);VO(globalContext) = &#123; a : 10, test : &lt;ref to function&gt;&#125;;VO(test functionContext) = &#123; x : 30, b: 20&#125;; 1.变量初始化阶段（对于函数来说） VO按照如下顺序填充: 函数参数 (若未传⼊入，初始化该参数值为undefined) 函数声明 (若发⽣生命名冲突，会覆盖) 变量声明 (初始化变量值为undefined，若发⽣生命名冲突，会忽略。) 123456789101112131415function test(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125;; (function x() &#123;&#125;); b = 20;&#125;test(10);AO(test) = &#123; a: 10, b: undefined, c: undefined, d: &lt;ref to func &quot;d&quot;&gt; e: undefined&#125;;//函数表达式不会影响VO 2.代码执行阶段1234567891011121314151617181920212223242526272829303132function test(a, b) &#123; var c = 10; function d() &#123;&#125; var e = function _e() &#123;&#125;; (function x() &#123;&#125;); b = 20;&#125;test(10);AO(test) = &#123; a: 10, b: 20, c: 10, d: &lt;reference to FunctionDeclaration &quot;d&quot;&gt; e: function _e() &#123;&#125;;&#125;;测试alert(x); // functionvar x = 10; alert(x); // 10x = 20;function x() &#123;&#125; alert(x); // 20if (true) &#123; var a = 1;&#125; else &#123; var b = true;&#125;alert(a); // 1alert(b); // undefined 首先，vo对象里面，有一个x，值是一个函数对象（函数声明前置），有一个a和b，值是undefined。var x=10：因为变量名和函数名冲突，忽略 然后进入代码执行阶段，var x=10,赋值成功，alert为10；因为b被前置处理，所以alert b不会报错，undefined 七.oop（面向对象程序设计）1.继承2.原型链3.prototype4.instanceof以上《js深入了解闭包和原型》 5.实现继承的方法1Student.prototype = Object.create(Person.prototype) 创建一个空对象，并将其原型指向person.prototype(ES5之后才可以使用） 1234567if(!Object.create)&#123; Object.create = function(proto)&#123; function F()&#123;&#125; F.prototype = proto; return new F; &#125;;&#125;//ES5之前使用方法 6.模拟重载重载的定义是指函数的方法名相同，但参数不同。比如我写两个关于js的同名函数： 123456789101112131415&lt;script type = &quot;text/javascript&quot; &gt; function add(a,b)&#123; var sum = a+b; alert (sum); &#125; add(2,3); //第二个函数 function add(c,d,e)&#123; var sum2 = c+d+e; alert (sum2); &#125; add(2,3,4);&lt;/script&gt; 结果为NaN 9 ，这就说明后面的函数把前一个同名函数覆盖掉了，从而可以得出js函数不存在重载，永远调用最后一个方法。 虽说JS函数不存在重载，但是我们可以实现js里面的模拟重载，接下来见证奇迹的时刻到了。要想实现js模拟重载必先回用到 arguments.用来存放js参数。实现方法如下： 1234567891011121314151617181920function add1()&#123; //比如传递的是两个参数 if(arguments.length == 2)&#123; return arguments[0] +arguments[1]; &#125;else if(arguments.length ==3)&#123; return arguments[0]+arguments[1]+arguments[2]; &#125;else if(arguments.length == 4)&#123; return arguments[0]+arguments[1]+arguments[2]+arguments[3]; &#125;else&#123; return 0 ; &#125;&#125; //调用 alert(add1(1,2)); alert(add2(1,2,3)); alert(add3(1,2,3,4)); alert(add4(1,2,3,4,5)); 结果 3 6 10 0 7.调用子类的方法（子掉父）123456789101112131415161718function Person(name)&#123; this.name=name;&#125;function Student(name,className)&#123; this.className=className; Person.call(this,name);//调用别的构造器 &#125;var mike=new Student(&apos;mike&apos;,&apos;Network3&apos;);//子类调用已被覆盖的父类的方法Person.prototype.init=function&#123;...&#125;Student.prototype.inti=function&#123; Person.prototype.init.apply(this,arguments); &#125; 8.链式调用12345678910111213function ClassManager()&#123;&#125; //先定义一个构造器ClassManager.prototype.addClass = function(str)&#123; console.log(&apos;Class + str + &apos;added&apos;); return this;&#125;; //然后在ClassMannager构造器上增加addclass方法,需要注意一点，最后return this，this指向classmanager的实例var manager = new ClassManager();manager.addClass(&apos;classA&apos;).addClass(&apos;classB&apos;).addClass(&apos;classC&apos;);//Class:class A added//Class:class B added//Class:class C added 9.抽象类**9.模块化所谓模块化就是将需要用到的方法封装成为一个模块，哪里需要直接调用即可，比如你需要计算1+1和2+2，那么你只需要调用a+b的方法即可，无需反复重写，但是由于js并不支持类的继承，因此如何封装和调用方法就成为js模块化的重要思路。 最简单的方式 123456789function sum(a,b)&#123; alert(a+b); &#125;function sub(a,b)&#123; alert(a-b); &#125; sum(1,1); sum(2,2); sub(11,1); 上面的sum（），sub（）分别都可以算作是一个模块，需要用的时候直接调用即可，但是这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。比如a，b是全局变量同时方法中需要改变a，b值的时候。 因此大多时候我们都会将其采用对象的写法： 12345678var Sum=new Object(&#123; a:1, b:2, sum:function()&#123; alert(this.a-this.b); &#125; &#125;); Sum.sum(); 上面的函数sum()，封装在Sum对象里。使用的时候，就是调用这个对象的属性。 Sum.sum(); 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写,比如： sum.a=2; 因此，在这个的基础上，我们可以采用立即执行函数写法： 12345678910111213141516var Sum=(function()&#123; var a=1; var b=2; var sum=function()&#123; alert(a+b); &#125;; var sub=function()&#123; alert(a-b); &#125;; return &#123; sum:sum, sub:sub &#125; &#125;)(); alert(Sum.a); Sum.sum(); 第一个输出的Sum.a是undefind，外部是无法获取我们模块内部参数的，但是由于方法我们返回成为一个对象，因此是可以由外部调用的。 同时该模块还可以为其添加新的方法 12345678Sum=(function () &#123; m3 = function () &#123; alert(&quot;开始计算&quot;); &#125;; return &#123;m3:m3&#125; &#125;)(Sum); Sum.m3(); 但是注意，这里不能直接调用Sum中的变量a，b，如果需要使用这些参数还需要重新赋予，关于解决方式大家有好的办法欢迎回复。 另外为了避免执行顺序等干扰造成程序报错，在添加方法时也可以写成 1234567Sum=(function () &#123; m3 = function () &#123; alert(&quot;im&quot;); &#125;; return &#123;m3:m3&#125;&#125;)(window.Sum || &#123;&#125;); 这样即使是空对象也可以添加成功。 八.正则与模式匹配1.什么是正则？在常见的字符串检索或替换中，我们需要提供一种模式表示检索或替换的规则。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串 2.正则基础3.范围符号4.特殊字符转义1/\^abc/.test(&apos;^abc&apos;); 5.分组6.重复7.三个Flagglobal ignoreCase multiline 12/abc/gim.test(&quot;ABC&quot;); //trueRegExp(&quot;abc&quot;,&quot;mgi&quot;); 8.RegExp 对象属性global ignoreCase multiline source 1234/abc/g.global //true/abc/g.ignoreCase //false/abc/g.multiline //false/abc/g.source //&quot;abc&quot; 9.RegExp 对象方法complie exec test toString 1234567/abc/.exec(&quot;abcdef&quot;); //&quot;abc&quot;/abc/.test(&quot;abcde&quot;); //true/abc/.toString(); //&quot;/abc/&quot;var reg = /abc/;reg.compile(&quot;def&quot;);reg.test(&quot;def&quot;); //true 10.string类型与正则相关的方法String.prototype.search 1&quot;abcabcdef&quot;.search(/(abc)\1); //0 String.prototype.replace 1&quot;aabbbbcc&quot;.repalce(/b+?/,&quot;1&quot;); //aa1bbbcc String.prototype.match 123&quot;aabbbbcc&quot;.match(/b+/); //[&quot;bbbb&quot;]&quot;aabbbbccbbaa&quot;.match(/b+/g); //[&quot;bbbb&quot;,&quot;bb&quot;] String.prototype.split 1&quot;aabbbbccbbaa&quot;.split(/b+/); //[&quot;aa&quot;,&quot;cc&quot;,&quot;aa&quot;]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017.04]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F2017.04%2F</url>
    <content type="text"><![CDATA[2017.04.01今天继续了dom编程艺术的100页，感觉真是新世界啊，跟着书上代码，有些思想真是了不起，不过现在还不是很熟，希望以后看多了，可以渐渐熟悉。 开始着手轮播图的制作，因为对这种动画很感兴趣，希望可以在假期里完成。 2017.04.02今天好好地放松了下。 2017.04.03早早起来，终于完成轮播图，虽然只是小小的部分，我觉得会做这个部分，下面的轮播应该也是那个道理，加油啦。自己打码规范还是不太好，要注意注意。 2017.04.05这是第二周的分享会。会议上大家都展示了自己的作品，上个星期，自己过得有点懵逼，感觉弱了很多。发现的缺点:1.页面自适应问题，不能固定高度2.字体也是有倒影的，text-index3.学习进度有点慢 接下来的努力:1.重新编写主页的代码2.完成分类页面，详情页面3.如果可以，在星期二，三把作业交上去4.这个星期继续读，dom编程语言 2017.04.06今天重新做了主页，不固定宽高，用百分比做，同时使用了flex布局，感觉flex方便很多，各种居中各种来。 好好努力~ 2017.04.07今天纠结了几个问题，也解决了这几个问题：1.页面自适应问题：要学会判断，有些设计稿需要铺满，有些设计稿固定宽高，设置最小宽度，居中就行。2.特殊的符号：可以用before after来做 2017.04.08今天将书架布局写出来了，用flex实现，确实简单很多，但是还有些地方需要微调。头脑有点发胀，休息半天。明天写分类（tab切换效果） 2017.04.09今天完成了分类栏，利用tab效果。感觉js很强大啊。 分页栏想了想还是不会，明天继续。 第三周水逆的一个星期，从星期二开始发烧到现在。从星期一断网到星期五。 一切都会过去的。 还是那个棒棒的微微！ 现在进度有点慢了，还在分类页，分页还没写出。希望到星期一可以写好。 也希望自己水逆过去！ 第四周身体在某天晚上总算好了起来，打码倍感精神。得知自己和别人相差一个页面的时候，有点奔溃，拼命赶了，终于赶出来了，小细节的问题肯定有的。大的框架应该是没问题的。 真好啊，竟然度过了一个月，啊~]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>维生数考核日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.03]]></title>
    <url>%2F2017%2F04%2F24%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F2017.03%2F</url>
    <content type="text"><![CDATA[2017.03.17现在已经是18号凌晨2点，从晚上8点一直弄个人主页，按照自己心里的想法，一步一步用代码实现想要的效果，挺不错的。 虽然一直推翻，因为自己心里想的和实际并符合。从背景配色选择到布局到文字，慢慢思索，慢慢推敲，还有时间，相信自己可以弄出喜欢的页面~ 比较伤感的是，忘记打注释了，现在回去打。看来必须保持这种习惯才行！ ps：tfboys的歌真有力量啊，都是青春的味道~ 2017.03.18又打码到深夜，凌晨2点，陪伴的不止是网易云的歌单，还有床下滴滴答答的鼠标声音。今天继续完成个人主页的首页，大概已经完成，接下来就是实现特效的时候了，希望自己能够慢慢，不要太着急，边学习边打码。今天也终于解决了一个特别大的问题，Min-width,每次弄好的框框，一缩小就跑出来，原来是我用的百分比，穿透了，解决方法是为框框的最大父元素加个min-width，这样就好了。这个问题纠结了好久好久，以为是定位问题，又推翻重新写，还是这样，可把我愁死了。明天早上起来学习定位 浮动问题！git这个家伙也好难搞哟，英语能力得提高了（捂脸）ps:终于发现了win10日历的好处！还有小娜！ 可以高效为我增加日程，贼开心。 2017.03.19今天又是宅宅的一天，下雨，感觉人有点郁闷。今天突然想把页面弄成响应式，可是一直遇到问题，哎，这个坎。希望明天可以把它解决了！感觉不能做太久，否则处理bug太久，也容易有讨厌的心理，嗯，也要注意休息休息。自从宿舍三只进入考核期，整个宿舍开始疯啦，哈哈！ 2017.03.20今天着重看了浮动和定位，因为之前写定位写到奔溃！白天看了css权威这本书后，有所启发，本想写笔记整理整理，没想到，在慕课网上 张鑫旭老师的见解更加厉害，很透彻，通过他的话，也好像懂了更多。虽然今天没有打码，不过我相信学习了这么多，多多少少下次打码更有启发，然后我想重写了，哭哭 2017.03.21今天解决了js自定义弹出框的问题，在网上找了很多例子，最后用display:none实现。完成了like页面的布局，将最初的版本拆了。解决了table中宽度不一的问题，刚开始调整的时候一直调不出，问题出在全局样式。 昨天看的定位确实有用，之前写的布局，老是滥用relative absolute，而不管为什么，回去重构后，发现很多定位都没必要。根据张鑫讯老师的说法，absolute真的很好用。 因为想写响应式布局，所以一直把宽度，高度设置为百分比，希望不会有什么bug 2017.03.22今天学习了css3进度条的设置。根据@keyframe transform translate 实现动画效果，动画是做出来了，但是配色好像不大好看。因为是好闺蜜生日，今天也好好地陪她，所以暂且放下学习啦~ 2017.03.23今天hi忙，hi hi 忙。上学，勤工，体育课，买礼物，心情复杂。事情一多，心态也不太好了，有点生气。心情不太好，效率不太高。今天完成了3个页面的设计，真是对色彩搭配无能了，以后要多看看搭配！争取明天把笔记，周记，作业交上去。！ 2017.03.24今天终于完成了作业，自己开的坑，跪着也要填完！ 总结：1.本周完成作业，多数用css css3实现效果，在做作业期间，边学习边打码，学到了动画效果，还有定位，浮动。深刻体会到滥用定位的后果，最开始写的布局被推翻，因为absolute和relative乱用。看来老师的视频，对定位和浮动有了一定了解。2.个人主页比较多隐藏的触发事件。3.个人主页设立了4个不同的尺寸，1024 * 768768 * 1280640 * 960320 * 480本来想设置响应式设计，可是知识掌握的不够，就做了个“四不像”，不过在这过程，也锻炼了布局的技巧。4.深刻体会颜色搭配多么重要，总是弄不出自己想要的色彩。以后得好好看看色彩搭配。5.现在上传笔记发现，还是markdom好啊！下个星期起一定要养成好习惯！ 作业顺序：首页是star跳转到me然后有me like futrue三个布局点击 2017.03.27这两天发生了点事，一直郁郁寡欢，各种咸鱼躺。今天终于要打起精神学习，希望自己不要辜负自己。 终于打起精神，学习了。发现自己知识掌握太少了，有很多知识，比如选择器，命名，不懂，瞎弄，导致打码效率很低。 发现，自己看视频可以更专心，边看视频边打码，原来还可以让自己打码更规范。 2017.03.28今天完成了作业的两个动画，是用css3的动画属性。加上js的addEventLisener，感觉效果还行。不过代码的规范性，注释的标注，还要多加注意。 2017.03.29今天回家了，因为一些事情。嗯。师姐点评了我的作业：1、文件最好可以是分类用文件夹放好 2.有些css代码重复 可以用一个class就好然后再用nth-of-type()设置位置 3、花心思简化代码 4、可以深入学习dom操作（dom编程艺术），跟着写demo 5.这样的注释可以帮助版本更替 6.很棒，继续加油！ 2017.03.30在家感觉挺不错的，今天完成了主页和登录框。纠结了一个小小的东西，密码的形式，想太多了，在网上溜达了半天，最后，原来没那么复杂呀。墙外世界真是好，终于翻墙了。！！！！现在开始要好好学习书本知识了，感觉前面已经把自己学到的用完了，额！充电！ 原来git是这样用的，原来文件夹可以直接推上去的，啊！原来可以直接改的！ 2017.03.31今天终于搭建起了自己的个人博客，终于有个小天地，供我自由发挥，现在只能域名审核完毕啦~开始看书啦！300多页的dom编程艺术，希望3天之内能够看完，感觉js dom真是个好东西呀，看来推书中的布局又要推翻啦~ YES！终于会在markdown上传图片啦 终于审核完毕！！有自己的博客啦！！！]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>维生数考核日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推书总结]]></title>
    <url>%2F2017%2F04%2F20%2F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%2F%E6%8E%A8%E4%B9%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[整个推书项目从3月30日开始，到4月20日结束。按照主页-分类-详情-搜索页面的顺序进行打码。 1.主页：由于美观问题，采用比例方式将整个设计图自适应窗口，同时采用最小宽度的方法。 里面主要涉及 1.布局。采用盒子套盒子，flex的方法进行布局。 2.搜索框的书写。当时在这块卡了比较久的时间，因为以为是鼠标点击里面的字消失，所以用了onfocus ，onblur 。后来原来只是输入的时候字消失，则采用了placeholder。 3.分类框框的点击。因为要实现两个页面的互动，所以采用localstorage记录下点击的状态，在另一个页面继续用这个记录下的状态。中间有个难题是，怎么让它知道我点击的是哪一个呢？我采用了onclick的方法，用闭包的方法，为每一个类赋值，这样就更好记录状态。 4.登录框的弹出。采用了js的样式改变，style和innerHTML.里面的难点我认为是loading的弹出，我继续采用了localstorage来记录登录小头像是否变成用户名的状态，来实现loading动画的播放。 2.搜索页：其余三个页面都用px按照设计图直接编排。 里面主要涉及： 1.布局：还是用flex布局。‘ 2.轮播图：这个比较难。写码思想参考了慕课网老师的想法。整个代码核心是animate函数。点击小圆点，自动播放，都依赖于animate。 点击小圆点，分为三种情况，如果动画正在播放则无效，如果小圆点高亮则无效，否则根据点击的第几个个数来计算偏移量，传至animate函数，同时高亮，播放动画。 自动播放，分为两种情况，如果正在播放，则无效，否则传入默认值1280至animate函数。这里有个点，实现轮播无缝链接，需要将圆点的第几个数index变化。 animate函数。通过传入的偏移量，计算速度，并且判断移位是否在范围之内，在则动画播放，不在则调整，再播放动画。 3.内容填充。这里的数据交互用了很长的一段时间来把它突破，因为当时身体不太好，很迷糊，一直没有找到突破口，不晓得数据交互是什么东西。后来通过搜索引擎，师兄师姐指点，摸出了点门路。 我先把整个板块用css排好，然后把它们的html删掉。将数据获得之后，采用了几个循环，利用jq的append方法，将标签及数据一个个填充进去。 4.分类，分页栏。将数据填充好后，记录点击的类数，页数。分类框相对容易解决，记录完类数，则用tab方法实现类别的切换。 分页框，记录点击的页面，在这里要对数据的填充的循环条件进行修正，因为一页只能出现8本书，两行。比较难的点是下页的翻动，因为涉及了和总页数的判断，所以要得到总页数。之前一直用total这个全局变量来做总页数，然后发现它在之前的循环已经被固定了，不会因为类别的变化而变化。所以最后采用了Math.ceil(data.bookclass[currentcategory - 1].bookInfo.length / 8)的方法，用之前闭包得出的全局变量currentcategory当前类别来做。 3.详情页：里面主要涉及： 1.布局。 2.数据填充。里面比较难的点是如何让它知道我点的是哪一本书？因为一个页面只出现8本书，所以我给他们用数值添加新属性行不通。所以最后我利用了几个全局变量，当前类别，当前页数，当前书本数，构成表达式书写。 3.过渡。因为弹出框需要过渡，因此我采用了jq的css方法。 4.搜索页面里面主要涉及： 1.布局。 2.数据填充。 3.搜索的东西里的填充。采用localstorage。 4.分类下拉框。采用jq的过渡，slideToggle方法。 学到了什么： 1.这个月，过的很充实。打码的过程也挺爽，总是在遇到一个问题，解决一个问题的循环中度过，然后回首发现原来自己也可以解决这么多问题。不过学的知识很散，这个月学的知识因为都只是为了要写的代码服务，所以很杂，很碎片化。 2.一直想要培养的打码习惯，写注释终于培养出来了，实在不想再对着一堆代码发愁。不过写版本这件事，还是没有培养好。 要学习的还有很多，只有不断向前，才能不被别人追上/追上别人。]]></content>
      <categories>
        <category>实习总结</category>
      </categories>
      <tags>
        <tag>维生数考核日记</tag>
      </tags>
  </entry>
</search>
