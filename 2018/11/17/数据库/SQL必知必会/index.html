<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.3.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.3.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.3.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.3.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.3.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    }
  };
</script>

  <meta name="description" content="12graph LRA--&amp;gt;B1.1 数据库基础数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。表（table）某种特定类型数据的结构化清单。模式关于数据库和表的布局及特性的信息。">
<meta name="keywords" content="SQL">
<meta property="og:type" content="article">
<meta property="og:title" content="SQL必知必会">
<meta property="og:url" content="http://yoursite.com/2018/11/17/数据库/SQL必知必会/index.html">
<meta property="og:site_name" content="Wei Zhang">
<meta property="og:description" content="12graph LRA--&amp;gt;B1.1 数据库基础数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。表（table）某种特定类型数据的结构化清单。模式关于数据库和表的布局及特性的信息。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-02-04T04:55:17.089Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SQL必知必会">
<meta name="twitter:description" content="12graph LRA--&amp;gt;B1.1 数据库基础数据库（database）保存有组织的数据的容器（通常是一个文件或一组文件）。表（table）某种特定类型数据的结构化清单。模式关于数据库和表的布局及特性的信息。">
  <link rel="canonical" href="http://yoursite.com/2018/11/17/数据库/SQL必知必会/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>SQL必知必会 | Wei Zhang</title>
  <meta name="generator" content="Hexo 3.9.0">
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6b84e82d64204f777295ad7493af8ba2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wei Zhang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-wrapper">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content page-post-detail">
            

  <div id="posts" class="posts-expand">
    

  <article class="post" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/17/数据库/SQL必知必会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wei Zhang">
      <meta itemprop="description" content="Dream High.">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei Zhang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">SQL必知必会

          
        </h1>

        <div class="post-meta">
        
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2018-11-17 18:10:12" itemprop="dateCreated datePublished" datetime="2018-11-17T18:10:12+08:00">2018-11-17</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
            <div style="display: none">
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-04 12:55:17" itemprop="dateModified" datetime="2020-02-04T12:55:17+08:00">2020-02-04</time>
              </span>
            </div>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
              
            </span>
          

          
            <span class="post-meta-item" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          
  
  
          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              
                <span class="post-meta-item-text">本文字数：</span>
              
              <span>26k</span>
            </span>
          
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              
              <span>24 分钟</span>
            </span>
          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure><p>1.1 数据库基础<br>数据库（database）<br>保存有组织的数据的容器（通常是一个文件或一组文件）。</p><p>表（table）<br>某种特定类型数据的结构化清单。</p><p>模式<br>关于数据库和表的布局及特性的信息。</p><a id="more"></a>




<p>列（column）<br>表中的一个字段。所有表都是由一个或多个列组成的。</p>
<p>行（row）<br>表中的一个记录。</p>
<p>主键（primary key）<br>一列（或一组列），其值能够唯一标识表中每一行。</p>
<p>1.2<br>SQL<br>SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库沟通的语言。</p>
<p>第 2 章 MySQL简介<br>2.1 什么是MySQL<br>MySQL是一种DBMS（数据库管理系统）</p>
<p>2.1.1 客户机—服务器软件<br>DBMS可分为两类：一类为基于共享文件系统的DBMS，另一类为基于客户机—服务器的DBMS。(MySQL)</p>
<p>服务器部分是负责所有数据访问和处理的一个软件。这个软件运行在称为数据库服务器的计算机上。关于数据、数据添加、删除<br>和数据更新的所有请求都由服务器软件完成。<br>这些请求或更改来自运行客户机软件的计算机。客户机是与用户打交道的软件。</p>
<p>2.2 MySQL工具<br>为了使用MySQL，需要有一个客户机，即你需要用来与MySQL打交道（给MySQL提供要执行的命令）的一个应用。</p>
<p>2.2.1 mysql命令行实用程序</p>
<p>在操作系统命令提示符下输入mysql<br>会出现welcome to the mysql monitor</p>
<p>第３章 使用MySQL<br>3.1 连接<br>为了连接到MySQL，需要以下信息：<br> 主机名（计算机名）——如果连接到本地MySQL服务器，为localhost；<br> 端口（如果使用默认端口3306之外的端口）;<br> 一个合法的用户名；<br> 用户口令（如果需要）。</p>
<p>3.2 选择数据库<br>输入 use crashcourse;<br>输出 Database changed<br>分析 USE语句并不返回任何结果。依赖于使用的客户机，显示某种形式的通知。例如，这里显示出的Database changed消息是<br>mysql命令行实用程序在数据库选择成功后显示的。<br>（use为一个关键字）</p>
<p>3.3 了解数据库和表<br>1.SHOW DATABASES;返回可用数据库的一个列表。包含在这个列<br>表中的可能是MySQL内部使用的数据库（如例子中的mysql和information_schema）。当然，你自己的数据库列表可能看上去与这里的不一样。</p>
<p>2.SHOW TABLES;返回当前选择的数据库内可用表的列表。SHOW也可以用来显示表列：</p>
<p>3.SHOW COLUMNS 要求给出一个表名（这个例子中的 FROM customers），它对每个字段返回一行，行中包含字段名、数据<br>类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment）。<br>(DESCRIBE customers == SHOW COLUMNS FROM customers;)</p>
<p>4.SHOW STATUS，用于显示广泛的服务器状态信息；</p>
<p>5.SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句；</p>
<p>6.SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；</p>
<p>7.SHOW ERRORS和SHOW WARNINGS，用来显示服务器错误或警告消息。</p>
<p>第 4 章  检 索 数 据</p>
<p>4.1 SELECT语句<br>为了使用SELECT检索表数据，必须至少给出两条信息——想选择什<br>么，以及从什么地方选择。</p>
<p>4.2 检索单个列<br>SELECT prod_name<br>FROM products;</p>
<p>上述语句利用SELECT语句从products表中检索一个名为prod_name的列。所需的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。</p>
<p>4.3 检索多个列<br>SELECT prod_name,prod_id<br>FROM products;</p>
<p>4.4 检索所有列<br>SELECT *<br>FROM products;</p>
<p>4.5 检索不同的行<br>SELECT vend_id<br>FROM products;</p>
<p>会返回所有匹配的行，但是不想每个值每次都出现。比如上述命令，返回了14个行，因为有14个产品，但是只有4个经销商</p>
<p>SELECT DISTINCT vend_id<br>FROM products;</p>
<p>(不能部分使用DISTINCT DISTINCT关键字应用于所有列而<br>不仅是前置它的列。如果给出SELECT DISTINCT vend_id,<br>prod_price，除非指定的两个列都不同，否则所有行都将被<br>检索出来。)</p>
<p>4.6 限制结果<br>SELECT prod_name<br>FROM products<br>LIMIT 5;<br>返回不多于5行</p>
<p>SELECT prod_name<br>FROM products<br>LIMIT 5,5;<br>从第5行开始的5行，两个参数时，第一个为开始的位置，第二个为要检索的行数。</p>
<p>注释：<br>1.返回的数据没有顺序可言。<br>2.多条SQL语句必须以分号（；）分隔，不需要在单条SQL语句后加分号。如果你使用的是mysql命令行，必须加上分号来结束SQL语句。<br>3.SQL语句不区分大小写，建议对所有SQL关键字使用大写，而对所有列和表名使用小写。<br>4.在处理SQL语句时，其中所有空格都被忽略。SQL语句可以在一行上给出，也可以分成许多行。分开来比较易于读</p>
<p>第５章 排序检索数据</p>
<p>5.1 排序数据</p>
<p>SELECT prod_name<br>FROM products<br>ORDER BY prod_name;</p>
<p>(子句（clause）<br>一个子句通常由一个关键字和所提供的数据组<br>成。子句的例子有SELECT语句的FROM子句。)</p>
<p>5.2 按多个列排序</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>ORDER BY prod_name,prod_price;</p>
<p>5.3 指定排序方向</p>
<p>SELECT pord_id,prod_name,prod_price<br>FROM products<br>ORDER BY prod_name DESC,prod_price;</p>
<p>DESC关键字只应用到直接位于其前面的列名.降序</p>
<p>第６章 过 滤 数 据</p>
<p>6.1 使用WHERE子句</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>WHERE prod_price = 2.50;</p>
<p>从products表中检索两个列，但不返回所有行，只返<br>回prod_price值为2.50的行</p>
<p>(在同时使用ORDER BY和WHERE子句时，应<br>该让ORDER BY位于WHERE之后，否则将会产生错误)</p>
<p>6.2 WHERE子句操作符</p>
<p>6.2.1 检查单个值<br>SELECT prod_name,prod_price<br>FROM products<br>WHERE prod_name = ‘wei’;</p>
<p>MySQL在执行匹配时默认不区分大小写，所<br>以wei与WEI匹配。</p>
<p>6.2.2 不匹配检查</p>
<p>6.2.3 范围值检查</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>WHERE prod_price BETWEEN 5 AND 10;</p>
<p>在使用BETWEEN时，必须指定两个值<br>——所需范围的低端值和高端值。这两个值必须用AND关键字<br>分隔。BETWEEN匹配范围中所有的值，包括指定的开始值和结束值。</p>
<p>6.2.4 空值检查</p>
<p>(NULL 无值（no value），它与字段包含0、空字符串或仅仅包含<br>空格不同。)</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>WHERE prod_price IS NULL;</p>
<p>第 7 章 数 据 过 滤</p>
<p>7.1 组合WHERE子句</p>
<p>(操作符（operator） 用来联结或改变WHERE子句中的子句的关键<br>字。也称为逻辑操作符（logical operator）。)</p>
<p>7.1.1 AND操作符</p>
<p>SELECT pord_id,prod_name,prod_price<br>FROM products<br>WHERE vend_id = 1003 AND prod_price &lt;= 10;</p>
<p>7.1.2 OR操作符</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>WHERE vend_id = 1002 OR vend_id = 1003;</p>
<p>7.1.3 计算次序</p>
<p>WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂<br>和高级的过滤。AND的优先度大于OR，所以一定要用圆括号</p>
<p>任何时候使用具有AND和OR操作<br>符的WHERE子句，都应该使用圆括号明确地分组操作符。</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 13;</p>
<p>7.2 IN操作符</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>WHERE vend_id IN (1002，1003);</p>
<p>IN WHERE子句中用来指定要匹配值的清单的关键字，功能与OR<br>相当。用IN，更好</p>
<p>7.3 NOT操作符</p>
<p>否定它之后所<br>跟的任何条件。</p>
<p>SELECT prod_name,prod_price<br>FROM products<br>WHERE vend_id NOT IN (1002，1003);</p>
<p>第 8 章 用通配符进行过滤</p>
<p>8.1 LIKE操作符 </p>
<p>怎样搜索产品名中包含文本anvil的所有产品？用简单<br>的比较操作符肯定不行，必须使用通配符。利用通配符可创建比较特定<br>数据的搜索模式。在这个例子中，如果你想找出名称包含anvil的所有产<br>品，可构造一个通配符搜索模式，找出产品名中任何位置出现anvil的产<br>品。</p>
<p>通配符（wildcard） 用来匹配值的一部分的特殊字符。<br>搜索模式（search pattern）① 由字面值、通配符或两者组合构<br>成的搜索条件。</p>
<p>8.1.1 百分号（%）通配符</p>
<p>在搜索串中，%表示任何字符出现<br>任意次数。</p>
<p>SELECT prod_id,prod_name<br>FROM products<br>WHERE prod_name LIKE ‘jet%’;</p>
<p>此例子使用了搜索模式’jet%’。在执行这条子句时，将检索任<br>意以jet起头的词。%告诉MySQL接受jet之后的任意字符，不<br>管它有多少字符。</p>
<p>也可以放到开头，%jet%</p>
<p>(注意尾空格 :在保存词<br>anvil 时，如果它后面有一个或多个空格，则子句WHERE<br>prod_name LIKE ‘%anvil’将不会匹配它们，因为在最后的l<br>后有多余的字符。解决这个问题的一个简单的办法是在搜索模<br>式最后附加一个%。一个更好的办法是使用函数（第11章将会<br>介绍）去掉首尾空格。)</p>
<p>(注意NULL 虽然似乎%通配符可以匹配任何东西，但有一个例<br>外，即NULL。不匹配NULL)</p>
<p>8.1.2 下划线（_）通配符</p>
<p>下划线的用途与%一样，但下划<br>线只匹配单个字符而不是多个字符。</p>
<p>SELECT prod_id,prod_name<br>FROM products<br>WHERE prod_name LIKE ‘_ ton anvil’;</p>
<p>只能匹配 1 ton anvil,不能.5 ton anvil</p>
<p>8.2 使用通配符的技巧</p>
<p>不要过度使用通配符。</p>
<p>第9章 用正则表达式进行搜索</p>
<p>9.2.1 基本字符匹配</p>
<p>LIKE与REGEXP 在LIKE和REGEXP之间有一个重要的差别。请<br>看以下两条语句：</p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name LIKE ‘1000’;</p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘1000’;</p>
<p>如果执行上述两条语句，会发现第一条语句不返回数据，而第<br>二条语句返回一行。为什么？<br>正如第8章所述，LIKE匹配整个列。如果被匹配的文本在列值<br>中出现，LIKE将不会找到它，相应的行也不被返回（除非使用<br>通配符）。而REGEXP在列值内进行匹配，如果被匹配的文本在<br>列值中出现，REGEXP将会找到它，相应的行将被返回。这是一<br>个非常重要的差别。<br>那么，REGEXP能不能用来匹配整个列值（从而起与LIKE相同<br>输入<br>输出<br>分析<br>的作用）？答案是肯定的，使用^和$定位符（anchor）即可，<br>本章后面介绍。</p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘.1000’;</p>
<p>.是正则表达式语言中一个特殊<br>的字符。它表示匹配任意一个字符，</p>
<p>(匹配不区分大小写 MySQL中的正则表达式匹配（自版本<br>3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大<br>小写，可使用BINARY关键字，如WHERE prod_name REGEXP<br>BINARY ‘JetPack .000’。)</p>
<p>9.2.2 进行OR匹配</p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘1000|2000’;</p>
<p>9.2.3 匹配几个字符之一</p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘[123] ton’;</p>
<p>[123] = [1|2|3]</p>
<p>[^123]匹配除这些字符外的任何东西。</p>
<p>9.2.4 匹配范围</p>
<p>集合可用来定义要匹配的一个或多个字符。[1-3] [1-9] [a-z]</p>
<p>9.2.5 匹配特殊字符</p>
<p>为了匹配特殊字符，必须用\为前导。\-表示查找-，\.表示查找.。这种处理<br>就是所谓的转义.</p>
<p>\f 换页<br>\n 换行<br>\r 回车<br>\t 制表<br>\v 纵向制表</p>
<p>9.2.6 匹配字符类</p>
<p>存在找出你自己经常使用的数字、所有字母字符或所有数字字母字<br>符等的匹配。为更方便工作，可以使用预定义的字符集，称为字符类</p>
<p>类         说明<br>[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）<br>[:alpha:] 任意字符（同[a-zA-Z]）<br>[:blank:] 空格和制表（同[\t]）<br>[:cntrl:] ASCII控制字符（ASCII 0到31和127）<br>[:digit:] 任意数字（同[0-9]）<br>[:graph:] 与[:print:]相同，但不包括空格<br>[:lower:] 任意小写字母（同[a-z]）<br>[:print:] 任意可打印字符<br>[:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符<br>[:space:] 包括空格在内的任意空白字符（同[\f\n\r\t\v]）<br>[:upper:] 任意大写字母（同[A-Z]）<br>[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）</p>
<p>9.2.7 匹配多个实例</p>
<p>重复元字符</p>
<p>元字符 说 明</p>
<ul>
<li>0个或多个匹配</li>
</ul>
<ul>
<li>1个或多个匹配（等于{1,}）<br>? 0个或1个匹配（等于{0,1}）<br>{n} 指定数目的匹配<br>{n,} 不少于指定数目的匹配<br>{n,m} 匹配数目的范围（m不超过255）</li>
</ul>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘\([0-9] sticks?\)’<br>ORDER BY prod_name;</p>
<p>正则表达式\([0-9] sticks?\)需要解说一下。\(匹配)，<br>[0-9]匹配任意数字（这个例子中为1和5），sticks?匹配stick<br>和sticks（s后的?使s可选，因为?匹配它前面的任何字符的0次或1次出<br>现），\)匹配)。没有?，匹配stick和sticks会非常困难。</p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘[[:digit:]]{4}’<br>ORDER BY prod_name;</p>
<p>，[:digit:]匹配任意数字，因而它为数字的一个集<br>合。{4}确切地要求它前面的字符（任意数字）出现4次，所以<br>[[:digit:]]{4}匹配连在一起的任意4位数字。</p>
<p>9.2.8 定位符</p>
<p>定位元字符<br>元字符 说 明<br>^ 文本的开始<br>$ 文本的结尾<br>[[:&lt;:]] 词的开始<br>[[:&gt;:]] 词的结尾</p>
<p>SELECT prod_name<br>FROM products<br>WHERE prod_name REGEXP ‘^[0-9\.]’<br>ORDER BY prod_name;</p>
<p>^匹配串的开始。因此，^[0-9\.]只在.或任意数字为串中第<br>一个字符时才匹配它们。没有^，则还要多检索出4个别的行（那<br>些中间有数字的行）。</p>
<p>(^的双重用途 ^有两种用法。在集合中（用[和]定义），用它<br>来否定该集合，否则，用来指串的开始处。)</p>
<p>第 10 章  创建计算字段</p>
<p>10.1 计算字段</p>
<p>计算字段发挥作用:存储在表中的数据都不是应用程序所需要的。<br>我们需要直接从数据库中检索出转换、计算或格式化过的数据；而不是<br>检索出数据，然后再在客户机应用程序或报告程序中重新格式化。计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句<br>内创建的。</p>
<p>(字段（field） 基本上与列（column）的意思相同，经常互换使<br>用)</p>
<p>10.2 拼接字段</p>
<p>拼接（concatenate） 将值联结到一起构成单个值。</p>
<p>SELECT Concat(vend_name,’(‘,vend_country,’)’)<br>FROM vendors<br>ORDER BY vend_name;</p>
<p>Concat()拼接串，即把多个串连接起来形成一个较长的串。<br>Concat()需要一个或多个指定的串，各个串之间用逗号分隔。</p>
<p>SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’)<br>FROM vendors<br>ORDER BY vend_name;</p>
<p>RTrim()函数去掉值右边的所有空格.LTrim() Trim()</p>
<p>使用别名</p>
<p>SELECT Concat(RTrim(vend_name),’(‘,RTrim(vend_country),’)’) AS vend_title<br>FROM vendors<br>ORDER BY vend_name;</p>
<p>10.3 执行算术计算</p>
<p>SELECT prod_id,quantity,item_price<br>FROM orderitems<br>WHERE order_num = 2005;</p>
<p>计算字段的另一常见用途是对检索出的数据进行算术计算。举一个<br>例子，orders表包含收到的所有订单，orderitems表包含每个订单中的<br>各项物品。</p>
<p>SELECT prod_id,<br>quantity,<br>item_price,<br>quantity*item_price AS expanded_price<br>FROM orderitems<br>WHERE order_num = 2005;</p>
<p>第 11 章 使用数据处理函数</p>
<p>11.2.1 文本处理函数</p>
<p>常用的文本处理函数</p>
<p>函 数 说 明<br>Left() 返回串左边的字符<br>Length() 返回串的长度<br>Locate() 找出串的一个子串<br>Lower() 将串转换为小写<br>LTrim() 去掉串左边的空格<br>Right() 返回串右边的字符<br>RTrim() 去掉串右边的空格<br>Soundex() 返回串的SOUNDEX值<br>SubString() 返回子串的字符<br>Upper() 将串转换为大写</p>
<p>SOUNDEX是一个将任何文<br>本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似<br>的发音字符和音节，使得能对串进行发音比较而不是字母比较。</p>
<p>SELECT cust_name,cust_contact<br>FROM customers<br>WHERE Soundex(cust_contact) = Soundex(‘Y Lie’);</p>
<p>WHERE子句使用Soundex()函数来转换cust_<br>contact列值和搜索串为它们的SOUNDEX值。因为Y.Lee和<br>Y.Lie发音相似，所以它们的SOUNDEX值匹配</p>
<p>11.2.2 日期和时间处理函数</p>
<p>常用日期和时间处理函数</p>
<p>函 数 说 明<br>AddDate() 增加一个日期（天、周等）<br>AddTime() 增加一个时间（时、分等）<br>CurDate() 返回当前日期<br>CurTime() 返回当前时间<br>Date() 返回日期时间的日期部分<br>DateDiff() 计算两个日期之差<br>Date_Add() 高度灵活的日期运算函数<br>Date_Format() 返回一个格式化的日期或时间串<br>Day() 返回一个日期的天数部分<br>DayOfWeek() 对于一个日期，返回对应的星期几<br>Hour() 返回一个时间的小时部分<br>Minute() 返回一个时间的分钟部分<br>Month() 返回一个日期的月份部分<br>Now() 返回当前日期和时间<br>Second() 返回一个时间的秒部分<br>Time() 返回一个日期时间的时间部分<br>Year() 返回一个日期的年份部分</p>
<p>首先需要注意的是MySQL使用的日期格式。无论你什么时候指定一<br>93<br>图灵社区会员 臭豆腐(<a href="mailto:StinkBC@gmail.com" target="_blank" rel="noopener">StinkBC@gmail.com</a>) 专享 尊重版权<br>72 第 11 章 使用数据处理函数<br>个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为<br>格式yyyy-mm-dd。因此，2005年9月1日，给出为2005-09-01。</p>
<p>SELECT cust_id,order_num<br>FROM orders<br>WHERE Date(order_date) = ‘2015-09-01’;</p>
<p>SELECT cust_id,order_num<br>FROM orders<br>WHERE Year(order_date) = 2015 AND Month(order_date)= 9;</p>
<p>11.2.3 数值处理函数</p>
<p>常用数值处理函数</p>
<p>函 数 说 明<br>Abs() 返回一个数的绝对值<br>Cos() 返回一个角度的余弦<br>Exp() 返回一个数的指数值<br>Mod() 返回除操作的余数<br>Pi() 返回圆周率<br>Rand() 返回一个随机数<br>Sin() 返回一个角度的正弦<br>Sqrt() 返回一个数的平方根<br>Tan() 返回一个角度的正切</p>
<p>第 12 章 汇 总 数 据</p>
<p>SQL聚集函数</p>
<p>函 数 说 明<br>AVG() 返回某列的平均值<br>COUNT() 返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和</p>
<p>SELECT COUNT(*) AS num_items,<br>       MIN(prod_price) AS price_min,<br>       MAX(prod_price) AS price_max,<br>       AVG(prod_price) AS price_avg<br>FROM products;</p>
<p>1.为了获得多个列的平均值，<br>必须使用多个AVG()函数。AVG()函数忽略列值为NULL的行。<br>2.如果指定列名，则指定列的值为空的行被COUNT()<br>函数忽略，但如果COUNT()函数中用的是星号（<em>），则不忽<br>略。<br>3.以上5个聚集函数都可以如下使用： 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认<br>行为）；<br> 只包含不同的值，指定DISTINCT参数。<br>如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT<br>不能用于COUNT(</em>)，因此不允许使用COUNT（DISTINCT），<br>否则会产生错误。类似地，DISTINCT必须使用列名，不能用<br>于计算或表达式。</p>
<p>SELECT AVG(DISTINCT prod_price) AS price_avg<br>FROM products<br>WHERE vend_id = 1003;</p>
<p>4.取别名</p>
<p>第 13 章 分 组 数 据<br>13.1 数据分组<br>13.2 创建分组<br>分组是在SELECT语句的GROUP BY子句中建立的。</p>
<p>SELECT vend_id,COUNT(*) AS num_prods<br>FROM products<br>GROUP BY vend_id;</p>
<p>vend_id num_prods<br>1001 3<br>1002 2<br>1003 7<br>1005 2</p>
<p>上面的SELECT语句指定了两个列，vend_id包含产品供应商的ID，<br>num_prods为计算字段（用COUNT(*)函数建立）。GROUP BY子句指<br>示MySQL按vend_id排序并分组数据。这导致对每个vend_id而不是整个表<br>计算num_prods一次。从输出中可以看到，供应商1001有3个产品，供应商<br>1002有2个产品，供应商1003有7个产品，而供应商1005有2个产品。</p>
<p>重要的规定<br>1.GROUP BY子句可以包含任意数目的列<br>2.在建立分组时，指定的所有列都一起计算<br>（所以不能从个别的列取回数据）。<br>3.如果在SELECT中使用表达式，则必须在<br>GROUP BY子句中指定相同的表达式。不能使用别名。<br>4.除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子<br>句中给出。<br>5.如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列<br>中有多行NULL值，它们将分为一组。<br>6.GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</p>
<p>使用ROLLUP 使用WITH ROLLUP关键字，可以得到每个分组以<br>及每个分组汇总级别（针对每个分组）的值，如下所示：</p>
<p>SELECT vend_id,COUNT(*) AS num_prods<br>FROM products<br>GROUP BY vend_id WITH ROLLUP;</p>
<p>13.3 过滤分组<br>目前为止所<br>学过的所有类型的WHERE子句都可以用HAVING来替代。唯一的差别是<br>WHERE过滤行，而HAVING过滤分组。</p>
<p>SELECT vend_id,COUNT(<em>) AS num_prods<br>FROM products<br>GROUP BY vend_id<br>HAVING COUNT(</em>) &gt;= 2;</p>
<p>最后一行增加了<br>HAVING子句，它过滤COUNT(*) &gt;=2（两个以上的订单）的那些<br>分组。</p>
<p>HAVING 和 WHERE 结合的例子</p>
<p>SELECT vend_id,COUNT(<em>) AS num_prods<br>FROM products<br>WHERE prod_price &gt;= 10<br>GROUP BY vend_id<br>HAVING COUNT(</em>) &gt;= 2;</p>
<p>13.4 分组和排序<br>ORDER BY与GROUP BY<br>ORDER BY GROUP BY<br>排序产生的输出 分组行。但输出可能不是分组的顺序<br>任意列都可以使用（甚至<br>非选择的列也可以使用）<br>只可能使用选择列或表达式列，而且必须使用每个选择<br>列表达式<br>不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用</p>
<p>不要忘记ORDER BY 一般在使用GROUP BY子句时，应该也给<br>出ORDER BY子句。这是保证数据正确排序的唯一方法。千万<br>不要仅依赖GROUP BY排序数据。</p>
<p>SELECT order_num,SUM(quantity<em>item_price) AS ordertotal<br>FROM orderitems<br>GROUP BY order_num<br>HAVING SUM(quantity</em>item_price) &gt;= 50<br>ORDER BY ordertotal;</p>
<p>13.5 SELECT子句顺序<br>子 句 说 明 是否必须使用<br>SELECT 要返回的列或表达式 是<br>FROM 从中检索数据的表 仅在从表选择数据时使用<br>WHERE 行级过滤 否<br>GROUP BY 分组说明 仅在按组计算聚集时使用<br>HAVING 组级过滤 否<br>ORDER BY 输出排序顺序 否<br>LIMIT 要检索的行数 否</p>
<p>第 14 章 使用子查询</p>
<p>子查询最常见的使用<br>是在WHERE子句的IN操作符中，以及用来填充计算列</p>
<p>14.2 利用子查询进行过滤</p>
<p>SELECT cust_id<br>FROM orders<br>WHERE order_num IN (SELECT order_num<br>                    FROM orderitems<br>                    WHERE prod_id = ‘TBT2’)</p>
<p>在SELECT语句中，子查询总是从内向外处理。在处理上面的<br>SELECT语句时，MySQL实际上执行了两个操作。<br>首先，它执行下面的查询：SELECT order_num<br>                    FROM orderitems<br>                    WHERE prod_id = ‘TBT2’</p>
<p>此查询返回两个订单号：20005和20007。然后，这两个值以IN操作符要<br>求的逗号分隔的格式传递给外部查询的WHERE子句。外部查询变成：</p>
<p>SELECT cust_id<br>FROM orders<br>WHERE order_num IN (20005,20007)</p>
<p>14.3 作为计算字段使用子查询</p>
<p>假如需要显示customers<br>表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。<br>为了执行这个操作，遵循下面的步骤。<br>(1) 从customers表中检索客户列表。<br>(2) 对于检索出的每个客户，统计其在orders表中的订单数目。</p>
<p>SELECT cust_name,<br>       cust_state,<br>       (SELECT COUNT(*)<br>        FROM orders<br>        WHERE orders.cust_id = customers.cust_id) AS orders<br>FROM customers<br>ORDER BY cust_name;</p>
<p>HERE orders.cust_id = customers.cust_id) AS orders<br>用了完全限定列名</p>
<p>相关子查询（correlated subquery） 涉及外部查询的子查询。</p>
<p>第 15 章 联 结 表</p>
<p>15.1.1 关系表</p>
<p>假如有由同一供应商生产的多种物品，那么在何处存储供应<br>商信息（如，供应商名、地址、联系方法等）呢？</p>
<p>在这个例子中，可建立两个表，一个存储供应商信息，另一个存储<br>产品信息。vendors表包含所有供应商信息，每个供应商占一行，每个供<br>应商具有唯一的标识。此标识称为主键（primary key）（在第1章中首次<br>提到），可以是供应商ID或任何其他唯一值。<br>products表只存储产品信息，它除了存储供应商ID（vendors表的主<br>键）外不存储其他供应商信息。vendors表的主键又叫作products的外键，<br>它将vendors表与products表关联，利用供应商ID能从vendors表中找出<br>相应供应商的详细信息。</p>
<p>外键（foreign key） 外键为某个表中的一列，它包含另一个表<br>的主键值，定义了两个表之间的关系。</p>
<p>15.2 创建联结</p>
<p>联结的创建非常简单，规定要联结的所有表以及它们如何关联即可。</p>
<p>SELECT vend_name,prod_name,prod_price<br>FROM vendors,products<br>WHERE vendors.vend_id = products.vend_id<br>ORDER BY vend_name,prod_name;</p>
<p>1.必须WHERE<br>2.完全限定列名</p>
<p>笛卡儿积（cartesian product） 由没有联结条件的表关系返回<br>的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘<br>以第二个表中的行数。</p>
<p>SELECT vend_name,prod_name,prod_price<br>FROM vendors,products<br>ORDER BY vend_name,prod_name;</p>
<p>从上面的输出中可以看到，相应的笛卡儿积不是我们所想要<br>的。这里返回的数据用每个供应商匹配了每个产品，它包括了<br>供应商不正确的产品。实际上有的供应商根本就没有产品。</p>
<p>15.2.2 内部联结</p>
<p>目前为止所用的联结称为等值联结（equijoin），它基于两个表之间的<br>相等测试。这种联结也称为内部联结。</p>
<p>SELECT vend_name,prod_name,prod_price<br>FROM vendors INNER JOIN products<br>ON   vendors.vend_id = products.vend_id;</p>
<p>15.2.3 联结多个表</p>
<p>以14章的例子</p>
<p>SELECT cust_name,cust_contact<br>FROM customers,orders,orderitems<br>WHERE customers.cust_id = orders.cust_id<br>AND orderitems.order_num = orders.order_num<br>AND prod_id = ‘TNT2’;</p>
<p>第 16 章 创建高级联结</p>
<p>16.1 使用表别名</p>
<p>SELECT cust_name,cust_contact<br>FROM customers AS c,orders AS O,orderitems AS oi<br>WHERE c.cust_id = o.cust_id<br>AND oi.order_num = o.order_num<br>AND prod_id = ‘TNT2’;</p>
<p>16.2 使用不同类型的联结</p>
<p>现在来看3种其他联结，它们分别是自联结、自然联结和外部联结。</p>
<p>16.2.1 自联结</p>
<p>假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物<br>品的供应商生产的其他物品是否也存在这些问题。</p>
<p>SELECT prod_id,prod_name<br>FROM products<br>WHERE vend_id = (SELECT vend_id<br>                 FROM products<br>                 WHERE prod_id = ‘DTNTR’);</p>
<p>SELECT p1.prod_id,p1.prod_name<br>FROM products AS p1, products AS p2<br>WHERE p1.vend_id = p2.vend_id<br>AND p2.prod_id = ‘DTNTR’;</p>
<p>用自联结而不用子查询 自联结通常作为外部语句用来替代<br>从相同表中检索数据时使用的子查询语句。虽然最终的结果是<br>相同的，但有时候处理联结远比处理子查询快得多。应该试一<br>下两种方法，以确定哪一种的性能更好</p>
<p>16.2.2 自然联结</p>
<p>无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被<br>联结的列）。标准的联结（前一章中介绍的内部联结）返回所有数据，甚<br>至相同的列多次出现。自然联结排除多次出现，使每个列只返回一次。<br>这一<br>般是通过对表使用通配符（SELECT *），对所有其他表的列使用明确的子<br>集来完成的。</p>
<p>SELECT c.*,o.order_num,o.order_date,oi.prod_id,oi.quantity,oi.item_price<br>FROM customers AS c,orders AS o,orderitems AS oi<br>WHERE c.cust_id = o.cust_id<br>AND oi.order_num = o.order_num<br>AND prod_id = ‘FB’;</p>
<p>事实上，迄今为止我们建立的每个内部联结都是自然联结，很可能<br>我们永远都不会用到不是自然联结的内部联结</p>
<p>16.2.3 外部联结</p>
<p>联结包含了那些在相关表中没有关联行的行。这种<br>类型的联结称为外部联结。</p>
<p>为了检索所有客户，包括那些没有订单的客户，<br>可如下进行</p>
<p>SELECT customers.cust_id,orders.order_num<br>FROM customers LEFT OUTER JOIN orders<br>ON customers.cust_id = orders.cust_id;</p>
<p>这条SELECT语句使用了关<br>键字OUTER JOIN来指定联结的类型（而不是在WHERE子句中指<br>定）。但是，与内部联结关联两个表中的行不同的是，外部联结还包括没<br>有关联行的行。在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字<br>指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT<br>指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM<br>子句的左边表（customers表）中选择所有行。</p>
<p>16.3 使用带聚集函数的联结</p>
<p>如果要检索所有客户及每个客户所<br>下的订单数</p>
<p>SELECT customers.cust_name,<br>       customers.cust_id,<br>       COUNT(orders.order_num) AS num_ord<br>FROM customers INNER JOIN orders<br>ON customers.cust_id = orders.cust_id<br>GROUP BY customers.cust_id;</p>
<p>此SELECT语句使用INNER JOIN将customers和orders表互相关联。<br>GROUP BY 子句按客户分组数据，因此，函数调用 COUNT<br>(orders.order_num)对每个客户的订单计数，将它作为num_ord返回。</p>
<p>第 17 章 组 合 查 询</p>
<p>17.1 组合查询</p>
<p>也允许执行多个查询（多条SELECT语句），并将结果作为单个<br>查询结果集返回。这些组合查询通常称为并（union）或复合查询<br>（compound query）。<br>有两种基本情况，其中需要使用组合查询：<br> 在单个查询中从不同的表返回类似结构的数据；<br> 对单个表执行多个查询，按单个查询返回数据。</p>
<p>组合查询和多个WHERE条件 多数情况下，组合相同表的两个<br>查询完成的工作与具有多个WHERE子句条件的单条查询完成的<br>工作相同。换句话说，任何具有多个WHERE子句的SELECT语句<br>都可以作为一个组合查询给出</p>
<p>17.2 创建组合查询<br>17.2.1 使用UNION<br>假如需要价格小于等于5的所有物品的一个列表，而且<br>还想包括供应商1001和1002生产的所有物品（不考虑价格）</p>
<p>SELECT vend_id,prod_id,prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION<br>SELECT vend_id,prod_id,prod_price<br>FROM products<br>WHERE cend_id IN (1001,1002);</p>
<p>由前面的两条SELECT语句组成，语句中用UNION关键<br>字分隔。UNION指示MySQL执行两条SELECT语句，并把输出组<br>合成单个查询结果集。<br>作为参考，这里给出使用多条WHERE子句而不是使用UNION的相同查询：</p>
<p>SELECT vend_id,prod_id,prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>   OR vend_id IN (1001,1002);</p>
<p>17.2.2 UNION规则</p>
<p> UNION必须由两条或两条以上的SELECT语句组成，语句之间用关<br>键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个<br>UNION关键字）。<br> UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过<br>各个列不需要以相同的次序列出）。<br> 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以<br>隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</p>
<p>17.2.3 包含或取消重复的行</p>
<p>UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与<br>单条SELECT语句中使用多个WHERE子句条件一样）。这是UNION的默认行为，但是如果需要，可以改变它。事实上，如果<br>想返回所有匹配行，可使用UNION ALL而不是UNION。</p>
<p>17.2.4 对组合查询结果排序</p>
<p>在用UNION组合查询时，只<br>能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。</p>
<p>SELECT vend_id,prod_id,prod_price<br>FROM products<br>WHERE prod_price &lt;= 5<br>UNION<br>SELECT vend_id,prod_id,prod_price<br>FROM products<br>WHERE cend_id IN (1001,1002)<br>ORDER BY vend_id,prod_price;</p>
<p>第 18 章 全文本搜索</p>
<p>18.1 理解全文本搜索</p>
<p>并非所有引擎都支持全文本搜索:两个最常使用的引擎为MyISAM和InnoDB，<br>前者支持全文本搜索，而后者不支持。</p>
<p>18.2.1 启用全文本搜索支持</p>
<p>一般在创建表时启用全文本搜索。</p>
<p>CREATE TABLE productnotes<br>(<br>  note_id int NOT NULL AUTO_INCREMENT,<br>  prod_id char(10) NOT NULL,<br>  note_date datetime NOT NULL,<br>  note_text text NULL,<br>  PRIMARY KEY(node_id),<br>  FULLTEXT(node_text)<br>) ENGING=MyISAM;</p>
<p>这条<br>CREATE TABLE语句定义表productnotes并列出它所包含的列,这些列中有一个名为note_text的列，为了进行全文本搜索，<br>MySQL根据子句FULLTEXT(note_text)的指示对它进行索引。这里的<br>FULLTEXT索引单个列，如果需要也可以指定多个列。</p>
<p>在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，<br>索引随之自动更新。</p>
<p>不要在导入数据时使用FULLTEXT</p>
<p>18.2.2 进行全文本搜索</p>
<p>在索引之后，使用两个函数Match()和Against()执行全文本搜索，<br>其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<p>SELECT node_text<br>FROM productnotes<br>WHERE Match(note_text) Aginst(‘rabbit’);</p>
<p>1.使用完整的 Match() 说 明 传递给 Match() 的值必须与<br>FULLTEXT()定义中的相同。如果指定多个列，则必须列出它<br>们（而且次序正确）。<br>2.搜索不区分大小写</p>
<p>18.2.3 使用查询扩展</p>
<p>查询扩展用来设法放宽所返回的全文本搜索结果的范围。例如：你想找出所有提到anvils的注释。只有一个注释包含词anvils，<br>但你还想找出可能与你的搜索有关的所有其他行，即使它们不包含词anvils。</p>
<p>在使用查询扩展时，MySQL对数据和<br>索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有<br>行；<br> 其次，MySQL检查这些匹配行并选择所有有用的词（我们将会简<br>要地解释MySQL如何断定什么有用，什么无用）。<br> 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，<br>而且还使用所有有用的词。</p>
<p>SELECT node_text<br>FROM productnotes<br>WHERE Match(note_text) Aginst(‘anvils’ WITH QUERY EXPANSION);</p>
<p>18.2.4 布尔文本搜索</p>
<p>MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean<br>mode）。</p>
<p>即使没有FULLTEXT索引也可以使用,但这是一种非常缓慢的操作<br>（其性能将随着数据量的增加而降低）。</p>
<p>SELECT node_text<br>FROM productnotes<br>WHERE Match(note_text) Aginst(‘heavy’ IN BOOLEAN MOOE);</p>
<p>SELECT node_text<br>FROM productnotes<br>WHERE Match(note_text) Aginst(‘heavy -rope*’ IN BOOLEAN MOOE);</p>
<p>匹配包含heavy但不包含任意以rope开始的词的行.</p>
<p>全文本布尔操作符<br>布尔操作符 说 明</p>
<ul>
<li>包含，词必须存在</li>
</ul>
<ul>
<li>排除，词必须不出现<blockquote>
<p>包含，而且增加等级值<br>&lt; 包含，且减少等级值<br>() 把词组成子表达式（允许这些子表达式作为一个组被包含、<br>排除、排列等）<br>~ 取消一个词的排序值</p>
</blockquote>
</li>
</ul>
<ul>
<li>词尾的通配符<br>“” 定义一个短语（与单个词的列表不一样，它匹配整个短语以<br>便包含或排除这个短语）</li>
</ul>
<p>在布尔方式中，不按等级值降序排序返回的<br>行。</p>
<p>18.2.5 全文本搜索的使用说明</p>
<p> 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为<br>那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。<br> MySQL带有一个内建的非用词（stopword）列表，这些词在索引<br>全文本数据时总是被忽略。如果需要，可以覆盖这个列表（请参<br>阅MySQL文档以了解如何完成此工作）。<br> 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。<br>因此，MySQL规定了一条50%规则，如果一个词出现在50%以上<br>的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN<br>MODE。<br> 如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词<br>或者不出现，或者至少出现在50%的行中）。<br> 忽略词中的单引号。例如，don’t索引为dont。<br> 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文<br>本搜索结果。<br> 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。 </p>
<p>第 19 章 插 入 数 据</p>
<p>19.1 数据插入</p>
<p>INSERT是用来插入（或添加）行到数据库表的。插入可<br>以用几种方式使用：<br> 插入完整的行；<br> 插入行的一部分；<br> 插入多行；<br> 插入某些查询的结果</p>
<p>19.2 插入完整的行</p>
<p>INSERT INTO customers(cust_name,<br>  cust_address,<br>  cust_city,<br>  cust_state,<br>  cust_zip,<br>  cust_country,<br>  cust_contact,<br>  cust_email)<br>VALUES(‘Pep E. LaPew’,<br>  ‘100 Main Street’,<br>  ‘Los Angeles’,<br>  ‘CA’,<br>  ‘90046’,<br>  ‘USA’,<br>  NULL,<br>  NULL);</p>
<p>  省略列 如果表的定义允许，则可以在INSERT操作中省略某<br>些列。省略的列必须满足以下某个条件。<br> 该列定义为允许NULL值（无值或空值）。<br> 在表定义中给出默认值。这表示如果不给出值，将使用默<br>认值。</p>
<p>19.3 插入多个行</p>
<p>INSERT INTO customers(cust_name,<br>  cust_address,<br>  cust_city,<br>  cust_state,<br>  cust_zip,<br>  cust_country)<br>VALUES(‘Pep E. LaPew’,<br>  ‘100 Main Street’,<br>  ‘Los Angeles’,<br>  ‘CA’,<br>  ‘90046’,<br>  ‘USA’),<br>  (‘Pep E. LaPew’,<br>  ‘100 Main Street’,<br>  ‘Los Angeles’,<br>  ‘CA’,<br>  ‘90046’,<br>  ‘USA’<br>  );</p>
<p>其中单条INSERT语句有多组值，每组值用一对圆括号括起来，<br>用逗号分隔。</p>
<p>19.4 插入检索出的数据</p>
<p>想从另一表中合并客户列表到你的customers表,应该首先创建和填<br>充custnew表。custnew表的结构与附录B中描述的customers<br>表的相同。在填充custnew时，不应该使用已经在customers<br>中使用过的cust_id值（如果主键值重复，后续的INSERT操作<br>将会失败）或仅省略这列值让MySQL在导入数据的过程中产<br>生新值。</p>
<p>INSERT INTO customers(cust_id,<br>  cust_name,<br>  cust_address,<br>  cust_city,<br>  cust_state,<br>  cust_zip,<br>  cust_country)<br>SELECT cust_id,<br>  cust_name,<br>  cust_address,<br>  cust_city,<br>  cust_state,<br>  cust_zip,<br>  cust_country<br>FROM custnew;</p>
<p>第 20 章 更新和删除数据</p>
<p>20.1 更新数据</p>
<p>为了更新（修改）表中的数据，可使用UPDATE语句。</p>
<p> 更新表中特定行；<br> 更新表中所有行。</p>
<p>基本的<br>UPDATE语句由3部分组成，分别是：<br> 要更新的表；<br> 列名和它们的新值；<br> 确定要更新行的过滤条件。</p>
<p>客户10005现在有了电子邮件地址:</p>
<p>UPDATE customers<br>SET cust_email = ‘elmer@fudd.com’<br>WHERE cust_id = 10005;</p>
<p>更新多个列时，只需要使用单个SET命令，每个“列=值”对之间<br>用逗号分隔（最后一列之后不用逗号）。</p>
<p>UPDATE customers<br>SET cust_name = ‘The Fudds’,<br>    cust_email = ‘elmer@fudd.com’<br>WHERE cust_id = 10005;</p>
<p>为了删除某个列的值，可设置它为NULL（假如表定义允许NULL值）。</p>
<p>UPDATE customers<br>SET cust_email = NULL<br>WHERE cust_id = 10005;</p>
<p>20.2 删除数据</p>
<p>为了从一个表中删除（去掉）数据，使用DELETE语句。可以两种方<br>式使用DELETE：<br> 从表中删除特定的行；<br> 从表中删除所有行。</p>
<p>DELECT FROM customers<br>WHERE cust_id = 10006;</p>
<p>DELETE FROM要求指定从中删除数据的表名。<br>WHERE子句过滤要删除的行。在这个例子中，只删除客户10006。如果省<br>略WHERE子句，它将删除表中每个客户。<br>DELETE不需要列名或通配符。DELETE删除整行而不是删除列。为了<br>删除指定的列，请使用UPDATE语句。</p>
<p>删除表的内容而不是表 DELETE语句从表中删除行，甚至是<br>删除表中所有行。但是，DELETE不删除表本身。</p>
<p>如果想从表中删除所有行，不要使用DELETE。<br>可使用TRUNCATE TABLE语句</p>
<p>20.3 更新和删除的指导原则</p>
<p> 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE<br>子句的UPDATE或DELETE语句。<br> 保证每个表都有主键（如果忘记这个内容，请参阅第15章），尽可能<br>像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。<br> 在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进<br>行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不<br>正确。<br> 使用强制实施引用完整性的数据库（关于这个内容，请参阅第15<br>章），这样MySQL将不允许删除具有与其他表相关联的数据的行。</p>
<p>第 21 章 创建和操纵表</p>
<p>21.1 创建表</p>
<p>一般有两种创建表的方法：<br> 使用具有交互式创建和管理表的工具（如第2章讨论的工具）；<br> 表也可以直接用MySQL语句操纵。</p>
<p>值得注意的<br>是，在使用交互式工具时，实际上使用的是MySQL语句。</p>
<p>21.1.1 表创建基础</p>
<p>为利用CREATE TABLE创建表，必须给出下列信息：<br> 新表的名字，在关键字CREATE TABLE之后给出；<br> 表列的名字和定义，用逗号分隔。</p>
<p>CREATE TABLE customers<br>(<br>    cust_id int NOT NULL AUTO_INCREMENT,<br>    cust_name char(50) NOT NULL,<br>    cust_address char(50) NULL,<br>    cust_city char(50) NULL,<br>    PRIMARY KEY (cust_id)<br>) ENGINE = InnoDB;</p>
<p>(处理现有的表 在创建新表时，指定的表名必须不存在，否则<br>将出错。如果要防止意外覆盖已有的表，SQL要求首先手工删<br>除该表（请参阅后面的小节），然后再重建它，而不是简单地<br>用创建表语句覆盖它。)</p>
<p>21.1.2 使用NULL值</p>
<p>在插入或更新行时，该列必须有值。NULL为默认设置，如果不指定NOT NULL，则认为指定<br>的是NULL。NULL值是没有值，<br>它不是空串。</p>
<p>21.1.3 主键再介绍</p>
<p>主键值必须唯一。即，表中的每个行必须具有唯一的主<br>键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则<br>这些列的组合值必须唯一。</p>
<p>CREATE TABLE orderitems<br>(<br>    order_num int NOT NULL,<br>    order_item int NOT NULL,<br>    prod_id char(10) NOT NULL,<br>    quantity int NOT NULL,<br>    item_price decimal(8,2) NOT NULL,<br>    PRIMARY KEY (order_num,order_item)<br>) ENGINE=InnoDB;</p>
<p>orderitems表包含orders表中每个订单的细节。每个订单有多项物<br>品，但每个订单任何时候都只有1个第一项物品，1个第二项物品，如此<br>等等。因此，订单号（order_num列）和订单物品（order_item列）的组<br>合是唯一的，从而适合作为主键</p>
<p>21.1.4 使用AUTO_INCREMENT</p>
<p>AUTO_INCREMENT告诉MySQL，本列每当增加一行时自动增量。每次<br>执行一个INSERT操作时，MySQL自动对该列增量（从而才有这个关键字<br>AUTO_INCREMENT），给该列赋予下一个可用的值。这样给每个行分配一个<br>唯一的cust_id，从而可以用作主键值。每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通<br>过使它成为主键）。</p>
<p>21.1.5 指定默认值</p>
<p>如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。<br>默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定。</p>
<p>CREATE TABLE orderitems<br>(<br>    order_num int NOT NULL,<br>    order_item int NOT NULL,<br>    prod_id char(10) NOT NULL,<br>    quantity int NOT NULL DEFAULT 1,<br>    item_price decimal(8,2) NOT NULL,<br>    PRIMARY KEY (order_num,order_item)<br>) ENGINE=InnoDB;</p>
<p>(与大多数DBMS不一样，MySQL不允许使用函<br>数作为默认值，它只支持常量。)</p>
<p>21.1.6 引擎类型</p>
<p>如果省略ENGINE=语句，则<br>使用默认引擎（很可能是MyISAM），多数SQL语句都会默认使用它。</p>
<p>以下是几个需要知道的引擎：<br> InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文<br>本搜索；<br> MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）<br>中，速度很快（特别适合于临时表）；<br> MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），<br>但不支持事务处理。</p>
<p>21.2 更新表</p>
<p>为了使用ALTER TABLE更改表结构，必须给出下面的信息：<br> 在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将<br>出错）；<br> 所做更改的列表。</p>
<p>ALTER TABLE vendors<br>ADD vend_phone CHAR(20);</p>
<p>这条语句给vendors表增加一个名为vend_phone的列，必须明<br>确其数据类型。</p>
<p>21.3 删除表</p>
<p>删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语<br>句即可：</p>
<p>DROP TABLE customers2;</p>
<p>这条语句删除customers 2表（假设它存在）。删除表没有确认，<br>也不能撤销，执行这条语句将永久删除该表。</p>
<p>21.4 重命名表</p>
<p>RENAME TABLE customers2 TO customers;</p>
<p>第 22 章 使 用 视 图</p>
<p>22.1 视图</p>
<p>视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种MySQL的SELECT语句层次的封装，可用来简化数据处理以及重新格式化基础数据或保护基础数据。</p>
<p>22.2 使用视图</p>
<p> 视图用CREATE VIEW语句来创建。<br> 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。<br> 用DROP删除视图，其语法为DROP VIEW viewname;。<br> 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR<br>REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创<br>建一个视图；如果要更新的视图存在，则第2条更新语句会替换原<br>有视图。</p>
<p>22.2.1 利用视图简化复杂的联结</p>
<p>视图的最常见的应用之一是隐藏复杂的SQL</p>
<p>CREATE VIEW productcustomers AS SELECT cust_name,cust_contact,prod_id<br>FROM customers,orders,orderitems<br>WHERE customers.cust_id = orders.cust_id<br>  AND orderitems.order_num = orders.order_num;</p>
<p>这条语句创建一个名为productcustomers的视图，它联结三个<br>表，以返回已订购了任意产品的所有客户的列表。如果执行<br>SELECT * FROM productcustomers，将列出订购了任意产品的客户。</p>
<p>为检索订购了产品TNT2的客户，</p>
<p>SELECT cust_name,cust_contact<br>FROM productcustomers<br>WHERE prod_id = ‘TNT2’;</p>
<p>22.2.2 用视图重新格式化检索出的数据</p>
<p>CREATE VIEW vendorlocations AS<br>SELECT Concat(RTrim(cend_name),’(‘,RTrim(vend_country),’)’) AS vend_title<br>FROM vendors<br>ORDER BY vend_name;</p>
<p>SELECT * FROM vendorlocations;</p>
<p>22.2.3 用视图过滤不想要的数据</p>
<p>CREATE VIEW customeremaillist AS<br>SELECT cust_id,cust_name,cust_email<br>FROM customers<br>WHERE cust_email IS NOT NULL;</p>
<p>SELECT *<br>FROM customeremaillist;</p>
<p>22.2.4 使用视图与计算字段</p>
<p>视图对于简化计算字段的使用特别有用。</p>
<p>CREATE VIEW orderitemsexpanded AS<br>SELECT order_num,<br>       prod_id,<br>       quantity,<br>       item_price,<br>       quantity*item_price AS expanded_price<br>FROM orderitems;</p>
<p>SELECT *<br>FROM orderitemsexpanded<br>WHERE order_num = 20005;</p>
<p>22.2.5 更新视图</p>
<p>通常，视图是可更新的（即，可以对它们使用INSERT、UPDATE和<br>DELETE）。更新一个视图将更新其基表（可以回忆一下，视图本身没有数<br>据）。如果你对视图增加或删除行，实际上是对其基表增加或删除行。</p>
<p>但是，并非所有视图都是可更新的。基本上可以说，如果MySQL不<br>能正确地确定被更新的基数据，则不允许更新（包括插入和删除）。这实<br>际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：<br> 分组（使用GROUP BY和HAVING）；<br> 联结；<br> 子查询；<br> 并；<br> 聚集函数（Min()、Count()、Sum()等）；<br> DISTINCT；<br> 导出（计算）列</p>
<p>第 23 章 使用存储过程</p>
<p>23.1 存储过程</p>
<p>存储过程简单来说，就是为以后的使用而保存<br>的一条或多条MySQL语句的集合。</p>
<p>23.3 使用存储过程</p>
<p>23.3.1 执行存储过程</p>
<p>MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句<br>为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数。</p>
<p>CALL productpricing(@pricelow,<br>                    @pricehigh,<br>              @priceaverage);</p>
<p>执行名为productpricing的存储过程，它计算并返回产<br>品的最低、最高和平均价格。</p>
<p>23.3.2 创建存储过程</p>
<p>一个返回产品平均价格的存储过程.</p>
<p>CREATE PROCEDURE productpricing()<br>BEGIN<br>    SELECT Avg(prod_price) AS priceaverage<br>    FROM products;<br>END;</p>
<p>此存储过程名为<br>productpricing，用CREATE PROCEDURE productpricing()语<br>句定义。如果存储过程接受参数，它们将在()中列举出来。此存储过程没<br>有参数，但后跟的()仍然需要。BEGIN和END语句用来限定存储过程体，过<br>程体本身仅是一个简单的SELECT语句</p>
<p>CALL productpricing();</p>
<p>CALL productpricing();执行刚创建的存储过程并显示返回<br>的结果。因为存储过程实际上是一种函数，所以存储过程名后<br>需要有()符号（即使不传递参数也需要）。</p>
<p>23.3.3 删除存储过程</p>
<p>DROP PROCEDURE productpricing;</p>
<p>23.3.4 使用参数</p>
<p>一般，存储过程并不显示结果，而是把结果返回给你指定的变量。</p>
<p>CREATE PROCEDURE productpricing(<br>    OUT pl DECIMAL(8,2),<br>    OUT ph DECIMAL(8,2),<br>    OUT pa DECIMAL(8,2)<br>)<br>BEGIN<br>    SELECT Min(prod_price)<br>    INTO pl<br>    FROM products;<br>    SELECT Max(prod_price)<br>    INTO ph<br>    FROM products;<br>    SELECT Avg(prod_price)<br>    INTO pa<br>    FROM products;<br>END;</p>
<p>关键字OUT指出相应的参数用来从存储过程传出<br>一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存<br>储过程传出，如这里所用）和INOUT（对存储过程传入和传出）类型的参<br>数。存储过程的代码位于BEGIN和END语句内，如前所见，它们是一系列<br>SELECT语句，用来检索值，然后保存到相应的变量（通过指定INTO关键<br>字）。</p>
<p>CALL productpricing(@pricelow,<br>@pricehigh,<br>@priceaverage);</p>
<p>所以，这条CALL语句给出3个参数。它们是存储过<br>程将保存结果的3个变量的名字。在调用时，这条语句并不显示任何数据。它返回以后可以显示（或<br>在其他处理中使用）的变量。</p>
<p>为了显示检索出的产品平均价格:<br>SELECT @priceaverage;</p>
<p>使用IN和OUT参数的例子</p>
<p>CREATE PROCEDURE ordertotal(<br>IN onnumber INT,<br>OUT ototal DECIMAL(8,2)<br>)<br>BEGIN<br>    SELECT Sum(item_price*quantity)<br>    FROM orderitems<br>    WHERE order_num = onumber<br>    INTO ototal;<br>END;</p>
<p>onumber定义为IN，因为订单号被传入存储过程。ototal定义<br>为OUT，因为要从存储过程返回合计。SELECT语句使用这两个<br>参数，WHERE子句使用onumber选择正确的行，INTO使用ototal存储计算<br>出来的合计。</p>
<p>CALL ordertotal(20005,@total);</p>
<p>23.3.6 检查存储过程</p>
<p>SHOW CREATE PROCEDURE ordertotal;</p>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/SQL/" rel="tag"># SQL</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2018/11/02/实习总结/2018.11/" rel="next" title="2018.11">
                  <i class="fa fa-chevron-left"></i> 2018.11
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2018/12/04/实习总结/2018.12/" rel="prev" title="2018.12">
                  2018.12 <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc" data-target="post-toc-wrap">
          文章目录
        </li>
        <li class="sidebar-nav-overview" data-target="site-overview-wrap">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="/images/avatar.png"
      alt="Wei Zhang">
  <p class="site-author-name" itemprop="name">Wei Zhang</p>
  <div class="site-description motion-element" itemprop="description">Dream High.</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">297</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/categories/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/tags/">
          
        
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>



        </div>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wei Zhang</span>
  <div style="display: none">
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
      <span> 站点总字数:</span>
    </span>
    <span title="站点总字数">834k</span>
  </div>
  <div style="display: none">
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
      <span> 站点阅读时长 ≈ </span>
    </span>
    <span title="站点阅读时长">12:38</span>
  </div>

</div>

<div id="sitetime"></div>
<script language=javascript>
	function siteTime(){
		window.setTimeout("siteTime()", 1000);
		var seconds = 1000;
		var minutes = seconds * 60;
		var hours = minutes * 60;
		var days = hours * 24;
		var years = days * 365;
		var today = new Date();
		var todayYear = today.getFullYear();
		var todayMonth = today.getMonth()+1;
		var todayDate = today.getDate();
		var todayHour = today.getHours();
		var todayMinute = today.getMinutes();
		var todaySecond = today.getSeconds();
		/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
		year - 作为date对象的年份，为4位年份值
		month - 0-11之间的整数，做为date对象的月份
		day - 1-31之间的整数，做为date对象的天数
		hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
		minutes - 0-59之间的整数，做为date对象的分钟数
		seconds - 0-59之间的整数，做为date对象的秒数
		microseconds - 0-999之间的整数，做为date对象的毫秒数 */
		var t1 = Date.UTC(2017,08,12,15,15,47); //建站时间
		var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
		var diff = t2-t1;
		var diffYears = Math.floor(diff/years);
		var diffDays = Math.floor((diff/days)-diffYears*365);
		var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
		var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
		var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
		document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "+diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
	}
	siteTime();
</script>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.3.0</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      本站访客数&nbsp;<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人</span>
    </span>
  
    <span class="post-meta-divider" style="display: inline-block">|</span>
  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      本站总访问量&nbsp;<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>
    </span>
  
</div>












        
      </div>
    </footer>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  </div>

  
    
    
  
    
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/jquery/index.js?v=3.4.1"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script defer src="/lib/three/three.min.js"></script>
  <script defer src="/lib/three/three-waves.min.js"></script>
<script src="/js/utils.js?v=7.3.0"></script><script src="/js/motion.js?v=7.3.0"></script>
<script src="/js/schemes/pisces.js?v=7.3.0"></script>
<script src="/js/next-boot.js?v=7.3.0"></script>



  








  <script src="/js/local-search.js?v=7.3.0"></script>














  

  

  

  


<script>
NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'evzwVhGeeu0e8oJIovHWHhrg-gzGzoHsz',
    appKey: 'e8acWBp5aWlRHeY2YOarxIaK',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);
</script>

</body>
</html>
